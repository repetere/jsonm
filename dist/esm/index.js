var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod2) => function __require2() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all) => {
  for (var name296 in all)
    __defProp(target, name296, { get: all[name296], enumerable: true });
};
var __copyProps = (to2, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to2, key) && key !== except)
        __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to2;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/scikitjs/dist/esm/tf-singleton.js
function setBackend2(tfInput) {
  tf2 = tfInput;
}
function getBackend2() {
  if (tf2 === null) {
    throw Error(`
============================
Howdy \u{1F44B}\u{1F44B}. Looks like you are running scikit but you haven't set a Tensorflow backend. 
To do so, simply import (or require) your tensorflow library, and call setBackend like so,

import * as tf from '@tensorflow/tfjs'
import * as sk from 'scikitjs'
sk.setBackend(tf)

That will let scikit know you wish to use a tensorflow library to perform your calculations.
============================
    `);
  }
  return tf2;
}
var tf2;
var init_tf_singleton = __esm({
  "node_modules/scikitjs/dist/esm/tf-singleton.js"() {
    tf2 = null;
  }
});

// node_modules/scikitjs/dist/esm/typesUtils.js
function isString(value) {
  return typeof value === "string" || value instanceof String;
}
function isBoolean(value) {
  return typeof value === "boolean";
}
function isNumber(value) {
  return typeof value === "number";
}
function assert(expr, msg) {
  if (!expr) {
    throw new Error(msg);
  }
}
function inferShape(val, dtype) {
  let firstElem = val;
  if (isTypedArray(val)) {
    return dtype === "string" ? [] : [val.length];
  }
  if (!Array.isArray(val)) {
    return [];
  }
  const shape = [];
  while (Array.isArray(firstElem) || isTypedArray(firstElem) && dtype !== "string") {
    shape.push(firstElem.length);
    firstElem = firstElem[0];
  }
  if (Array.isArray(val)) {
    deepAssertShapeConsistency(val, shape, []);
  }
  return shape;
}
function deepAssertShapeConsistency(val, shape, indices) {
  indices = indices || [];
  if (!Array.isArray(val) && !isTypedArray(val)) {
    assert(shape.length === 0, `Element arr[${indices.join("][")}] is a primitive, but should be an array/TypedArray of ${shape[0]} elements`);
    return;
  }
  assert(shape.length > 0, `Element arr[${indices.join("][")}] should be a primitive, but is an array of ${val.length} elements`);
  assert(val.length === shape[0], `Element arr[${indices.join("][")}] should have ${shape[0]} elements, but has ${val.length} elements`);
  const subShape = shape.slice(1);
  for (let i2 = 0; i2 < val.length; ++i2) {
    deepAssertShapeConsistency(val[i2], subShape, indices.concat(i2));
  }
}
function inferDtype(values) {
  if (Array.isArray(values)) {
    return inferDtype(values[0]);
  }
  if (values instanceof Float32Array) {
    return "float32";
  } else if (values instanceof Int32Array || values instanceof Uint8Array) {
    return "int32";
  } else if (isNumber(values)) {
    return "float32";
  } else if (isString(values)) {
    return "string";
  } else if (isBoolean(values)) {
    return "bool";
  }
  return null;
}
function isTypedArray(a) {
  return a instanceof Float32Array || a instanceof Int32Array || a instanceof Uint8Array;
}
function isScikitLike1D(arr) {
  const shape = inferShape(arr);
  const dtype = inferDtype(arr);
  return shape.length === 1 && dtype !== null;
}
function isScikitLike2D(arr) {
  const shape = inferShape(arr);
  const dtype = inferDtype(arr);
  return shape.length === 2 && dtype !== null;
}
function isTensor(arr) {
  let tf3 = getBackend2();
  return arr instanceof tf3.Tensor;
}
function isSeriesInterface(arr) {
  if (typeof arr !== "object") {
    return false;
  }
  if (arr && arr.iloc && !arr.applyMap) {
    return true;
  }
  return false;
}
function isDataFrameInterface(arr) {
  if (typeof arr !== "object") {
    return false;
  }
  if (arr && arr.iloc && arr.applyMap) {
    return true;
  }
  return false;
}
function isScikit1D(arr) {
  if (isSeriesInterface(arr)) {
    return true;
  }
  if (isTensor(arr)) {
    return arr.rank === 1;
  }
  return isScikitLike1D(arr);
}
function isScikit2D(arr) {
  if (isDataFrameInterface(arr)) {
    return true;
  }
  if (isTensor(arr)) {
    return arr.rank === 2;
  }
  return isScikitLike2D(arr);
}
function isScikitVecOrMatrix(arr) {
  return isScikit1D(arr) || isScikit2D(arr);
}
var init_typesUtils = __esm({
  "node_modules/scikitjs/dist/esm/typesUtils.js"() {
    init_tf_singleton();
  }
});

// node_modules/scikitjs/dist/esm/utils.js
function convertToTensor1D(data, dtype) {
  let tf3 = getBackend2();
  if (isSeriesInterface(data)) {
    return dtype ? data.tensor.asType(dtype) : data.tensor;
  }
  if (isTensor(data)) {
    if (data.shape.length === 1) {
      if (!dtype || data.dtype == dtype) {
        return data;
      }
      return data.asType(dtype);
    } else {
      throw new Error("ParamError: if data is a Tensor it must be a Tensor1D. If you really meant to reshape this tensor than use tf.reshape");
    }
  }
  return dtype ? tf3.tensor1d(data, dtype) : tf3.tensor1d(data);
}
function convertToNumericTensor1D(data, dtype) {
  const newTensor = convertToTensor1D(data, dtype);
  if (newTensor.dtype === "string") {
    throw new Error("ParamError: data has string dtype, can't convert to numeric Tensor");
  }
  return newTensor;
}
function convertToTensor2D(data, dtype) {
  let tf3 = getBackend2();
  if (isDataFrameInterface(data)) {
    return dtype ? data.tensor.asType(dtype) : data.tensor;
  }
  if (isTensor(data)) {
    if (data.shape.length === 2) {
      if (!dtype || data.dtype == dtype) {
        return data;
      }
      return data.asType(dtype);
    } else {
      throw new Error("ParamError: if data is a Tensor it must be a Tensor2D. If you really meant to reshape this tensor than use tf.reshape");
    }
  }
  if (Array.isArray(data) && isTypedArray(data[0])) {
    const shape = inferShape(data);
    const newData = data.map((el) => Array.from(el));
    return dtype ? tf3.tensor2d(newData, shape, dtype) : tf3.tensor2d(newData, shape);
  }
  return dtype ? tf3.tensor2d(data, void 0, dtype) : tf3.tensor2d(data, void 0);
}
function convertToTensor1D_2D(data, dtype) {
  try {
    const new1DTensor = convertToTensor1D(data, dtype);
    return new1DTensor;
  } catch (e3) {
    try {
      const new2DTensor = convertToTensor2D(data, dtype);
      return new2DTensor;
    } catch (newE) {
      throw new Error('ParamError: Can"t convert data into 1D or 2D tensor');
    }
  }
}
function convertToNumericTensor2D(data, dtype) {
  const newTensor = convertToTensor2D(data, dtype);
  if (newTensor.dtype === "string") {
    throw new Error("ParamError: data has string dtype, can't convert to numeric Tensor");
  }
  return newTensor;
}
function convertToNumericTensor1D_2D(data, dtype) {
  const newTensor = convertToTensor1D_2D(data, dtype);
  if (newTensor.dtype === "string") {
    throw new Error("ParamError: data has string dtype, can't convert to numeric Tensor");
  }
  return newTensor;
}
function convertScikit2DToArray(data) {
  if (isDataFrameInterface(data)) {
    return data.values;
  }
  if (isTensor(data)) {
    return data.arraySync();
  }
  return data;
}
function convertScikit1DToArray(data) {
  if (isSeriesInterface(data)) {
    return data.values;
  }
  if (isTensor(data)) {
    return data.arraySync();
  }
  return data;
}
function getLength(X) {
  assert(isScikitVecOrMatrix(X), "X isn't a Scikit2D or Scikit1D object");
  if (isTensor(X)) {
    return X.shape[0];
  }
  if (isDataFrameInterface(X) || isSeriesInterface(X)) {
    return X.size;
  }
  return X.length;
}
function sampleWithoutReplacement(size2, n, seed) {
  let tf3 = getBackend2();
  let curMap = /* @__PURE__ */ new Map();
  let finalNumbs = [];
  let randoms = tf3.randomUniform([n], 0, size2, "float32", seed).dataSync();
  for (let i2 = 0; i2 < randoms.length; i2++) {
    randoms[i2] = randoms[i2] * (size2 - i2) / size2;
    let randInt2 = Math.floor(randoms[i2]);
    let lastIndex = size2 - i2 - 1;
    if (curMap.get(randInt2) === void 0) {
      curMap.set(randInt2, randInt2);
    }
    if (curMap.get(lastIndex) === void 0) {
      curMap.set(lastIndex, lastIndex);
    }
    let holder = curMap.get(lastIndex);
    curMap.set(lastIndex, curMap.get(randInt2));
    curMap.set(randInt2, holder);
    finalNumbs.push(curMap.get(lastIndex));
  }
  return finalNumbs;
}
var init_utils = __esm({
  "node_modules/scikitjs/dist/esm/utils.js"() {
    init_typesUtils();
    init_tf_singleton();
  }
});

// node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "node_modules/lodash/_freeGlobal.js"(exports, module) {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module.exports = freeGlobal;
  }
});

// node_modules/lodash/_root.js
var require_root = __commonJS({
  "node_modules/lodash/_root.js"(exports, module) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module.exports = root;
  }
});

// node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "node_modules/lodash/_Symbol.js"(exports, module) {
    var root = require_root();
    var Symbol2 = root.Symbol;
    module.exports = Symbol2;
  }
});

// node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "node_modules/lodash/_getRawTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty3.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e3) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module.exports = getRawTag;
  }
});

// node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "node_modules/lodash/_objectToString.js"(exports, module) {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module.exports = objectToString;
  }
});

// node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "node_modules/lodash/_baseGetTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module.exports = baseGetTag;
  }
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "node_modules/lodash/isObject.js"(exports, module) {
    function isObject2(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module.exports = isObject2;
  }
});

// node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/lodash/isFunction.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObject2 = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction2(value) {
      if (!isObject2(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module.exports = isFunction2;
  }
});

// node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "node_modules/lodash/_coreJsData.js"(exports, module) {
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    module.exports = coreJsData;
  }
});

// node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "node_modules/lodash/_isMasked.js"(exports, module) {
    var coreJsData = require_coreJsData();
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    module.exports = isMasked;
  }
});

// node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "node_modules/lodash/_toSource.js"(exports, module) {
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e3) {
        }
        try {
          return func + "";
        } catch (e3) {
        }
      }
      return "";
    }
    module.exports = toSource;
  }
});

// node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "node_modules/lodash/_baseIsNative.js"(exports, module) {
    var isFunction2 = require_isFunction();
    var isMasked = require_isMasked();
    var isObject2 = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty3).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject2(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    module.exports = baseIsNative;
  }
});

// node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "node_modules/lodash/_getValue.js"(exports, module) {
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    module.exports = getValue;
  }
});

// node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "node_modules/lodash/_getNative.js"(exports, module) {
    var baseIsNative = require_baseIsNative();
    var getValue = require_getValue();
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    module.exports = getNative;
  }
});

// node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  "node_modules/lodash/_nativeCreate.js"(exports, module) {
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    module.exports = nativeCreate;
  }
});

// node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  "node_modules/lodash/_hashClear.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    module.exports = hashClear;
  }
});

// node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  "node_modules/lodash/_hashDelete.js"(exports, module) {
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    module.exports = hashDelete;
  }
});

// node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  "node_modules/lodash/_hashGet.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty3.call(data, key) ? data[key] : void 0;
    }
    module.exports = hashGet;
  }
});

// node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  "node_modules/lodash/_hashHas.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty3.call(data, key);
    }
    module.exports = hashHas;
  }
});

// node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  "node_modules/lodash/_hashSet.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    module.exports = hashSet;
  }
});

// node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  "node_modules/lodash/_Hash.js"(exports, module) {
    var hashClear = require_hashClear();
    var hashDelete = require_hashDelete();
    var hashGet = require_hashGet();
    var hashHas = require_hashHas();
    var hashSet = require_hashSet();
    function Hash(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    module.exports = Hash;
  }
});

// node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  "node_modules/lodash/_listCacheClear.js"(exports, module) {
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    module.exports = listCacheClear;
  }
});

// node_modules/lodash/eq.js
var require_eq = __commonJS({
  "node_modules/lodash/eq.js"(exports, module) {
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    module.exports = eq;
  }
});

// node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  "node_modules/lodash/_assocIndexOf.js"(exports, module) {
    var eq = require_eq();
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    module.exports = assocIndexOf;
  }
});

// node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  "node_modules/lodash/_listCacheDelete.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      if (index2 < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index2 == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index2, 1);
      }
      --this.size;
      return true;
    }
    module.exports = listCacheDelete;
  }
});

// node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  "node_modules/lodash/_listCacheGet.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      return index2 < 0 ? void 0 : data[index2][1];
    }
    module.exports = listCacheGet;
  }
});

// node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  "node_modules/lodash/_listCacheHas.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    module.exports = listCacheHas;
  }
});

// node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  "node_modules/lodash/_listCacheSet.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key, value) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      if (index2 < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index2][1] = value;
      }
      return this;
    }
    module.exports = listCacheSet;
  }
});

// node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  "node_modules/lodash/_ListCache.js"(exports, module) {
    var listCacheClear = require_listCacheClear();
    var listCacheDelete = require_listCacheDelete();
    var listCacheGet = require_listCacheGet();
    var listCacheHas = require_listCacheHas();
    var listCacheSet = require_listCacheSet();
    function ListCache(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module.exports = ListCache;
  }
});

// node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "node_modules/lodash/_Map.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var Map2 = getNative(root, "Map");
    module.exports = Map2;
  }
});

// node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  "node_modules/lodash/_mapCacheClear.js"(exports, module) {
    var Hash = require_Hash();
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    module.exports = mapCacheClear;
  }
});

// node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  "node_modules/lodash/_isKeyable.js"(exports, module) {
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    module.exports = isKeyable;
  }
});

// node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  "node_modules/lodash/_getMapData.js"(exports, module) {
    var isKeyable = require_isKeyable();
    function getMapData(map3, key) {
      var data = map3.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    module.exports = getMapData;
  }
});

// node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  "node_modules/lodash/_mapCacheDelete.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    module.exports = mapCacheDelete;
  }
});

// node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  "node_modules/lodash/_mapCacheGet.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    module.exports = mapCacheGet;
  }
});

// node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  "node_modules/lodash/_mapCacheHas.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    module.exports = mapCacheHas;
  }
});

// node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  "node_modules/lodash/_mapCacheSet.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size2 = data.size;
      data.set(key, value);
      this.size += data.size == size2 ? 0 : 1;
      return this;
    }
    module.exports = mapCacheSet;
  }
});

// node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  "node_modules/lodash/_MapCache.js"(exports, module) {
    var mapCacheClear = require_mapCacheClear();
    var mapCacheDelete = require_mapCacheDelete();
    var mapCacheGet = require_mapCacheGet();
    var mapCacheHas = require_mapCacheHas();
    var mapCacheSet = require_mapCacheSet();
    function MapCache(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module.exports = MapCache;
  }
});

// node_modules/lodash/_setCacheAdd.js
var require_setCacheAdd = __commonJS({
  "node_modules/lodash/_setCacheAdd.js"(exports, module) {
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    module.exports = setCacheAdd;
  }
});

// node_modules/lodash/_setCacheHas.js
var require_setCacheHas = __commonJS({
  "node_modules/lodash/_setCacheHas.js"(exports, module) {
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    module.exports = setCacheHas;
  }
});

// node_modules/lodash/_SetCache.js
var require_SetCache = __commonJS({
  "node_modules/lodash/_SetCache.js"(exports, module) {
    var MapCache = require_MapCache();
    var setCacheAdd = require_setCacheAdd();
    var setCacheHas = require_setCacheHas();
    function SetCache(values) {
      var index2 = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index2 < length) {
        this.add(values[index2]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    module.exports = SetCache;
  }
});

// node_modules/lodash/_baseFindIndex.js
var require_baseFindIndex = __commonJS({
  "node_modules/lodash/_baseFindIndex.js"(exports, module) {
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index2-- : ++index2 < length) {
        if (predicate(array[index2], index2, array)) {
          return index2;
        }
      }
      return -1;
    }
    module.exports = baseFindIndex;
  }
});

// node_modules/lodash/_baseIsNaN.js
var require_baseIsNaN = __commonJS({
  "node_modules/lodash/_baseIsNaN.js"(exports, module) {
    function baseIsNaN(value) {
      return value !== value;
    }
    module.exports = baseIsNaN;
  }
});

// node_modules/lodash/_strictIndexOf.js
var require_strictIndexOf = __commonJS({
  "node_modules/lodash/_strictIndexOf.js"(exports, module) {
    function strictIndexOf(array, value, fromIndex) {
      var index2 = fromIndex - 1, length = array.length;
      while (++index2 < length) {
        if (array[index2] === value) {
          return index2;
        }
      }
      return -1;
    }
    module.exports = strictIndexOf;
  }
});

// node_modules/lodash/_baseIndexOf.js
var require_baseIndexOf = __commonJS({
  "node_modules/lodash/_baseIndexOf.js"(exports, module) {
    var baseFindIndex = require_baseFindIndex();
    var baseIsNaN = require_baseIsNaN();
    var strictIndexOf = require_strictIndexOf();
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    module.exports = baseIndexOf;
  }
});

// node_modules/lodash/_arrayIncludes.js
var require_arrayIncludes = __commonJS({
  "node_modules/lodash/_arrayIncludes.js"(exports, module) {
    var baseIndexOf = require_baseIndexOf();
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    module.exports = arrayIncludes;
  }
});

// node_modules/lodash/_arrayIncludesWith.js
var require_arrayIncludesWith = __commonJS({
  "node_modules/lodash/_arrayIncludesWith.js"(exports, module) {
    function arrayIncludesWith(array, value, comparator) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (comparator(value, array[index2])) {
          return true;
        }
      }
      return false;
    }
    module.exports = arrayIncludesWith;
  }
});

// node_modules/lodash/_cacheHas.js
var require_cacheHas = __commonJS({
  "node_modules/lodash/_cacheHas.js"(exports, module) {
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    module.exports = cacheHas;
  }
});

// node_modules/lodash/_Set.js
var require_Set = __commonJS({
  "node_modules/lodash/_Set.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var Set2 = getNative(root, "Set");
    module.exports = Set2;
  }
});

// node_modules/lodash/noop.js
var require_noop = __commonJS({
  "node_modules/lodash/noop.js"(exports, module) {
    function noop() {
    }
    module.exports = noop;
  }
});

// node_modules/lodash/_setToArray.js
var require_setToArray = __commonJS({
  "node_modules/lodash/_setToArray.js"(exports, module) {
    function setToArray(set) {
      var index2 = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index2] = value;
      });
      return result;
    }
    module.exports = setToArray;
  }
});

// node_modules/lodash/_createSet.js
var require_createSet = __commonJS({
  "node_modules/lodash/_createSet.js"(exports, module) {
    var Set2 = require_Set();
    var noop = require_noop();
    var setToArray = require_setToArray();
    var INFINITY = 1 / 0;
    var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values) {
      return new Set2(values);
    };
    module.exports = createSet;
  }
});

// node_modules/lodash/_baseUniq.js
var require_baseUniq = __commonJS({
  "node_modules/lodash/_baseUniq.js"(exports, module) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var cacheHas = require_cacheHas();
    var createSet = require_createSet();
    var setToArray = require_setToArray();
    var LARGE_ARRAY_SIZE = 200;
    function baseUniq(array, iteratee, comparator) {
      var index2 = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      } else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache();
      } else {
        seen = iteratee ? [] : result;
      }
      outer:
        while (++index2 < length) {
          var value = array[index2], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result.push(value);
          } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }
    module.exports = baseUniq;
  }
});

// node_modules/lodash/uniq.js
var require_uniq = __commonJS({
  "node_modules/lodash/uniq.js"(exports, module) {
    var baseUniq = require_baseUniq();
    function uniq3(array) {
      return array && array.length ? baseUniq(array) : [];
    }
    module.exports = uniq3;
  }
});

// node_modules/scikitjs/dist/esm/metrics/metrics.js
var metrics_exports = {};
__export(metrics_exports, {
  accuracyScore: () => accuracyScore,
  confusionMatrix: () => confusionMatrix,
  hingeLoss: () => hingeLoss,
  huberLoss: () => huberLoss,
  logLoss: () => logLoss,
  meanAbsoluteError: () => meanAbsoluteError,
  meanSquaredError: () => meanSquaredError,
  meanSquaredLogError: () => meanSquaredLogError,
  precisionScore: () => precisionScore,
  r2Score: () => r2Score,
  recallScore: () => recallScore,
  rocAucScore: () => rocAucScore,
  zeroOneLoss: () => zeroOneLoss
});
function assertInputIsWellFormed(labels, predictions) {
  assert(isScikit1D(labels), "Labels can't be converted to a 1D Tensor");
  assert(isScikit1D(predictions), "Predictions can't be converted to a 1D Tensor");
  let labelsT = convertToNumericTensor1D(labels);
  let predictionsT = convertToNumericTensor1D(predictions);
  assert(labelsT.size > 0, "Must have 1 label or more");
  assert(predictionsT.size > 0, "Must have 1 prediction or more");
  assert(labelsT.size === predictionsT.size, "Not the same size arrays");
  return { labelsT, predictionsT };
}
function accuracyScore(labels, predictions) {
  const { labelsT, predictionsT } = assertInputIsWellFormed(labels, predictions);
  const result = labelsT.equal(predictionsT).sum().div(labelsT.size);
  return result.dataSync()[0];
}
function precisionScore(labels, predictions) {
  let tf3 = getBackend2();
  const { labelsT, predictionsT } = assertInputIsWellFormed(labels, predictions);
  const result = tf3.metrics.precision(labelsT, predictionsT);
  return result.dataSync()[0];
}
function recallScore(labels, predictions) {
  let tf3 = getBackend2();
  const { labelsT, predictionsT } = assertInputIsWellFormed(labels, predictions);
  const result = tf3.metrics.recall(labelsT, predictionsT);
  return result.dataSync()[0];
}
function r2Score(labels, predictions) {
  let tf3 = getBackend2();
  const { labelsT, predictionsT } = assertInputIsWellFormed(labels, predictions);
  const numerator = tf3.metrics.meanSquaredError(labelsT, predictionsT);
  const denominator = tf3.metrics.meanSquaredError(labelsT, labelsT.mean());
  const result = tf3.sub(1, numerator.div(denominator));
  return result.dataSync()[0];
}
function meanAbsoluteError(labels, predictions) {
  let tf3 = getBackend2();
  const { labelsT, predictionsT } = assertInputIsWellFormed(labels, predictions);
  const result = tf3.metrics.meanAbsoluteError(labelsT, predictionsT);
  return result.dataSync()[0];
}
function meanSquaredError(labels, predictions) {
  let tf3 = getBackend2();
  const { labelsT, predictionsT } = assertInputIsWellFormed(labels, predictions);
  const result = tf3.metrics.meanSquaredError(labelsT, predictionsT);
  return result.dataSync()[0];
}
function meanSquaredLogError(labels, predictions) {
  let tf3 = getBackend2();
  const { labelsT, predictionsT } = assertInputIsWellFormed(labels, predictions);
  const result = tf3.square(labelsT.log1p().sub(predictionsT.log1p())).sum().div(labelsT.size);
  return result.dataSync()[0];
}
function hingeLoss(labels, predictions) {
  let tf3 = getBackend2();
  const { labelsT, predictionsT } = assertInputIsWellFormed(labels, predictions);
  const result = tf3.losses.hingeLoss(labelsT, predictionsT);
  return result.dataSync()[0];
}
function huberLoss(labels, predictions) {
  let tf3 = getBackend2();
  const { labelsT, predictionsT } = assertInputIsWellFormed(labels, predictions);
  const result = tf3.losses.huberLoss(labelsT, predictionsT);
  return result.dataSync()[0];
}
function logLoss(labels, predictions) {
  let tf3 = getBackend2();
  const { labelsT, predictionsT } = assertInputIsWellFormed(labels, predictions);
  const result = tf3.losses.logLoss(labelsT, predictionsT);
  return result.dataSync()[0];
}
function zeroOneLoss(labels, predictions) {
  let tf3 = getBackend2();
  const { labelsT, predictionsT } = assertInputIsWellFormed(labels, predictions);
  const result = tf3.sub(1, accuracyScore(labelsT, predictionsT));
  return result.dataSync()[0];
}
function confusionMatrix(labels, predictions) {
  let tf3 = getBackend2();
  const { labelsT, predictionsT } = assertInputIsWellFormed(labels, predictions);
  const uniqueNumber = (0, import_uniq.default)(labelsT.dataSync());
  return tf3.math.confusionMatrix(labelsT, predictionsT, uniqueNumber.length).arraySync();
}
function rocAucScore(labels, predictions) {
  const { labelsT, predictionsT } = assertInputIsWellFormed(labels, predictions);
  let x = labelsT.arraySync();
  let y = predictionsT.arraySync();
  x.push(1);
  y.push(1);
  let area = 0;
  for (let i2 = 0; i2 < x.length - 1; i2++) {
    area += x[i2] * y[i2 + 1] - x[i2 + 1] * y[i2];
  }
  area -= 1;
  return Math.abs(area) / 2;
}
var import_uniq;
var init_metrics = __esm({
  "node_modules/scikitjs/dist/esm/metrics/metrics.js"() {
    init_utils();
    init_typesUtils();
    import_uniq = __toESM(require_uniq());
    init_tf_singleton();
  }
});

// node_modules/base64-arraybuffer/dist/base64-arraybuffer.umd.js
var require_base64_arraybuffer_umd = __commonJS({
  "node_modules/base64-arraybuffer/dist/base64-arraybuffer.umd.js"(exports, module) {
    (function(global2, factory2) {
      typeof exports === "object" && typeof module !== "undefined" ? factory2(exports) : typeof define === "function" && define.amd ? define(["exports"], factory2) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory2(global2["base64-arraybuffer"] = {}));
    })(exports, function(exports2) {
      "use strict";
      var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
      for (var i2 = 0; i2 < chars.length; i2++) {
        lookup[chars.charCodeAt(i2)] = i2;
      }
      var encode2 = function(arraybuffer) {
        var bytes = new Uint8Array(arraybuffer), i3, len = bytes.length, base64 = "";
        for (i3 = 0; i3 < len; i3 += 3) {
          base64 += chars[bytes[i3] >> 2];
          base64 += chars[(bytes[i3] & 3) << 4 | bytes[i3 + 1] >> 4];
          base64 += chars[(bytes[i3 + 1] & 15) << 2 | bytes[i3 + 2] >> 6];
          base64 += chars[bytes[i3 + 2] & 63];
        }
        if (len % 3 === 2) {
          base64 = base64.substring(0, base64.length - 1) + "=";
        } else if (len % 3 === 1) {
          base64 = base64.substring(0, base64.length - 2) + "==";
        }
        return base64;
      };
      var decode2 = function(base64) {
        var bufferLength = base64.length * 0.75, len = base64.length, i3, p = 0, encoded1, encoded2, encoded3, encoded4;
        if (base64[base64.length - 1] === "=") {
          bufferLength--;
          if (base64[base64.length - 2] === "=") {
            bufferLength--;
          }
        }
        var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
        for (i3 = 0; i3 < len; i3 += 4) {
          encoded1 = lookup[base64.charCodeAt(i3)];
          encoded2 = lookup[base64.charCodeAt(i3 + 1)];
          encoded3 = lookup[base64.charCodeAt(i3 + 2)];
          encoded4 = lookup[base64.charCodeAt(i3 + 3)];
          bytes[p++] = encoded1 << 2 | encoded2 >> 4;
          bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
          bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
        }
        return arraybuffer;
      };
      exports2.decode = decode2;
      exports2.encode = encode2;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/scikitjs/dist/esm/simpleSerializer.js
function randomString(numLetters) {
  let curLetter = "";
  for (let i2 = 0; i2 < numLetters; i2++) {
    let index2 = Math.floor(Math.random() * letters.length);
    curLetter += letters[index2];
  }
  return curLetter;
}
async function toObjectInner(val, ignoreKeys = []) {
  let tf3 = getBackend2();
  if (["number", "string", "undefined", "boolean"].includes(typeof val)) {
    return val;
  }
  if (typeof val === "function") {
    console.warn(`warning: Serializing function ${val}. Not going to be able to deserialize this later.`);
    if (val.name) {
      return val.name;
    }
  }
  if (typeof val === "object") {
    if (val === null) {
      return null;
    }
    if (Array.isArray(val)) {
      return await Promise.all(val.map(async (el) => await toObjectInner(el, ignoreKeys)));
    }
    if (val instanceof tf3.Tensor) {
      return {
        name: "Tensor",
        value: val.arraySync()
      };
    }
    if (val instanceof Int32Array) {
      return {
        name: "Int32Array",
        value: Array.from(val)
      };
    }
    if (val instanceof Float32Array) {
      return {
        name: "Float32Array",
        value: Array.from(val)
      };
    }
    if (val instanceof tf3.Sequential) {
      let mem = new JSONHandler();
      await val.save(mem);
      return {
        name: "Sequential",
        artifacts: mem.savedArtifacts
      };
    }
    if (val.ENV && val.AdadeltaOptimizer && val.version) {
      return {
        name: "TF",
        version: val.version.tfjs
      };
    }
    let response = {};
    for (let key of Object.keys(val)) {
      if (ignoreKeys.includes(key)) {
        continue;
      }
      response[key] = await toObjectInner(val[key], ignoreKeys);
    }
    return response;
  }
}
async function fromObjectInner(val) {
  let tf3 = getBackend2();
  if (typeof val !== "object") {
    return val;
  }
  if (val === null) {
    return null;
  }
  if (val.name === "Tensor") {
    return tf3.tensor(val.value);
  }
  if (val.name === "Sequential") {
    let newMem = new JSONHandler(val.artifacts);
    return await tf3.loadLayersModel(newMem);
  }
  if (val.name === "Int32Array") {
    return new Int32Array(val.value);
  }
  if (val.name === "Float32Array") {
    return new Float32Array(val.value);
  }
  if (val.name === "TF") {
    return tf3;
  }
  if (Array.isArray(val)) {
    return await Promise.all(val.map(async (el) => await fromObjectInner(el)));
  }
  for (let key of Object.keys(val)) {
    val[key] = await fromObjectInner(val[key]);
  }
  if (EstimatorList.includes(val.name)) {
    let module = await Promise.resolve().then(() => (init_esm2(), esm_exports));
    let model = module[val.name];
    let resultObj = new model(val);
    for (let key of Object.keys(val)) {
      resultObj[key] = val[key];
    }
    return resultObj;
  }
  return val;
}
async function fromObject(val) {
  try {
    return await fromObjectInner(val);
  } catch (e3) {
    console.error(e3);
  }
}
async function fromJSON(val) {
  return await fromObject(JSON.parse(val));
}
var import_base64_arraybuffer, EstimatorList, letters, JSONHandler, ignoredKeysForSGDRegressor, Serialize;
var init_simpleSerializer = __esm({
  "node_modules/scikitjs/dist/esm/simpleSerializer.js"() {
    import_base64_arraybuffer = __toESM(require_base64_arraybuffer_umd());
    init_tf_singleton();
    EstimatorList = [
      "KNeighborsRegressor",
      "LinearRegression",
      "LassoRegression",
      "RidgeRegression",
      "ElasticNet",
      "LogisticRegression",
      "DummyRegressor",
      "DummyClassifier",
      "MinMaxScaler",
      "StandardScaler",
      "MaxAbsScaler",
      "SimpleImputer",
      "OneHotEncoder",
      "LabelEncoder",
      "OrdinalEncoder",
      "Normalizer",
      "Pipeline",
      "ColumnTransformer",
      "RobustScaler",
      "KMeans",
      "VotingRegressor",
      "VotingClassifier",
      "LinearSVC",
      "LinearSVR",
      "GaussianNB",
      "DecisionTreeClassifier",
      "DecisionTreeRegressor",
      "ClassificationCriterion",
      "RegressionCriterion",
      "Splitter",
      "DecisionTreeBase",
      "DecisionTree"
    ];
    letters = "abcdefghijklmnopqrstuvwxy";
    JSONHandler = class {
      savedArtifacts;
      constructor(artifacts) {
        this.savedArtifacts = artifacts || null;
      }
      async save(artifacts) {
        artifacts.weightData = (0, import_base64_arraybuffer.encode)(artifacts.weightData);
        let mapping = {};
        for (let i2 = 0; i2 < artifacts.modelTopology.config.layers.length; i2++) {
          let curWeightSpec = artifacts.modelTopology.config.layers[i2];
          let randomName = randomString(6);
          mapping[curWeightSpec.config.name] = randomName;
          curWeightSpec.config.name = randomName;
        }
        for (let i2 = 0; i2 < artifacts.weightSpecs.length; i2++) {
          let cur = artifacts.weightSpecs[i2];
          let allMaps = Object.keys(mapping);
          allMaps.forEach((el) => {
            if (cur.name.includes(el)) {
              cur.name = cur.name.replace(el, mapping[el]);
            }
          });
        }
        this.savedArtifacts = artifacts;
        return {
          modelArtifactsInfo: {
            dateSaved: new Date(),
            modelTopologyType: "JSON",
            modelTopologyBytes: JSON.stringify(artifacts.modelTopology).length,
            weightSpecsBytes: JSON.stringify(artifacts.weightSpecs).length,
            weightDataBytes: artifacts.weightData.byteLength
          }
        };
      }
      async load() {
        this.savedArtifacts.weightData = (0, import_base64_arraybuffer.decode)(this.savedArtifacts.weightData);
        return this.savedArtifacts;
      }
    };
    ignoredKeysForSGDRegressor = [
      "modelCompileArgs",
      "modelFitArgs",
      "denseLayerArgs"
    ];
    Serialize = class {
      async toObject() {
        return await toObjectInner(this, ignoredKeysForSGDRegressor);
      }
      async toJSON() {
        return JSON.stringify(await this.toObject());
      }
    };
  }
});

// node_modules/scikitjs/dist/esm/mixins.js
var TransformerMixin, RegressorMixin, ClassifierMixin;
var init_mixins = __esm({
  "node_modules/scikitjs/dist/esm/mixins.js"() {
    init_metrics();
    init_simpleSerializer();
    init_typesUtils();
    init_utils();
    TransformerMixin = class extends Serialize {
      fitTransform(X) {
        return this.fit(X).transform(X);
      }
    };
    RegressorMixin = class extends Serialize {
      EstimatorType = "regressor";
      score(X, y) {
        const yPred = this.predict(X);
        return r2Score(y, yPred);
      }
    };
    ClassifierMixin = class extends Serialize {
      EstimatorType = "classifier";
      score(X, y) {
        const yPred = this.predict(X);
        const yTrue = convertToNumericTensor1D_2D(y);
        assert(yPred.shape.length === yTrue.shape.length, "The shape of the model output doesn't match the shape of the actual y values");
        if (isScikit2D(y)) {
          return accuracyScore(yTrue.argMax(1), yPred.argMax(1));
        }
        return accuracyScore(y, yPred);
      }
    };
  }
});

// node_modules/scikitjs/dist/esm/linear_model/SgdRegressor.js
var SGDRegressor;
var init_SgdRegressor = __esm({
  "node_modules/scikitjs/dist/esm/linear_model/SgdRegressor.js"() {
    init_utils();
    init_mixins();
    init_tf_singleton();
    SGDRegressor = class extends RegressorMixin {
      model;
      modelFitArgs;
      modelCompileArgs;
      denseLayerArgs;
      isMultiOutput;
      optimizerType;
      lossType;
      constructor({ modelFitArgs, modelCompileArgs, denseLayerArgs, optimizerType, lossType }) {
        super();
        this.tf = getBackend2();
        this.model = this.tf.sequential();
        this.modelFitArgs = modelFitArgs;
        this.modelCompileArgs = modelCompileArgs;
        this.denseLayerArgs = denseLayerArgs;
        this.isMultiOutput = false;
        this.optimizerType = optimizerType;
        this.lossType = lossType;
      }
      initializeModel(X, y, weightsTensors = []) {
        this.denseLayerArgs.units = y.shape.length === 1 ? 1 : y.shape[1];
        const model = this.tf.sequential();
        model.add(this.tf.layers.dense({
          inputShape: [X.shape[1]],
          ...this.denseLayerArgs
        }));
        model.compile(this.modelCompileArgs);
        if (weightsTensors?.length) {
          model.setWeights(weightsTensors);
        }
        this.model = model;
      }
      async fit(X, y) {
        let XTwoD = convertToNumericTensor2D(X);
        let yOneD = convertToNumericTensor1D_2D(y);
        if (yOneD.shape.length > 1) {
          this.isMultiOutput = true;
        }
        if (this.model.layers.length === 0) {
          this.initializeModel(XTwoD, yOneD);
        }
        await this.model.fit(XTwoD, yOneD, { ...this.modelFitArgs });
        return this;
      }
      importModel(params) {
        let myCoef = this.tf.tensor2d(params.coef, [params.coef.length, 1], "float32");
        let myIntercept = this.tf.tensor1d([params.intercept], "float32");
        this.initializeModel(myCoef, myIntercept, [myCoef, myIntercept]);
        return this;
      }
      getParams() {
        return {
          modelFitArgs: this.modelFitArgs,
          modelCompileArgs: this.modelCompileArgs,
          denseLayerArgs: this.denseLayerArgs,
          optimizerType: this.optimizerType,
          lossType: this.lossType
        };
      }
      setParams(params) {
        this.modelCompileArgs = params.modelCompileArgs;
        this.modelFitArgs = params.modelFitArgs;
        this.denseLayerArgs = params.denseLayerArgs;
        return this;
      }
      predict(X) {
        let XTwoD = convertToNumericTensor2D(X);
        if (this.model.layers.length === 0) {
          throw new RangeError('Need to call "fit" before "predict"');
        }
        const predictions = this.model.predict(XTwoD);
        if (!this.isMultiOutput) {
          return predictions.reshape([-1]);
        }
        return predictions;
      }
      get coef() {
        const modelWeights = this.model.getWeights();
        if (modelWeights.length === 0) {
          return this.tf.tensor2d([]);
        }
        let coefficients = modelWeights[0];
        if (coefficients.shape[1] === 1) {
          return coefficients.reshape([coefficients.shape[0]]);
        }
        return coefficients;
      }
      get intercept() {
        const modelWeights = this.model.getWeights();
        if (modelWeights.length < 2) {
          return 0;
        }
        let intercept = modelWeights[1];
        if (intercept.size === 1) {
          return intercept.arraySync()[0];
        }
        return intercept;
      }
    };
  }
});

// node_modules/scikitjs/dist/esm/linear_model/LinearRegression.js
var LinearRegression;
var init_LinearRegression = __esm({
  "node_modules/scikitjs/dist/esm/linear_model/LinearRegression.js"() {
    init_SgdRegressor();
    init_tf_singleton();
    LinearRegression = class extends SGDRegressor {
      constructor({ fitIntercept = true, modelFitOptions } = {}) {
        let tf3 = getBackend2();
        super({
          modelCompileArgs: {
            optimizer: tf3.train.adam(0.1),
            loss: tf3.losses.meanSquaredError,
            metrics: ["mse"]
          },
          modelFitArgs: {
            batchSize: 32,
            epochs: 1e3,
            verbose: 0,
            callbacks: [
              tf3.callbacks.earlyStopping({ monitor: "mse", patience: 30 })
            ],
            ...modelFitOptions
          },
          denseLayerArgs: {
            units: 1,
            useBias: Boolean(fitIntercept)
          },
          optimizerType: "adam",
          lossType: "meanSquaredError"
        });
        this.name = "LinearRegression";
      }
    };
  }
});

// node_modules/scikitjs/dist/esm/linear_model/LassoRegression.js
var LassoRegression;
var init_LassoRegression = __esm({
  "node_modules/scikitjs/dist/esm/linear_model/LassoRegression.js"() {
    init_SgdRegressor();
    init_tf_singleton();
    LassoRegression = class extends SGDRegressor {
      constructor({ fitIntercept = true, alpha = 1 } = {}) {
        let tf3 = getBackend2();
        super({
          modelCompileArgs: {
            optimizer: tf3.train.adam(0.1),
            loss: tf3.losses.meanSquaredError,
            metrics: ["mse"]
          },
          modelFitArgs: {
            batchSize: 32,
            epochs: 1e3,
            verbose: 0,
            callbacks: [
              tf3.callbacks.earlyStopping({ monitor: "mse", patience: 50 })
            ]
          },
          denseLayerArgs: {
            units: 1,
            kernelRegularizer: tf3.regularizers.l1({ l1: alpha }),
            useBias: Boolean(fitIntercept)
          },
          optimizerType: "adam",
          lossType: "meanSquaredError"
        });
        this.name = "LassoRegression";
      }
    };
  }
});

// node_modules/scikitjs/dist/esm/linear_model/RidgeRegression.js
var RidgeRegression;
var init_RidgeRegression = __esm({
  "node_modules/scikitjs/dist/esm/linear_model/RidgeRegression.js"() {
    init_SgdRegressor();
    init_tf_singleton();
    RidgeRegression = class extends SGDRegressor {
      constructor({ fitIntercept = true, alpha = 0.01 } = {}) {
        let tf3 = getBackend2();
        super({
          modelCompileArgs: {
            optimizer: tf3.train.adam(0.1),
            loss: tf3.losses.meanSquaredError,
            metrics: ["mse"]
          },
          modelFitArgs: {
            batchSize: 32,
            epochs: 1e3,
            verbose: 0,
            callbacks: [
              tf3.callbacks.earlyStopping({ monitor: "mse", patience: 50 })
            ]
          },
          denseLayerArgs: {
            units: 1,
            kernelRegularizer: tf3.regularizers.l2({ l2: alpha }),
            useBias: Boolean(fitIntercept)
          },
          optimizerType: "adam",
          lossType: "meanSquaredError"
        });
        this.name = "RidgeRegression";
      }
    };
  }
});

// node_modules/scikitjs/dist/esm/linear_model/ElasticNet.js
var ElasticNet;
var init_ElasticNet = __esm({
  "node_modules/scikitjs/dist/esm/linear_model/ElasticNet.js"() {
    init_SgdRegressor();
    init_tf_singleton();
    ElasticNet = class extends SGDRegressor {
      constructor({ alpha = 1, l1Ratio = 0.5, fitIntercept = true } = {}) {
        let tf3 = getBackend2();
        super({
          modelCompileArgs: {
            optimizer: tf3.train.adam(0.1),
            loss: tf3.losses.meanSquaredError,
            metrics: ["mse"]
          },
          modelFitArgs: {
            batchSize: 32,
            epochs: 1e3,
            verbose: 0,
            callbacks: [
              tf3.callbacks.earlyStopping({ monitor: "mse", patience: 50 })
            ]
          },
          denseLayerArgs: {
            units: 1,
            kernelRegularizer: tf3.regularizers.l1l2({
              l1: alpha * l1Ratio,
              l2: 0.5 * alpha * (1 - l1Ratio)
            }),
            useBias: Boolean(fitIntercept)
          },
          optimizerType: "adam",
          lossType: "meanSquaredError"
        });
        this.name = "ElasticNet";
      }
    };
  }
});

// node_modules/scikitjs/dist/esm/preprocessing/OneHotEncoder.js
var OneHotEncoder;
var init_OneHotEncoder = __esm({
  "node_modules/scikitjs/dist/esm/preprocessing/OneHotEncoder.js"() {
    init_utils();
    init_mixins();
    init_tf_singleton();
    init_typesUtils();
    OneHotEncoder = class extends TransformerMixin {
      categories;
      handleUnknown;
      categoriesParam;
      drop;
      nFeaturesIn;
      featureNamesIn;
      name = "OneHotEncoder";
      constructor({ categories = "auto", handleUnknown = "error", drop } = {}) {
        super();
        this.tf = getBackend2();
        this.categoriesParam = categories;
        this.categories = [];
        this.handleUnknown = handleUnknown;
        this.nFeaturesIn = 0;
        this.featureNamesIn = [];
        this.drop = drop;
      }
      classesToMapping(classes2) {
        const labels = /* @__PURE__ */ new Map();
        classes2.forEach((value, index2) => {
          labels.set(value, index2);
        });
        return labels;
      }
      loopOver2DArrayToSetLabels(array2D) {
        for (let j = 0; j < array2D[0].length; j++) {
          let curSet = /* @__PURE__ */ new Set();
          for (let i2 = 0; i2 < array2D.length; i2++) {
            curSet.add(array2D[i2][j]);
          }
          let results = Array.from(curSet);
          this.categories.push(results);
        }
      }
      fit(X, y) {
        const array2D = convertScikit2DToArray(X);
        if (this.categoriesParam === "auto") {
          this.loopOver2DArrayToSetLabels(array2D);
          return this;
        }
        this.categories = this.categoriesParam;
        this.nFeaturesIn = array2D.length === 0 ? 0 : array2D[0].length || 0;
        if (isDataFrameInterface(X)) {
          this.featureNamesIn = [...X.columns];
        }
        return this;
      }
      loopOver2DArrayToUseLabels(array2D) {
        let labels = this.categories.map((el) => this.classesToMapping(el));
        let finalArray = [];
        for (let i2 = 0; i2 < array2D.length; i2++) {
          let curArray = [];
          for (let j = 0; j < array2D[0].length; j++) {
            let curElem = array2D[i2][j];
            let val = labels[j].get(curElem);
            if (val === void 0) {
              if (this.handleUnknown === "error") {
                throw new Error(`Unknown value ${curElem} encountered while transforming. Not encountered in training data`);
              } else {
                val = -1;
              }
            }
            if (this.drop === "first") {
              val -= 1;
            }
            curArray.push(val);
          }
          finalArray.push(curArray);
        }
        return finalArray;
      }
      convertToOneHot(tensor, numberOfOneHotColumns) {
        if (numberOfOneHotColumns >= 2) {
          return this.tf.oneHot(tensor, numberOfOneHotColumns);
        }
        if (numberOfOneHotColumns === 1) {
          tensor = this.tf.where(tensor.equal(0), this.tf.ones(tensor.shape, "int32"), this.tf.zeros(tensor.shape, "int32"));
          return tensor.reshape([-1, 1]);
        }
        return this.tf.tensor2d([]);
      }
      transform(X, y) {
        const array2D = convertScikit2DToArray(X);
        const result2D = this.loopOver2DArrayToUseLabels(array2D);
        const newTensor = this.tf.tensor2d(result2D, void 0, "int32");
        return this.tf.concat(newTensor.unstack(1).map((el, i2) => {
          let categoryNumber = this.categories[i2].length;
          let numberOfOneHotColumns = this.drop === "first" ? categoryNumber - 1 : categoryNumber;
          let val = this.convertToOneHot(el, numberOfOneHotColumns);
          return val;
        }), 1);
      }
      inverseTransform(X) {
        let labels = this.classesToMapping(this.categories[0]);
        const tensorLabels = X.argMax(1);
        const invMap = new Map(Array.from(labels, (a) => a.reverse()));
        const tempData = tensorLabels.arraySync().map((value) => {
          return invMap.get(value) === void 0 ? null : invMap.get(value);
        });
        return tempData;
      }
    };
  }
});

// node_modules/scikitjs/dist/esm/linear_model/SgdClassifier.js
var SGDClassifier;
var init_SgdClassifier = __esm({
  "node_modules/scikitjs/dist/esm/linear_model/SgdClassifier.js"() {
    init_utils();
    init_OneHotEncoder();
    init_typesUtils();
    init_mixins();
    init_tf_singleton();
    SGDClassifier = class extends ClassifierMixin {
      model;
      modelFitArgs;
      modelCompileArgs;
      denseLayerArgs;
      optimizerType;
      lossType;
      oneHot;
      tf;
      isMultiOutput;
      constructor({ modelFitArgs, modelCompileArgs, denseLayerArgs, optimizerType, lossType }) {
        super();
        this.tf = getBackend2();
        this.model = this.tf.sequential();
        this.modelFitArgs = modelFitArgs;
        this.modelCompileArgs = modelCompileArgs;
        this.denseLayerArgs = denseLayerArgs;
        this.optimizerType = optimizerType;
        this.lossType = lossType;
        this.isMultiOutput = false;
        this.oneHot = new OneHotEncoder();
      }
      initializeModelForClassification(y) {
        let yToInt = y.toInt();
        if (yToInt.shape.length === 2) {
          this.modelCompileArgs.loss = this.tf.losses.softmaxCrossEntropy;
          return yToInt;
        } else {
          const yTwoD = y.reshape([-1, 1]);
          const yTwoDOneHotEncoded = this.oneHot.fitTransform(yTwoD);
          if (this.oneHot.categories[0].length > 2) {
            this.modelCompileArgs.loss = this.tf.losses.softmaxCrossEntropy;
          } else {
            this.modelCompileArgs.loss = this.tf.losses.sigmoidCrossEntropy;
          }
          return yTwoDOneHotEncoded;
        }
      }
      initializeModel(X, y, weightsTensors = []) {
        this.denseLayerArgs.units = y.shape.length === 1 ? 1 : y.shape[1];
        const model = this.tf.sequential();
        model.add(this.tf.layers.dense({
          inputShape: [X.shape[1]],
          ...this.denseLayerArgs
        }));
        model.compile(this.modelCompileArgs);
        if (weightsTensors?.length) {
          model.setWeights(weightsTensors);
        }
        this.model = model;
      }
      async fit(X, y) {
        let XTwoD = convertToNumericTensor2D(X);
        let yOneD = convertToNumericTensor1D_2D(y);
        const yTwoD = this.initializeModelForClassification(yOneD);
        if (yOneD.shape.length > 1) {
          this.isMultiOutput = true;
        }
        if (this.model.layers.length === 0) {
          this.initializeModel(XTwoD, yTwoD);
        }
        await this.model.fit(XTwoD, yTwoD, { ...this.modelFitArgs });
        return this;
      }
      importModel(params) {
        let myCoef = this.tf.tensor2d(params.coef, [params.coef.length, 1], "float32");
        let myIntercept = this.tf.tensor1d([params.intercept], "float32");
        this.initializeModel(myCoef, myIntercept, [myCoef, myIntercept]);
        return this;
      }
      getParams() {
        return {
          modelFitArgs: this.modelFitArgs,
          modelCompileArgs: this.modelCompileArgs,
          denseLayerArgs: this.denseLayerArgs,
          optimizerType: this.optimizerType,
          lossType: this.lossType
        };
      }
      setParams(params) {
        this.modelCompileArgs = params.modelCompileArgs;
        this.modelFitArgs = params.modelFitArgs;
        this.denseLayerArgs = params.denseLayerArgs;
        return this;
      }
      predictProba(X) {
        assert(this.model.layers.length > 0, 'Need to call "fit" before "predict"');
        let XTwoD = convertToNumericTensor2D(X);
        return this.model.predict(XTwoD);
      }
      predict(X) {
        assert(this.model.layers.length > 0, 'Need to call "fit" before "predict"');
        const y2D = this.predictProba(X);
        if (this.isMultiOutput) {
          return this.tf.oneHot(y2D.argMax(1), y2D.shape[1]);
        }
        return this.tf.tensor1d(this.oneHot.inverseTransform(y2D));
      }
      get coef() {
        const modelWeights = this.model.getWeights();
        if (modelWeights.length === 0) {
          return this.tf.tensor2d([]);
        }
        let coefficients = modelWeights[0];
        if (coefficients.shape[1] === 1) {
          return coefficients.reshape([coefficients.shape[0]]);
        }
        return coefficients;
      }
      get intercept() {
        const modelWeights = this.model.getWeights();
        if (modelWeights.length < 2) {
          return 0;
        }
        let intercept = modelWeights[1];
        if (intercept.size === 1) {
          return intercept.arraySync()[0];
        }
        return intercept;
      }
    };
  }
});

// node_modules/scikitjs/dist/esm/linear_model/LogisticRegression.js
var LogisticRegression;
var init_LogisticRegression = __esm({
  "node_modules/scikitjs/dist/esm/linear_model/LogisticRegression.js"() {
    init_SgdClassifier();
    init_tf_singleton();
    LogisticRegression = class extends SGDClassifier {
      constructor({ penalty = "l2", C = 1, fitIntercept = true, modelFitOptions } = {}) {
        let tf3 = getBackend2();
        super({
          modelCompileArgs: {
            optimizer: tf3.train.adam(0.1),
            loss: tf3.losses.softmaxCrossEntropy,
            metrics: ["accuracy"]
          },
          modelFitArgs: {
            batchSize: 32,
            epochs: 1e3,
            verbose: 0,
            callbacks: [
              tf3.callbacks.earlyStopping({ monitor: "loss", patience: 50 })
            ],
            ...modelFitOptions
          },
          denseLayerArgs: {
            units: 1,
            useBias: Boolean(fitIntercept),
            activation: "softmax",
            kernelInitializer: tf3.initializers.zeros(),
            biasInitializer: tf3.initializers.zeros(),
            kernelRegularizer: penalty === "l2" ? tf3.regularizers.l2({ l2: C }) : penalty === "l1" ? tf3.regularizers.l1({ l1: C }) : void 0
          },
          isClassification: true,
          optimizerType: "adam",
          lossType: "softmaxCrossEntropy"
        });
        this.name = "LogisticRegression";
      }
    };
  }
});

// node_modules/@babel/runtime/helpers/extends.js
var require_extends = __commonJS({
  "node_modules/@babel/runtime/helpers/extends.js"(exports, module) {
    function _extends6() {
      module.exports = _extends6 = Object.assign ? Object.assign.bind() : function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      return _extends6.apply(this, arguments);
    }
    module.exports = _extends6, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/mathjs/lib/esm/core/config.js
var DEFAULT_CONFIG;
var init_config = __esm({
  "node_modules/mathjs/lib/esm/core/config.js"() {
    DEFAULT_CONFIG = {
      epsilon: 1e-12,
      matrix: "Matrix",
      number: "number",
      precision: 64,
      predictable: false,
      randomSeed: null
    };
  }
});

// node_modules/mathjs/lib/esm/utils/is.js
function isNumber2(x) {
  return typeof x === "number";
}
function isBigNumber(x) {
  if (!x || typeof x !== "object" || typeof x.constructor !== "function") {
    return false;
  }
  if (x.isBigNumber === true && typeof x.constructor.prototype === "object" && x.constructor.prototype.isBigNumber === true) {
    return true;
  }
  if (typeof x.constructor.isDecimal === "function" && x.constructor.isDecimal(x) === true) {
    return true;
  }
  return false;
}
function isComplex(x) {
  return x && typeof x === "object" && Object.getPrototypeOf(x).isComplex === true || false;
}
function isFraction(x) {
  return x && typeof x === "object" && Object.getPrototypeOf(x).isFraction === true || false;
}
function isUnit(x) {
  return x && x.constructor.prototype.isUnit === true || false;
}
function isString2(x) {
  return typeof x === "string";
}
function isMatrix(x) {
  return x && x.constructor.prototype.isMatrix === true || false;
}
function isCollection(x) {
  return Array.isArray(x) || isMatrix(x);
}
function isDenseMatrix(x) {
  return x && x.isDenseMatrix && x.constructor.prototype.isMatrix === true || false;
}
function isSparseMatrix(x) {
  return x && x.isSparseMatrix && x.constructor.prototype.isMatrix === true || false;
}
function isRange(x) {
  return x && x.constructor.prototype.isRange === true || false;
}
function isIndex(x) {
  return x && x.constructor.prototype.isIndex === true || false;
}
function isBoolean2(x) {
  return typeof x === "boolean";
}
function isResultSet(x) {
  return x && x.constructor.prototype.isResultSet === true || false;
}
function isHelp(x) {
  return x && x.constructor.prototype.isHelp === true || false;
}
function isFunction(x) {
  return typeof x === "function";
}
function isDate(x) {
  return x instanceof Date;
}
function isRegExp(x) {
  return x instanceof RegExp;
}
function isObject(x) {
  return !!(x && typeof x === "object" && x.constructor === Object && !isComplex(x) && !isFraction(x));
}
function isNull(x) {
  return x === null;
}
function isUndefined(x) {
  return x === void 0;
}
function isAccessorNode(x) {
  return x && x.isAccessorNode === true && x.constructor.prototype.isNode === true || false;
}
function isArrayNode(x) {
  return x && x.isArrayNode === true && x.constructor.prototype.isNode === true || false;
}
function isAssignmentNode(x) {
  return x && x.isAssignmentNode === true && x.constructor.prototype.isNode === true || false;
}
function isBlockNode(x) {
  return x && x.isBlockNode === true && x.constructor.prototype.isNode === true || false;
}
function isConditionalNode(x) {
  return x && x.isConditionalNode === true && x.constructor.prototype.isNode === true || false;
}
function isConstantNode(x) {
  return x && x.isConstantNode === true && x.constructor.prototype.isNode === true || false;
}
function isFunctionAssignmentNode(x) {
  return x && x.isFunctionAssignmentNode === true && x.constructor.prototype.isNode === true || false;
}
function isFunctionNode(x) {
  return x && x.isFunctionNode === true && x.constructor.prototype.isNode === true || false;
}
function isIndexNode(x) {
  return x && x.isIndexNode === true && x.constructor.prototype.isNode === true || false;
}
function isNode(x) {
  return x && x.isNode === true && x.constructor.prototype.isNode === true || false;
}
function isObjectNode(x) {
  return x && x.isObjectNode === true && x.constructor.prototype.isNode === true || false;
}
function isOperatorNode(x) {
  return x && x.isOperatorNode === true && x.constructor.prototype.isNode === true || false;
}
function isParenthesisNode(x) {
  return x && x.isParenthesisNode === true && x.constructor.prototype.isNode === true || false;
}
function isRangeNode(x) {
  return x && x.isRangeNode === true && x.constructor.prototype.isNode === true || false;
}
function isSymbolNode(x) {
  return x && x.isSymbolNode === true && x.constructor.prototype.isNode === true || false;
}
function isChain(x) {
  return x && x.constructor.prototype.isChain === true || false;
}
function typeOf(x) {
  var t = typeof x;
  if (t === "object") {
    if (x === null)
      return "null";
    if (Array.isArray(x))
      return "Array";
    if (x instanceof Date)
      return "Date";
    if (x instanceof RegExp)
      return "RegExp";
    if (isBigNumber(x))
      return "BigNumber";
    if (isComplex(x))
      return "Complex";
    if (isFraction(x))
      return "Fraction";
    if (isMatrix(x))
      return "Matrix";
    if (isUnit(x))
      return "Unit";
    if (isIndex(x))
      return "Index";
    if (isRange(x))
      return "Range";
    if (isResultSet(x))
      return "ResultSet";
    if (isNode(x))
      return x.type;
    if (isChain(x))
      return "Chain";
    if (isHelp(x))
      return "Help";
    return "Object";
  }
  if (t === "function")
    return "Function";
  return t;
}
var isArray;
var init_is = __esm({
  "node_modules/mathjs/lib/esm/utils/is.js"() {
    isArray = Array.isArray;
  }
});

// node_modules/mathjs/lib/esm/utils/object.js
function clone(x) {
  var type = typeof x;
  if (type === "number" || type === "string" || type === "boolean" || x === null || x === void 0) {
    return x;
  }
  if (typeof x.clone === "function") {
    return x.clone();
  }
  if (Array.isArray(x)) {
    return x.map(function(value) {
      return clone(value);
    });
  }
  if (x instanceof Date)
    return new Date(x.valueOf());
  if (isBigNumber(x))
    return x;
  if (x instanceof RegExp)
    throw new TypeError("Cannot clone " + x);
  return mapObject(x, clone);
}
function mapObject(object, callback) {
  var clone3 = {};
  for (var key in object) {
    if (hasOwnProperty2(object, key)) {
      clone3[key] = callback(object[key]);
    }
  }
  return clone3;
}
function extend(a, b) {
  for (var prop in b) {
    if (hasOwnProperty2(b, prop)) {
      a[prop] = b[prop];
    }
  }
  return a;
}
function deepStrictEqual(a, b) {
  var prop, i2, len;
  if (Array.isArray(a)) {
    if (!Array.isArray(b)) {
      return false;
    }
    if (a.length !== b.length) {
      return false;
    }
    for (i2 = 0, len = a.length; i2 < len; i2++) {
      if (!deepStrictEqual(a[i2], b[i2])) {
        return false;
      }
    }
    return true;
  } else if (typeof a === "function") {
    return a === b;
  } else if (a instanceof Object) {
    if (Array.isArray(b) || !(b instanceof Object)) {
      return false;
    }
    for (prop in a) {
      if (!(prop in b) || !deepStrictEqual(a[prop], b[prop])) {
        return false;
      }
    }
    for (prop in b) {
      if (!(prop in a)) {
        return false;
      }
    }
    return true;
  } else {
    return a === b;
  }
}
function lazy(object, prop, valueResolver) {
  var _uninitialized = true;
  var _value;
  Object.defineProperty(object, prop, {
    get: function get() {
      if (_uninitialized) {
        _value = valueResolver();
        _uninitialized = false;
      }
      return _value;
    },
    set: function set(value) {
      _value = value;
      _uninitialized = false;
    },
    configurable: true,
    enumerable: true
  });
}
function hasOwnProperty2(object, property) {
  return object && Object.hasOwnProperty.call(object, property);
}
function pickShallow(object, properties2) {
  var copy = {};
  for (var i2 = 0; i2 < properties2.length; i2++) {
    var key = properties2[i2];
    var value = object[key];
    if (value !== void 0) {
      copy[key] = value;
    }
  }
  return copy;
}
var init_object = __esm({
  "node_modules/mathjs/lib/esm/utils/object.js"() {
    init_is();
  }
});

// node_modules/mathjs/lib/esm/core/function/config.js
var MATRIX_OPTIONS, NUMBER_OPTIONS;
var init_config2 = __esm({
  "node_modules/mathjs/lib/esm/core/function/config.js"() {
    MATRIX_OPTIONS = ["Matrix", "Array"];
    NUMBER_OPTIONS = ["number", "BigNumber", "Fraction"];
  }
});

// node_modules/mathjs/lib/esm/entry/configReadonly.js
var import_extends, config;
var init_configReadonly = __esm({
  "node_modules/mathjs/lib/esm/entry/configReadonly.js"() {
    import_extends = __toESM(require_extends(), 1);
    init_config();
    init_config2();
    config = function config2(options) {
      if (options) {
        throw new Error("The global config is readonly. \nPlease create a mathjs instance if you want to change the default configuration. \nExample:\n\n  import { create, all } from 'mathjs';\n  const mathjs = create(all);\n  mathjs.config({ number: 'BigNumber' });\n");
      }
      return Object.freeze(DEFAULT_CONFIG);
    };
    (0, import_extends.default)(config, DEFAULT_CONFIG, {
      MATRIX_OPTIONS,
      NUMBER_OPTIONS
    });
  }
});

// node_modules/typed-function/typed-function.js
var require_typed_function = __commonJS({
  "node_modules/typed-function/typed-function.js"(exports, module) {
    "use strict";
    (function(root, factory2) {
      if (typeof define === "function" && define.amd) {
        define([], factory2);
      } else if (typeof exports === "object") {
        module.exports = factory2();
      } else {
        root.typed = factory2();
      }
    })(exports, function() {
      function ok() {
        return true;
      }
      function notOk() {
        return false;
      }
      function undef() {
        return void 0;
      }
      function create() {
        var _types = [
          { name: "number", test: function(x) {
            return typeof x === "number";
          } },
          { name: "string", test: function(x) {
            return typeof x === "string";
          } },
          { name: "boolean", test: function(x) {
            return typeof x === "boolean";
          } },
          { name: "Function", test: function(x) {
            return typeof x === "function";
          } },
          { name: "Array", test: Array.isArray },
          { name: "Date", test: function(x) {
            return x instanceof Date;
          } },
          { name: "RegExp", test: function(x) {
            return x instanceof RegExp;
          } },
          { name: "Object", test: function(x) {
            return typeof x === "object" && x !== null && x.constructor === Object;
          } },
          { name: "null", test: function(x) {
            return x === null;
          } },
          { name: "undefined", test: function(x) {
            return x === void 0;
          } }
        ];
        var anyType = {
          name: "any",
          test: ok
        };
        var _ignore = [];
        var _conversions = [];
        var typed2 = {
          types: _types,
          conversions: _conversions,
          ignore: _ignore
        };
        function findTypeByName(typeName) {
          var entry = findInArray(typed2.types, function(entry2) {
            return entry2.name === typeName;
          });
          if (entry) {
            return entry;
          }
          if (typeName === "any") {
            return anyType;
          }
          var hint = findInArray(typed2.types, function(entry2) {
            return entry2.name.toLowerCase() === typeName.toLowerCase();
          });
          throw new TypeError('Unknown type "' + typeName + '"' + (hint ? '. Did you mean "' + hint.name + '"?' : ""));
        }
        function findTypeIndex(type) {
          if (type === anyType) {
            return 999;
          }
          return typed2.types.indexOf(type);
        }
        function findTypeName(value) {
          var entry = findInArray(typed2.types, function(entry2) {
            return entry2.test(value);
          });
          if (entry) {
            return entry.name;
          }
          throw new TypeError("Value has unknown type. Value: " + value);
        }
        function find(fn, signature) {
          if (!fn.signatures) {
            throw new TypeError("Function is no typed-function");
          }
          var arr;
          if (typeof signature === "string") {
            arr = signature.split(",");
            for (var i2 = 0; i2 < arr.length; i2++) {
              arr[i2] = arr[i2].trim();
            }
          } else if (Array.isArray(signature)) {
            arr = signature;
          } else {
            throw new TypeError("String array or a comma separated string expected");
          }
          var str = arr.join(",");
          var match = fn.signatures[str];
          if (match) {
            return match;
          }
          throw new TypeError("Signature not found (signature: " + (fn.name || "unnamed") + "(" + arr.join(", ") + "))");
        }
        function convert(value, type) {
          var from = findTypeName(value);
          if (type === from) {
            return value;
          }
          for (var i2 = 0; i2 < typed2.conversions.length; i2++) {
            var conversion = typed2.conversions[i2];
            if (conversion.from === from && conversion.to === type) {
              return conversion.convert(value);
            }
          }
          throw new Error("Cannot convert from " + from + " to " + type);
        }
        function stringifyParams(params) {
          return params.map(function(param) {
            var typeNames = param.types.map(getTypeName);
            return (param.restParam ? "..." : "") + typeNames.join("|");
          }).join(",");
        }
        function parseParam(param, conversions) {
          var restParam = param.indexOf("...") === 0;
          var types = !restParam ? param : param.length > 3 ? param.slice(3) : "any";
          var typeNames = types.split("|").map(trim).filter(notEmpty).filter(notIgnore);
          var matchingConversions = filterConversions(conversions, typeNames);
          var exactTypes = typeNames.map(function(typeName) {
            var type = findTypeByName(typeName);
            return {
              name: typeName,
              typeIndex: findTypeIndex(type),
              test: type.test,
              conversion: null,
              conversionIndex: -1
            };
          });
          var convertibleTypes = matchingConversions.map(function(conversion) {
            var type = findTypeByName(conversion.from);
            return {
              name: conversion.from,
              typeIndex: findTypeIndex(type),
              test: type.test,
              conversion,
              conversionIndex: conversions.indexOf(conversion)
            };
          });
          return {
            types: exactTypes.concat(convertibleTypes),
            restParam
          };
        }
        function parseSignature(signature, fn, conversions) {
          var params = [];
          if (signature.trim() !== "") {
            params = signature.split(",").map(trim).map(function(param, index2, array) {
              var parsedParam = parseParam(param, conversions);
              if (parsedParam.restParam && index2 !== array.length - 1) {
                throw new SyntaxError('Unexpected rest parameter "' + param + '": only allowed for the last parameter');
              }
              return parsedParam;
            });
          }
          if (params.some(isInvalidParam)) {
            return null;
          }
          return {
            params,
            fn
          };
        }
        function hasRestParam(params) {
          var param = last(params);
          return param ? param.restParam : false;
        }
        function hasConversions(param) {
          return param.types.some(function(type) {
            return type.conversion != null;
          });
        }
        function compileTest(param) {
          if (!param || param.types.length === 0) {
            return ok;
          } else if (param.types.length === 1) {
            return findTypeByName(param.types[0].name).test;
          } else if (param.types.length === 2) {
            var test0 = findTypeByName(param.types[0].name).test;
            var test1 = findTypeByName(param.types[1].name).test;
            return function or2(x) {
              return test0(x) || test1(x);
            };
          } else {
            var tests = param.types.map(function(type) {
              return findTypeByName(type.name).test;
            });
            return function or2(x) {
              for (var i2 = 0; i2 < tests.length; i2++) {
                if (tests[i2](x)) {
                  return true;
                }
              }
              return false;
            };
          }
        }
        function compileTests(params) {
          var tests, test0, test1;
          if (hasRestParam(params)) {
            tests = initial(params).map(compileTest);
            var varIndex = tests.length;
            var lastTest = compileTest(last(params));
            var testRestParam = function(args) {
              for (var i2 = varIndex; i2 < args.length; i2++) {
                if (!lastTest(args[i2])) {
                  return false;
                }
              }
              return true;
            };
            return function testArgs(args) {
              for (var i2 = 0; i2 < tests.length; i2++) {
                if (!tests[i2](args[i2])) {
                  return false;
                }
              }
              return testRestParam(args) && args.length >= varIndex + 1;
            };
          } else {
            if (params.length === 0) {
              return function testArgs(args) {
                return args.length === 0;
              };
            } else if (params.length === 1) {
              test0 = compileTest(params[0]);
              return function testArgs(args) {
                return test0(args[0]) && args.length === 1;
              };
            } else if (params.length === 2) {
              test0 = compileTest(params[0]);
              test1 = compileTest(params[1]);
              return function testArgs(args) {
                return test0(args[0]) && test1(args[1]) && args.length === 2;
              };
            } else {
              tests = params.map(compileTest);
              return function testArgs(args) {
                for (var i2 = 0; i2 < tests.length; i2++) {
                  if (!tests[i2](args[i2])) {
                    return false;
                  }
                }
                return args.length === tests.length;
              };
            }
          }
        }
        function getParamAtIndex(signature, index2) {
          return index2 < signature.params.length ? signature.params[index2] : hasRestParam(signature.params) ? last(signature.params) : null;
        }
        function getExpectedTypeNames(signature, index2, excludeConversions) {
          var param = getParamAtIndex(signature, index2);
          var types = param ? excludeConversions ? param.types.filter(isExactType) : param.types : [];
          return types.map(getTypeName);
        }
        function getTypeName(type) {
          return type.name;
        }
        function isExactType(type) {
          return type.conversion === null || type.conversion === void 0;
        }
        function mergeExpectedParams(signatures, index2) {
          var typeNames = uniq3(flatMap(signatures, function(signature) {
            return getExpectedTypeNames(signature, index2, false);
          }));
          return typeNames.indexOf("any") !== -1 ? ["any"] : typeNames;
        }
        function createError(name296, args, signatures) {
          var err, expected;
          var _name = name296 || "unnamed";
          var matchingSignatures = signatures;
          var index2;
          for (index2 = 0; index2 < args.length; index2++) {
            var nextMatchingDefs = matchingSignatures.filter(function(signature) {
              var test = compileTest(getParamAtIndex(signature, index2));
              return (index2 < signature.params.length || hasRestParam(signature.params)) && test(args[index2]);
            });
            if (nextMatchingDefs.length === 0) {
              expected = mergeExpectedParams(matchingSignatures, index2);
              if (expected.length > 0) {
                var actualType = findTypeName(args[index2]);
                err = new TypeError("Unexpected type of argument in function " + _name + " (expected: " + expected.join(" or ") + ", actual: " + actualType + ", index: " + index2 + ")");
                err.data = {
                  category: "wrongType",
                  fn: _name,
                  index: index2,
                  actual: actualType,
                  expected
                };
                return err;
              }
            } else {
              matchingSignatures = nextMatchingDefs;
            }
          }
          var lengths = matchingSignatures.map(function(signature) {
            return hasRestParam(signature.params) ? Infinity : signature.params.length;
          });
          if (args.length < Math.min.apply(null, lengths)) {
            expected = mergeExpectedParams(matchingSignatures, index2);
            err = new TypeError("Too few arguments in function " + _name + " (expected: " + expected.join(" or ") + ", index: " + args.length + ")");
            err.data = {
              category: "tooFewArgs",
              fn: _name,
              index: args.length,
              expected
            };
            return err;
          }
          var maxLength = Math.max.apply(null, lengths);
          if (args.length > maxLength) {
            err = new TypeError("Too many arguments in function " + _name + " (expected: " + maxLength + ", actual: " + args.length + ")");
            err.data = {
              category: "tooManyArgs",
              fn: _name,
              index: args.length,
              expectedLength: maxLength
            };
            return err;
          }
          err = new TypeError('Arguments of type "' + args.join(", ") + '" do not match any of the defined signatures of function ' + _name + ".");
          err.data = {
            category: "mismatch",
            actual: args.map(findTypeName)
          };
          return err;
        }
        function getLowestTypeIndex(param) {
          var min2 = 999;
          for (var i2 = 0; i2 < param.types.length; i2++) {
            if (isExactType(param.types[i2])) {
              min2 = Math.min(min2, param.types[i2].typeIndex);
            }
          }
          return min2;
        }
        function getLowestConversionIndex(param) {
          var min2 = 999;
          for (var i2 = 0; i2 < param.types.length; i2++) {
            if (!isExactType(param.types[i2])) {
              min2 = Math.min(min2, param.types[i2].conversionIndex);
            }
          }
          return min2;
        }
        function compareParams(param1, param2) {
          var c;
          c = param1.restParam - param2.restParam;
          if (c !== 0) {
            return c;
          }
          c = hasConversions(param1) - hasConversions(param2);
          if (c !== 0) {
            return c;
          }
          c = getLowestTypeIndex(param1) - getLowestTypeIndex(param2);
          if (c !== 0) {
            return c;
          }
          return getLowestConversionIndex(param1) - getLowestConversionIndex(param2);
        }
        function compareSignatures(signature1, signature2) {
          var len = Math.min(signature1.params.length, signature2.params.length);
          var i2;
          var c;
          c = signature1.params.some(hasConversions) - signature2.params.some(hasConversions);
          if (c !== 0) {
            return c;
          }
          for (i2 = 0; i2 < len; i2++) {
            c = hasConversions(signature1.params[i2]) - hasConversions(signature2.params[i2]);
            if (c !== 0) {
              return c;
            }
          }
          for (i2 = 0; i2 < len; i2++) {
            c = compareParams(signature1.params[i2], signature2.params[i2]);
            if (c !== 0) {
              return c;
            }
          }
          return signature1.params.length - signature2.params.length;
        }
        function filterConversions(conversions, typeNames) {
          var matches = {};
          conversions.forEach(function(conversion) {
            if (typeNames.indexOf(conversion.from) === -1 && typeNames.indexOf(conversion.to) !== -1 && !matches[conversion.from]) {
              matches[conversion.from] = conversion;
            }
          });
          return Object.keys(matches).map(function(from) {
            return matches[from];
          });
        }
        function compileArgsPreprocessing(params, fn) {
          var fnConvert = fn;
          if (params.some(hasConversions)) {
            var restParam = hasRestParam(params);
            var compiledConversions = params.map(compileArgConversion);
            fnConvert = function convertArgs() {
              var args = [];
              var last2 = restParam ? arguments.length - 1 : arguments.length;
              for (var i2 = 0; i2 < last2; i2++) {
                args[i2] = compiledConversions[i2](arguments[i2]);
              }
              if (restParam) {
                args[last2] = arguments[last2].map(compiledConversions[last2]);
              }
              return fn.apply(this, args);
            };
          }
          var fnPreprocess = fnConvert;
          if (hasRestParam(params)) {
            var offset = params.length - 1;
            fnPreprocess = function preprocessRestParams() {
              return fnConvert.apply(
                this,
                slice(arguments, 0, offset).concat([slice(arguments, offset)])
              );
            };
          }
          return fnPreprocess;
        }
        function compileArgConversion(param) {
          var test0, test1, conversion0, conversion1;
          var tests = [];
          var conversions = [];
          param.types.forEach(function(type) {
            if (type.conversion) {
              tests.push(findTypeByName(type.conversion.from).test);
              conversions.push(type.conversion.convert);
            }
          });
          switch (conversions.length) {
            case 0:
              return function convertArg(arg2) {
                return arg2;
              };
            case 1:
              test0 = tests[0];
              conversion0 = conversions[0];
              return function convertArg(arg2) {
                if (test0(arg2)) {
                  return conversion0(arg2);
                }
                return arg2;
              };
            case 2:
              test0 = tests[0];
              test1 = tests[1];
              conversion0 = conversions[0];
              conversion1 = conversions[1];
              return function convertArg(arg2) {
                if (test0(arg2)) {
                  return conversion0(arg2);
                }
                if (test1(arg2)) {
                  return conversion1(arg2);
                }
                return arg2;
              };
            default:
              return function convertArg(arg2) {
                for (var i2 = 0; i2 < conversions.length; i2++) {
                  if (tests[i2](arg2)) {
                    return conversions[i2](arg2);
                  }
                }
                return arg2;
              };
          }
        }
        function createSignaturesMap(signatures) {
          var signaturesMap = {};
          signatures.forEach(function(signature) {
            if (!signature.params.some(hasConversions)) {
              splitParams(signature.params, true).forEach(function(params) {
                signaturesMap[stringifyParams(params)] = signature.fn;
              });
            }
          });
          return signaturesMap;
        }
        function splitParams(params, ignoreConversionTypes) {
          function _splitParams(params2, index2, types) {
            if (index2 < params2.length) {
              var param = params2[index2];
              var filteredTypes = ignoreConversionTypes ? param.types.filter(isExactType) : param.types;
              var typeGroups;
              if (param.restParam) {
                var exactTypes = filteredTypes.filter(isExactType);
                typeGroups = exactTypes.length < filteredTypes.length ? [exactTypes, filteredTypes] : [filteredTypes];
              } else {
                typeGroups = filteredTypes.map(function(type) {
                  return [type];
                });
              }
              return flatMap(typeGroups, function(typeGroup) {
                return _splitParams(params2, index2 + 1, types.concat([typeGroup]));
              });
            } else {
              var splittedParams = types.map(function(type, typeIndex) {
                return {
                  types: type,
                  restParam: typeIndex === params2.length - 1 && hasRestParam(params2)
                };
              });
              return [splittedParams];
            }
          }
          return _splitParams(params, 0, []);
        }
        function hasConflictingParams(signature1, signature2) {
          var ii = Math.max(signature1.params.length, signature2.params.length);
          for (var i2 = 0; i2 < ii; i2++) {
            var typesNames1 = getExpectedTypeNames(signature1, i2, true);
            var typesNames2 = getExpectedTypeNames(signature2, i2, true);
            if (!hasOverlap(typesNames1, typesNames2)) {
              return false;
            }
          }
          var len1 = signature1.params.length;
          var len2 = signature2.params.length;
          var restParam1 = hasRestParam(signature1.params);
          var restParam2 = hasRestParam(signature2.params);
          return restParam1 ? restParam2 ? len1 === len2 : len2 >= len1 : restParam2 ? len1 >= len2 : len1 === len2;
        }
        function createTypedFunction(name296, signaturesMap) {
          if (Object.keys(signaturesMap).length === 0) {
            throw new SyntaxError("No signatures provided");
          }
          var parsedSignatures = [];
          Object.keys(signaturesMap).map(function(signature) {
            return parseSignature(signature, signaturesMap[signature], typed2.conversions);
          }).filter(notNull).forEach(function(parsedSignature) {
            var conflictingSignature = findInArray(parsedSignatures, function(s) {
              return hasConflictingParams(s, parsedSignature);
            });
            if (conflictingSignature) {
              throw new TypeError('Conflicting signatures "' + stringifyParams(conflictingSignature.params) + '" and "' + stringifyParams(parsedSignature.params) + '".');
            }
            parsedSignatures.push(parsedSignature);
          });
          var signatures = flatMap(parsedSignatures, function(parsedSignature) {
            var params = parsedSignature ? splitParams(parsedSignature.params, false) : [];
            return params.map(function(params2) {
              return {
                params: params2,
                fn: parsedSignature.fn
              };
            });
          }).filter(notNull);
          signatures.sort(compareSignatures);
          var ok0 = signatures[0] && signatures[0].params.length <= 2 && !hasRestParam(signatures[0].params);
          var ok1 = signatures[1] && signatures[1].params.length <= 2 && !hasRestParam(signatures[1].params);
          var ok2 = signatures[2] && signatures[2].params.length <= 2 && !hasRestParam(signatures[2].params);
          var ok3 = signatures[3] && signatures[3].params.length <= 2 && !hasRestParam(signatures[3].params);
          var ok4 = signatures[4] && signatures[4].params.length <= 2 && !hasRestParam(signatures[4].params);
          var ok5 = signatures[5] && signatures[5].params.length <= 2 && !hasRestParam(signatures[5].params);
          var allOk = ok0 && ok1 && ok2 && ok3 && ok4 && ok5;
          var tests = signatures.map(function(signature) {
            return compileTests(signature.params);
          });
          var test00 = ok0 ? compileTest(signatures[0].params[0]) : notOk;
          var test10 = ok1 ? compileTest(signatures[1].params[0]) : notOk;
          var test20 = ok2 ? compileTest(signatures[2].params[0]) : notOk;
          var test30 = ok3 ? compileTest(signatures[3].params[0]) : notOk;
          var test40 = ok4 ? compileTest(signatures[4].params[0]) : notOk;
          var test50 = ok5 ? compileTest(signatures[5].params[0]) : notOk;
          var test01 = ok0 ? compileTest(signatures[0].params[1]) : notOk;
          var test11 = ok1 ? compileTest(signatures[1].params[1]) : notOk;
          var test21 = ok2 ? compileTest(signatures[2].params[1]) : notOk;
          var test31 = ok3 ? compileTest(signatures[3].params[1]) : notOk;
          var test41 = ok4 ? compileTest(signatures[4].params[1]) : notOk;
          var test51 = ok5 ? compileTest(signatures[5].params[1]) : notOk;
          var fns = signatures.map(function(signature) {
            return compileArgsPreprocessing(signature.params, signature.fn);
          });
          var fn0 = ok0 ? fns[0] : undef;
          var fn1 = ok1 ? fns[1] : undef;
          var fn2 = ok2 ? fns[2] : undef;
          var fn3 = ok3 ? fns[3] : undef;
          var fn4 = ok4 ? fns[4] : undef;
          var fn5 = ok5 ? fns[5] : undef;
          var len0 = ok0 ? signatures[0].params.length : -1;
          var len1 = ok1 ? signatures[1].params.length : -1;
          var len2 = ok2 ? signatures[2].params.length : -1;
          var len3 = ok3 ? signatures[3].params.length : -1;
          var len4 = ok4 ? signatures[4].params.length : -1;
          var len5 = ok5 ? signatures[5].params.length : -1;
          var iStart = allOk ? 6 : 0;
          var iEnd = signatures.length;
          var generic = function generic2() {
            "use strict";
            for (var i2 = iStart; i2 < iEnd; i2++) {
              if (tests[i2](arguments)) {
                return fns[i2].apply(this, arguments);
              }
            }
            return typed2.onMismatch(name296, arguments, signatures);
          };
          var fn = function fn6(arg0, arg1) {
            "use strict";
            if (arguments.length === len0 && test00(arg0) && test01(arg1)) {
              return fn0.apply(fn6, arguments);
            }
            if (arguments.length === len1 && test10(arg0) && test11(arg1)) {
              return fn1.apply(fn6, arguments);
            }
            if (arguments.length === len2 && test20(arg0) && test21(arg1)) {
              return fn2.apply(fn6, arguments);
            }
            if (arguments.length === len3 && test30(arg0) && test31(arg1)) {
              return fn3.apply(fn6, arguments);
            }
            if (arguments.length === len4 && test40(arg0) && test41(arg1)) {
              return fn4.apply(fn6, arguments);
            }
            if (arguments.length === len5 && test50(arg0) && test51(arg1)) {
              return fn5.apply(fn6, arguments);
            }
            return generic.apply(fn6, arguments);
          };
          try {
            Object.defineProperty(fn, "name", { value: name296 });
          } catch (err) {
          }
          fn.signatures = createSignaturesMap(signatures);
          return fn;
        }
        function _onMismatch(name296, args, signatures) {
          throw createError(name296, args, signatures);
        }
        function notIgnore(typeName) {
          return typed2.ignore.indexOf(typeName) === -1;
        }
        function trim(str) {
          return str.trim();
        }
        function notEmpty(str) {
          return !!str;
        }
        function notNull(value) {
          return value !== null;
        }
        function isInvalidParam(param) {
          return param.types.length === 0;
        }
        function initial(arr) {
          return arr.slice(0, arr.length - 1);
        }
        function last(arr) {
          return arr[arr.length - 1];
        }
        function slice(arr, start, end) {
          return Array.prototype.slice.call(arr, start, end);
        }
        function contains(array, item) {
          return array.indexOf(item) !== -1;
        }
        function hasOverlap(array1, array2) {
          for (var i2 = 0; i2 < array1.length; i2++) {
            if (contains(array2, array1[i2])) {
              return true;
            }
          }
          return false;
        }
        function findInArray(arr, test) {
          for (var i2 = 0; i2 < arr.length; i2++) {
            if (test(arr[i2])) {
              return arr[i2];
            }
          }
          return void 0;
        }
        function uniq3(arr) {
          var entries = {};
          for (var i2 = 0; i2 < arr.length; i2++) {
            entries[arr[i2]] = true;
          }
          return Object.keys(entries);
        }
        function flatMap(arr, callback) {
          return Array.prototype.concat.apply([], arr.map(callback));
        }
        function getName(fns) {
          var name296 = "";
          for (var i2 = 0; i2 < fns.length; i2++) {
            var fn = fns[i2];
            if ((typeof fn.signatures === "object" || typeof fn.signature === "string") && fn.name !== "") {
              if (name296 === "") {
                name296 = fn.name;
              } else if (name296 !== fn.name) {
                var err = new Error("Function names do not match (expected: " + name296 + ", actual: " + fn.name + ")");
                err.data = {
                  actual: fn.name,
                  expected: name296
                };
                throw err;
              }
            }
          }
          return name296;
        }
        function extractSignatures(fns) {
          var err;
          var signaturesMap = {};
          function validateUnique(_signature, _fn) {
            if (signaturesMap.hasOwnProperty(_signature) && _fn !== signaturesMap[_signature]) {
              err = new Error('Signature "' + _signature + '" is defined twice');
              err.data = { signature: _signature };
              throw err;
            }
          }
          for (var i2 = 0; i2 < fns.length; i2++) {
            var fn = fns[i2];
            if (typeof fn.signatures === "object") {
              for (var signature in fn.signatures) {
                if (fn.signatures.hasOwnProperty(signature)) {
                  validateUnique(signature, fn.signatures[signature]);
                  signaturesMap[signature] = fn.signatures[signature];
                }
              }
            } else if (typeof fn.signature === "string") {
              validateUnique(fn.signature, fn);
              signaturesMap[fn.signature] = fn;
            } else {
              err = new TypeError("Function is no typed-function (index: " + i2 + ")");
              err.data = { index: i2 };
              throw err;
            }
          }
          return signaturesMap;
        }
        typed2 = createTypedFunction("typed", {
          "string, Object": createTypedFunction,
          "Object": function(signaturesMap) {
            var fns = [];
            for (var signature in signaturesMap) {
              if (signaturesMap.hasOwnProperty(signature)) {
                fns.push(signaturesMap[signature]);
              }
            }
            var name296 = getName(fns);
            return createTypedFunction(name296, signaturesMap);
          },
          "...Function": function(fns) {
            return createTypedFunction(getName(fns), extractSignatures(fns));
          },
          "string, ...Function": function(name296, fns) {
            return createTypedFunction(name296, extractSignatures(fns));
          }
        });
        typed2.create = create;
        typed2.types = _types;
        typed2.conversions = _conversions;
        typed2.ignore = _ignore;
        typed2.onMismatch = _onMismatch;
        typed2.throwMismatchError = _onMismatch;
        typed2.createError = createError;
        typed2.convert = convert;
        typed2.find = find;
        typed2.addType = function(type, beforeObjectTest) {
          if (!type || typeof type.name !== "string" || typeof type.test !== "function") {
            throw new TypeError("Object with properties {name: string, test: function} expected");
          }
          if (beforeObjectTest !== false) {
            for (var i2 = 0; i2 < typed2.types.length; i2++) {
              if (typed2.types[i2].name === "Object") {
                typed2.types.splice(i2, 0, type);
                return;
              }
            }
          }
          typed2.types.push(type);
        };
        typed2.addConversion = function(conversion) {
          if (!conversion || typeof conversion.from !== "string" || typeof conversion.to !== "string" || typeof conversion.convert !== "function") {
            throw new TypeError("Object with properties {from: string, to: string, convert: function} expected");
          }
          typed2.conversions.push(conversion);
        };
        return typed2;
      }
      return create();
    });
  }
});

// node_modules/mathjs/lib/esm/utils/number.js
function isInteger(value) {
  if (typeof value === "boolean") {
    return true;
  }
  return isFinite(value) ? value === Math.round(value) : false;
}
function formatNumberToBase(n, base, size2) {
  var prefixes = {
    2: "0b",
    8: "0o",
    16: "0x"
  };
  var prefix = prefixes[base];
  var suffix = "";
  if (size2) {
    if (size2 < 1) {
      throw new Error("size must be in greater than 0");
    }
    if (!isInteger(size2)) {
      throw new Error("size must be an integer");
    }
    if (n > 2 ** (size2 - 1) - 1 || n < -(2 ** (size2 - 1))) {
      throw new Error("Value must be in range [-2^".concat(size2 - 1, ", 2^").concat(size2 - 1, "-1]"));
    }
    if (!isInteger(n)) {
      throw new Error("Value must be an integer");
    }
    if (n < 0) {
      n = n + 2 ** size2;
    }
    suffix = "i".concat(size2);
  }
  var sign3 = "";
  if (n < 0) {
    n = -n;
    sign3 = "-";
  }
  return "".concat(sign3).concat(prefix).concat(n.toString(base)).concat(suffix);
}
function format(value, options) {
  if (typeof options === "function") {
    return options(value);
  }
  if (value === Infinity) {
    return "Infinity";
  } else if (value === -Infinity) {
    return "-Infinity";
  } else if (isNaN(value)) {
    return "NaN";
  }
  var notation = "auto";
  var precision;
  var wordSize;
  if (options) {
    if (options.notation) {
      notation = options.notation;
    }
    if (isNumber2(options)) {
      precision = options;
    } else if (isNumber2(options.precision)) {
      precision = options.precision;
    }
    if (options.wordSize) {
      wordSize = options.wordSize;
      if (typeof wordSize !== "number") {
        throw new Error('Option "wordSize" must be a number');
      }
    }
  }
  switch (notation) {
    case "fixed":
      return toFixed(value, precision);
    case "exponential":
      return toExponential(value, precision);
    case "engineering":
      return toEngineering(value, precision);
    case "bin":
      return formatNumberToBase(value, 2, wordSize);
    case "oct":
      return formatNumberToBase(value, 8, wordSize);
    case "hex":
      return formatNumberToBase(value, 16, wordSize);
    case "auto":
      return toPrecision(value, precision, options && options).replace(/((\.\d*?)(0+))($|e)/, function() {
        var digits2 = arguments[2];
        var e3 = arguments[4];
        return digits2 !== "." ? digits2 + e3 : e3;
      });
    default:
      throw new Error('Unknown notation "' + notation + '". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
  }
}
function splitNumber(value) {
  var match = String(value).toLowerCase().match(/^(-?)(\d+\.?\d*)(e([+-]?\d+))?$/);
  if (!match) {
    throw new SyntaxError("Invalid number " + value);
  }
  var sign3 = match[1];
  var digits2 = match[2];
  var exponent = parseFloat(match[4] || "0");
  var dot2 = digits2.indexOf(".");
  exponent += dot2 !== -1 ? dot2 - 1 : digits2.length - 1;
  var coefficients = digits2.replace(".", "").replace(/^0*/, function(zeros3) {
    exponent -= zeros3.length;
    return "";
  }).replace(/0*$/, "").split("").map(function(d) {
    return parseInt(d);
  });
  if (coefficients.length === 0) {
    coefficients.push(0);
    exponent++;
  }
  return {
    sign: sign3,
    coefficients,
    exponent
  };
}
function toEngineering(value, precision) {
  if (isNaN(value) || !isFinite(value)) {
    return String(value);
  }
  var split = splitNumber(value);
  var rounded = roundDigits(split, precision);
  var e3 = rounded.exponent;
  var c = rounded.coefficients;
  var newExp = e3 % 3 === 0 ? e3 : e3 < 0 ? e3 - 3 - e3 % 3 : e3 - e3 % 3;
  if (isNumber2(precision)) {
    while (precision > c.length || e3 - newExp + 1 > c.length) {
      c.push(0);
    }
  } else {
    var missingZeros = Math.abs(e3 - newExp) - (c.length - 1);
    for (var i2 = 0; i2 < missingZeros; i2++) {
      c.push(0);
    }
  }
  var expDiff = Math.abs(e3 - newExp);
  var decimalIdx = 1;
  while (expDiff > 0) {
    decimalIdx++;
    expDiff--;
  }
  var decimals = c.slice(decimalIdx).join("");
  var decimalVal = isNumber2(precision) && decimals.length || decimals.match(/[1-9]/) ? "." + decimals : "";
  var str = c.slice(0, decimalIdx).join("") + decimalVal + "e" + (e3 >= 0 ? "+" : "") + newExp.toString();
  return rounded.sign + str;
}
function toFixed(value, precision) {
  if (isNaN(value) || !isFinite(value)) {
    return String(value);
  }
  var splitValue = splitNumber(value);
  var rounded = typeof precision === "number" ? roundDigits(splitValue, splitValue.exponent + 1 + precision) : splitValue;
  var c = rounded.coefficients;
  var p = rounded.exponent + 1;
  var pp = p + (precision || 0);
  if (c.length < pp) {
    c = c.concat(zeros(pp - c.length));
  }
  if (p < 0) {
    c = zeros(-p + 1).concat(c);
    p = 1;
  }
  if (p < c.length) {
    c.splice(p, 0, p === 0 ? "0." : ".");
  }
  return rounded.sign + c.join("");
}
function toExponential(value, precision) {
  if (isNaN(value) || !isFinite(value)) {
    return String(value);
  }
  var split = splitNumber(value);
  var rounded = precision ? roundDigits(split, precision) : split;
  var c = rounded.coefficients;
  var e3 = rounded.exponent;
  if (c.length < precision) {
    c = c.concat(zeros(precision - c.length));
  }
  var first = c.shift();
  return rounded.sign + first + (c.length > 0 ? "." + c.join("") : "") + "e" + (e3 >= 0 ? "+" : "") + e3;
}
function toPrecision(value, precision, options) {
  if (isNaN(value) || !isFinite(value)) {
    return String(value);
  }
  var lowerExp = options && options.lowerExp !== void 0 ? options.lowerExp : -3;
  var upperExp = options && options.upperExp !== void 0 ? options.upperExp : 5;
  var split = splitNumber(value);
  var rounded = precision ? roundDigits(split, precision) : split;
  if (rounded.exponent < lowerExp || rounded.exponent >= upperExp) {
    return toExponential(value, precision);
  } else {
    var c = rounded.coefficients;
    var e3 = rounded.exponent;
    if (c.length < precision) {
      c = c.concat(zeros(precision - c.length));
    }
    c = c.concat(zeros(e3 - c.length + 1 + (c.length < precision ? precision - c.length : 0)));
    c = zeros(-e3).concat(c);
    var dot2 = e3 > 0 ? e3 : 0;
    if (dot2 < c.length - 1) {
      c.splice(dot2 + 1, 0, ".");
    }
    return rounded.sign + c.join("");
  }
}
function roundDigits(split, precision) {
  var rounded = {
    sign: split.sign,
    coefficients: split.coefficients,
    exponent: split.exponent
  };
  var c = rounded.coefficients;
  while (precision <= 0) {
    c.unshift(0);
    rounded.exponent++;
    precision++;
  }
  if (c.length > precision) {
    var removed = c.splice(precision, c.length - precision);
    if (removed[0] >= 5) {
      var i2 = precision - 1;
      c[i2]++;
      while (c[i2] === 10) {
        c.pop();
        if (i2 === 0) {
          c.unshift(0);
          rounded.exponent++;
          i2++;
        }
        i2--;
        c[i2]++;
      }
    }
  }
  return rounded;
}
function zeros(length) {
  var arr = [];
  for (var i2 = 0; i2 < length; i2++) {
    arr.push(0);
  }
  return arr;
}
function digits(value) {
  return value.toExponential().replace(/e.*$/, "").replace(/^0\.?0*|\./, "").length;
}
function nearlyEqual(x, y, epsilon) {
  if (epsilon === null || epsilon === void 0) {
    return x === y;
  }
  if (x === y) {
    return true;
  }
  if (isNaN(x) || isNaN(y)) {
    return false;
  }
  if (isFinite(x) && isFinite(y)) {
    var diff2 = Math.abs(x - y);
    if (diff2 < DBL_EPSILON) {
      return true;
    } else {
      return diff2 <= Math.max(Math.abs(x), Math.abs(y)) * epsilon;
    }
  }
  return false;
}
function copysign(x, y) {
  var signx = x > 0 ? true : x < 0 ? false : 1 / x === Infinity;
  var signy = y > 0 ? true : y < 0 ? false : 1 / y === Infinity;
  return signx ^ signy ? -x : x;
}
var sign, log2, log10, log1p, cbrt, expm1, DBL_EPSILON, acosh, asinh, atanh, cosh, sinh, tanh;
var init_number = __esm({
  "node_modules/mathjs/lib/esm/utils/number.js"() {
    init_is();
    sign = Math.sign || function(x) {
      if (x > 0) {
        return 1;
      } else if (x < 0) {
        return -1;
      } else {
        return 0;
      }
    };
    log2 = Math.log2 || function log22(x) {
      return Math.log(x) / Math.LN2;
    };
    log10 = Math.log10 || function log102(x) {
      return Math.log(x) / Math.LN10;
    };
    log1p = Math.log1p || function(x) {
      return Math.log(x + 1);
    };
    cbrt = Math.cbrt || function cbrt2(x) {
      if (x === 0) {
        return x;
      }
      var negate = x < 0;
      var result;
      if (negate) {
        x = -x;
      }
      if (isFinite(x)) {
        result = Math.exp(Math.log(x) / 3);
        result = (x / (result * result) + 2 * result) / 3;
      } else {
        result = x;
      }
      return negate ? -result : result;
    };
    expm1 = Math.expm1 || function expm12(x) {
      return x >= 2e-4 || x <= -2e-4 ? Math.exp(x) - 1 : x + x * x / 2 + x * x * x / 6;
    };
    DBL_EPSILON = Number.EPSILON || 2220446049250313e-31;
    acosh = Math.acosh || function(x) {
      return Math.log(Math.sqrt(x * x - 1) + x);
    };
    asinh = Math.asinh || function(x) {
      return Math.log(Math.sqrt(x * x + 1) + x);
    };
    atanh = Math.atanh || function(x) {
      return Math.log((1 + x) / (1 - x)) / 2;
    };
    cosh = Math.cosh || function(x) {
      return (Math.exp(x) + Math.exp(-x)) / 2;
    };
    sinh = Math.sinh || function(x) {
      return (Math.exp(x) - Math.exp(-x)) / 2;
    };
    tanh = Math.tanh || function(x) {
      var e3 = Math.exp(2 * x);
      return (e3 - 1) / (e3 + 1);
    };
  }
});

// node_modules/mathjs/lib/esm/utils/bignumber/formatter.js
function formatBigNumberToBase(n, base, size2) {
  var BigNumberCtor = n.constructor;
  var big2 = new BigNumberCtor(2);
  var suffix = "";
  if (size2) {
    if (size2 < 1) {
      throw new Error("size must be in greater than 0");
    }
    if (!isInteger(size2)) {
      throw new Error("size must be an integer");
    }
    if (n.greaterThan(big2.pow(size2 - 1).sub(1)) || n.lessThan(big2.pow(size2 - 1).mul(-1))) {
      throw new Error("Value must be in range [-2^".concat(size2 - 1, ", 2^").concat(size2 - 1, "-1]"));
    }
    if (!n.isInteger()) {
      throw new Error("Value must be an integer");
    }
    if (n.lessThan(0)) {
      n = n.add(big2.pow(size2));
    }
    suffix = "i".concat(size2);
  }
  switch (base) {
    case 2:
      return "".concat(n.toBinary()).concat(suffix);
    case 8:
      return "".concat(n.toOctal()).concat(suffix);
    case 16:
      return "".concat(n.toHexadecimal()).concat(suffix);
    default:
      throw new Error("Base ".concat(base, " not supported "));
  }
}
function format2(value, options) {
  if (typeof options === "function") {
    return options(value);
  }
  if (!value.isFinite()) {
    return value.isNaN() ? "NaN" : value.gt(0) ? "Infinity" : "-Infinity";
  }
  var notation = "auto";
  var precision;
  var wordSize;
  if (options !== void 0) {
    if (options.notation) {
      notation = options.notation;
    }
    if (typeof options === "number") {
      precision = options;
    } else if (options.precision) {
      precision = options.precision;
    }
    if (options.wordSize) {
      wordSize = options.wordSize;
      if (typeof wordSize !== "number") {
        throw new Error('Option "wordSize" must be a number');
      }
    }
  }
  switch (notation) {
    case "fixed":
      return toFixed2(value, precision);
    case "exponential":
      return toExponential2(value, precision);
    case "engineering":
      return toEngineering2(value, precision);
    case "bin":
      return formatBigNumberToBase(value, 2, wordSize);
    case "oct":
      return formatBigNumberToBase(value, 8, wordSize);
    case "hex":
      return formatBigNumberToBase(value, 16, wordSize);
    case "auto": {
      var lowerExp = options && options.lowerExp !== void 0 ? options.lowerExp : -3;
      var upperExp = options && options.upperExp !== void 0 ? options.upperExp : 5;
      if (value.isZero())
        return "0";
      var str;
      var rounded = value.toSignificantDigits(precision);
      var exp2 = rounded.e;
      if (exp2 >= lowerExp && exp2 < upperExp) {
        str = rounded.toFixed();
      } else {
        str = toExponential2(value, precision);
      }
      return str.replace(/((\.\d*?)(0+))($|e)/, function() {
        var digits2 = arguments[2];
        var e3 = arguments[4];
        return digits2 !== "." ? digits2 + e3 : e3;
      });
    }
    default:
      throw new Error('Unknown notation "' + notation + '". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
  }
}
function toEngineering2(value, precision) {
  var e3 = value.e;
  var newExp = e3 % 3 === 0 ? e3 : e3 < 0 ? e3 - 3 - e3 % 3 : e3 - e3 % 3;
  var valueWithoutExp = value.mul(Math.pow(10, -newExp));
  var valueStr = valueWithoutExp.toPrecision(precision);
  if (valueStr.indexOf("e") !== -1) {
    valueStr = valueWithoutExp.toString();
  }
  return valueStr + "e" + (e3 >= 0 ? "+" : "") + newExp.toString();
}
function toExponential2(value, precision) {
  if (precision !== void 0) {
    return value.toExponential(precision - 1);
  } else {
    return value.toExponential();
  }
}
function toFixed2(value, precision) {
  return value.toFixed(precision);
}
var init_formatter = __esm({
  "node_modules/mathjs/lib/esm/utils/bignumber/formatter.js"() {
    init_number();
  }
});

// node_modules/mathjs/lib/esm/utils/string.js
function endsWith(text, search) {
  var start = text.length - search.length;
  var end = text.length;
  return text.substring(start, end) === search;
}
function format3(value, options) {
  var result = _format(value, options);
  if (options && typeof options === "object" && "truncate" in options && result.length > options.truncate) {
    return result.substring(0, options.truncate - 3) + "...";
  }
  return result;
}
function _format(value, options) {
  if (typeof value === "number") {
    return format(value, options);
  }
  if (isBigNumber(value)) {
    return format2(value, options);
  }
  if (looksLikeFraction(value)) {
    if (!options || options.fraction !== "decimal") {
      return value.s * value.n + "/" + value.d;
    } else {
      return value.toString();
    }
  }
  if (Array.isArray(value)) {
    return formatArray(value, options);
  }
  if (isString2(value)) {
    return '"' + value + '"';
  }
  if (typeof value === "function") {
    return value.syntax ? String(value.syntax) : "function";
  }
  if (value && typeof value === "object") {
    if (typeof value.format === "function") {
      return value.format(options);
    } else if (value && value.toString(options) !== {}.toString()) {
      return value.toString(options);
    } else {
      var entries = Object.keys(value).map((key) => {
        return '"' + key + '": ' + format3(value[key], options);
      });
      return "{" + entries.join(", ") + "}";
    }
  }
  return String(value);
}
function stringify(value) {
  var text = String(value);
  var escaped = "";
  var i2 = 0;
  while (i2 < text.length) {
    var c = text.charAt(i2);
    if (c === "\\") {
      escaped += c;
      i2++;
      c = text.charAt(i2);
      if (c === "" || '"\\/bfnrtu'.indexOf(c) === -1) {
        escaped += "\\";
      }
      escaped += c;
    } else if (c === '"') {
      escaped += '\\"';
    } else {
      escaped += c;
    }
    i2++;
  }
  return '"' + escaped + '"';
}
function escape(value) {
  var text = String(value);
  text = text.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  return text;
}
function formatArray(array, options) {
  if (Array.isArray(array)) {
    var str = "[";
    var len = array.length;
    for (var i2 = 0; i2 < len; i2++) {
      if (i2 !== 0) {
        str += ", ";
      }
      str += formatArray(array[i2], options);
    }
    str += "]";
    return str;
  } else {
    return format3(array, options);
  }
}
function looksLikeFraction(value) {
  return value && typeof value === "object" && typeof value.s === "number" && typeof value.n === "number" && typeof value.d === "number" || false;
}
function compareText(x, y) {
  if (!isString2(x)) {
    throw new TypeError("Unexpected type of argument in function compareText (expected: string or Array or Matrix, actual: " + typeOf(x) + ", index: 0)");
  }
  if (!isString2(y)) {
    throw new TypeError("Unexpected type of argument in function compareText (expected: string or Array or Matrix, actual: " + typeOf(y) + ", index: 1)");
  }
  return x === y ? 0 : x > y ? 1 : -1;
}
var init_string = __esm({
  "node_modules/mathjs/lib/esm/utils/string.js"() {
    init_is();
    init_number();
    init_formatter();
  }
});

// node_modules/mathjs/lib/esm/error/DimensionError.js
function DimensionError(actual, expected, relation) {
  if (!(this instanceof DimensionError)) {
    throw new SyntaxError("Constructor must be called with the new operator");
  }
  this.actual = actual;
  this.expected = expected;
  this.relation = relation;
  this.message = "Dimension mismatch (" + (Array.isArray(actual) ? "[" + actual.join(", ") + "]" : actual) + " " + (this.relation || "!=") + " " + (Array.isArray(expected) ? "[" + expected.join(", ") + "]" : expected) + ")";
  this.stack = new Error().stack;
}
var init_DimensionError = __esm({
  "node_modules/mathjs/lib/esm/error/DimensionError.js"() {
    DimensionError.prototype = new RangeError();
    DimensionError.prototype.constructor = RangeError;
    DimensionError.prototype.name = "DimensionError";
    DimensionError.prototype.isDimensionError = true;
  }
});

// node_modules/mathjs/lib/esm/error/IndexError.js
function IndexError(index2, min2, max2) {
  if (!(this instanceof IndexError)) {
    throw new SyntaxError("Constructor must be called with the new operator");
  }
  this.index = index2;
  if (arguments.length < 3) {
    this.min = 0;
    this.max = min2;
  } else {
    this.min = min2;
    this.max = max2;
  }
  if (this.min !== void 0 && this.index < this.min) {
    this.message = "Index out of range (" + this.index + " < " + this.min + ")";
  } else if (this.max !== void 0 && this.index >= this.max) {
    this.message = "Index out of range (" + this.index + " > " + (this.max - 1) + ")";
  } else {
    this.message = "Index out of range (" + this.index + ")";
  }
  this.stack = new Error().stack;
}
var init_IndexError = __esm({
  "node_modules/mathjs/lib/esm/error/IndexError.js"() {
    IndexError.prototype = new RangeError();
    IndexError.prototype.constructor = RangeError;
    IndexError.prototype.name = "IndexError";
    IndexError.prototype.isIndexError = true;
  }
});

// node_modules/mathjs/lib/esm/utils/array.js
function arraySize(x) {
  var s = [];
  while (Array.isArray(x)) {
    s.push(x.length);
    x = x[0];
  }
  return s;
}
function _validate(array, size2, dim) {
  var i2;
  var len = array.length;
  if (len !== size2[dim]) {
    throw new DimensionError(len, size2[dim]);
  }
  if (dim < size2.length - 1) {
    var dimNext = dim + 1;
    for (i2 = 0; i2 < len; i2++) {
      var child2 = array[i2];
      if (!Array.isArray(child2)) {
        throw new DimensionError(size2.length - 1, size2.length, "<");
      }
      _validate(array[i2], size2, dimNext);
    }
  } else {
    for (i2 = 0; i2 < len; i2++) {
      if (Array.isArray(array[i2])) {
        throw new DimensionError(size2.length + 1, size2.length, ">");
      }
    }
  }
}
function validate(array, size2) {
  var isScalar = size2.length === 0;
  if (isScalar) {
    if (Array.isArray(array)) {
      throw new DimensionError(array.length, 0);
    }
  } else {
    _validate(array, size2, 0);
  }
}
function validateIndex(index2, length) {
  if (!isNumber2(index2) || !isInteger(index2)) {
    throw new TypeError("Index must be an integer (value: " + index2 + ")");
  }
  if (index2 < 0 || typeof length === "number" && index2 >= length) {
    throw new IndexError(index2, length);
  }
}
function resize(array, size2, defaultValue) {
  if (!Array.isArray(array) || !Array.isArray(size2)) {
    throw new TypeError("Array expected");
  }
  if (size2.length === 0) {
    throw new Error("Resizing to scalar is not supported");
  }
  size2.forEach(function(value) {
    if (!isNumber2(value) || !isInteger(value) || value < 0) {
      throw new TypeError("Invalid size, must contain positive integers (size: " + format3(size2) + ")");
    }
  });
  var _defaultValue = defaultValue !== void 0 ? defaultValue : 0;
  _resize(array, size2, 0, _defaultValue);
  return array;
}
function _resize(array, size2, dim, defaultValue) {
  var i2;
  var elem;
  var oldLen = array.length;
  var newLen = size2[dim];
  var minLen = Math.min(oldLen, newLen);
  array.length = newLen;
  if (dim < size2.length - 1) {
    var dimNext = dim + 1;
    for (i2 = 0; i2 < minLen; i2++) {
      elem = array[i2];
      if (!Array.isArray(elem)) {
        elem = [elem];
        array[i2] = elem;
      }
      _resize(elem, size2, dimNext, defaultValue);
    }
    for (i2 = minLen; i2 < newLen; i2++) {
      elem = [];
      array[i2] = elem;
      _resize(elem, size2, dimNext, defaultValue);
    }
  } else {
    for (i2 = 0; i2 < minLen; i2++) {
      while (Array.isArray(array[i2])) {
        array[i2] = array[i2][0];
      }
    }
    for (i2 = minLen; i2 < newLen; i2++) {
      array[i2] = defaultValue;
    }
  }
}
function reshape(array, sizes) {
  var flatArray = flatten(array);
  var currentLength = flatArray.length;
  if (!Array.isArray(array) || !Array.isArray(sizes)) {
    throw new TypeError("Array expected");
  }
  if (sizes.length === 0) {
    throw new DimensionError(0, currentLength, "!=");
  }
  sizes = processSizesWildcard(sizes, currentLength);
  var newLength = product(sizes);
  if (currentLength !== newLength) {
    throw new DimensionError(newLength, currentLength, "!=");
  }
  try {
    return _reshape(flatArray, sizes);
  } catch (e3) {
    if (e3 instanceof DimensionError) {
      throw new DimensionError(newLength, currentLength, "!=");
    }
    throw e3;
  }
}
function processSizesWildcard(sizes, currentLength) {
  var newLength = product(sizes);
  var processedSizes = sizes.slice();
  var WILDCARD = -1;
  var wildCardIndex = sizes.indexOf(WILDCARD);
  var isMoreThanOneWildcard = sizes.indexOf(WILDCARD, wildCardIndex + 1) >= 0;
  if (isMoreThanOneWildcard) {
    throw new Error("More than one wildcard in sizes");
  }
  var hasWildcard = wildCardIndex >= 0;
  var canReplaceWildcard = currentLength % newLength === 0;
  if (hasWildcard) {
    if (canReplaceWildcard) {
      processedSizes[wildCardIndex] = -currentLength / newLength;
    } else {
      throw new Error("Could not replace wildcard, since " + currentLength + " is no multiple of " + -newLength);
    }
  }
  return processedSizes;
}
function product(array) {
  return array.reduce((prev, curr) => prev * curr, 1);
}
function _reshape(array, sizes) {
  var tmpArray = array;
  var tmpArray2;
  for (var sizeIndex = sizes.length - 1; sizeIndex > 0; sizeIndex--) {
    var size2 = sizes[sizeIndex];
    tmpArray2 = [];
    var length = tmpArray.length / size2;
    for (var i2 = 0; i2 < length; i2++) {
      tmpArray2.push(tmpArray.slice(i2 * size2, (i2 + 1) * size2));
    }
    tmpArray = tmpArray2;
  }
  return tmpArray;
}
function squeeze(array, size2) {
  var s = size2 || arraySize(array);
  while (Array.isArray(array) && array.length === 1) {
    array = array[0];
    s.shift();
  }
  var dims = s.length;
  while (s[dims - 1] === 1) {
    dims--;
  }
  if (dims < s.length) {
    array = _squeeze(array, dims, 0);
    s.length = dims;
  }
  return array;
}
function _squeeze(array, dims, dim) {
  var i2, ii;
  if (dim < dims) {
    var next = dim + 1;
    for (i2 = 0, ii = array.length; i2 < ii; i2++) {
      array[i2] = _squeeze(array[i2], dims, next);
    }
  } else {
    while (Array.isArray(array)) {
      array = array[0];
    }
  }
  return array;
}
function unsqueeze(array, dims, outer, size2) {
  var s = size2 || arraySize(array);
  if (outer) {
    for (var i2 = 0; i2 < outer; i2++) {
      array = [array];
      s.unshift(1);
    }
  }
  array = _unsqueeze(array, dims, 0);
  while (s.length < dims) {
    s.push(1);
  }
  return array;
}
function _unsqueeze(array, dims, dim) {
  var i2, ii;
  if (Array.isArray(array)) {
    var next = dim + 1;
    for (i2 = 0, ii = array.length; i2 < ii; i2++) {
      array[i2] = _unsqueeze(array[i2], dims, next);
    }
  } else {
    for (var d = dim; d < dims; d++) {
      array = [array];
    }
  }
  return array;
}
function flatten(array) {
  if (!Array.isArray(array)) {
    return array;
  }
  var flat = [];
  array.forEach(function callback(value) {
    if (Array.isArray(value)) {
      value.forEach(callback);
    } else {
      flat.push(value);
    }
  });
  return flat;
}
function map(array, callback) {
  return Array.prototype.map.call(array, callback);
}
function forEach(array, callback) {
  Array.prototype.forEach.call(array, callback);
}
function filter(array, callback) {
  if (arraySize(array).length !== 1) {
    throw new Error("Only one dimensional matrices supported");
  }
  return Array.prototype.filter.call(array, callback);
}
function filterRegExp(array, regexp) {
  if (arraySize(array).length !== 1) {
    throw new Error("Only one dimensional matrices supported");
  }
  return Array.prototype.filter.call(array, (entry) => regexp.test(entry));
}
function join(array, separator) {
  return Array.prototype.join.call(array, separator);
}
function identify(a) {
  if (!Array.isArray(a)) {
    throw new TypeError("Array input expected");
  }
  if (a.length === 0) {
    return a;
  }
  var b = [];
  var count2 = 0;
  b[0] = {
    value: a[0],
    identifier: 0
  };
  for (var i2 = 1; i2 < a.length; i2++) {
    if (a[i2] === a[i2 - 1]) {
      count2++;
    } else {
      count2 = 0;
    }
    b.push({
      value: a[i2],
      identifier: count2
    });
  }
  return b;
}
function generalize(a) {
  if (!Array.isArray(a)) {
    throw new TypeError("Array input expected");
  }
  if (a.length === 0) {
    return a;
  }
  var b = [];
  for (var i2 = 0; i2 < a.length; i2++) {
    b.push(a[i2].value);
  }
  return b;
}
function getArrayDataType(array, typeOf3) {
  var type;
  var length = 0;
  for (var i2 = 0; i2 < array.length; i2++) {
    var item = array[i2];
    var isArray2 = Array.isArray(item);
    if (i2 === 0 && isArray2) {
      length = item.length;
    }
    if (isArray2 && item.length !== length) {
      return void 0;
    }
    var itemType = isArray2 ? getArrayDataType(item, typeOf3) : typeOf3(item);
    if (type === void 0) {
      type = itemType;
    } else if (type !== itemType) {
      return "mixed";
    } else {
    }
  }
  return type;
}
var init_array = __esm({
  "node_modules/mathjs/lib/esm/utils/array.js"() {
    init_number();
    init_is();
    init_string();
    init_DimensionError();
    init_IndexError();
  }
});

// node_modules/mathjs/lib/esm/utils/factory.js
function factory(name296, dependencies297, create, meta) {
  function assertAndCreate(scope) {
    var deps = pickShallow(scope, dependencies297.map(stripOptionalNotation));
    assertDependencies(name296, dependencies297, scope);
    return create(deps);
  }
  assertAndCreate.isFactory = true;
  assertAndCreate.fn = name296;
  assertAndCreate.dependencies = dependencies297.slice().sort();
  if (meta) {
    assertAndCreate.meta = meta;
  }
  return assertAndCreate;
}
function assertDependencies(name296, dependencies297, scope) {
  var allDefined = dependencies297.filter((dependency) => !isOptionalDependency(dependency)).every((dependency) => scope[dependency] !== void 0);
  if (!allDefined) {
    var missingDependencies = dependencies297.filter((dependency) => scope[dependency] === void 0);
    throw new Error('Cannot create function "'.concat(name296, '", ') + "some dependencies are missing: ".concat(missingDependencies.map((d) => '"'.concat(d, '"')).join(", "), "."));
  }
}
function isOptionalDependency(dependency) {
  return dependency && dependency[0] === "?";
}
function stripOptionalNotation(dependency) {
  return dependency && dependency[0] === "?" ? dependency.slice(1) : dependency;
}
var init_factory = __esm({
  "node_modules/mathjs/lib/esm/utils/factory.js"() {
    init_object();
  }
});

// node_modules/mathjs/lib/esm/utils/customs.js
function getSafeProperty(object, prop) {
  if (isPlainObject(object) && isSafeProperty(object, prop)) {
    return object[prop];
  }
  if (typeof object[prop] === "function" && isSafeMethod(object, prop)) {
    throw new Error('Cannot access method "' + prop + '" as a property');
  }
  throw new Error('No access to property "' + prop + '"');
}
function setSafeProperty(object, prop, value) {
  if (isPlainObject(object) && isSafeProperty(object, prop)) {
    object[prop] = value;
    return value;
  }
  throw new Error('No access to property "' + prop + '"');
}
function hasSafeProperty(object, prop) {
  return prop in object;
}
function isSafeProperty(object, prop) {
  if (!object || typeof object !== "object") {
    return false;
  }
  if (hasOwnProperty2(safeNativeProperties, prop)) {
    return true;
  }
  if (prop in Object.prototype) {
    return false;
  }
  if (prop in Function.prototype) {
    return false;
  }
  return true;
}
function validateSafeMethod(object, method) {
  if (!isSafeMethod(object, method)) {
    throw new Error('No access to method "' + method + '"');
  }
}
function isSafeMethod(object, method) {
  if (object === null || object === void 0 || typeof object[method] !== "function") {
    return false;
  }
  if (hasOwnProperty2(object, method) && Object.getPrototypeOf && method in Object.getPrototypeOf(object)) {
    return false;
  }
  if (hasOwnProperty2(safeNativeMethods, method)) {
    return true;
  }
  if (method in Object.prototype) {
    return false;
  }
  if (method in Function.prototype) {
    return false;
  }
  return true;
}
function isPlainObject(object) {
  return typeof object === "object" && object && object.constructor === Object;
}
var safeNativeProperties, safeNativeMethods;
var init_customs = __esm({
  "node_modules/mathjs/lib/esm/utils/customs.js"() {
    init_object();
    safeNativeProperties = {
      length: true,
      name: true
    };
    safeNativeMethods = {
      toString: true,
      valueOf: true,
      toLocaleString: true
    };
  }
});

// node_modules/mathjs/lib/esm/utils/map.js
function createEmptyMap() {
  return /* @__PURE__ */ new Map();
}
function createMap(mapOrObject) {
  if (!mapOrObject) {
    return createEmptyMap();
  }
  if (isMap(mapOrObject)) {
    return mapOrObject;
  }
  if (isObject(mapOrObject)) {
    return new ObjectWrappingMap(mapOrObject);
  }
  throw new Error("createMap can create maps from objects or Maps");
}
function toObject(map3) {
  if (map3 instanceof ObjectWrappingMap) {
    return map3.wrappedObject;
  }
  var object = {};
  for (var key of map3.keys()) {
    var value = map3.get(key);
    setSafeProperty(object, key, value);
  }
  return object;
}
function isMap(object) {
  if (!object) {
    return false;
  }
  return object instanceof Map || object instanceof ObjectWrappingMap || typeof object.set === "function" && typeof object.get === "function" && typeof object.keys === "function" && typeof object.has === "function";
}
function assign(map3) {
  for (var _len = arguments.length, objects = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    objects[_key - 1] = arguments[_key];
  }
  for (var args of objects) {
    if (!args) {
      continue;
    }
    if (isMap(args)) {
      for (var key of args.keys()) {
        map3.set(key, args.get(key));
      }
    } else if (isObject(args)) {
      for (var _key2 of Object.keys(args)) {
        map3.set(_key2, args[_key2]);
      }
    }
  }
  return map3;
}
var ObjectWrappingMap;
var init_map = __esm({
  "node_modules/mathjs/lib/esm/utils/map.js"() {
    init_customs();
    init_is();
    ObjectWrappingMap = class {
      constructor(object) {
        this.wrappedObject = object;
      }
      keys() {
        return Object.keys(this.wrappedObject);
      }
      get(key) {
        return getSafeProperty(this.wrappedObject, key);
      }
      set(key, value) {
        setSafeProperty(this.wrappedObject, key, value);
        return this;
      }
      has(key) {
        return hasSafeProperty(this.wrappedObject, key);
      }
    };
  }
});

// node_modules/mathjs/lib/esm/core/function/typed.js
function throwNoBignumber(x) {
  throw new Error("Cannot convert value ".concat(x, " into a BigNumber: no class 'BigNumber' provided"));
}
function throwNoComplex(x) {
  throw new Error("Cannot convert value ".concat(x, " into a Complex number: no class 'Complex' provided"));
}
function throwNoMatrix() {
  throw new Error("Cannot convert array into a Matrix: no class 'DenseMatrix' provided");
}
function throwNoFraction(x) {
  throw new Error("Cannot convert value ".concat(x, " into a Fraction, no class 'Fraction' provided."));
}
var import_typed_function, _createTyped2, dependencies, createTyped;
var init_typed = __esm({
  "node_modules/mathjs/lib/esm/core/function/typed.js"() {
    init_is();
    import_typed_function = __toESM(require_typed_function(), 1);
    init_number();
    init_factory();
    init_map();
    _createTyped2 = function _createTyped() {
      _createTyped2 = import_typed_function.default.create;
      return import_typed_function.default;
    };
    dependencies = ["?BigNumber", "?Complex", "?DenseMatrix", "?Fraction"];
    createTyped = /* @__PURE__ */ factory("typed", dependencies, function createTyped2(_ref) {
      var {
        BigNumber: BigNumber2,
        Complex: Complex3,
        DenseMatrix: DenseMatrix2,
        Fraction: Fraction3
      } = _ref;
      var typed2 = _createTyped2();
      typed2.types = [
        {
          name: "number",
          test: isNumber2
        },
        {
          name: "Complex",
          test: isComplex
        },
        {
          name: "BigNumber",
          test: isBigNumber
        },
        {
          name: "Fraction",
          test: isFraction
        },
        {
          name: "Unit",
          test: isUnit
        },
        {
          name: "string",
          test: isString2
        },
        {
          name: "Chain",
          test: isChain
        },
        {
          name: "Array",
          test: isArray
        },
        {
          name: "Matrix",
          test: isMatrix
        },
        {
          name: "DenseMatrix",
          test: isDenseMatrix
        },
        {
          name: "SparseMatrix",
          test: isSparseMatrix
        },
        {
          name: "Range",
          test: isRange
        },
        {
          name: "Index",
          test: isIndex
        },
        {
          name: "boolean",
          test: isBoolean2
        },
        {
          name: "ResultSet",
          test: isResultSet
        },
        {
          name: "Help",
          test: isHelp
        },
        {
          name: "function",
          test: isFunction
        },
        {
          name: "Date",
          test: isDate
        },
        {
          name: "RegExp",
          test: isRegExp
        },
        {
          name: "null",
          test: isNull
        },
        {
          name: "undefined",
          test: isUndefined
        },
        {
          name: "AccessorNode",
          test: isAccessorNode
        },
        {
          name: "ArrayNode",
          test: isArrayNode
        },
        {
          name: "AssignmentNode",
          test: isAssignmentNode
        },
        {
          name: "BlockNode",
          test: isBlockNode
        },
        {
          name: "ConditionalNode",
          test: isConditionalNode
        },
        {
          name: "ConstantNode",
          test: isConstantNode
        },
        {
          name: "FunctionNode",
          test: isFunctionNode
        },
        {
          name: "FunctionAssignmentNode",
          test: isFunctionAssignmentNode
        },
        {
          name: "IndexNode",
          test: isIndexNode
        },
        {
          name: "Node",
          test: isNode
        },
        {
          name: "ObjectNode",
          test: isObjectNode
        },
        {
          name: "OperatorNode",
          test: isOperatorNode
        },
        {
          name: "ParenthesisNode",
          test: isParenthesisNode
        },
        {
          name: "RangeNode",
          test: isRangeNode
        },
        {
          name: "SymbolNode",
          test: isSymbolNode
        },
        {
          name: "Map",
          test: isMap
        },
        {
          name: "Object",
          test: isObject
        }
      ];
      typed2.conversions = [{
        from: "number",
        to: "BigNumber",
        convert: function convert(x) {
          if (!BigNumber2) {
            throwNoBignumber(x);
          }
          if (digits(x) > 15) {
            throw new TypeError("Cannot implicitly convert a number with >15 significant digits to BigNumber (value: " + x + "). Use function bignumber(x) to convert to BigNumber.");
          }
          return new BigNumber2(x);
        }
      }, {
        from: "number",
        to: "Complex",
        convert: function convert(x) {
          if (!Complex3) {
            throwNoComplex(x);
          }
          return new Complex3(x, 0);
        }
      }, {
        from: "number",
        to: "string",
        convert: function convert(x) {
          return x + "";
        }
      }, {
        from: "BigNumber",
        to: "Complex",
        convert: function convert(x) {
          if (!Complex3) {
            throwNoComplex(x);
          }
          return new Complex3(x.toNumber(), 0);
        }
      }, {
        from: "Fraction",
        to: "BigNumber",
        convert: function convert(x) {
          throw new TypeError("Cannot implicitly convert a Fraction to BigNumber or vice versa. Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.");
        }
      }, {
        from: "Fraction",
        to: "Complex",
        convert: function convert(x) {
          if (!Complex3) {
            throwNoComplex(x);
          }
          return new Complex3(x.valueOf(), 0);
        }
      }, {
        from: "number",
        to: "Fraction",
        convert: function convert(x) {
          if (!Fraction3) {
            throwNoFraction(x);
          }
          var f = new Fraction3(x);
          if (f.valueOf() !== x) {
            throw new TypeError("Cannot implicitly convert a number to a Fraction when there will be a loss of precision (value: " + x + "). Use function fraction(x) to convert to Fraction.");
          }
          return f;
        }
      }, {
        from: "string",
        to: "number",
        convert: function convert(x) {
          var n = Number(x);
          if (isNaN(n)) {
            throw new Error('Cannot convert "' + x + '" to a number');
          }
          return n;
        }
      }, {
        from: "string",
        to: "BigNumber",
        convert: function convert(x) {
          if (!BigNumber2) {
            throwNoBignumber(x);
          }
          try {
            return new BigNumber2(x);
          } catch (err) {
            throw new Error('Cannot convert "' + x + '" to BigNumber');
          }
        }
      }, {
        from: "string",
        to: "Fraction",
        convert: function convert(x) {
          if (!Fraction3) {
            throwNoFraction(x);
          }
          try {
            return new Fraction3(x);
          } catch (err) {
            throw new Error('Cannot convert "' + x + '" to Fraction');
          }
        }
      }, {
        from: "string",
        to: "Complex",
        convert: function convert(x) {
          if (!Complex3) {
            throwNoComplex(x);
          }
          try {
            return new Complex3(x);
          } catch (err) {
            throw new Error('Cannot convert "' + x + '" to Complex');
          }
        }
      }, {
        from: "boolean",
        to: "number",
        convert: function convert(x) {
          return +x;
        }
      }, {
        from: "boolean",
        to: "BigNumber",
        convert: function convert(x) {
          if (!BigNumber2) {
            throwNoBignumber(x);
          }
          return new BigNumber2(+x);
        }
      }, {
        from: "boolean",
        to: "Fraction",
        convert: function convert(x) {
          if (!Fraction3) {
            throwNoFraction(x);
          }
          return new Fraction3(+x);
        }
      }, {
        from: "boolean",
        to: "string",
        convert: function convert(x) {
          return String(x);
        }
      }, {
        from: "Array",
        to: "Matrix",
        convert: function convert(array) {
          if (!DenseMatrix2) {
            throwNoMatrix();
          }
          return new DenseMatrix2(array);
        }
      }, {
        from: "Matrix",
        to: "Array",
        convert: function convert(matrix2) {
          return matrix2.valueOf();
        }
      }];
      return typed2;
    });
  }
});

// node_modules/mathjs/lib/esm/type/resultset/ResultSet.js
var name, dependencies2, createResultSet;
var init_ResultSet = __esm({
  "node_modules/mathjs/lib/esm/type/resultset/ResultSet.js"() {
    init_factory();
    name = "ResultSet";
    dependencies2 = [];
    createResultSet = /* @__PURE__ */ factory(name, dependencies2, () => {
      function ResultSet2(entries) {
        if (!(this instanceof ResultSet2)) {
          throw new SyntaxError("Constructor must be called with the new operator");
        }
        this.entries = entries || [];
      }
      ResultSet2.prototype.type = "ResultSet";
      ResultSet2.prototype.isResultSet = true;
      ResultSet2.prototype.valueOf = function() {
        return this.entries;
      };
      ResultSet2.prototype.toString = function() {
        return "[" + this.entries.join(", ") + "]";
      };
      ResultSet2.prototype.toJSON = function() {
        return {
          mathjs: "ResultSet",
          entries: this.entries
        };
      };
      ResultSet2.fromJSON = function(json) {
        return new ResultSet2(json.entries);
      };
      return ResultSet2;
    }, {
      isClass: true
    });
  }
});

// node_modules/decimal.js/decimal.js
var require_decimal = __commonJS({
  "node_modules/decimal.js/decimal.js"(exports, module) {
    (function(globalScope) {
      "use strict";
      var EXP_LIMIT = 9e15, MAX_DIGITS = 1e9, NUMERALS = "0123456789abcdef", LN102 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", DEFAULTS = {
        precision: 20,
        rounding: 4,
        modulo: 1,
        toExpNeg: -7,
        toExpPos: 21,
        minE: -EXP_LIMIT,
        maxE: EXP_LIMIT,
        crypto: false
      }, Decimal4, inexact, noConflict, quadrant, external = true, decimalError = "[DecimalError] ", invalidArgument = decimalError + "Invalid argument: ", precisionLimitExceeded = decimalError + "Precision limit exceeded", cryptoUnavailable = decimalError + "crypto unavailable", tag = "[object Decimal]", mathfloor = Math.floor, mathpow = Math.pow, isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, BASE = 1e7, LOG_BASE = 7, MAX_SAFE_INTEGER = 9007199254740991, LN10_PRECISION = LN102.length - 1, PI_PRECISION = PI.length - 1, P2 = { toStringTag: tag };
      P2.absoluteValue = P2.abs = function() {
        var x = new this.constructor(this);
        if (x.s < 0)
          x.s = 1;
        return finalise(x);
      };
      P2.ceil = function() {
        return finalise(new this.constructor(this), this.e + 1, 2);
      };
      P2.clampedTo = P2.clamp = function(min3, max3) {
        var k, x = this, Ctor = x.constructor;
        min3 = new Ctor(min3);
        max3 = new Ctor(max3);
        if (!min3.s || !max3.s)
          return new Ctor(NaN);
        if (min3.gt(max3))
          throw Error(invalidArgument + max3);
        k = x.cmp(min3);
        return k < 0 ? min3 : x.cmp(max3) > 0 ? max3 : new Ctor(x);
      };
      P2.comparedTo = P2.cmp = function(y) {
        var i2, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;
        if (!xd || !yd) {
          return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
        }
        if (!xd[0] || !yd[0])
          return xd[0] ? xs : yd[0] ? -ys : 0;
        if (xs !== ys)
          return xs;
        if (x.e !== y.e)
          return x.e > y.e ^ xs < 0 ? 1 : -1;
        xdL = xd.length;
        ydL = yd.length;
        for (i2 = 0, j = xdL < ydL ? xdL : ydL; i2 < j; ++i2) {
          if (xd[i2] !== yd[i2])
            return xd[i2] > yd[i2] ^ xs < 0 ? 1 : -1;
        }
        return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
      };
      P2.cosine = P2.cos = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (!x.d)
          return new Ctor(NaN);
        if (!x.d[0])
          return new Ctor(1);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
        Ctor.rounding = 1;
        x = cosine(Ctor, toLessThanHalfPi(Ctor, x));
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
      };
      P2.cubeRoot = P2.cbrt = function() {
        var e3, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;
        if (!x.isFinite() || x.isZero())
          return new Ctor(x);
        external = false;
        s = x.s * mathpow(x.s * x, 1 / 3);
        if (!s || Math.abs(s) == 1 / 0) {
          n = digitsToString(x.d);
          e3 = x.e;
          if (s = (e3 - n.length + 1) % 3)
            n += s == 1 || s == -2 ? "0" : "00";
          s = mathpow(n, 1 / 3);
          e3 = mathfloor((e3 + 1) / 3) - (e3 % 3 == (e3 < 0 ? -1 : 2));
          if (s == 1 / 0) {
            n = "5e" + e3;
          } else {
            n = s.toExponential();
            n = n.slice(0, n.indexOf("e") + 1) + e3;
          }
          r = new Ctor(n);
          r.s = x.s;
        } else {
          r = new Ctor(s.toString());
        }
        sd = (e3 = Ctor.precision) + 3;
        for (; ; ) {
          t = r;
          t3 = t.times(t).times(t);
          t3plusx = t3.plus(x);
          r = divide2(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);
          if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
            n = n.slice(sd - 3, sd + 1);
            if (n == "9999" || !rep && n == "4999") {
              if (!rep) {
                finalise(t, e3 + 1, 0);
                if (t.times(t).times(t).eq(x)) {
                  r = t;
                  break;
                }
              }
              sd += 4;
              rep = 1;
            } else {
              if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                finalise(r, e3 + 1, 1);
                m = !r.times(r).times(r).eq(x);
              }
              break;
            }
          }
        }
        external = true;
        return finalise(r, e3, Ctor.rounding, m);
      };
      P2.decimalPlaces = P2.dp = function() {
        var w, d = this.d, n = NaN;
        if (d) {
          w = d.length - 1;
          n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;
          w = d[w];
          if (w)
            for (; w % 10 == 0; w /= 10)
              n--;
          if (n < 0)
            n = 0;
        }
        return n;
      };
      P2.dividedBy = P2.div = function(y) {
        return divide2(this, new this.constructor(y));
      };
      P2.dividedToIntegerBy = P2.divToInt = function(y) {
        var x = this, Ctor = x.constructor;
        return finalise(divide2(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
      };
      P2.equals = P2.eq = function(y) {
        return this.cmp(y) === 0;
      };
      P2.floor = function() {
        return finalise(new this.constructor(this), this.e + 1, 3);
      };
      P2.greaterThan = P2.gt = function(y) {
        return this.cmp(y) > 0;
      };
      P2.greaterThanOrEqualTo = P2.gte = function(y) {
        var k = this.cmp(y);
        return k == 1 || k === 0;
      };
      P2.hyperbolicCosine = P2.cosh = function() {
        var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);
        if (!x.isFinite())
          return new Ctor(x.s ? 1 / 0 : NaN);
        if (x.isZero())
          return one;
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
        Ctor.rounding = 1;
        len = x.d.length;
        if (len < 32) {
          k = Math.ceil(len / 3);
          n = (1 / tinyPow(4, k)).toString();
        } else {
          k = 16;
          n = "2.3283064365386962890625e-10";
        }
        x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);
        var cosh2_x, i2 = k, d8 = new Ctor(8);
        for (; i2--; ) {
          cosh2_x = x.times(x);
          x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
        }
        return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
      };
      P2.hyperbolicSine = P2.sinh = function() {
        var k, pr, rm, len, x = this, Ctor = x.constructor;
        if (!x.isFinite() || x.isZero())
          return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
        Ctor.rounding = 1;
        len = x.d.length;
        if (len < 3) {
          x = taylorSeries(Ctor, 2, x, x, true);
        } else {
          k = 1.4 * Math.sqrt(len);
          k = k > 16 ? 16 : k | 0;
          x = x.times(1 / tinyPow(5, k));
          x = taylorSeries(Ctor, 2, x, x, true);
          var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
          for (; k--; ) {
            sinh2_x = x.times(x);
            x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
          }
        }
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return finalise(x, pr, rm, true);
      };
      P2.hyperbolicTangent = P2.tanh = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (!x.isFinite())
          return new Ctor(x.s);
        if (x.isZero())
          return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + 7;
        Ctor.rounding = 1;
        return divide2(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
      };
      P2.inverseCosine = P2.acos = function() {
        var halfPi, x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
        if (k !== -1) {
          return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
        }
        if (x.isZero())
          return getPi(Ctor, pr + 4, rm).times(0.5);
        Ctor.precision = pr + 6;
        Ctor.rounding = 1;
        x = x.asin();
        halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return halfPi.minus(x);
      };
      P2.inverseHyperbolicCosine = P2.acosh = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (x.lte(1))
          return new Ctor(x.eq(1) ? 0 : NaN);
        if (!x.isFinite())
          return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
        Ctor.rounding = 1;
        external = false;
        x = x.times(x).minus(1).sqrt().plus(x);
        external = true;
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x.ln();
      };
      P2.inverseHyperbolicSine = P2.asinh = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (!x.isFinite() || x.isZero())
          return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
        Ctor.rounding = 1;
        external = false;
        x = x.times(x).plus(1).sqrt().plus(x);
        external = true;
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x.ln();
      };
      P2.inverseHyperbolicTangent = P2.atanh = function() {
        var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;
        if (!x.isFinite())
          return new Ctor(NaN);
        if (x.e >= 0)
          return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        xsd = x.sd();
        if (Math.max(xsd, pr) < 2 * -x.e - 1)
          return finalise(new Ctor(x), pr, rm, true);
        Ctor.precision = wpr = xsd - x.e;
        x = divide2(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);
        Ctor.precision = pr + 4;
        Ctor.rounding = 1;
        x = x.ln();
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x.times(0.5);
      };
      P2.inverseSine = P2.asin = function() {
        var halfPi, k, pr, rm, x = this, Ctor = x.constructor;
        if (x.isZero())
          return new Ctor(x);
        k = x.abs().cmp(1);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        if (k !== -1) {
          if (k === 0) {
            halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
            halfPi.s = x.s;
            return halfPi;
          }
          return new Ctor(NaN);
        }
        Ctor.precision = pr + 6;
        Ctor.rounding = 1;
        x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x.times(2);
      };
      P2.inverseTangent = P2.atan = function() {
        var i2, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;
        if (!x.isFinite()) {
          if (!x.s)
            return new Ctor(NaN);
          if (pr + 4 <= PI_PRECISION) {
            r = getPi(Ctor, pr + 4, rm).times(0.5);
            r.s = x.s;
            return r;
          }
        } else if (x.isZero()) {
          return new Ctor(x);
        } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
          r = getPi(Ctor, pr + 4, rm).times(0.25);
          r.s = x.s;
          return r;
        }
        Ctor.precision = wpr = pr + 10;
        Ctor.rounding = 1;
        k = Math.min(28, wpr / LOG_BASE + 2 | 0);
        for (i2 = k; i2; --i2)
          x = x.div(x.times(x).plus(1).sqrt().plus(1));
        external = false;
        j = Math.ceil(wpr / LOG_BASE);
        n = 1;
        x2 = x.times(x);
        r = new Ctor(x);
        px = x;
        for (; i2 !== -1; ) {
          px = px.times(x2);
          t = r.minus(px.div(n += 2));
          px = px.times(x2);
          r = t.plus(px.div(n += 2));
          if (r.d[j] !== void 0)
            for (i2 = j; r.d[i2] === t.d[i2] && i2--; )
              ;
        }
        if (k)
          r = r.times(2 << k - 1);
        external = true;
        return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
      };
      P2.isFinite = function() {
        return !!this.d;
      };
      P2.isInteger = P2.isInt = function() {
        return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
      };
      P2.isNaN = function() {
        return !this.s;
      };
      P2.isNegative = P2.isNeg = function() {
        return this.s < 0;
      };
      P2.isPositive = P2.isPos = function() {
        return this.s > 0;
      };
      P2.isZero = function() {
        return !!this.d && this.d[0] === 0;
      };
      P2.lessThan = P2.lt = function(y) {
        return this.cmp(y) < 0;
      };
      P2.lessThanOrEqualTo = P2.lte = function(y) {
        return this.cmp(y) < 1;
      };
      P2.logarithm = P2.log = function(base) {
        var isBase10, d, denominator, k, inf, num, sd, r, arg2 = this, Ctor = arg2.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
        if (base == null) {
          base = new Ctor(10);
          isBase10 = true;
        } else {
          base = new Ctor(base);
          d = base.d;
          if (base.s < 0 || !d || !d[0] || base.eq(1))
            return new Ctor(NaN);
          isBase10 = base.eq(10);
        }
        d = arg2.d;
        if (arg2.s < 0 || !d || !d[0] || arg2.eq(1)) {
          return new Ctor(d && !d[0] ? -1 / 0 : arg2.s != 1 ? NaN : d ? 0 : 1 / 0);
        }
        if (isBase10) {
          if (d.length > 1) {
            inf = true;
          } else {
            for (k = d[0]; k % 10 === 0; )
              k /= 10;
            inf = k !== 1;
          }
        }
        external = false;
        sd = pr + guard;
        num = naturalLogarithm(arg2, sd);
        denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
        r = divide2(num, denominator, sd, 1);
        if (checkRoundingDigits(r.d, k = pr, rm)) {
          do {
            sd += 10;
            num = naturalLogarithm(arg2, sd);
            denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
            r = divide2(num, denominator, sd, 1);
            if (!inf) {
              if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
                r = finalise(r, pr + 1, 0);
              }
              break;
            }
          } while (checkRoundingDigits(r.d, k += 10, rm));
        }
        external = true;
        return finalise(r, pr, rm);
      };
      P2.minus = P2.sub = function(y) {
        var d, e3, i2, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;
        y = new Ctor(y);
        if (!x.d || !y.d) {
          if (!x.s || !y.s)
            y = new Ctor(NaN);
          else if (x.d)
            y.s = -y.s;
          else
            y = new Ctor(y.d || x.s !== y.s ? x : NaN);
          return y;
        }
        if (x.s != y.s) {
          y.s = -y.s;
          return x.plus(y);
        }
        xd = x.d;
        yd = y.d;
        pr = Ctor.precision;
        rm = Ctor.rounding;
        if (!xd[0] || !yd[0]) {
          if (yd[0])
            y.s = -y.s;
          else if (xd[0])
            y = new Ctor(x);
          else
            return new Ctor(rm === 3 ? -0 : 0);
          return external ? finalise(y, pr, rm) : y;
        }
        e3 = mathfloor(y.e / LOG_BASE);
        xe = mathfloor(x.e / LOG_BASE);
        xd = xd.slice();
        k = xe - e3;
        if (k) {
          xLTy = k < 0;
          if (xLTy) {
            d = xd;
            k = -k;
            len = yd.length;
          } else {
            d = yd;
            e3 = xe;
            len = xd.length;
          }
          i2 = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
          if (k > i2) {
            k = i2;
            d.length = 1;
          }
          d.reverse();
          for (i2 = k; i2--; )
            d.push(0);
          d.reverse();
        } else {
          i2 = xd.length;
          len = yd.length;
          xLTy = i2 < len;
          if (xLTy)
            len = i2;
          for (i2 = 0; i2 < len; i2++) {
            if (xd[i2] != yd[i2]) {
              xLTy = xd[i2] < yd[i2];
              break;
            }
          }
          k = 0;
        }
        if (xLTy) {
          d = xd;
          xd = yd;
          yd = d;
          y.s = -y.s;
        }
        len = xd.length;
        for (i2 = yd.length - len; i2 > 0; --i2)
          xd[len++] = 0;
        for (i2 = yd.length; i2 > k; ) {
          if (xd[--i2] < yd[i2]) {
            for (j = i2; j && xd[--j] === 0; )
              xd[j] = BASE - 1;
            --xd[j];
            xd[i2] += BASE;
          }
          xd[i2] -= yd[i2];
        }
        for (; xd[--len] === 0; )
          xd.pop();
        for (; xd[0] === 0; xd.shift())
          --e3;
        if (!xd[0])
          return new Ctor(rm === 3 ? -0 : 0);
        y.d = xd;
        y.e = getBase10Exponent(xd, e3);
        return external ? finalise(y, pr, rm) : y;
      };
      P2.modulo = P2.mod = function(y) {
        var q, x = this, Ctor = x.constructor;
        y = new Ctor(y);
        if (!x.d || !y.s || y.d && !y.d[0])
          return new Ctor(NaN);
        if (!y.d || x.d && !x.d[0]) {
          return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
        }
        external = false;
        if (Ctor.modulo == 9) {
          q = divide2(x, y.abs(), 0, 3, 1);
          q.s *= y.s;
        } else {
          q = divide2(x, y, 0, Ctor.modulo, 1);
        }
        q = q.times(y);
        external = true;
        return x.minus(q);
      };
      P2.naturalExponential = P2.exp = function() {
        return naturalExponential(this);
      };
      P2.naturalLogarithm = P2.ln = function() {
        return naturalLogarithm(this);
      };
      P2.negated = P2.neg = function() {
        var x = new this.constructor(this);
        x.s = -x.s;
        return finalise(x);
      };
      P2.plus = P2.add = function(y) {
        var carry, d, e3, i2, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;
        y = new Ctor(y);
        if (!x.d || !y.d) {
          if (!x.s || !y.s)
            y = new Ctor(NaN);
          else if (!x.d)
            y = new Ctor(y.d || x.s === y.s ? x : NaN);
          return y;
        }
        if (x.s != y.s) {
          y.s = -y.s;
          return x.minus(y);
        }
        xd = x.d;
        yd = y.d;
        pr = Ctor.precision;
        rm = Ctor.rounding;
        if (!xd[0] || !yd[0]) {
          if (!yd[0])
            y = new Ctor(x);
          return external ? finalise(y, pr, rm) : y;
        }
        k = mathfloor(x.e / LOG_BASE);
        e3 = mathfloor(y.e / LOG_BASE);
        xd = xd.slice();
        i2 = k - e3;
        if (i2) {
          if (i2 < 0) {
            d = xd;
            i2 = -i2;
            len = yd.length;
          } else {
            d = yd;
            e3 = k;
            len = xd.length;
          }
          k = Math.ceil(pr / LOG_BASE);
          len = k > len ? k + 1 : len + 1;
          if (i2 > len) {
            i2 = len;
            d.length = 1;
          }
          d.reverse();
          for (; i2--; )
            d.push(0);
          d.reverse();
        }
        len = xd.length;
        i2 = yd.length;
        if (len - i2 < 0) {
          i2 = len;
          d = yd;
          yd = xd;
          xd = d;
        }
        for (carry = 0; i2; ) {
          carry = (xd[--i2] = xd[i2] + yd[i2] + carry) / BASE | 0;
          xd[i2] %= BASE;
        }
        if (carry) {
          xd.unshift(carry);
          ++e3;
        }
        for (len = xd.length; xd[--len] == 0; )
          xd.pop();
        y.d = xd;
        y.e = getBase10Exponent(xd, e3);
        return external ? finalise(y, pr, rm) : y;
      };
      P2.precision = P2.sd = function(z) {
        var k, x = this;
        if (z !== void 0 && z !== !!z && z !== 1 && z !== 0)
          throw Error(invalidArgument + z);
        if (x.d) {
          k = getPrecision(x.d);
          if (z && x.e + 1 > k)
            k = x.e + 1;
        } else {
          k = NaN;
        }
        return k;
      };
      P2.round = function() {
        var x = this, Ctor = x.constructor;
        return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
      };
      P2.sine = P2.sin = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (!x.isFinite())
          return new Ctor(NaN);
        if (x.isZero())
          return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
        Ctor.rounding = 1;
        x = sine(Ctor, toLessThanHalfPi(Ctor, x));
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
      };
      P2.squareRoot = P2.sqrt = function() {
        var m, n, sd, r, rep, t, x = this, d = x.d, e3 = x.e, s = x.s, Ctor = x.constructor;
        if (s !== 1 || !d || !d[0]) {
          return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
        }
        external = false;
        s = Math.sqrt(+x);
        if (s == 0 || s == 1 / 0) {
          n = digitsToString(d);
          if ((n.length + e3) % 2 == 0)
            n += "0";
          s = Math.sqrt(n);
          e3 = mathfloor((e3 + 1) / 2) - (e3 < 0 || e3 % 2);
          if (s == 1 / 0) {
            n = "5e" + e3;
          } else {
            n = s.toExponential();
            n = n.slice(0, n.indexOf("e") + 1) + e3;
          }
          r = new Ctor(n);
        } else {
          r = new Ctor(s.toString());
        }
        sd = (e3 = Ctor.precision) + 3;
        for (; ; ) {
          t = r;
          r = t.plus(divide2(x, t, sd + 2, 1)).times(0.5);
          if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
            n = n.slice(sd - 3, sd + 1);
            if (n == "9999" || !rep && n == "4999") {
              if (!rep) {
                finalise(t, e3 + 1, 0);
                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }
              sd += 4;
              rep = 1;
            } else {
              if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                finalise(r, e3 + 1, 1);
                m = !r.times(r).eq(x);
              }
              break;
            }
          }
        }
        external = true;
        return finalise(r, e3, Ctor.rounding, m);
      };
      P2.tangent = P2.tan = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (!x.isFinite())
          return new Ctor(NaN);
        if (x.isZero())
          return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + 10;
        Ctor.rounding = 1;
        x = x.sin();
        x.s = 1;
        x = divide2(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
      };
      P2.times = P2.mul = function(y) {
        var carry, e3, i2, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;
        y.s *= x.s;
        if (!xd || !xd[0] || !yd || !yd[0]) {
          return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);
        }
        e3 = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
        xdL = xd.length;
        ydL = yd.length;
        if (xdL < ydL) {
          r = xd;
          xd = yd;
          yd = r;
          rL = xdL;
          xdL = ydL;
          ydL = rL;
        }
        r = [];
        rL = xdL + ydL;
        for (i2 = rL; i2--; )
          r.push(0);
        for (i2 = ydL; --i2 >= 0; ) {
          carry = 0;
          for (k = xdL + i2; k > i2; ) {
            t = r[k] + yd[i2] * xd[k - i2 - 1] + carry;
            r[k--] = t % BASE | 0;
            carry = t / BASE | 0;
          }
          r[k] = (r[k] + carry) % BASE | 0;
        }
        for (; !r[--rL]; )
          r.pop();
        if (carry)
          ++e3;
        else
          r.shift();
        y.d = r;
        y.e = getBase10Exponent(r, e3);
        return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
      };
      P2.toBinary = function(sd, rm) {
        return toStringBinary(this, 2, sd, rm);
      };
      P2.toDecimalPlaces = P2.toDP = function(dp, rm) {
        var x = this, Ctor = x.constructor;
        x = new Ctor(x);
        if (dp === void 0)
          return x;
        checkInt32(dp, 0, MAX_DIGITS);
        if (rm === void 0)
          rm = Ctor.rounding;
        else
          checkInt32(rm, 0, 8);
        return finalise(x, dp + x.e + 1, rm);
      };
      P2.toExponential = function(dp, rm) {
        var str, x = this, Ctor = x.constructor;
        if (dp === void 0) {
          str = finiteToString(x, true);
        } else {
          checkInt32(dp, 0, MAX_DIGITS);
          if (rm === void 0)
            rm = Ctor.rounding;
          else
            checkInt32(rm, 0, 8);
          x = finalise(new Ctor(x), dp + 1, rm);
          str = finiteToString(x, true, dp + 1);
        }
        return x.isNeg() && !x.isZero() ? "-" + str : str;
      };
      P2.toFixed = function(dp, rm) {
        var str, y, x = this, Ctor = x.constructor;
        if (dp === void 0) {
          str = finiteToString(x);
        } else {
          checkInt32(dp, 0, MAX_DIGITS);
          if (rm === void 0)
            rm = Ctor.rounding;
          else
            checkInt32(rm, 0, 8);
          y = finalise(new Ctor(x), dp + x.e + 1, rm);
          str = finiteToString(y, false, dp + y.e + 1);
        }
        return x.isNeg() && !x.isZero() ? "-" + str : str;
      };
      P2.toFraction = function(maxD) {
        var d, d0, d1, d2, e3, k, n, n0, n16, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;
        if (!xd)
          return new Ctor(x);
        n16 = d0 = new Ctor(1);
        d1 = n0 = new Ctor(0);
        d = new Ctor(d1);
        e3 = d.e = getPrecision(xd) - x.e - 1;
        k = e3 % LOG_BASE;
        d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);
        if (maxD == null) {
          maxD = e3 > 0 ? d : n16;
        } else {
          n = new Ctor(maxD);
          if (!n.isInt() || n.lt(n16))
            throw Error(invalidArgument + n);
          maxD = n.gt(d) ? e3 > 0 ? d : n16 : n;
        }
        external = false;
        n = new Ctor(digitsToString(xd));
        pr = Ctor.precision;
        Ctor.precision = e3 = xd.length * LOG_BASE * 2;
        for (; ; ) {
          q = divide2(n, d, 0, 1, 1);
          d2 = d0.plus(q.times(d1));
          if (d2.cmp(maxD) == 1)
            break;
          d0 = d1;
          d1 = d2;
          d2 = n16;
          n16 = n0.plus(q.times(d2));
          n0 = d2;
          d2 = d;
          d = n.minus(q.times(d2));
          n = d2;
        }
        d2 = divide2(maxD.minus(d0), d1, 0, 1, 1);
        n0 = n0.plus(d2.times(n16));
        d0 = d0.plus(d2.times(d1));
        n0.s = n16.s = x.s;
        r = divide2(n16, d1, e3, 1).minus(x).abs().cmp(divide2(n0, d0, e3, 1).minus(x).abs()) < 1 ? [n16, d1] : [n0, d0];
        Ctor.precision = pr;
        external = true;
        return r;
      };
      P2.toHexadecimal = P2.toHex = function(sd, rm) {
        return toStringBinary(this, 16, sd, rm);
      };
      P2.toNearest = function(y, rm) {
        var x = this, Ctor = x.constructor;
        x = new Ctor(x);
        if (y == null) {
          if (!x.d)
            return x;
          y = new Ctor(1);
          rm = Ctor.rounding;
        } else {
          y = new Ctor(y);
          if (rm === void 0) {
            rm = Ctor.rounding;
          } else {
            checkInt32(rm, 0, 8);
          }
          if (!x.d)
            return y.s ? x : y;
          if (!y.d) {
            if (y.s)
              y.s = x.s;
            return y;
          }
        }
        if (y.d[0]) {
          external = false;
          x = divide2(x, y, 0, rm, 1).times(y);
          external = true;
          finalise(x);
        } else {
          y.s = x.s;
          x = y;
        }
        return x;
      };
      P2.toNumber = function() {
        return +this;
      };
      P2.toOctal = function(sd, rm) {
        return toStringBinary(this, 8, sd, rm);
      };
      P2.toPower = P2.pow = function(y) {
        var e3, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));
        if (!x.d || !y.d || !x.d[0] || !y.d[0])
          return new Ctor(mathpow(+x, yn));
        x = new Ctor(x);
        if (x.eq(1))
          return x;
        pr = Ctor.precision;
        rm = Ctor.rounding;
        if (y.eq(1))
          return finalise(x, pr, rm);
        e3 = mathfloor(y.e / LOG_BASE);
        if (e3 >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
          r = intPow(Ctor, x, k, pr);
          return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
        }
        s = x.s;
        if (s < 0) {
          if (e3 < y.d.length - 1)
            return new Ctor(NaN);
          if ((y.d[e3] & 1) == 0)
            s = 1;
          if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
            x.s = s;
            return x;
          }
        }
        k = mathpow(+x, yn);
        e3 = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log("0." + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + "").e;
        if (e3 > Ctor.maxE + 1 || e3 < Ctor.minE - 1)
          return new Ctor(e3 > 0 ? s / 0 : 0);
        external = false;
        Ctor.rounding = x.s = 1;
        k = Math.min(12, (e3 + "").length);
        r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);
        if (r.d) {
          r = finalise(r, pr + 5, 1);
          if (checkRoundingDigits(r.d, pr, rm)) {
            e3 = pr + 10;
            r = finalise(naturalExponential(y.times(naturalLogarithm(x, e3 + k)), e3), e3 + 5, 1);
            if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
              r = finalise(r, pr + 1, 0);
            }
          }
        }
        r.s = s;
        external = true;
        Ctor.rounding = rm;
        return finalise(r, pr, rm);
      };
      P2.toPrecision = function(sd, rm) {
        var str, x = this, Ctor = x.constructor;
        if (sd === void 0) {
          str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
        } else {
          checkInt32(sd, 1, MAX_DIGITS);
          if (rm === void 0)
            rm = Ctor.rounding;
          else
            checkInt32(rm, 0, 8);
          x = finalise(new Ctor(x), sd, rm);
          str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
        }
        return x.isNeg() && !x.isZero() ? "-" + str : str;
      };
      P2.toSignificantDigits = P2.toSD = function(sd, rm) {
        var x = this, Ctor = x.constructor;
        if (sd === void 0) {
          sd = Ctor.precision;
          rm = Ctor.rounding;
        } else {
          checkInt32(sd, 1, MAX_DIGITS);
          if (rm === void 0)
            rm = Ctor.rounding;
          else
            checkInt32(rm, 0, 8);
        }
        return finalise(new Ctor(x), sd, rm);
      };
      P2.toString = function() {
        var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
        return x.isNeg() && !x.isZero() ? "-" + str : str;
      };
      P2.truncated = P2.trunc = function() {
        return finalise(new this.constructor(this), this.e + 1, 1);
      };
      P2.valueOf = P2.toJSON = function() {
        var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
        return x.isNeg() ? "-" + str : str;
      };
      function digitsToString(d) {
        var i2, k, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
        if (indexOfLastWord > 0) {
          str += w;
          for (i2 = 1; i2 < indexOfLastWord; i2++) {
            ws = d[i2] + "";
            k = LOG_BASE - ws.length;
            if (k)
              str += getZeroString(k);
            str += ws;
          }
          w = d[i2];
          ws = w + "";
          k = LOG_BASE - ws.length;
          if (k)
            str += getZeroString(k);
        } else if (w === 0) {
          return "0";
        }
        for (; w % 10 === 0; )
          w /= 10;
        return str + w;
      }
      function checkInt32(i2, min3, max3) {
        if (i2 !== ~~i2 || i2 < min3 || i2 > max3) {
          throw Error(invalidArgument + i2);
        }
      }
      function checkRoundingDigits(d, i2, rm, repeating) {
        var di, k, r, rd;
        for (k = d[0]; k >= 10; k /= 10)
          --i2;
        if (--i2 < 0) {
          i2 += LOG_BASE;
          di = 0;
        } else {
          di = Math.ceil((i2 + 1) / LOG_BASE);
          i2 %= LOG_BASE;
        }
        k = mathpow(10, LOG_BASE - i2);
        rd = d[di] % k | 0;
        if (repeating == null) {
          if (i2 < 3) {
            if (i2 == 0)
              rd = rd / 100 | 0;
            else if (i2 == 1)
              rd = rd / 10 | 0;
            r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;
          } else {
            r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i2 - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
          }
        } else {
          if (i2 < 4) {
            if (i2 == 0)
              rd = rd / 1e3 | 0;
            else if (i2 == 1)
              rd = rd / 100 | 0;
            else if (i2 == 2)
              rd = rd / 10 | 0;
            r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
          } else {
            r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1e3 | 0) == mathpow(10, i2 - 3) - 1;
          }
        }
        return r;
      }
      function convertBase(str, baseIn, baseOut) {
        var j, arr = [0], arrL, i2 = 0, strL = str.length;
        for (; i2 < strL; ) {
          for (arrL = arr.length; arrL--; )
            arr[arrL] *= baseIn;
          arr[0] += NUMERALS.indexOf(str.charAt(i2++));
          for (j = 0; j < arr.length; j++) {
            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] === void 0)
                arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }
        return arr.reverse();
      }
      function cosine(Ctor, x) {
        var k, len, y;
        if (x.isZero())
          return x;
        len = x.d.length;
        if (len < 32) {
          k = Math.ceil(len / 3);
          y = (1 / tinyPow(4, k)).toString();
        } else {
          k = 16;
          y = "2.3283064365386962890625e-10";
        }
        Ctor.precision += k;
        x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));
        for (var i2 = k; i2--; ) {
          var cos2x = x.times(x);
          x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
        }
        Ctor.precision -= k;
        return x;
      }
      var divide2 = function() {
        function multiplyInteger(x, k, base) {
          var temp, carry = 0, i2 = x.length;
          for (x = x.slice(); i2--; ) {
            temp = x[i2] * k + carry;
            x[i2] = temp % base | 0;
            carry = temp / base | 0;
          }
          if (carry)
            x.unshift(carry);
          return x;
        }
        function compare2(a, b, aL, bL) {
          var i2, r;
          if (aL != bL) {
            r = aL > bL ? 1 : -1;
          } else {
            for (i2 = r = 0; i2 < aL; i2++) {
              if (a[i2] != b[i2]) {
                r = a[i2] > b[i2] ? 1 : -1;
                break;
              }
            }
          }
          return r;
        }
        function subtract2(a, b, aL, base) {
          var i2 = 0;
          for (; aL--; ) {
            a[aL] -= i2;
            i2 = a[aL] < b[aL] ? 1 : 0;
            a[aL] = i2 * base + a[aL] - b[aL];
          }
          for (; !a[0] && a.length > 1; )
            a.shift();
        }
        return function(x, y, pr, rm, dp, base) {
          var cmp, e3, i2, k, logBase, more, prod2, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign4 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;
          if (!xd || !xd[0] || !yd || !yd[0]) {
            return new Ctor(
              !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : xd && xd[0] == 0 || !yd ? sign4 * 0 : sign4 / 0
            );
          }
          if (base) {
            logBase = 1;
            e3 = x.e - y.e;
          } else {
            base = BASE;
            logBase = LOG_BASE;
            e3 = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
          }
          yL = yd.length;
          xL = xd.length;
          q = new Ctor(sign4);
          qd = q.d = [];
          for (i2 = 0; yd[i2] == (xd[i2] || 0); i2++)
            ;
          if (yd[i2] > (xd[i2] || 0))
            e3--;
          if (pr == null) {
            sd = pr = Ctor.precision;
            rm = Ctor.rounding;
          } else if (dp) {
            sd = pr + (x.e - y.e) + 1;
          } else {
            sd = pr;
          }
          if (sd < 0) {
            qd.push(1);
            more = true;
          } else {
            sd = sd / logBase + 2 | 0;
            i2 = 0;
            if (yL == 1) {
              k = 0;
              yd = yd[0];
              sd++;
              for (; (i2 < xL || k) && sd--; i2++) {
                t = k * base + (xd[i2] || 0);
                qd[i2] = t / yd | 0;
                k = t % yd | 0;
              }
              more = k || i2 < xL;
            } else {
              k = base / (yd[0] + 1) | 0;
              if (k > 1) {
                yd = multiplyInteger(yd, k, base);
                xd = multiplyInteger(xd, k, base);
                yL = yd.length;
                xL = xd.length;
              }
              xi = yL;
              rem = xd.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; )
                rem[remL++] = 0;
              yz = yd.slice();
              yz.unshift(0);
              yd0 = yd[0];
              if (yd[1] >= base / 2)
                ++yd0;
              do {
                k = 0;
                cmp = compare2(yd, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL)
                    rem0 = rem0 * base + (rem[1] || 0);
                  k = rem0 / yd0 | 0;
                  if (k > 1) {
                    if (k >= base)
                      k = base - 1;
                    prod2 = multiplyInteger(yd, k, base);
                    prodL = prod2.length;
                    remL = rem.length;
                    cmp = compare2(prod2, rem, prodL, remL);
                    if (cmp == 1) {
                      k--;
                      subtract2(prod2, yL < prodL ? yz : yd, prodL, base);
                    }
                  } else {
                    if (k == 0)
                      cmp = k = 1;
                    prod2 = yd.slice();
                  }
                  prodL = prod2.length;
                  if (prodL < remL)
                    prod2.unshift(0);
                  subtract2(rem, prod2, remL, base);
                  if (cmp == -1) {
                    remL = rem.length;
                    cmp = compare2(yd, rem, yL, remL);
                    if (cmp < 1) {
                      k++;
                      subtract2(rem, yL < remL ? yz : yd, remL, base);
                    }
                  }
                  remL = rem.length;
                } else if (cmp === 0) {
                  k++;
                  rem = [0];
                }
                qd[i2++] = k;
                if (cmp && rem[0]) {
                  rem[remL++] = xd[xi] || 0;
                } else {
                  rem = [xd[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] !== void 0) && sd--);
              more = rem[0] !== void 0;
            }
            if (!qd[0])
              qd.shift();
          }
          if (logBase == 1) {
            q.e = e3;
            inexact = more;
          } else {
            for (i2 = 1, k = qd[0]; k >= 10; k /= 10)
              i2++;
            q.e = i2 + e3 * logBase - 1;
            finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
          }
          return q;
        };
      }();
      function finalise(x, sd, rm, isTruncated) {
        var digits2, i2, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;
        out:
          if (sd != null) {
            xd = x.d;
            if (!xd)
              return x;
            for (digits2 = 1, k = xd[0]; k >= 10; k /= 10)
              digits2++;
            i2 = sd - digits2;
            if (i2 < 0) {
              i2 += LOG_BASE;
              j = sd;
              w = xd[xdi = 0];
              rd = w / mathpow(10, digits2 - j - 1) % 10 | 0;
            } else {
              xdi = Math.ceil((i2 + 1) / LOG_BASE);
              k = xd.length;
              if (xdi >= k) {
                if (isTruncated) {
                  for (; k++ <= xdi; )
                    xd.push(0);
                  w = rd = 0;
                  digits2 = 1;
                  i2 %= LOG_BASE;
                  j = i2 - LOG_BASE + 1;
                } else {
                  break out;
                }
              } else {
                w = k = xd[xdi];
                for (digits2 = 1; k >= 10; k /= 10)
                  digits2++;
                i2 %= LOG_BASE;
                j = i2 - LOG_BASE + digits2;
                rd = j < 0 ? 0 : w / mathpow(10, digits2 - j - 1) % 10 | 0;
              }
            }
            isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits2 - j - 1));
            roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && (i2 > 0 ? j > 0 ? w / mathpow(10, digits2 - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
            if (sd < 1 || !xd[0]) {
              xd.length = 0;
              if (roundUp) {
                sd -= x.e + 1;
                xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
                x.e = -sd || 0;
              } else {
                xd[0] = x.e = 0;
              }
              return x;
            }
            if (i2 == 0) {
              xd.length = xdi;
              k = 1;
              xdi--;
            } else {
              xd.length = xdi + 1;
              k = mathpow(10, LOG_BASE - i2);
              xd[xdi] = j > 0 ? (w / mathpow(10, digits2 - j) % mathpow(10, j) | 0) * k : 0;
            }
            if (roundUp) {
              for (; ; ) {
                if (xdi == 0) {
                  for (i2 = 1, j = xd[0]; j >= 10; j /= 10)
                    i2++;
                  j = xd[0] += k;
                  for (k = 1; j >= 10; j /= 10)
                    k++;
                  if (i2 != k) {
                    x.e++;
                    if (xd[0] == BASE)
                      xd[0] = 1;
                  }
                  break;
                } else {
                  xd[xdi] += k;
                  if (xd[xdi] != BASE)
                    break;
                  xd[xdi--] = 0;
                  k = 1;
                }
              }
            }
            for (i2 = xd.length; xd[--i2] === 0; )
              xd.pop();
          }
        if (external) {
          if (x.e > Ctor.maxE) {
            x.d = null;
            x.e = NaN;
          } else if (x.e < Ctor.minE) {
            x.e = 0;
            x.d = [0];
          }
        }
        return x;
      }
      function finiteToString(x, isExp, sd) {
        if (!x.isFinite())
          return nonFiniteToString(x);
        var k, e3 = x.e, str = digitsToString(x.d), len = str.length;
        if (isExp) {
          if (sd && (k = sd - len) > 0) {
            str = str.charAt(0) + "." + str.slice(1) + getZeroString(k);
          } else if (len > 1) {
            str = str.charAt(0) + "." + str.slice(1);
          }
          str = str + (x.e < 0 ? "e" : "e+") + x.e;
        } else if (e3 < 0) {
          str = "0." + getZeroString(-e3 - 1) + str;
          if (sd && (k = sd - len) > 0)
            str += getZeroString(k);
        } else if (e3 >= len) {
          str += getZeroString(e3 + 1 - len);
          if (sd && (k = sd - e3 - 1) > 0)
            str = str + "." + getZeroString(k);
        } else {
          if ((k = e3 + 1) < len)
            str = str.slice(0, k) + "." + str.slice(k);
          if (sd && (k = sd - len) > 0) {
            if (e3 + 1 === len)
              str += ".";
            str += getZeroString(k);
          }
        }
        return str;
      }
      function getBase10Exponent(digits2, e3) {
        var w = digits2[0];
        for (e3 *= LOG_BASE; w >= 10; w /= 10)
          e3++;
        return e3;
      }
      function getLn10(Ctor, sd, pr) {
        if (sd > LN10_PRECISION) {
          external = true;
          if (pr)
            Ctor.precision = pr;
          throw Error(precisionLimitExceeded);
        }
        return finalise(new Ctor(LN102), sd, 1, true);
      }
      function getPi(Ctor, sd, rm) {
        if (sd > PI_PRECISION)
          throw Error(precisionLimitExceeded);
        return finalise(new Ctor(PI), sd, rm, true);
      }
      function getPrecision(digits2) {
        var w = digits2.length - 1, len = w * LOG_BASE + 1;
        w = digits2[w];
        if (w) {
          for (; w % 10 == 0; w /= 10)
            len--;
          for (w = digits2[0]; w >= 10; w /= 10)
            len++;
        }
        return len;
      }
      function getZeroString(k) {
        var zs = "";
        for (; k--; )
          zs += "0";
        return zs;
      }
      function intPow(Ctor, x, n, pr) {
        var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE + 4);
        external = false;
        for (; ; ) {
          if (n % 2) {
            r = r.times(x);
            if (truncate(r.d, k))
              isTruncated = true;
          }
          n = mathfloor(n / 2);
          if (n === 0) {
            n = r.d.length - 1;
            if (isTruncated && r.d[n] === 0)
              ++r.d[n];
            break;
          }
          x = x.times(x);
          truncate(x.d, k);
        }
        external = true;
        return r;
      }
      function isOdd(n) {
        return n.d[n.d.length - 1] & 1;
      }
      function maxOrMin(Ctor, args, ltgt) {
        var y, x = new Ctor(args[0]), i2 = 0;
        for (; ++i2 < args.length; ) {
          y = new Ctor(args[i2]);
          if (!y.s) {
            x = y;
            break;
          } else if (x[ltgt](y)) {
            x = y;
          }
        }
        return x;
      }
      function naturalExponential(x, sd) {
        var denominator, guard, j, pow3, sum3, t, wpr, rep = 0, i2 = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
        if (!x.d || !x.d[0] || x.e > 17) {
          return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);
        }
        if (sd == null) {
          external = false;
          wpr = pr;
        } else {
          wpr = sd;
        }
        t = new Ctor(0.03125);
        while (x.e > -2) {
          x = x.times(t);
          k += 5;
        }
        guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
        wpr += guard;
        denominator = pow3 = sum3 = new Ctor(1);
        Ctor.precision = wpr;
        for (; ; ) {
          pow3 = finalise(pow3.times(x), wpr, 1);
          denominator = denominator.times(++i2);
          t = sum3.plus(divide2(pow3, denominator, wpr, 1));
          if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum3.d).slice(0, wpr)) {
            j = k;
            while (j--)
              sum3 = finalise(sum3.times(sum3), wpr, 1);
            if (sd == null) {
              if (rep < 3 && checkRoundingDigits(sum3.d, wpr - guard, rm, rep)) {
                Ctor.precision = wpr += 10;
                denominator = pow3 = t = new Ctor(1);
                i2 = 0;
                rep++;
              } else {
                return finalise(sum3, Ctor.precision = pr, rm, external = true);
              }
            } else {
              Ctor.precision = pr;
              return sum3;
            }
          }
          sum3 = t;
        }
      }
      function naturalLogarithm(y, sd) {
        var c, c0, denominator, e3, numerator, rep, sum3, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
        if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
          return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
        }
        if (sd == null) {
          external = false;
          wpr = pr;
        } else {
          wpr = sd;
        }
        Ctor.precision = wpr += guard;
        c = digitsToString(xd);
        c0 = c.charAt(0);
        if (Math.abs(e3 = x.e) < 15e14) {
          while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
            x = x.times(y);
            c = digitsToString(x.d);
            c0 = c.charAt(0);
            n++;
          }
          e3 = x.e;
          if (c0 > 1) {
            x = new Ctor("0." + c);
            e3++;
          } else {
            x = new Ctor(c0 + "." + c.slice(1));
          }
        } else {
          t = getLn10(Ctor, wpr + 2, pr).times(e3 + "");
          x = naturalLogarithm(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
          Ctor.precision = pr;
          return sd == null ? finalise(x, pr, rm, external = true) : x;
        }
        x1 = x;
        sum3 = numerator = x = divide2(x.minus(1), x.plus(1), wpr, 1);
        x2 = finalise(x.times(x), wpr, 1);
        denominator = 3;
        for (; ; ) {
          numerator = finalise(numerator.times(x2), wpr, 1);
          t = sum3.plus(divide2(numerator, new Ctor(denominator), wpr, 1));
          if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum3.d).slice(0, wpr)) {
            sum3 = sum3.times(2);
            if (e3 !== 0)
              sum3 = sum3.plus(getLn10(Ctor, wpr + 2, pr).times(e3 + ""));
            sum3 = divide2(sum3, new Ctor(n), wpr, 1);
            if (sd == null) {
              if (checkRoundingDigits(sum3.d, wpr - guard, rm, rep)) {
                Ctor.precision = wpr += guard;
                t = numerator = x = divide2(x1.minus(1), x1.plus(1), wpr, 1);
                x2 = finalise(x.times(x), wpr, 1);
                denominator = rep = 1;
              } else {
                return finalise(sum3, Ctor.precision = pr, rm, external = true);
              }
            } else {
              Ctor.precision = pr;
              return sum3;
            }
          }
          sum3 = t;
          denominator += 2;
        }
      }
      function nonFiniteToString(x) {
        return String(x.s * x.s / 0);
      }
      function parseDecimal(x, str) {
        var e3, i2, len;
        if ((e3 = str.indexOf(".")) > -1)
          str = str.replace(".", "");
        if ((i2 = str.search(/e/i)) > 0) {
          if (e3 < 0)
            e3 = i2;
          e3 += +str.slice(i2 + 1);
          str = str.substring(0, i2);
        } else if (e3 < 0) {
          e3 = str.length;
        }
        for (i2 = 0; str.charCodeAt(i2) === 48; i2++)
          ;
        for (len = str.length; str.charCodeAt(len - 1) === 48; --len)
          ;
        str = str.slice(i2, len);
        if (str) {
          len -= i2;
          x.e = e3 = e3 - i2 - 1;
          x.d = [];
          i2 = (e3 + 1) % LOG_BASE;
          if (e3 < 0)
            i2 += LOG_BASE;
          if (i2 < len) {
            if (i2)
              x.d.push(+str.slice(0, i2));
            for (len -= LOG_BASE; i2 < len; )
              x.d.push(+str.slice(i2, i2 += LOG_BASE));
            str = str.slice(i2);
            i2 = LOG_BASE - str.length;
          } else {
            i2 -= len;
          }
          for (; i2--; )
            str += "0";
          x.d.push(+str);
          if (external) {
            if (x.e > x.constructor.maxE) {
              x.d = null;
              x.e = NaN;
            } else if (x.e < x.constructor.minE) {
              x.e = 0;
              x.d = [0];
            }
          }
        } else {
          x.e = 0;
          x.d = [0];
        }
        return x;
      }
      function parseOther(x, str) {
        var base, Ctor, divisor, i2, isFloat, len, p, xd, xe;
        if (str.indexOf("_") > -1) {
          str = str.replace(/(\d)_(?=\d)/g, "$1");
          if (isDecimal.test(str))
            return parseDecimal(x, str);
        } else if (str === "Infinity" || str === "NaN") {
          if (!+str)
            x.s = NaN;
          x.e = NaN;
          x.d = null;
          return x;
        }
        if (isHex.test(str)) {
          base = 16;
          str = str.toLowerCase();
        } else if (isBinary.test(str)) {
          base = 2;
        } else if (isOctal.test(str)) {
          base = 8;
        } else {
          throw Error(invalidArgument + str);
        }
        i2 = str.search(/p/i);
        if (i2 > 0) {
          p = +str.slice(i2 + 1);
          str = str.substring(2, i2);
        } else {
          str = str.slice(2);
        }
        i2 = str.indexOf(".");
        isFloat = i2 >= 0;
        Ctor = x.constructor;
        if (isFloat) {
          str = str.replace(".", "");
          len = str.length;
          i2 = len - i2;
          divisor = intPow(Ctor, new Ctor(base), i2, i2 * 2);
        }
        xd = convertBase(str, base, BASE);
        xe = xd.length - 1;
        for (i2 = xe; xd[i2] === 0; --i2)
          xd.pop();
        if (i2 < 0)
          return new Ctor(x.s * 0);
        x.e = getBase10Exponent(xd, xe);
        x.d = xd;
        external = false;
        if (isFloat)
          x = divide2(x, divisor, len * 4);
        if (p)
          x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal4.pow(2, p));
        external = true;
        return x;
      }
      function sine(Ctor, x) {
        var k, len = x.d.length;
        if (len < 3) {
          return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);
        }
        k = 1.4 * Math.sqrt(len);
        k = k > 16 ? 16 : k | 0;
        x = x.times(1 / tinyPow(5, k));
        x = taylorSeries(Ctor, 2, x, x);
        var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
        for (; k--; ) {
          sin2_x = x.times(x);
          x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
        }
        return x;
      }
      function taylorSeries(Ctor, n, x, y, isHyperbolic) {
        var j, t, u, x2, i2 = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);
        external = false;
        x2 = x.times(x);
        u = new Ctor(y);
        for (; ; ) {
          t = divide2(u.times(x2), new Ctor(n++ * n++), pr, 1);
          u = isHyperbolic ? y.plus(t) : y.minus(t);
          y = divide2(t.times(x2), new Ctor(n++ * n++), pr, 1);
          t = u.plus(y);
          if (t.d[k] !== void 0) {
            for (j = k; t.d[j] === u.d[j] && j--; )
              ;
            if (j == -1)
              break;
          }
          j = u;
          u = y;
          y = t;
          t = j;
          i2++;
        }
        external = true;
        t.d.length = k + 1;
        return t;
      }
      function tinyPow(b, e3) {
        var n = b;
        while (--e3)
          n *= b;
        return n;
      }
      function toLessThanHalfPi(Ctor, x) {
        var t, isNeg = x.s < 0, pi3 = getPi(Ctor, Ctor.precision, 1), halfPi = pi3.times(0.5);
        x = x.abs();
        if (x.lte(halfPi)) {
          quadrant = isNeg ? 4 : 1;
          return x;
        }
        t = x.divToInt(pi3);
        if (t.isZero()) {
          quadrant = isNeg ? 3 : 2;
        } else {
          x = x.minus(t.times(pi3));
          if (x.lte(halfPi)) {
            quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
            return x;
          }
          quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
        }
        return x.minus(pi3).abs();
      }
      function toStringBinary(x, baseOut, sd, rm) {
        var base, e3, i2, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== void 0;
        if (isExp) {
          checkInt32(sd, 1, MAX_DIGITS);
          if (rm === void 0)
            rm = Ctor.rounding;
          else
            checkInt32(rm, 0, 8);
        } else {
          sd = Ctor.precision;
          rm = Ctor.rounding;
        }
        if (!x.isFinite()) {
          str = nonFiniteToString(x);
        } else {
          str = finiteToString(x);
          i2 = str.indexOf(".");
          if (isExp) {
            base = 2;
            if (baseOut == 16) {
              sd = sd * 4 - 3;
            } else if (baseOut == 8) {
              sd = sd * 3 - 2;
            }
          } else {
            base = baseOut;
          }
          if (i2 >= 0) {
            str = str.replace(".", "");
            y = new Ctor(1);
            y.e = str.length - i2;
            y.d = convertBase(finiteToString(y), 10, base);
            y.e = y.d.length;
          }
          xd = convertBase(str, 10, base);
          e3 = len = xd.length;
          for (; xd[--len] == 0; )
            xd.pop();
          if (!xd[0]) {
            str = isExp ? "0p+0" : "0";
          } else {
            if (i2 < 0) {
              e3--;
            } else {
              x = new Ctor(x);
              x.d = xd;
              x.e = e3;
              x = divide2(x, y, sd, rm, 0, base);
              xd = x.d;
              e3 = x.e;
              roundUp = inexact;
            }
            i2 = xd[sd];
            k = base / 2;
            roundUp = roundUp || xd[sd + 1] !== void 0;
            roundUp = rm < 4 ? (i2 !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i2 > k || i2 === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));
            xd.length = sd;
            if (roundUp) {
              for (; ++xd[--sd] > base - 1; ) {
                xd[sd] = 0;
                if (!sd) {
                  ++e3;
                  xd.unshift(1);
                }
              }
            }
            for (len = xd.length; !xd[len - 1]; --len)
              ;
            for (i2 = 0, str = ""; i2 < len; i2++)
              str += NUMERALS.charAt(xd[i2]);
            if (isExp) {
              if (len > 1) {
                if (baseOut == 16 || baseOut == 8) {
                  i2 = baseOut == 16 ? 4 : 3;
                  for (--len; len % i2; len++)
                    str += "0";
                  xd = convertBase(str, base, baseOut);
                  for (len = xd.length; !xd[len - 1]; --len)
                    ;
                  for (i2 = 1, str = "1."; i2 < len; i2++)
                    str += NUMERALS.charAt(xd[i2]);
                } else {
                  str = str.charAt(0) + "." + str.slice(1);
                }
              }
              str = str + (e3 < 0 ? "p" : "p+") + e3;
            } else if (e3 < 0) {
              for (; ++e3; )
                str = "0" + str;
              str = "0." + str;
            } else {
              if (++e3 > len)
                for (e3 -= len; e3--; )
                  str += "0";
              else if (e3 < len)
                str = str.slice(0, e3) + "." + str.slice(e3);
            }
          }
          str = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str;
        }
        return x.s < 0 ? "-" + str : str;
      }
      function truncate(arr, len) {
        if (arr.length > len) {
          arr.length = len;
          return true;
        }
      }
      function abs2(x) {
        return new this(x).abs();
      }
      function acos2(x) {
        return new this(x).acos();
      }
      function acosh3(x) {
        return new this(x).acosh();
      }
      function add2(x, y) {
        return new this(x).plus(y);
      }
      function asin2(x) {
        return new this(x).asin();
      }
      function asinh3(x) {
        return new this(x).asinh();
      }
      function atan3(x) {
        return new this(x).atan();
      }
      function atanh3(x) {
        return new this(x).atanh();
      }
      function atan22(y, x) {
        y = new this(y);
        x = new this(x);
        var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;
        if (!y.s || !x.s) {
          r = new this(NaN);
        } else if (!y.d && !x.d) {
          r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
          r.s = y.s;
        } else if (!x.d || y.isZero()) {
          r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
          r.s = y.s;
        } else if (!y.d || x.isZero()) {
          r = getPi(this, wpr, 1).times(0.5);
          r.s = y.s;
        } else if (x.s < 0) {
          this.precision = wpr;
          this.rounding = 1;
          r = this.atan(divide2(y, x, wpr, 1));
          x = getPi(this, wpr, 1);
          this.precision = pr;
          this.rounding = rm;
          r = y.s < 0 ? r.minus(x) : r.plus(x);
        } else {
          r = this.atan(divide2(y, x, wpr, 1));
        }
        return r;
      }
      function cbrt4(x) {
        return new this(x).cbrt();
      }
      function ceil2(x) {
        return finalise(x = new this(x), x.e + 1, 2);
      }
      function clamp(x, min3, max3) {
        return new this(x).clamp(min3, max3);
      }
      function config3(obj) {
        if (!obj || typeof obj !== "object")
          throw Error(decimalError + "Object expected");
        var i2, p, v, useDefaults = obj.defaults === true, ps = [
          "precision",
          1,
          MAX_DIGITS,
          "rounding",
          0,
          8,
          "toExpNeg",
          -EXP_LIMIT,
          0,
          "toExpPos",
          0,
          EXP_LIMIT,
          "maxE",
          0,
          EXP_LIMIT,
          "minE",
          -EXP_LIMIT,
          0,
          "modulo",
          0,
          9
        ];
        for (i2 = 0; i2 < ps.length; i2 += 3) {
          if (p = ps[i2], useDefaults)
            this[p] = DEFAULTS[p];
          if ((v = obj[p]) !== void 0) {
            if (mathfloor(v) === v && v >= ps[i2 + 1] && v <= ps[i2 + 2])
              this[p] = v;
            else
              throw Error(invalidArgument + p + ": " + v);
          }
        }
        if (p = "crypto", useDefaults)
          this[p] = DEFAULTS[p];
        if ((v = obj[p]) !== void 0) {
          if (v === true || v === false || v === 0 || v === 1) {
            if (v) {
              if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                this[p] = true;
              } else {
                throw Error(cryptoUnavailable);
              }
            } else {
              this[p] = false;
            }
          } else {
            throw Error(invalidArgument + p + ": " + v);
          }
        }
        return this;
      }
      function cos2(x) {
        return new this(x).cos();
      }
      function cosh3(x) {
        return new this(x).cosh();
      }
      function clone3(obj) {
        var i2, p, ps;
        function Decimal5(v) {
          var e3, i3, t, x = this;
          if (!(x instanceof Decimal5))
            return new Decimal5(v);
          x.constructor = Decimal5;
          if (isDecimalInstance(v)) {
            x.s = v.s;
            if (external) {
              if (!v.d || v.e > Decimal5.maxE) {
                x.e = NaN;
                x.d = null;
              } else if (v.e < Decimal5.minE) {
                x.e = 0;
                x.d = [0];
              } else {
                x.e = v.e;
                x.d = v.d.slice();
              }
            } else {
              x.e = v.e;
              x.d = v.d ? v.d.slice() : v.d;
            }
            return;
          }
          t = typeof v;
          if (t === "number") {
            if (v === 0) {
              x.s = 1 / v < 0 ? -1 : 1;
              x.e = 0;
              x.d = [0];
              return;
            }
            if (v < 0) {
              v = -v;
              x.s = -1;
            } else {
              x.s = 1;
            }
            if (v === ~~v && v < 1e7) {
              for (e3 = 0, i3 = v; i3 >= 10; i3 /= 10)
                e3++;
              if (external) {
                if (e3 > Decimal5.maxE) {
                  x.e = NaN;
                  x.d = null;
                } else if (e3 < Decimal5.minE) {
                  x.e = 0;
                  x.d = [0];
                } else {
                  x.e = e3;
                  x.d = [v];
                }
              } else {
                x.e = e3;
                x.d = [v];
              }
              return;
            } else if (v * 0 !== 0) {
              if (!v)
                x.s = NaN;
              x.e = NaN;
              x.d = null;
              return;
            }
            return parseDecimal(x, v.toString());
          } else if (t !== "string") {
            throw Error(invalidArgument + v);
          }
          if ((i3 = v.charCodeAt(0)) === 45) {
            v = v.slice(1);
            x.s = -1;
          } else {
            if (i3 === 43)
              v = v.slice(1);
            x.s = 1;
          }
          return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
        }
        Decimal5.prototype = P2;
        Decimal5.ROUND_UP = 0;
        Decimal5.ROUND_DOWN = 1;
        Decimal5.ROUND_CEIL = 2;
        Decimal5.ROUND_FLOOR = 3;
        Decimal5.ROUND_HALF_UP = 4;
        Decimal5.ROUND_HALF_DOWN = 5;
        Decimal5.ROUND_HALF_EVEN = 6;
        Decimal5.ROUND_HALF_CEIL = 7;
        Decimal5.ROUND_HALF_FLOOR = 8;
        Decimal5.EUCLID = 9;
        Decimal5.config = Decimal5.set = config3;
        Decimal5.clone = clone3;
        Decimal5.isDecimal = isDecimalInstance;
        Decimal5.abs = abs2;
        Decimal5.acos = acos2;
        Decimal5.acosh = acosh3;
        Decimal5.add = add2;
        Decimal5.asin = asin2;
        Decimal5.asinh = asinh3;
        Decimal5.atan = atan3;
        Decimal5.atanh = atanh3;
        Decimal5.atan2 = atan22;
        Decimal5.cbrt = cbrt4;
        Decimal5.ceil = ceil2;
        Decimal5.clamp = clamp;
        Decimal5.cos = cos2;
        Decimal5.cosh = cosh3;
        Decimal5.div = div;
        Decimal5.exp = exp2;
        Decimal5.floor = floor2;
        Decimal5.hypot = hypot2;
        Decimal5.ln = ln;
        Decimal5.log = log3;
        Decimal5.log10 = log104;
        Decimal5.log2 = log24;
        Decimal5.max = max2;
        Decimal5.min = min2;
        Decimal5.mod = mod2;
        Decimal5.mul = mul;
        Decimal5.pow = pow2;
        Decimal5.random = random2;
        Decimal5.round = round2;
        Decimal5.sign = sign3;
        Decimal5.sin = sin2;
        Decimal5.sinh = sinh3;
        Decimal5.sqrt = sqrt2;
        Decimal5.sub = sub;
        Decimal5.sum = sum2;
        Decimal5.tan = tan2;
        Decimal5.tanh = tanh3;
        Decimal5.trunc = trunc;
        if (obj === void 0)
          obj = {};
        if (obj) {
          if (obj.defaults !== true) {
            ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
            for (i2 = 0; i2 < ps.length; )
              if (!obj.hasOwnProperty(p = ps[i2++]))
                obj[p] = this[p];
          }
        }
        Decimal5.config(obj);
        return Decimal5;
      }
      function div(x, y) {
        return new this(x).div(y);
      }
      function exp2(x) {
        return new this(x).exp();
      }
      function floor2(x) {
        return finalise(x = new this(x), x.e + 1, 3);
      }
      function hypot2() {
        var i2, n, t = new this(0);
        external = false;
        for (i2 = 0; i2 < arguments.length; ) {
          n = new this(arguments[i2++]);
          if (!n.d) {
            if (n.s) {
              external = true;
              return new this(1 / 0);
            }
            t = n;
          } else if (t.d) {
            t = t.plus(n.times(n));
          }
        }
        external = true;
        return t.sqrt();
      }
      function isDecimalInstance(obj) {
        return obj instanceof Decimal4 || obj && obj.toStringTag === tag || false;
      }
      function ln(x) {
        return new this(x).ln();
      }
      function log3(x, y) {
        return new this(x).log(y);
      }
      function log24(x) {
        return new this(x).log(2);
      }
      function log104(x) {
        return new this(x).log(10);
      }
      function max2() {
        return maxOrMin(this, arguments, "lt");
      }
      function min2() {
        return maxOrMin(this, arguments, "gt");
      }
      function mod2(x, y) {
        return new this(x).mod(y);
      }
      function mul(x, y) {
        return new this(x).mul(y);
      }
      function pow2(x, y) {
        return new this(x).pow(y);
      }
      function random2(sd) {
        var d, e3, k, n, i2 = 0, r = new this(1), rd = [];
        if (sd === void 0)
          sd = this.precision;
        else
          checkInt32(sd, 1, MAX_DIGITS);
        k = Math.ceil(sd / LOG_BASE);
        if (!this.crypto) {
          for (; i2 < k; )
            rd[i2++] = Math.random() * 1e7 | 0;
        } else if (crypto.getRandomValues) {
          d = crypto.getRandomValues(new Uint32Array(k));
          for (; i2 < k; ) {
            n = d[i2];
            if (n >= 429e7) {
              d[i2] = crypto.getRandomValues(new Uint32Array(1))[0];
            } else {
              rd[i2++] = n % 1e7;
            }
          }
        } else if (crypto.randomBytes) {
          d = crypto.randomBytes(k *= 4);
          for (; i2 < k; ) {
            n = d[i2] + (d[i2 + 1] << 8) + (d[i2 + 2] << 16) + ((d[i2 + 3] & 127) << 24);
            if (n >= 214e7) {
              crypto.randomBytes(4).copy(d, i2);
            } else {
              rd.push(n % 1e7);
              i2 += 4;
            }
          }
          i2 = k / 4;
        } else {
          throw Error(cryptoUnavailable);
        }
        k = rd[--i2];
        sd %= LOG_BASE;
        if (k && sd) {
          n = mathpow(10, LOG_BASE - sd);
          rd[i2] = (k / n | 0) * n;
        }
        for (; rd[i2] === 0; i2--)
          rd.pop();
        if (i2 < 0) {
          e3 = 0;
          rd = [0];
        } else {
          e3 = -1;
          for (; rd[0] === 0; e3 -= LOG_BASE)
            rd.shift();
          for (k = 1, n = rd[0]; n >= 10; n /= 10)
            k++;
          if (k < LOG_BASE)
            e3 -= LOG_BASE - k;
        }
        r.e = e3;
        r.d = rd;
        return r;
      }
      function round2(x) {
        return finalise(x = new this(x), x.e + 1, this.rounding);
      }
      function sign3(x) {
        x = new this(x);
        return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;
      }
      function sin2(x) {
        return new this(x).sin();
      }
      function sinh3(x) {
        return new this(x).sinh();
      }
      function sqrt2(x) {
        return new this(x).sqrt();
      }
      function sub(x, y) {
        return new this(x).sub(y);
      }
      function sum2() {
        var i2 = 0, args = arguments, x = new this(args[i2]);
        external = false;
        for (; x.s && ++i2 < args.length; )
          x = x.plus(args[i2]);
        external = true;
        return finalise(x, this.precision, this.rounding);
      }
      function tan2(x) {
        return new this(x).tan();
      }
      function tanh3(x) {
        return new this(x).tanh();
      }
      function trunc(x) {
        return finalise(x = new this(x), x.e + 1, 1);
      }
      Decimal4 = clone3(DEFAULTS);
      Decimal4.prototype.constructor = Decimal4;
      Decimal4["default"] = Decimal4.Decimal = Decimal4;
      LN102 = new Decimal4(LN102);
      PI = new Decimal4(PI);
      if (typeof define == "function" && define.amd) {
        define(function() {
          return Decimal4;
        });
      } else if (typeof module != "undefined" && module.exports) {
        if (typeof Symbol == "function" && typeof Symbol.iterator == "symbol") {
          P2[Symbol["for"]("nodejs.util.inspect.custom")] = P2.toString;
          P2[Symbol.toStringTag] = "Decimal";
        }
        module.exports = Decimal4;
      } else {
        if (!globalScope) {
          globalScope = typeof self != "undefined" && self && self.self == self ? self : window;
        }
        noConflict = globalScope.Decimal;
        Decimal4.noConflict = function() {
          globalScope.Decimal = noConflict;
          return Decimal4;
        };
        globalScope.Decimal = Decimal4;
      }
    })(exports);
  }
});

// node_modules/mathjs/lib/esm/type/bignumber/BigNumber.js
var import_decimal, name2, dependencies3, createBigNumberClass;
var init_BigNumber = __esm({
  "node_modules/mathjs/lib/esm/type/bignumber/BigNumber.js"() {
    import_decimal = __toESM(require_decimal(), 1);
    init_factory();
    name2 = "BigNumber";
    dependencies3 = ["?on", "config"];
    createBigNumberClass = /* @__PURE__ */ factory(name2, dependencies3, (_ref) => {
      var {
        on,
        config: config3
      } = _ref;
      var BigNumber2 = import_decimal.default.clone({
        precision: config3.precision,
        modulo: import_decimal.default.EUCLID
      });
      BigNumber2.prototype = Object.create(BigNumber2.prototype);
      BigNumber2.prototype.type = "BigNumber";
      BigNumber2.prototype.isBigNumber = true;
      BigNumber2.prototype.toJSON = function() {
        return {
          mathjs: "BigNumber",
          value: this.toString()
        };
      };
      BigNumber2.fromJSON = function(json) {
        return new BigNumber2(json.value);
      };
      if (on) {
        on("config", function(curr, prev) {
          if (curr.precision !== prev.precision) {
            BigNumber2.config({
              precision: curr.precision
            });
          }
        });
      }
      return BigNumber2;
    }, {
      isClass: true
    });
  }
});

// node_modules/complex.js/complex.js
var require_complex = __commonJS({
  "node_modules/complex.js/complex.js"(exports, module) {
    (function(root) {
      "use strict";
      var cosh3 = Math.cosh || function(x) {
        return Math.abs(x) < 1e-9 ? 1 - x : (Math.exp(x) + Math.exp(-x)) * 0.5;
      };
      var sinh3 = Math.sinh || function(x) {
        return Math.abs(x) < 1e-9 ? x : (Math.exp(x) - Math.exp(-x)) * 0.5;
      };
      var cosm1 = function(x) {
        var b = Math.PI / 4;
        if (-b > x || x > b) {
          return Math.cos(x) - 1;
        }
        var xx = x * x;
        return xx * (xx * (xx * (xx * (xx * (xx * (xx * (xx / 20922789888e3 - 1 / 87178291200) + 1 / 479001600) - 1 / 3628800) + 1 / 40320) - 1 / 720) + 1 / 24) - 1 / 2);
      };
      var hypot2 = function(x, y) {
        var a = Math.abs(x);
        var b = Math.abs(y);
        if (a < 3e3 && b < 3e3) {
          return Math.sqrt(a * a + b * b);
        }
        if (a < b) {
          a = b;
          b = x / y;
        } else {
          b = y / x;
        }
        return a * Math.sqrt(1 + b * b);
      };
      var parser_exit = function() {
        throw SyntaxError("Invalid Param");
      };
      function logHypot(a, b) {
        var _a = Math.abs(a);
        var _b = Math.abs(b);
        if (a === 0) {
          return Math.log(_b);
        }
        if (b === 0) {
          return Math.log(_a);
        }
        if (_a < 3e3 && _b < 3e3) {
          return Math.log(a * a + b * b) * 0.5;
        }
        a = a / 2;
        b = b / 2;
        return 0.5 * Math.log(a * a + b * b) + Math.LN2;
      }
      var parse2 = function(a, b) {
        var z = { "re": 0, "im": 0 };
        if (a === void 0 || a === null) {
          z["re"] = z["im"] = 0;
        } else if (b !== void 0) {
          z["re"] = a;
          z["im"] = b;
        } else
          switch (typeof a) {
            case "object":
              if ("im" in a && "re" in a) {
                z["re"] = a["re"];
                z["im"] = a["im"];
              } else if ("abs" in a && "arg" in a) {
                if (!Number.isFinite(a["abs"]) && Number.isFinite(a["arg"])) {
                  return Complex3["INFINITY"];
                }
                z["re"] = a["abs"] * Math.cos(a["arg"]);
                z["im"] = a["abs"] * Math.sin(a["arg"]);
              } else if ("r" in a && "phi" in a) {
                if (!Number.isFinite(a["r"]) && Number.isFinite(a["phi"])) {
                  return Complex3["INFINITY"];
                }
                z["re"] = a["r"] * Math.cos(a["phi"]);
                z["im"] = a["r"] * Math.sin(a["phi"]);
              } else if (a.length === 2) {
                z["re"] = a[0];
                z["im"] = a[1];
              } else {
                parser_exit();
              }
              break;
            case "string":
              z["im"] = z["re"] = 0;
              var tokens = a.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g);
              var plus = 1;
              var minus = 0;
              if (tokens === null) {
                parser_exit();
              }
              for (var i2 = 0; i2 < tokens.length; i2++) {
                var c = tokens[i2];
                if (c === " " || c === "	" || c === "\n") {
                } else if (c === "+") {
                  plus++;
                } else if (c === "-") {
                  minus++;
                } else if (c === "i" || c === "I") {
                  if (plus + minus === 0) {
                    parser_exit();
                  }
                  if (tokens[i2 + 1] !== " " && !isNaN(tokens[i2 + 1])) {
                    z["im"] += parseFloat((minus % 2 ? "-" : "") + tokens[i2 + 1]);
                    i2++;
                  } else {
                    z["im"] += parseFloat((minus % 2 ? "-" : "") + "1");
                  }
                  plus = minus = 0;
                } else {
                  if (plus + minus === 0 || isNaN(c)) {
                    parser_exit();
                  }
                  if (tokens[i2 + 1] === "i" || tokens[i2 + 1] === "I") {
                    z["im"] += parseFloat((minus % 2 ? "-" : "") + c);
                    i2++;
                  } else {
                    z["re"] += parseFloat((minus % 2 ? "-" : "") + c);
                  }
                  plus = minus = 0;
                }
              }
              if (plus + minus > 0) {
                parser_exit();
              }
              break;
            case "number":
              z["im"] = 0;
              z["re"] = a;
              break;
            default:
              parser_exit();
          }
        if (isNaN(z["re"]) || isNaN(z["im"])) {
        }
        return z;
      };
      function Complex3(a, b) {
        if (!(this instanceof Complex3)) {
          return new Complex3(a, b);
        }
        var z = parse2(a, b);
        this["re"] = z["re"];
        this["im"] = z["im"];
      }
      Complex3.prototype = {
        "re": 0,
        "im": 0,
        "sign": function() {
          var abs2 = this["abs"]();
          return new Complex3(
            this["re"] / abs2,
            this["im"] / abs2
          );
        },
        "add": function(a, b) {
          var z = new Complex3(a, b);
          if (this["isInfinite"]() && z["isInfinite"]()) {
            return Complex3["NAN"];
          }
          if (this["isInfinite"]() || z["isInfinite"]()) {
            return Complex3["INFINITY"];
          }
          return new Complex3(
            this["re"] + z["re"],
            this["im"] + z["im"]
          );
        },
        "sub": function(a, b) {
          var z = new Complex3(a, b);
          if (this["isInfinite"]() && z["isInfinite"]()) {
            return Complex3["NAN"];
          }
          if (this["isInfinite"]() || z["isInfinite"]()) {
            return Complex3["INFINITY"];
          }
          return new Complex3(
            this["re"] - z["re"],
            this["im"] - z["im"]
          );
        },
        "mul": function(a, b) {
          var z = new Complex3(a, b);
          if (this["isInfinite"]() && z["isZero"]() || this["isZero"]() && z["isInfinite"]()) {
            return Complex3["NAN"];
          }
          if (this["isInfinite"]() || z["isInfinite"]()) {
            return Complex3["INFINITY"];
          }
          if (z["im"] === 0 && this["im"] === 0) {
            return new Complex3(this["re"] * z["re"], 0);
          }
          return new Complex3(
            this["re"] * z["re"] - this["im"] * z["im"],
            this["re"] * z["im"] + this["im"] * z["re"]
          );
        },
        "div": function(a, b) {
          var z = new Complex3(a, b);
          if (this["isZero"]() && z["isZero"]() || this["isInfinite"]() && z["isInfinite"]()) {
            return Complex3["NAN"];
          }
          if (this["isInfinite"]() || z["isZero"]()) {
            return Complex3["INFINITY"];
          }
          if (this["isZero"]() || z["isInfinite"]()) {
            return Complex3["ZERO"];
          }
          a = this["re"];
          b = this["im"];
          var c = z["re"];
          var d = z["im"];
          var t, x;
          if (0 === d) {
            return new Complex3(a / c, b / c);
          }
          if (Math.abs(c) < Math.abs(d)) {
            x = c / d;
            t = c * x + d;
            return new Complex3(
              (a * x + b) / t,
              (b * x - a) / t
            );
          } else {
            x = d / c;
            t = d * x + c;
            return new Complex3(
              (a + b * x) / t,
              (b - a * x) / t
            );
          }
        },
        "pow": function(a, b) {
          var z = new Complex3(a, b);
          a = this["re"];
          b = this["im"];
          if (z["isZero"]()) {
            return Complex3["ONE"];
          }
          if (z["im"] === 0) {
            if (b === 0 && a > 0) {
              return new Complex3(Math.pow(a, z["re"]), 0);
            } else if (a === 0) {
              switch ((z["re"] % 4 + 4) % 4) {
                case 0:
                  return new Complex3(Math.pow(b, z["re"]), 0);
                case 1:
                  return new Complex3(0, Math.pow(b, z["re"]));
                case 2:
                  return new Complex3(-Math.pow(b, z["re"]), 0);
                case 3:
                  return new Complex3(0, -Math.pow(b, z["re"]));
              }
            }
          }
          if (a === 0 && b === 0 && z["re"] > 0 && z["im"] >= 0) {
            return Complex3["ZERO"];
          }
          var arg2 = Math.atan2(b, a);
          var loh = logHypot(a, b);
          a = Math.exp(z["re"] * loh - z["im"] * arg2);
          b = z["im"] * loh + z["re"] * arg2;
          return new Complex3(
            a * Math.cos(b),
            a * Math.sin(b)
          );
        },
        "sqrt": function() {
          var a = this["re"];
          var b = this["im"];
          var r = this["abs"]();
          var re2, im2;
          if (a >= 0) {
            if (b === 0) {
              return new Complex3(Math.sqrt(a), 0);
            }
            re2 = 0.5 * Math.sqrt(2 * (r + a));
          } else {
            re2 = Math.abs(b) / Math.sqrt(2 * (r - a));
          }
          if (a <= 0) {
            im2 = 0.5 * Math.sqrt(2 * (r - a));
          } else {
            im2 = Math.abs(b) / Math.sqrt(2 * (r + a));
          }
          return new Complex3(re2, b < 0 ? -im2 : im2);
        },
        "exp": function() {
          var tmp = Math.exp(this["re"]);
          if (this["im"] === 0) {
          }
          return new Complex3(
            tmp * Math.cos(this["im"]),
            tmp * Math.sin(this["im"])
          );
        },
        "expm1": function() {
          var a = this["re"];
          var b = this["im"];
          return new Complex3(
            Math.expm1(a) * Math.cos(b) + cosm1(b),
            Math.exp(a) * Math.sin(b)
          );
        },
        "log": function() {
          var a = this["re"];
          var b = this["im"];
          if (b === 0 && a > 0) {
          }
          return new Complex3(
            logHypot(a, b),
            Math.atan2(b, a)
          );
        },
        "abs": function() {
          return hypot2(this["re"], this["im"]);
        },
        "arg": function() {
          return Math.atan2(this["im"], this["re"]);
        },
        "sin": function() {
          var a = this["re"];
          var b = this["im"];
          return new Complex3(
            Math.sin(a) * cosh3(b),
            Math.cos(a) * sinh3(b)
          );
        },
        "cos": function() {
          var a = this["re"];
          var b = this["im"];
          return new Complex3(
            Math.cos(a) * cosh3(b),
            -Math.sin(a) * sinh3(b)
          );
        },
        "tan": function() {
          var a = 2 * this["re"];
          var b = 2 * this["im"];
          var d = Math.cos(a) + cosh3(b);
          return new Complex3(
            Math.sin(a) / d,
            sinh3(b) / d
          );
        },
        "cot": function() {
          var a = 2 * this["re"];
          var b = 2 * this["im"];
          var d = Math.cos(a) - cosh3(b);
          return new Complex3(
            -Math.sin(a) / d,
            sinh3(b) / d
          );
        },
        "sec": function() {
          var a = this["re"];
          var b = this["im"];
          var d = 0.5 * cosh3(2 * b) + 0.5 * Math.cos(2 * a);
          return new Complex3(
            Math.cos(a) * cosh3(b) / d,
            Math.sin(a) * sinh3(b) / d
          );
        },
        "csc": function() {
          var a = this["re"];
          var b = this["im"];
          var d = 0.5 * cosh3(2 * b) - 0.5 * Math.cos(2 * a);
          return new Complex3(
            Math.sin(a) * cosh3(b) / d,
            -Math.cos(a) * sinh3(b) / d
          );
        },
        "asin": function() {
          var a = this["re"];
          var b = this["im"];
          var t1 = new Complex3(
            b * b - a * a + 1,
            -2 * a * b
          )["sqrt"]();
          var t2 = new Complex3(
            t1["re"] - b,
            t1["im"] + a
          )["log"]();
          return new Complex3(t2["im"], -t2["re"]);
        },
        "acos": function() {
          var a = this["re"];
          var b = this["im"];
          var t1 = new Complex3(
            b * b - a * a + 1,
            -2 * a * b
          )["sqrt"]();
          var t2 = new Complex3(
            t1["re"] - b,
            t1["im"] + a
          )["log"]();
          return new Complex3(Math.PI / 2 - t2["im"], t2["re"]);
        },
        "atan": function() {
          var a = this["re"];
          var b = this["im"];
          if (a === 0) {
            if (b === 1) {
              return new Complex3(0, Infinity);
            }
            if (b === -1) {
              return new Complex3(0, -Infinity);
            }
          }
          var d = a * a + (1 - b) * (1 - b);
          var t1 = new Complex3(
            (1 - b * b - a * a) / d,
            -2 * a / d
          ).log();
          return new Complex3(-0.5 * t1["im"], 0.5 * t1["re"]);
        },
        "acot": function() {
          var a = this["re"];
          var b = this["im"];
          if (b === 0) {
            return new Complex3(Math.atan2(1, a), 0);
          }
          var d = a * a + b * b;
          return d !== 0 ? new Complex3(
            a / d,
            -b / d
          ).atan() : new Complex3(
            a !== 0 ? a / 0 : 0,
            b !== 0 ? -b / 0 : 0
          ).atan();
        },
        "asec": function() {
          var a = this["re"];
          var b = this["im"];
          if (a === 0 && b === 0) {
            return new Complex3(0, Infinity);
          }
          var d = a * a + b * b;
          return d !== 0 ? new Complex3(
            a / d,
            -b / d
          ).acos() : new Complex3(
            a !== 0 ? a / 0 : 0,
            b !== 0 ? -b / 0 : 0
          ).acos();
        },
        "acsc": function() {
          var a = this["re"];
          var b = this["im"];
          if (a === 0 && b === 0) {
            return new Complex3(Math.PI / 2, Infinity);
          }
          var d = a * a + b * b;
          return d !== 0 ? new Complex3(
            a / d,
            -b / d
          ).asin() : new Complex3(
            a !== 0 ? a / 0 : 0,
            b !== 0 ? -b / 0 : 0
          ).asin();
        },
        "sinh": function() {
          var a = this["re"];
          var b = this["im"];
          return new Complex3(
            sinh3(a) * Math.cos(b),
            cosh3(a) * Math.sin(b)
          );
        },
        "cosh": function() {
          var a = this["re"];
          var b = this["im"];
          return new Complex3(
            cosh3(a) * Math.cos(b),
            sinh3(a) * Math.sin(b)
          );
        },
        "tanh": function() {
          var a = 2 * this["re"];
          var b = 2 * this["im"];
          var d = cosh3(a) + Math.cos(b);
          return new Complex3(
            sinh3(a) / d,
            Math.sin(b) / d
          );
        },
        "coth": function() {
          var a = 2 * this["re"];
          var b = 2 * this["im"];
          var d = cosh3(a) - Math.cos(b);
          return new Complex3(
            sinh3(a) / d,
            -Math.sin(b) / d
          );
        },
        "csch": function() {
          var a = this["re"];
          var b = this["im"];
          var d = Math.cos(2 * b) - cosh3(2 * a);
          return new Complex3(
            -2 * sinh3(a) * Math.cos(b) / d,
            2 * cosh3(a) * Math.sin(b) / d
          );
        },
        "sech": function() {
          var a = this["re"];
          var b = this["im"];
          var d = Math.cos(2 * b) + cosh3(2 * a);
          return new Complex3(
            2 * cosh3(a) * Math.cos(b) / d,
            -2 * sinh3(a) * Math.sin(b) / d
          );
        },
        "asinh": function() {
          var tmp = this["im"];
          this["im"] = -this["re"];
          this["re"] = tmp;
          var res = this["asin"]();
          this["re"] = -this["im"];
          this["im"] = tmp;
          tmp = res["re"];
          res["re"] = -res["im"];
          res["im"] = tmp;
          return res;
        },
        "acosh": function() {
          var res = this["acos"]();
          if (res["im"] <= 0) {
            var tmp = res["re"];
            res["re"] = -res["im"];
            res["im"] = tmp;
          } else {
            var tmp = res["im"];
            res["im"] = -res["re"];
            res["re"] = tmp;
          }
          return res;
        },
        "atanh": function() {
          var a = this["re"];
          var b = this["im"];
          var noIM = a > 1 && b === 0;
          var oneMinus = 1 - a;
          var onePlus = 1 + a;
          var d = oneMinus * oneMinus + b * b;
          var x = d !== 0 ? new Complex3(
            (onePlus * oneMinus - b * b) / d,
            (b * oneMinus + onePlus * b) / d
          ) : new Complex3(
            a !== -1 ? a / 0 : 0,
            b !== 0 ? b / 0 : 0
          );
          var temp = x["re"];
          x["re"] = logHypot(x["re"], x["im"]) / 2;
          x["im"] = Math.atan2(x["im"], temp) / 2;
          if (noIM) {
            x["im"] = -x["im"];
          }
          return x;
        },
        "acoth": function() {
          var a = this["re"];
          var b = this["im"];
          if (a === 0 && b === 0) {
            return new Complex3(0, Math.PI / 2);
          }
          var d = a * a + b * b;
          return d !== 0 ? new Complex3(
            a / d,
            -b / d
          ).atanh() : new Complex3(
            a !== 0 ? a / 0 : 0,
            b !== 0 ? -b / 0 : 0
          ).atanh();
        },
        "acsch": function() {
          var a = this["re"];
          var b = this["im"];
          if (b === 0) {
            return new Complex3(
              a !== 0 ? Math.log(a + Math.sqrt(a * a + 1)) : Infinity,
              0
            );
          }
          var d = a * a + b * b;
          return d !== 0 ? new Complex3(
            a / d,
            -b / d
          ).asinh() : new Complex3(
            a !== 0 ? a / 0 : 0,
            b !== 0 ? -b / 0 : 0
          ).asinh();
        },
        "asech": function() {
          var a = this["re"];
          var b = this["im"];
          if (this["isZero"]()) {
            return Complex3["INFINITY"];
          }
          var d = a * a + b * b;
          return d !== 0 ? new Complex3(
            a / d,
            -b / d
          ).acosh() : new Complex3(
            a !== 0 ? a / 0 : 0,
            b !== 0 ? -b / 0 : 0
          ).acosh();
        },
        "inverse": function() {
          if (this["isZero"]()) {
            return Complex3["INFINITY"];
          }
          if (this["isInfinite"]()) {
            return Complex3["ZERO"];
          }
          var a = this["re"];
          var b = this["im"];
          var d = a * a + b * b;
          return new Complex3(a / d, -b / d);
        },
        "conjugate": function() {
          return new Complex3(this["re"], -this["im"]);
        },
        "neg": function() {
          return new Complex3(-this["re"], -this["im"]);
        },
        "ceil": function(places) {
          places = Math.pow(10, places || 0);
          return new Complex3(
            Math.ceil(this["re"] * places) / places,
            Math.ceil(this["im"] * places) / places
          );
        },
        "floor": function(places) {
          places = Math.pow(10, places || 0);
          return new Complex3(
            Math.floor(this["re"] * places) / places,
            Math.floor(this["im"] * places) / places
          );
        },
        "round": function(places) {
          places = Math.pow(10, places || 0);
          return new Complex3(
            Math.round(this["re"] * places) / places,
            Math.round(this["im"] * places) / places
          );
        },
        "equals": function(a, b) {
          var z = new Complex3(a, b);
          return Math.abs(z["re"] - this["re"]) <= Complex3["EPSILON"] && Math.abs(z["im"] - this["im"]) <= Complex3["EPSILON"];
        },
        "clone": function() {
          return new Complex3(this["re"], this["im"]);
        },
        "toString": function() {
          var a = this["re"];
          var b = this["im"];
          var ret = "";
          if (this["isNaN"]()) {
            return "NaN";
          }
          if (this["isInfinite"]()) {
            return "Infinity";
          }
          if (Math.abs(a) < Complex3["EPSILON"]) {
            a = 0;
          }
          if (Math.abs(b) < Complex3["EPSILON"]) {
            b = 0;
          }
          if (b === 0) {
            return ret + a;
          }
          if (a !== 0) {
            ret += a;
            ret += " ";
            if (b < 0) {
              b = -b;
              ret += "-";
            } else {
              ret += "+";
            }
            ret += " ";
          } else if (b < 0) {
            b = -b;
            ret += "-";
          }
          if (1 !== b) {
            ret += b;
          }
          return ret + "i";
        },
        "toVector": function() {
          return [this["re"], this["im"]];
        },
        "valueOf": function() {
          if (this["im"] === 0) {
            return this["re"];
          }
          return null;
        },
        "isNaN": function() {
          return isNaN(this["re"]) || isNaN(this["im"]);
        },
        "isZero": function() {
          return this["im"] === 0 && this["re"] === 0;
        },
        "isFinite": function() {
          return isFinite(this["re"]) && isFinite(this["im"]);
        },
        "isInfinite": function() {
          return !(this["isNaN"]() || this["isFinite"]());
        }
      };
      Complex3["ZERO"] = new Complex3(0, 0);
      Complex3["ONE"] = new Complex3(1, 0);
      Complex3["I"] = new Complex3(0, 1);
      Complex3["PI"] = new Complex3(Math.PI, 0);
      Complex3["E"] = new Complex3(Math.E, 0);
      Complex3["INFINITY"] = new Complex3(Infinity, Infinity);
      Complex3["NAN"] = new Complex3(NaN, NaN);
      Complex3["EPSILON"] = 1e-15;
      if (typeof define === "function" && define["amd"]) {
        define([], function() {
          return Complex3;
        });
      } else if (typeof exports === "object") {
        Object.defineProperty(Complex3, "__esModule", { "value": true });
        Complex3["default"] = Complex3;
        Complex3["Complex"] = Complex3;
        module["exports"] = Complex3;
      } else {
        root["Complex"] = Complex3;
      }
    })(exports);
  }
});

// node_modules/mathjs/lib/esm/type/complex/Complex.js
var import_complex, name3, dependencies4, createComplexClass;
var init_Complex = __esm({
  "node_modules/mathjs/lib/esm/type/complex/Complex.js"() {
    import_complex = __toESM(require_complex(), 1);
    init_number();
    init_is();
    init_factory();
    name3 = "Complex";
    dependencies4 = [];
    createComplexClass = /* @__PURE__ */ factory(name3, dependencies4, () => {
      import_complex.default.prototype.type = "Complex";
      import_complex.default.prototype.isComplex = true;
      import_complex.default.prototype.toJSON = function() {
        return {
          mathjs: "Complex",
          re: this.re,
          im: this.im
        };
      };
      import_complex.default.prototype.toPolar = function() {
        return {
          r: this.abs(),
          phi: this.arg()
        };
      };
      import_complex.default.prototype.format = function(options) {
        var str = "";
        var im2 = this.im;
        var re2 = this.re;
        var strRe = format(this.re, options);
        var strIm = format(this.im, options);
        var precision = isNumber2(options) ? options : options ? options.precision : null;
        if (precision !== null) {
          var epsilon = Math.pow(10, -precision);
          if (Math.abs(re2 / im2) < epsilon) {
            re2 = 0;
          }
          if (Math.abs(im2 / re2) < epsilon) {
            im2 = 0;
          }
        }
        if (im2 === 0) {
          str = strRe;
        } else if (re2 === 0) {
          if (im2 === 1) {
            str = "i";
          } else if (im2 === -1) {
            str = "-i";
          } else {
            str = strIm + "i";
          }
        } else {
          if (im2 < 0) {
            if (im2 === -1) {
              str = strRe + " - i";
            } else {
              str = strRe + " - " + strIm.substring(1) + "i";
            }
          } else {
            if (im2 === 1) {
              str = strRe + " + i";
            } else {
              str = strRe + " + " + strIm + "i";
            }
          }
        }
        return str;
      };
      import_complex.default.fromPolar = function(args) {
        switch (arguments.length) {
          case 1: {
            var arg2 = arguments[0];
            if (typeof arg2 === "object") {
              return (0, import_complex.default)(arg2);
            } else {
              throw new TypeError("Input has to be an object with r and phi keys.");
            }
          }
          case 2: {
            var r = arguments[0];
            var phi3 = arguments[1];
            if (isNumber2(r)) {
              if (isUnit(phi3) && phi3.hasBase("ANGLE")) {
                phi3 = phi3.toNumber("rad");
              }
              if (isNumber2(phi3)) {
                return new import_complex.default({
                  r,
                  phi: phi3
                });
              }
              throw new TypeError("Phi is not a number nor an angle unit.");
            } else {
              throw new TypeError("Radius r is not a number.");
            }
          }
          default:
            throw new SyntaxError("Wrong number of arguments in function fromPolar");
        }
      };
      import_complex.default.prototype.valueOf = import_complex.default.prototype.toString;
      import_complex.default.fromJSON = function(json) {
        return new import_complex.default(json);
      };
      import_complex.default.compare = function(a, b) {
        if (a.re > b.re) {
          return 1;
        }
        if (a.re < b.re) {
          return -1;
        }
        if (a.im > b.im) {
          return 1;
        }
        if (a.im < b.im) {
          return -1;
        }
        return 0;
      };
      return import_complex.default;
    }, {
      isClass: true
    });
  }
});

// node_modules/fraction.js/fraction.js
var require_fraction = __commonJS({
  "node_modules/fraction.js/fraction.js"(exports, module) {
    (function(root) {
      "use strict";
      var MAX_CYCLE_LEN = 2e3;
      var P2 = {
        "s": 1,
        "n": 0,
        "d": 1
      };
      function assign2(n, s) {
        if (isNaN(n = parseInt(n, 10))) {
          throw Fraction3["InvalidParameter"];
        }
        return n * s;
      }
      function newFraction(n, d) {
        if (d === 0) {
          throw Fraction3["DivisionByZero"];
        }
        var f = Object.create(Fraction3.prototype);
        f["s"] = n < 0 ? -1 : 1;
        n = n < 0 ? -n : n;
        var a = gcd2(n, d);
        f["n"] = n / a;
        f["d"] = d / a;
        return f;
      }
      function factorize(num) {
        var factors = {};
        var n = num;
        var i2 = 2;
        var s = 4;
        while (s <= n) {
          while (n % i2 === 0) {
            n /= i2;
            factors[i2] = (factors[i2] || 0) + 1;
          }
          s += 1 + 2 * i2++;
        }
        if (n !== num) {
          if (n > 1)
            factors[n] = (factors[n] || 0) + 1;
        } else {
          factors[num] = (factors[num] || 0) + 1;
        }
        return factors;
      }
      var parse2 = function(p1, p2) {
        var n = 0, d = 1, s = 1;
        var v = 0, w = 0, x = 0, y = 1, z = 1;
        var A = 0, B = 1;
        var C = 1, D = 1;
        var N = 1e7;
        var M;
        if (p1 === void 0 || p1 === null) {
        } else if (p2 !== void 0) {
          n = p1;
          d = p2;
          s = n * d;
          if (n % 1 !== 0 || d % 1 !== 0) {
            throw Fraction3["NonIntegerParameter"];
          }
        } else
          switch (typeof p1) {
            case "object": {
              if ("d" in p1 && "n" in p1) {
                n = p1["n"];
                d = p1["d"];
                if ("s" in p1)
                  n *= p1["s"];
              } else if (0 in p1) {
                n = p1[0];
                if (1 in p1)
                  d = p1[1];
              } else {
                throw Fraction3["InvalidParameter"];
              }
              s = n * d;
              break;
            }
            case "number": {
              if (p1 < 0) {
                s = p1;
                p1 = -p1;
              }
              if (p1 % 1 === 0) {
                n = p1;
              } else if (p1 > 0) {
                if (p1 >= 1) {
                  z = Math.pow(10, Math.floor(1 + Math.log(p1) / Math.LN10));
                  p1 /= z;
                }
                while (B <= N && D <= N) {
                  M = (A + C) / (B + D);
                  if (p1 === M) {
                    if (B + D <= N) {
                      n = A + C;
                      d = B + D;
                    } else if (D > B) {
                      n = C;
                      d = D;
                    } else {
                      n = A;
                      d = B;
                    }
                    break;
                  } else {
                    if (p1 > M) {
                      A += C;
                      B += D;
                    } else {
                      C += A;
                      D += B;
                    }
                    if (B > N) {
                      n = C;
                      d = D;
                    } else {
                      n = A;
                      d = B;
                    }
                  }
                }
                n *= z;
              } else if (isNaN(p1) || isNaN(p2)) {
                d = n = NaN;
              }
              break;
            }
            case "string": {
              B = p1.match(/\d+|./g);
              if (B === null)
                throw Fraction3["InvalidParameter"];
              if (B[A] === "-") {
                s = -1;
                A++;
              } else if (B[A] === "+") {
                A++;
              }
              if (B.length === A + 1) {
                w = assign2(B[A++], s);
              } else if (B[A + 1] === "." || B[A] === ".") {
                if (B[A] !== ".") {
                  v = assign2(B[A++], s);
                }
                A++;
                if (A + 1 === B.length || B[A + 1] === "(" && B[A + 3] === ")" || B[A + 1] === "'" && B[A + 3] === "'") {
                  w = assign2(B[A], s);
                  y = Math.pow(10, B[A].length);
                  A++;
                }
                if (B[A] === "(" && B[A + 2] === ")" || B[A] === "'" && B[A + 2] === "'") {
                  x = assign2(B[A + 1], s);
                  z = Math.pow(10, B[A + 1].length) - 1;
                  A += 3;
                }
              } else if (B[A + 1] === "/" || B[A + 1] === ":") {
                w = assign2(B[A], s);
                y = assign2(B[A + 2], 1);
                A += 3;
              } else if (B[A + 3] === "/" && B[A + 1] === " ") {
                v = assign2(B[A], s);
                w = assign2(B[A + 2], s);
                y = assign2(B[A + 4], 1);
                A += 5;
              }
              if (B.length <= A) {
                d = y * z;
                s = n = x + d * v + z * w;
                break;
              }
            }
            default:
              throw Fraction3["InvalidParameter"];
          }
        if (d === 0) {
          throw Fraction3["DivisionByZero"];
        }
        P2["s"] = s < 0 ? -1 : 1;
        P2["n"] = Math.abs(n);
        P2["d"] = Math.abs(d);
      };
      function modpow(b, e3, m) {
        var r = 1;
        for (; e3 > 0; b = b * b % m, e3 >>= 1) {
          if (e3 & 1) {
            r = r * b % m;
          }
        }
        return r;
      }
      function cycleLen(n, d) {
        for (; d % 2 === 0; d /= 2) {
        }
        for (; d % 5 === 0; d /= 5) {
        }
        if (d === 1)
          return 0;
        var rem = 10 % d;
        var t = 1;
        for (; rem !== 1; t++) {
          rem = rem * 10 % d;
          if (t > MAX_CYCLE_LEN)
            return 0;
        }
        return t;
      }
      function cycleStart(n, d, len) {
        var rem1 = 1;
        var rem2 = modpow(10, len, d);
        for (var t = 0; t < 300; t++) {
          if (rem1 === rem2)
            return t;
          rem1 = rem1 * 10 % d;
          rem2 = rem2 * 10 % d;
        }
        return 0;
      }
      function gcd2(a, b) {
        if (!a)
          return b;
        if (!b)
          return a;
        while (1) {
          a %= b;
          if (!a)
            return b;
          b %= a;
          if (!b)
            return a;
        }
      }
      ;
      function Fraction3(a, b) {
        parse2(a, b);
        if (this instanceof Fraction3) {
          a = gcd2(P2["d"], P2["n"]);
          this["s"] = P2["s"];
          this["n"] = P2["n"] / a;
          this["d"] = P2["d"] / a;
        } else {
          return newFraction(P2["s"] * P2["n"], P2["d"]);
        }
      }
      Fraction3["DivisionByZero"] = new Error("Division by Zero");
      Fraction3["InvalidParameter"] = new Error("Invalid argument");
      Fraction3["NonIntegerParameter"] = new Error("Parameters must be integer");
      Fraction3.prototype = {
        "s": 1,
        "n": 0,
        "d": 1,
        "abs": function() {
          return newFraction(this["n"], this["d"]);
        },
        "neg": function() {
          return newFraction(-this["s"] * this["n"], this["d"]);
        },
        "add": function(a, b) {
          parse2(a, b);
          return newFraction(
            this["s"] * this["n"] * P2["d"] + P2["s"] * this["d"] * P2["n"],
            this["d"] * P2["d"]
          );
        },
        "sub": function(a, b) {
          parse2(a, b);
          return newFraction(
            this["s"] * this["n"] * P2["d"] - P2["s"] * this["d"] * P2["n"],
            this["d"] * P2["d"]
          );
        },
        "mul": function(a, b) {
          parse2(a, b);
          return newFraction(
            this["s"] * P2["s"] * this["n"] * P2["n"],
            this["d"] * P2["d"]
          );
        },
        "div": function(a, b) {
          parse2(a, b);
          return newFraction(
            this["s"] * P2["s"] * this["n"] * P2["d"],
            this["d"] * P2["n"]
          );
        },
        "clone": function() {
          return newFraction(this["s"] * this["n"], this["d"]);
        },
        "mod": function(a, b) {
          if (isNaN(this["n"]) || isNaN(this["d"])) {
            return new Fraction3(NaN);
          }
          if (a === void 0) {
            return newFraction(this["s"] * this["n"] % this["d"], 1);
          }
          parse2(a, b);
          if (0 === P2["n"] && 0 === this["d"]) {
            throw Fraction3["DivisionByZero"];
          }
          return newFraction(
            this["s"] * (P2["d"] * this["n"]) % (P2["n"] * this["d"]),
            P2["d"] * this["d"]
          );
        },
        "gcd": function(a, b) {
          parse2(a, b);
          return newFraction(gcd2(P2["n"], this["n"]) * gcd2(P2["d"], this["d"]), P2["d"] * this["d"]);
        },
        "lcm": function(a, b) {
          parse2(a, b);
          if (P2["n"] === 0 && this["n"] === 0) {
            return newFraction(0, 1);
          }
          return newFraction(P2["n"] * this["n"], gcd2(P2["n"], this["n"]) * gcd2(P2["d"], this["d"]));
        },
        "ceil": function(places) {
          places = Math.pow(10, places || 0);
          if (isNaN(this["n"]) || isNaN(this["d"])) {
            return new Fraction3(NaN);
          }
          return newFraction(Math.ceil(places * this["s"] * this["n"] / this["d"]), places);
        },
        "floor": function(places) {
          places = Math.pow(10, places || 0);
          if (isNaN(this["n"]) || isNaN(this["d"])) {
            return new Fraction3(NaN);
          }
          return newFraction(Math.floor(places * this["s"] * this["n"] / this["d"]), places);
        },
        "round": function(places) {
          places = Math.pow(10, places || 0);
          if (isNaN(this["n"]) || isNaN(this["d"])) {
            return new Fraction3(NaN);
          }
          return newFraction(Math.round(places * this["s"] * this["n"] / this["d"]), places);
        },
        "inverse": function() {
          return newFraction(this["s"] * this["d"], this["n"]);
        },
        "pow": function(a, b) {
          parse2(a, b);
          if (P2["d"] === 1) {
            if (P2["s"] < 0) {
              return newFraction(Math.pow(this["s"] * this["d"], P2["n"]), Math.pow(this["n"], P2["n"]));
            } else {
              return newFraction(Math.pow(this["s"] * this["n"], P2["n"]), Math.pow(this["d"], P2["n"]));
            }
          }
          if (this["s"] < 0)
            return null;
          var N = factorize(this["n"]);
          var D = factorize(this["d"]);
          var n = 1;
          var d = 1;
          for (var k in N) {
            if (k === "1")
              continue;
            if (k === "0") {
              n = 0;
              break;
            }
            N[k] *= P2["n"];
            if (N[k] % P2["d"] === 0) {
              N[k] /= P2["d"];
            } else
              return null;
            n *= Math.pow(k, N[k]);
          }
          for (var k in D) {
            if (k === "1")
              continue;
            D[k] *= P2["n"];
            if (D[k] % P2["d"] === 0) {
              D[k] /= P2["d"];
            } else
              return null;
            d *= Math.pow(k, D[k]);
          }
          if (P2["s"] < 0) {
            return newFraction(d, n);
          }
          return newFraction(n, d);
        },
        "equals": function(a, b) {
          parse2(a, b);
          return this["s"] * this["n"] * P2["d"] === P2["s"] * P2["n"] * this["d"];
        },
        "compare": function(a, b) {
          parse2(a, b);
          var t = this["s"] * this["n"] * P2["d"] - P2["s"] * P2["n"] * this["d"];
          return (0 < t) - (t < 0);
        },
        "simplify": function(eps) {
          if (isNaN(this["n"]) || isNaN(this["d"])) {
            return this;
          }
          eps = eps || 1e-3;
          var thisABS = this["abs"]();
          var cont = thisABS["toContinued"]();
          for (var i2 = 1; i2 < cont.length; i2++) {
            var s = newFraction(cont[i2 - 1], 1);
            for (var k = i2 - 2; k >= 0; k--) {
              s = s["inverse"]()["add"](cont[k]);
            }
            if (s["sub"](thisABS)["abs"]().valueOf() < eps) {
              return s["mul"](this["s"]);
            }
          }
          return this;
        },
        "divisible": function(a, b) {
          parse2(a, b);
          return !(!(P2["n"] * this["d"]) || this["n"] * P2["d"] % (P2["n"] * this["d"]));
        },
        "valueOf": function() {
          return this["s"] * this["n"] / this["d"];
        },
        "toFraction": function(excludeWhole) {
          var whole, str = "";
          var n = this["n"];
          var d = this["d"];
          if (this["s"] < 0) {
            str += "-";
          }
          if (d === 1) {
            str += n;
          } else {
            if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
              str += whole;
              str += " ";
              n %= d;
            }
            str += n;
            str += "/";
            str += d;
          }
          return str;
        },
        "toLatex": function(excludeWhole) {
          var whole, str = "";
          var n = this["n"];
          var d = this["d"];
          if (this["s"] < 0) {
            str += "-";
          }
          if (d === 1) {
            str += n;
          } else {
            if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
              str += whole;
              n %= d;
            }
            str += "\\frac{";
            str += n;
            str += "}{";
            str += d;
            str += "}";
          }
          return str;
        },
        "toContinued": function() {
          var t;
          var a = this["n"];
          var b = this["d"];
          var res = [];
          if (isNaN(a) || isNaN(b)) {
            return res;
          }
          do {
            res.push(Math.floor(a / b));
            t = a % b;
            a = b;
            b = t;
          } while (a !== 1);
          return res;
        },
        "toString": function(dec) {
          var N = this["n"];
          var D = this["d"];
          if (isNaN(N) || isNaN(D)) {
            return "NaN";
          }
          dec = dec || 15;
          var cycLen = cycleLen(N, D);
          var cycOff = cycleStart(N, D, cycLen);
          var str = this["s"] < 0 ? "-" : "";
          str += N / D | 0;
          N %= D;
          N *= 10;
          if (N)
            str += ".";
          if (cycLen) {
            for (var i2 = cycOff; i2--; ) {
              str += N / D | 0;
              N %= D;
              N *= 10;
            }
            str += "(";
            for (var i2 = cycLen; i2--; ) {
              str += N / D | 0;
              N %= D;
              N *= 10;
            }
            str += ")";
          } else {
            for (var i2 = dec; N && i2--; ) {
              str += N / D | 0;
              N %= D;
              N *= 10;
            }
          }
          return str;
        }
      };
      if (typeof define === "function" && define["amd"]) {
        define([], function() {
          return Fraction3;
        });
      } else if (typeof exports === "object") {
        Object.defineProperty(Fraction3, "__esModule", { "value": true });
        Fraction3["default"] = Fraction3;
        Fraction3["Fraction"] = Fraction3;
        module["exports"] = Fraction3;
      } else {
        root["Fraction"] = Fraction3;
      }
    })(exports);
  }
});

// node_modules/mathjs/lib/esm/type/fraction/Fraction.js
var import_fraction, name4, dependencies5, createFractionClass;
var init_Fraction = __esm({
  "node_modules/mathjs/lib/esm/type/fraction/Fraction.js"() {
    import_fraction = __toESM(require_fraction(), 1);
    init_factory();
    name4 = "Fraction";
    dependencies5 = [];
    createFractionClass = /* @__PURE__ */ factory(name4, dependencies5, () => {
      import_fraction.default.prototype.type = "Fraction";
      import_fraction.default.prototype.isFraction = true;
      import_fraction.default.prototype.toJSON = function() {
        return {
          mathjs: "Fraction",
          n: this.s * this.n,
          d: this.d
        };
      };
      import_fraction.default.fromJSON = function(json) {
        return new import_fraction.default(json);
      };
      return import_fraction.default;
    }, {
      isClass: true
    });
  }
});

// node_modules/mathjs/lib/esm/type/matrix/Range.js
var name5, dependencies6, createRangeClass;
var init_Range = __esm({
  "node_modules/mathjs/lib/esm/type/matrix/Range.js"() {
    init_is();
    init_number();
    init_factory();
    name5 = "Range";
    dependencies6 = [];
    createRangeClass = /* @__PURE__ */ factory(name5, dependencies6, () => {
      function Range2(start, end, step) {
        if (!(this instanceof Range2)) {
          throw new SyntaxError("Constructor must be called with the new operator");
        }
        var hasStart = start !== null && start !== void 0;
        var hasEnd = end !== null && end !== void 0;
        var hasStep = step !== null && step !== void 0;
        if (hasStart) {
          if (isBigNumber(start)) {
            start = start.toNumber();
          } else if (typeof start !== "number") {
            throw new TypeError("Parameter start must be a number");
          }
        }
        if (hasEnd) {
          if (isBigNumber(end)) {
            end = end.toNumber();
          } else if (typeof end !== "number") {
            throw new TypeError("Parameter end must be a number");
          }
        }
        if (hasStep) {
          if (isBigNumber(step)) {
            step = step.toNumber();
          } else if (typeof step !== "number") {
            throw new TypeError("Parameter step must be a number");
          }
        }
        this.start = hasStart ? parseFloat(start) : 0;
        this.end = hasEnd ? parseFloat(end) : 0;
        this.step = hasStep ? parseFloat(step) : 1;
      }
      Range2.prototype.type = "Range";
      Range2.prototype.isRange = true;
      Range2.parse = function(str) {
        if (typeof str !== "string") {
          return null;
        }
        var args = str.split(":");
        var nums = args.map(function(arg2) {
          return parseFloat(arg2);
        });
        var invalid = nums.some(function(num) {
          return isNaN(num);
        });
        if (invalid) {
          return null;
        }
        switch (nums.length) {
          case 2:
            return new Range2(nums[0], nums[1]);
          case 3:
            return new Range2(nums[0], nums[2], nums[1]);
          default:
            return null;
        }
      };
      Range2.prototype.clone = function() {
        return new Range2(this.start, this.end, this.step);
      };
      Range2.prototype.size = function() {
        var len = 0;
        var start = this.start;
        var step = this.step;
        var end = this.end;
        var diff2 = end - start;
        if (sign(step) === sign(diff2)) {
          len = Math.ceil(diff2 / step);
        } else if (diff2 === 0) {
          len = 0;
        }
        if (isNaN(len)) {
          len = 0;
        }
        return [len];
      };
      Range2.prototype.min = function() {
        var size2 = this.size()[0];
        if (size2 > 0) {
          if (this.step > 0) {
            return this.start;
          } else {
            return this.start + (size2 - 1) * this.step;
          }
        } else {
          return void 0;
        }
      };
      Range2.prototype.max = function() {
        var size2 = this.size()[0];
        if (size2 > 0) {
          if (this.step > 0) {
            return this.start + (size2 - 1) * this.step;
          } else {
            return this.start;
          }
        } else {
          return void 0;
        }
      };
      Range2.prototype.forEach = function(callback) {
        var x = this.start;
        var step = this.step;
        var end = this.end;
        var i2 = 0;
        if (step > 0) {
          while (x < end) {
            callback(x, [i2], this);
            x += step;
            i2++;
          }
        } else if (step < 0) {
          while (x > end) {
            callback(x, [i2], this);
            x += step;
            i2++;
          }
        }
      };
      Range2.prototype.map = function(callback) {
        var array = [];
        this.forEach(function(value, index2, obj) {
          array[index2[0]] = callback(value, index2, obj);
        });
        return array;
      };
      Range2.prototype.toArray = function() {
        var array = [];
        this.forEach(function(value, index2) {
          array[index2[0]] = value;
        });
        return array;
      };
      Range2.prototype.valueOf = function() {
        return this.toArray();
      };
      Range2.prototype.format = function(options) {
        var str = format(this.start, options);
        if (this.step !== 1) {
          str += ":" + format(this.step, options);
        }
        str += ":" + format(this.end, options);
        return str;
      };
      Range2.prototype.toString = function() {
        return this.format();
      };
      Range2.prototype.toJSON = function() {
        return {
          mathjs: "Range",
          start: this.start,
          end: this.end,
          step: this.step
        };
      };
      Range2.fromJSON = function(json) {
        return new Range2(json.start, json.end, json.step);
      };
      return Range2;
    }, {
      isClass: true
    });
  }
});

// node_modules/mathjs/lib/esm/type/matrix/Matrix.js
var name6, dependencies7, createMatrixClass;
var init_Matrix = __esm({
  "node_modules/mathjs/lib/esm/type/matrix/Matrix.js"() {
    init_factory();
    name6 = "Matrix";
    dependencies7 = [];
    createMatrixClass = /* @__PURE__ */ factory(name6, dependencies7, () => {
      function Matrix2() {
        if (!(this instanceof Matrix2)) {
          throw new SyntaxError("Constructor must be called with the new operator");
        }
      }
      Matrix2.prototype.type = "Matrix";
      Matrix2.prototype.isMatrix = true;
      Matrix2.prototype.storage = function() {
        throw new Error("Cannot invoke storage on a Matrix interface");
      };
      Matrix2.prototype.datatype = function() {
        throw new Error("Cannot invoke datatype on a Matrix interface");
      };
      Matrix2.prototype.create = function(data, datatype) {
        throw new Error("Cannot invoke create on a Matrix interface");
      };
      Matrix2.prototype.subset = function(index2, replacement, defaultValue) {
        throw new Error("Cannot invoke subset on a Matrix interface");
      };
      Matrix2.prototype.get = function(index2) {
        throw new Error("Cannot invoke get on a Matrix interface");
      };
      Matrix2.prototype.set = function(index2, value, defaultValue) {
        throw new Error("Cannot invoke set on a Matrix interface");
      };
      Matrix2.prototype.resize = function(size2, defaultValue) {
        throw new Error("Cannot invoke resize on a Matrix interface");
      };
      Matrix2.prototype.reshape = function(size2, defaultValue) {
        throw new Error("Cannot invoke reshape on a Matrix interface");
      };
      Matrix2.prototype.clone = function() {
        throw new Error("Cannot invoke clone on a Matrix interface");
      };
      Matrix2.prototype.size = function() {
        throw new Error("Cannot invoke size on a Matrix interface");
      };
      Matrix2.prototype.map = function(callback, skipZeros) {
        throw new Error("Cannot invoke map on a Matrix interface");
      };
      Matrix2.prototype.forEach = function(callback) {
        throw new Error("Cannot invoke forEach on a Matrix interface");
      };
      Matrix2.prototype[Symbol.iterator] = function() {
        throw new Error("Cannot iterate a Matrix interface");
      };
      Matrix2.prototype.toArray = function() {
        throw new Error("Cannot invoke toArray on a Matrix interface");
      };
      Matrix2.prototype.valueOf = function() {
        throw new Error("Cannot invoke valueOf on a Matrix interface");
      };
      Matrix2.prototype.format = function(options) {
        throw new Error("Cannot invoke format on a Matrix interface");
      };
      Matrix2.prototype.toString = function() {
        throw new Error("Cannot invoke toString on a Matrix interface");
      };
      return Matrix2;
    }, {
      isClass: true
    });
  }
});

// node_modules/mathjs/lib/esm/type/matrix/DenseMatrix.js
var name7, dependencies8, createDenseMatrixClass;
var init_DenseMatrix = __esm({
  "node_modules/mathjs/lib/esm/type/matrix/DenseMatrix.js"() {
    init_is();
    init_array();
    init_string();
    init_number();
    init_object();
    init_DimensionError();
    init_factory();
    name7 = "DenseMatrix";
    dependencies8 = ["Matrix"];
    createDenseMatrixClass = /* @__PURE__ */ factory(name7, dependencies8, (_ref) => {
      var {
        Matrix: Matrix2
      } = _ref;
      function DenseMatrix2(data, datatype) {
        if (!(this instanceof DenseMatrix2)) {
          throw new SyntaxError("Constructor must be called with the new operator");
        }
        if (datatype && !isString2(datatype)) {
          throw new Error("Invalid datatype: " + datatype);
        }
        if (isMatrix(data)) {
          if (data.type === "DenseMatrix") {
            this._data = clone(data._data);
            this._size = clone(data._size);
            this._datatype = datatype || data._datatype;
          } else {
            this._data = data.toArray();
            this._size = data.size();
            this._datatype = datatype || data._datatype;
          }
        } else if (data && isArray(data.data) && isArray(data.size)) {
          this._data = data.data;
          this._size = data.size;
          validate(this._data, this._size);
          this._datatype = datatype || data.datatype;
        } else if (isArray(data)) {
          this._data = preprocess(data);
          this._size = arraySize(this._data);
          validate(this._data, this._size);
          this._datatype = datatype;
        } else if (data) {
          throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
        } else {
          this._data = [];
          this._size = [0];
          this._datatype = datatype;
        }
      }
      DenseMatrix2.prototype = new Matrix2();
      DenseMatrix2.prototype.createDenseMatrix = function(data, datatype) {
        return new DenseMatrix2(data, datatype);
      };
      DenseMatrix2.prototype.type = "DenseMatrix";
      DenseMatrix2.prototype.isDenseMatrix = true;
      DenseMatrix2.prototype.getDataType = function() {
        return getArrayDataType(this._data, typeOf);
      };
      DenseMatrix2.prototype.storage = function() {
        return "dense";
      };
      DenseMatrix2.prototype.datatype = function() {
        return this._datatype;
      };
      DenseMatrix2.prototype.create = function(data, datatype) {
        return new DenseMatrix2(data, datatype);
      };
      DenseMatrix2.prototype.subset = function(index2, replacement, defaultValue) {
        switch (arguments.length) {
          case 1:
            return _get(this, index2);
          case 2:
          case 3:
            return _set(this, index2, replacement, defaultValue);
          default:
            throw new SyntaxError("Wrong number of arguments");
        }
      };
      DenseMatrix2.prototype.get = function(index2) {
        if (!isArray(index2)) {
          throw new TypeError("Array expected");
        }
        if (index2.length !== this._size.length) {
          throw new DimensionError(index2.length, this._size.length);
        }
        for (var x = 0; x < index2.length; x++) {
          validateIndex(index2[x], this._size[x]);
        }
        var data = this._data;
        for (var i2 = 0, ii = index2.length; i2 < ii; i2++) {
          var indexI = index2[i2];
          validateIndex(indexI, data.length);
          data = data[indexI];
        }
        return data;
      };
      DenseMatrix2.prototype.set = function(index2, value, defaultValue) {
        if (!isArray(index2)) {
          throw new TypeError("Array expected");
        }
        if (index2.length < this._size.length) {
          throw new DimensionError(index2.length, this._size.length, "<");
        }
        var i2, ii, indexI;
        var size2 = index2.map(function(i3) {
          return i3 + 1;
        });
        _fit(this, size2, defaultValue);
        var data = this._data;
        for (i2 = 0, ii = index2.length - 1; i2 < ii; i2++) {
          indexI = index2[i2];
          validateIndex(indexI, data.length);
          data = data[indexI];
        }
        indexI = index2[index2.length - 1];
        validateIndex(indexI, data.length);
        data[indexI] = value;
        return this;
      };
      function _get(matrix2, index2) {
        if (!isIndex(index2)) {
          throw new TypeError("Invalid index");
        }
        var isScalar = index2.isScalar();
        if (isScalar) {
          return matrix2.get(index2.min());
        } else {
          var size2 = index2.size();
          if (size2.length !== matrix2._size.length) {
            throw new DimensionError(size2.length, matrix2._size.length);
          }
          var min2 = index2.min();
          var max2 = index2.max();
          for (var i2 = 0, ii = matrix2._size.length; i2 < ii; i2++) {
            validateIndex(min2[i2], matrix2._size[i2]);
            validateIndex(max2[i2], matrix2._size[i2]);
          }
          return new DenseMatrix2(_getSubmatrix(matrix2._data, index2, size2.length, 0), matrix2._datatype);
        }
      }
      function _getSubmatrix(data, index2, dims, dim) {
        var last = dim === dims - 1;
        var range2 = index2.dimension(dim);
        if (last) {
          return range2.map(function(i2) {
            validateIndex(i2, data.length);
            return data[i2];
          }).valueOf();
        } else {
          return range2.map(function(i2) {
            validateIndex(i2, data.length);
            var child2 = data[i2];
            return _getSubmatrix(child2, index2, dims, dim + 1);
          }).valueOf();
        }
      }
      function _set(matrix2, index2, submatrix, defaultValue) {
        if (!index2 || index2.isIndex !== true) {
          throw new TypeError("Invalid index");
        }
        var iSize = index2.size();
        var isScalar = index2.isScalar();
        var sSize;
        if (isMatrix(submatrix)) {
          sSize = submatrix.size();
          submatrix = submatrix.valueOf();
        } else {
          sSize = arraySize(submatrix);
        }
        if (isScalar) {
          if (sSize.length !== 0) {
            throw new TypeError("Scalar expected");
          }
          matrix2.set(index2.min(), submatrix, defaultValue);
        } else {
          if (iSize.length < matrix2._size.length) {
            throw new DimensionError(iSize.length, matrix2._size.length, "<");
          }
          if (sSize.length < iSize.length) {
            var i2 = 0;
            var outer = 0;
            while (iSize[i2] === 1 && sSize[i2] === 1) {
              i2++;
            }
            while (iSize[i2] === 1) {
              outer++;
              i2++;
            }
            submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
          }
          if (!deepStrictEqual(iSize, sSize)) {
            throw new DimensionError(iSize, sSize, ">");
          }
          var size2 = index2.max().map(function(i3) {
            return i3 + 1;
          });
          _fit(matrix2, size2, defaultValue);
          var dims = iSize.length;
          var dim = 0;
          _setSubmatrix(matrix2._data, index2, submatrix, dims, dim);
        }
        return matrix2;
      }
      function _setSubmatrix(data, index2, submatrix, dims, dim) {
        var last = dim === dims - 1;
        var range2 = index2.dimension(dim);
        if (last) {
          range2.forEach(function(dataIndex, subIndex) {
            validateIndex(dataIndex);
            data[dataIndex] = submatrix[subIndex[0]];
          });
        } else {
          range2.forEach(function(dataIndex, subIndex) {
            validateIndex(dataIndex);
            _setSubmatrix(data[dataIndex], index2, submatrix[subIndex[0]], dims, dim + 1);
          });
        }
      }
      DenseMatrix2.prototype.resize = function(size2, defaultValue, copy) {
        if (!isCollection(size2)) {
          throw new TypeError("Array or Matrix expected");
        }
        var sizeArray = size2.valueOf().map((value) => {
          return Array.isArray(value) && value.length === 1 ? value[0] : value;
        });
        var m = copy ? this.clone() : this;
        return _resize2(m, sizeArray, defaultValue);
      };
      function _resize2(matrix2, size2, defaultValue) {
        if (size2.length === 0) {
          var v = matrix2._data;
          while (isArray(v)) {
            v = v[0];
          }
          return v;
        }
        matrix2._size = size2.slice(0);
        matrix2._data = resize(matrix2._data, matrix2._size, defaultValue);
        return matrix2;
      }
      DenseMatrix2.prototype.reshape = function(size2, copy) {
        var m = copy ? this.clone() : this;
        m._data = reshape(m._data, size2);
        var currentLength = m._size.reduce((length, size3) => length * size3);
        m._size = processSizesWildcard(size2, currentLength);
        return m;
      };
      function _fit(matrix2, size2, defaultValue) {
        var newSize = matrix2._size.slice(0);
        var changed = false;
        while (newSize.length < size2.length) {
          newSize.push(0);
          changed = true;
        }
        for (var i2 = 0, ii = size2.length; i2 < ii; i2++) {
          if (size2[i2] > newSize[i2]) {
            newSize[i2] = size2[i2];
            changed = true;
          }
        }
        if (changed) {
          _resize2(matrix2, newSize, defaultValue);
        }
      }
      DenseMatrix2.prototype.clone = function() {
        var m = new DenseMatrix2({
          data: clone(this._data),
          size: clone(this._size),
          datatype: this._datatype
        });
        return m;
      };
      DenseMatrix2.prototype.size = function() {
        return this._size.slice(0);
      };
      DenseMatrix2.prototype.map = function(callback) {
        var me = this;
        var recurse = function recurse2(value, index2) {
          if (isArray(value)) {
            return value.map(function(child2, i2) {
              return recurse2(child2, index2.concat(i2));
            });
          } else {
            return callback(value, index2, me);
          }
        };
        var data = recurse(this._data, []);
        var datatype = this._datatype !== void 0 ? getArrayDataType(data, typeOf) : void 0;
        return new DenseMatrix2(data, datatype);
      };
      DenseMatrix2.prototype.forEach = function(callback) {
        var me = this;
        var recurse = function recurse2(value, index2) {
          if (isArray(value)) {
            value.forEach(function(child2, i2) {
              recurse2(child2, index2.concat(i2));
            });
          } else {
            callback(value, index2, me);
          }
        };
        recurse(this._data, []);
      };
      DenseMatrix2.prototype[Symbol.iterator] = function* () {
        var recurse = function* recurse2(value, index2) {
          if (isArray(value)) {
            for (var i2 = 0; i2 < value.length; i2++) {
              yield* recurse2(value[i2], index2.concat(i2));
            }
          } else {
            yield {
              value,
              index: index2
            };
          }
        };
        yield* recurse(this._data, []);
      };
      DenseMatrix2.prototype.rows = function() {
        var result = [];
        var s = this.size();
        if (s.length !== 2) {
          throw new TypeError("Rows can only be returned for a 2D matrix.");
        }
        var data = this._data;
        for (var row2 of data) {
          result.push(new DenseMatrix2([row2], this._datatype));
        }
        return result;
      };
      DenseMatrix2.prototype.columns = function() {
        var _this = this;
        var result = [];
        var s = this.size();
        if (s.length !== 2) {
          throw new TypeError("Rows can only be returned for a 2D matrix.");
        }
        var data = this._data;
        var _loop = function _loop2(i3) {
          var col = data.map((row2) => [row2[i3]]);
          result.push(new DenseMatrix2(col, _this._datatype));
        };
        for (var i2 = 0; i2 < s[1]; i2++) {
          _loop(i2);
        }
        return result;
      };
      DenseMatrix2.prototype.toArray = function() {
        return clone(this._data);
      };
      DenseMatrix2.prototype.valueOf = function() {
        return this._data;
      };
      DenseMatrix2.prototype.format = function(options) {
        return format3(this._data, options);
      };
      DenseMatrix2.prototype.toString = function() {
        return format3(this._data);
      };
      DenseMatrix2.prototype.toJSON = function() {
        return {
          mathjs: "DenseMatrix",
          data: this._data,
          size: this._size,
          datatype: this._datatype
        };
      };
      DenseMatrix2.prototype.diagonal = function(k) {
        if (k) {
          if (isBigNumber(k)) {
            k = k.toNumber();
          }
          if (!isNumber2(k) || !isInteger(k)) {
            throw new TypeError("The parameter k must be an integer number");
          }
        } else {
          k = 0;
        }
        var kSuper = k > 0 ? k : 0;
        var kSub = k < 0 ? -k : 0;
        var rows = this._size[0];
        var columns = this._size[1];
        var n = Math.min(rows - kSub, columns - kSuper);
        var data = [];
        for (var i2 = 0; i2 < n; i2++) {
          data[i2] = this._data[i2 + kSub][i2 + kSuper];
        }
        return new DenseMatrix2({
          data,
          size: [n],
          datatype: this._datatype
        });
      };
      DenseMatrix2.diagonal = function(size2, value, k, defaultValue) {
        if (!isArray(size2)) {
          throw new TypeError("Array expected, size parameter");
        }
        if (size2.length !== 2) {
          throw new Error("Only two dimensions matrix are supported");
        }
        size2 = size2.map(function(s) {
          if (isBigNumber(s)) {
            s = s.toNumber();
          }
          if (!isNumber2(s) || !isInteger(s) || s < 1) {
            throw new Error("Size values must be positive integers");
          }
          return s;
        });
        if (k) {
          if (isBigNumber(k)) {
            k = k.toNumber();
          }
          if (!isNumber2(k) || !isInteger(k)) {
            throw new TypeError("The parameter k must be an integer number");
          }
        } else {
          k = 0;
        }
        var kSuper = k > 0 ? k : 0;
        var kSub = k < 0 ? -k : 0;
        var rows = size2[0];
        var columns = size2[1];
        var n = Math.min(rows - kSub, columns - kSuper);
        var _value;
        if (isArray(value)) {
          if (value.length !== n) {
            throw new Error("Invalid value array length");
          }
          _value = function _value2(i2) {
            return value[i2];
          };
        } else if (isMatrix(value)) {
          var ms = value.size();
          if (ms.length !== 1 || ms[0] !== n) {
            throw new Error("Invalid matrix length");
          }
          _value = function _value2(i2) {
            return value.get([i2]);
          };
        } else {
          _value = function _value2() {
            return value;
          };
        }
        if (!defaultValue) {
          defaultValue = isBigNumber(_value(0)) ? _value(0).mul(0) : 0;
        }
        var data = [];
        if (size2.length > 0) {
          data = resize(data, size2, defaultValue);
          for (var d = 0; d < n; d++) {
            data[d + kSub][d + kSuper] = _value(d);
          }
        }
        return new DenseMatrix2({
          data,
          size: [rows, columns]
        });
      };
      DenseMatrix2.fromJSON = function(json) {
        return new DenseMatrix2(json);
      };
      DenseMatrix2.prototype.swapRows = function(i2, j) {
        if (!isNumber2(i2) || !isInteger(i2) || !isNumber2(j) || !isInteger(j)) {
          throw new Error("Row index must be positive integers");
        }
        if (this._size.length !== 2) {
          throw new Error("Only two dimensional matrix is supported");
        }
        validateIndex(i2, this._size[0]);
        validateIndex(j, this._size[0]);
        DenseMatrix2._swapRows(i2, j, this._data);
        return this;
      };
      DenseMatrix2._swapRows = function(i2, j, data) {
        var vi = data[i2];
        data[i2] = data[j];
        data[j] = vi;
      };
      function preprocess(data) {
        for (var i2 = 0, ii = data.length; i2 < ii; i2++) {
          var elem = data[i2];
          if (isArray(elem)) {
            data[i2] = preprocess(elem);
          } else if (elem && elem.isMatrix === true) {
            data[i2] = preprocess(elem.valueOf());
          }
        }
        return data;
      }
      return DenseMatrix2;
    }, {
      isClass: true
    });
  }
});

// node_modules/mathjs/lib/esm/function/utils/clone.js
var name8, dependencies9, createClone;
var init_clone = __esm({
  "node_modules/mathjs/lib/esm/function/utils/clone.js"() {
    init_object();
    init_factory();
    name8 = "clone";
    dependencies9 = ["typed"];
    createClone = /* @__PURE__ */ factory(name8, dependencies9, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2(name8, {
        any: clone
      });
    });
  }
});

// node_modules/mathjs/lib/esm/utils/switch.js
function _switch(mat) {
  var I = mat.length;
  var J = mat[0].length;
  var i2, j;
  var ret = [];
  for (j = 0; j < J; j++) {
    var tmp = [];
    for (i2 = 0; i2 < I; i2++) {
      tmp.push(mat[i2][j]);
    }
    ret.push(tmp);
  }
  return ret;
}
var init_switch = __esm({
  "node_modules/mathjs/lib/esm/utils/switch.js"() {
  }
});

// node_modules/mathjs/lib/esm/utils/collection.js
function containsCollections(array) {
  for (var i2 = 0; i2 < array.length; i2++) {
    if (isCollection(array[i2])) {
      return true;
    }
  }
  return false;
}
function deepForEach(array, callback) {
  if (isMatrix(array)) {
    array = array.valueOf();
  }
  for (var i2 = 0, ii = array.length; i2 < ii; i2++) {
    var value = array[i2];
    if (Array.isArray(value)) {
      deepForEach(value, callback);
    } else {
      callback(value);
    }
  }
}
function deepMap(array, callback, skipZeros) {
  if (array && typeof array.map === "function") {
    return array.map(function(x) {
      return deepMap(x, callback, skipZeros);
    });
  } else {
    return callback(array);
  }
}
function reduce(mat, dim, callback) {
  var size2 = Array.isArray(mat) ? arraySize(mat) : mat.size();
  if (dim < 0 || dim >= size2.length) {
    throw new IndexError(dim, size2.length);
  }
  if (isMatrix(mat)) {
    return mat.create(_reduce(mat.valueOf(), dim, callback));
  } else {
    return _reduce(mat, dim, callback);
  }
}
function _reduce(mat, dim, callback) {
  var i2, ret, val, tran;
  if (dim <= 0) {
    if (!Array.isArray(mat[0])) {
      val = mat[0];
      for (i2 = 1; i2 < mat.length; i2++) {
        val = callback(val, mat[i2]);
      }
      return val;
    } else {
      tran = _switch(mat);
      ret = [];
      for (i2 = 0; i2 < tran.length; i2++) {
        ret[i2] = _reduce(tran[i2], dim - 1, callback);
      }
      return ret;
    }
  } else {
    ret = [];
    for (i2 = 0; i2 < mat.length; i2++) {
      ret[i2] = _reduce(mat[i2], dim - 1, callback);
    }
    return ret;
  }
}
function scatter(a, j, w, x, u, mark, cindex, f, inverse, update, value) {
  var avalues = a._values;
  var aindex = a._index;
  var aptr = a._ptr;
  var k, k0, k1, i2;
  if (x) {
    for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
      i2 = aindex[k];
      if (w[i2] !== mark) {
        w[i2] = mark;
        cindex.push(i2);
        if (update) {
          x[i2] = inverse ? f(avalues[k], value) : f(value, avalues[k]);
          u[i2] = mark;
        } else {
          x[i2] = avalues[k];
        }
      } else {
        x[i2] = inverse ? f(avalues[k], x[i2]) : f(x[i2], avalues[k]);
        u[i2] = mark;
      }
    }
  } else {
    for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
      i2 = aindex[k];
      if (w[i2] !== mark) {
        w[i2] = mark;
        cindex.push(i2);
      } else {
        u[i2] = mark;
      }
    }
  }
}
var init_collection = __esm({
  "node_modules/mathjs/lib/esm/utils/collection.js"() {
    init_is();
    init_IndexError();
    init_array();
    init_switch();
  }
});

// node_modules/mathjs/lib/esm/function/utils/isInteger.js
var name9, dependencies10, createIsInteger;
var init_isInteger = __esm({
  "node_modules/mathjs/lib/esm/function/utils/isInteger.js"() {
    init_collection();
    init_number();
    init_factory();
    name9 = "isInteger";
    dependencies10 = ["typed"];
    createIsInteger = /* @__PURE__ */ factory(name9, dependencies10, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2(name9, {
        number: isInteger,
        BigNumber: function BigNumber2(x) {
          return x.isInt();
        },
        Fraction: function Fraction3(x) {
          return x.d === 1 && isFinite(x.n);
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/plain/number/arithmetic.js
function absNumber(a) {
  return Math.abs(a);
}
function addNumber(a, b) {
  return a + b;
}
function subtractNumber(a, b) {
  return a - b;
}
function multiplyNumber(a, b) {
  return a * b;
}
function divideNumber(a, b) {
  return a / b;
}
function unaryMinusNumber(x) {
  return -x;
}
function unaryPlusNumber(x) {
  return x;
}
function cbrtNumber(x) {
  return cbrt(x);
}
function cubeNumber(x) {
  return x * x * x;
}
function expNumber(x) {
  return Math.exp(x);
}
function expm1Number(x) {
  return expm1(x);
}
function gcdNumber(a, b) {
  if (!isInteger(a) || !isInteger(b)) {
    throw new Error("Parameters in function gcd must be integer numbers");
  }
  var r;
  while (b !== 0) {
    r = a % b;
    a = b;
    b = r;
  }
  return a < 0 ? -a : a;
}
function lcmNumber(a, b) {
  if (!isInteger(a) || !isInteger(b)) {
    throw new Error("Parameters in function lcm must be integer numbers");
  }
  if (a === 0 || b === 0) {
    return 0;
  }
  var t;
  var prod2 = a * b;
  while (b !== 0) {
    t = b;
    b = a % t;
    a = t;
  }
  return Math.abs(prod2 / a);
}
function logNumber(x, y) {
  if (y) {
    return Math.log(x) / Math.log(y);
  }
  return Math.log(x);
}
function log10Number(x) {
  return log10(x);
}
function log2Number(x) {
  return log2(x);
}
function log1pNumber(x) {
  return log1p(x);
}
function modNumber(x, y) {
  if (y > 0) {
    return x - y * Math.floor(x / y);
  } else if (y === 0) {
    return x;
  } else {
    throw new Error("Cannot calculate mod for a negative divisor");
  }
}
function nthRootNumber(a) {
  var root = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
  var inv2 = root < 0;
  if (inv2) {
    root = -root;
  }
  if (root === 0) {
    throw new Error("Root must be non-zero");
  }
  if (a < 0 && Math.abs(root) % 2 !== 1) {
    throw new Error("Root must be odd when a is negative.");
  }
  if (a === 0) {
    return inv2 ? Infinity : 0;
  }
  if (!isFinite(a)) {
    return inv2 ? 0 : a;
  }
  var x = Math.pow(Math.abs(a), 1 / root);
  x = a < 0 ? -x : x;
  return inv2 ? 1 / x : x;
}
function signNumber(x) {
  return sign(x);
}
function sqrtNumber(x) {
  return Math.sqrt(x);
}
function squareNumber(x) {
  return x * x;
}
function xgcdNumber(a, b) {
  var t;
  var q;
  var r;
  var x = 0;
  var lastx = 1;
  var y = 1;
  var lasty = 0;
  if (!isInteger(a) || !isInteger(b)) {
    throw new Error("Parameters in function xgcd must be integer numbers");
  }
  while (b) {
    q = Math.floor(a / b);
    r = a - q * b;
    t = x;
    x = lastx - q * x;
    lastx = t;
    t = y;
    y = lasty - q * y;
    lasty = t;
    a = b;
    b = r;
  }
  var res;
  if (a < 0) {
    res = [-a, -lastx, -lasty];
  } else {
    res = [a, a ? lastx : 0, lasty];
  }
  return res;
}
function powNumber(x, y) {
  if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {
    return 0;
  }
  return Math.pow(x, y);
}
function roundNumber(value) {
  var decimals = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  if (!isInteger(decimals) || decimals < 0 || decimals > 15) {
    throw new Error("Number of decimals in function round must be an integer from 0 to 15 inclusive");
  }
  return parseFloat(toFixed(value, decimals));
}
function normNumber(x) {
  return Math.abs(x);
}
var n1, n2;
var init_arithmetic = __esm({
  "node_modules/mathjs/lib/esm/plain/number/arithmetic.js"() {
    init_number();
    n1 = "number";
    n2 = "number, number";
    absNumber.signature = n1;
    addNumber.signature = n2;
    subtractNumber.signature = n2;
    multiplyNumber.signature = n2;
    divideNumber.signature = n2;
    unaryMinusNumber.signature = n1;
    unaryPlusNumber.signature = n1;
    cbrtNumber.signature = n1;
    cubeNumber.signature = n1;
    expNumber.signature = n1;
    expm1Number.signature = n1;
    gcdNumber.signature = n2;
    lcmNumber.signature = n2;
    log10Number.signature = n1;
    log2Number.signature = n1;
    log1pNumber.signature = n1;
    modNumber.signature = n2;
    signNumber.signature = n1;
    sqrtNumber.signature = n1;
    squareNumber.signature = n1;
    xgcdNumber.signature = n2;
    powNumber.signature = n2;
    normNumber.signature = n1;
  }
});

// node_modules/mathjs/lib/esm/plain/number/bitwise.js
function bitAndNumber(x, y) {
  if (!isInteger(x) || !isInteger(y)) {
    throw new Error("Integers expected in function bitAnd");
  }
  return x & y;
}
function bitNotNumber(x) {
  if (!isInteger(x)) {
    throw new Error("Integer expected in function bitNot");
  }
  return ~x;
}
function bitOrNumber(x, y) {
  if (!isInteger(x) || !isInteger(y)) {
    throw new Error("Integers expected in function bitOr");
  }
  return x | y;
}
function bitXorNumber(x, y) {
  if (!isInteger(x) || !isInteger(y)) {
    throw new Error("Integers expected in function bitXor");
  }
  return x ^ y;
}
function leftShiftNumber(x, y) {
  if (!isInteger(x) || !isInteger(y)) {
    throw new Error("Integers expected in function leftShift");
  }
  return x << y;
}
function rightArithShiftNumber(x, y) {
  if (!isInteger(x) || !isInteger(y)) {
    throw new Error("Integers expected in function rightArithShift");
  }
  return x >> y;
}
function rightLogShiftNumber(x, y) {
  if (!isInteger(x) || !isInteger(y)) {
    throw new Error("Integers expected in function rightLogShift");
  }
  return x >>> y;
}
var n12, n22;
var init_bitwise = __esm({
  "node_modules/mathjs/lib/esm/plain/number/bitwise.js"() {
    init_number();
    n12 = "number";
    n22 = "number, number";
    bitAndNumber.signature = n22;
    bitNotNumber.signature = n12;
    bitOrNumber.signature = n22;
    bitXorNumber.signature = n22;
    leftShiftNumber.signature = n22;
    rightArithShiftNumber.signature = n22;
    rightLogShiftNumber.signature = n22;
  }
});

// node_modules/mathjs/lib/esm/utils/product.js
function product2(i2, n) {
  if (n < i2) {
    return 1;
  }
  if (n === i2) {
    return n;
  }
  var half = n + i2 >> 1;
  return product2(i2, half) * product2(half + 1, n);
}
var init_product = __esm({
  "node_modules/mathjs/lib/esm/utils/product.js"() {
  }
});

// node_modules/mathjs/lib/esm/plain/number/combinations.js
function combinationsNumber(n, k) {
  if (!isInteger(n) || n < 0) {
    throw new TypeError("Positive integer value expected in function combinations");
  }
  if (!isInteger(k) || k < 0) {
    throw new TypeError("Positive integer value expected in function combinations");
  }
  if (k > n) {
    throw new TypeError("k must be less than or equal to n");
  }
  var nMinusk = n - k;
  var answer = 1;
  var firstnumerator = k < nMinusk ? nMinusk + 1 : k + 1;
  var nextdivisor = 2;
  var lastdivisor = k < nMinusk ? k : nMinusk;
  for (var nextnumerator = firstnumerator; nextnumerator <= n; ++nextnumerator) {
    answer *= nextnumerator;
    while (nextdivisor <= lastdivisor && answer % nextdivisor === 0) {
      answer /= nextdivisor;
      ++nextdivisor;
    }
  }
  if (nextdivisor <= lastdivisor) {
    answer /= product2(nextdivisor, lastdivisor);
  }
  return answer;
}
var init_combinations = __esm({
  "node_modules/mathjs/lib/esm/plain/number/combinations.js"() {
    init_number();
    init_product();
    combinationsNumber.signature = "number, number";
  }
});

// node_modules/mathjs/lib/esm/plain/number/constants.js
var pi, tau, e, phi;
var init_constants = __esm({
  "node_modules/mathjs/lib/esm/plain/number/constants.js"() {
    pi = Math.PI;
    tau = 2 * Math.PI;
    e = Math.E;
    phi = 1.618033988749895;
  }
});

// node_modules/mathjs/lib/esm/plain/number/logical.js
function notNumber(x) {
  return !x;
}
function orNumber(x, y) {
  return !!(x || y);
}
function xorNumber(x, y) {
  return !!x !== !!y;
}
function andNumber(x, y) {
  return !!(x && y);
}
var n13, n23;
var init_logical = __esm({
  "node_modules/mathjs/lib/esm/plain/number/logical.js"() {
    n13 = "number";
    n23 = "number, number";
    notNumber.signature = n13;
    orNumber.signature = n23;
    xorNumber.signature = n23;
    andNumber.signature = n23;
  }
});

// node_modules/mathjs/lib/esm/plain/number/relational.js
var init_relational = __esm({
  "node_modules/mathjs/lib/esm/plain/number/relational.js"() {
  }
});

// node_modules/mathjs/lib/esm/plain/number/probability.js
function gammaNumber(n) {
  var x;
  if (isInteger(n)) {
    if (n <= 0) {
      return isFinite(n) ? Infinity : NaN;
    }
    if (n > 171) {
      return Infinity;
    }
    return product2(1, n - 1);
  }
  if (n < 0.5) {
    return Math.PI / (Math.sin(Math.PI * n) * gammaNumber(1 - n));
  }
  if (n >= 171.35) {
    return Infinity;
  }
  if (n > 85) {
    var twoN = n * n;
    var threeN = twoN * n;
    var fourN = threeN * n;
    var fiveN = fourN * n;
    return Math.sqrt(2 * Math.PI / n) * Math.pow(n / Math.E, n) * (1 + 1 / (12 * n) + 1 / (288 * twoN) - 139 / (51840 * threeN) - 571 / (2488320 * fourN) + 163879 / (209018880 * fiveN) + 5246819 / (75246796800 * fiveN * n));
  }
  --n;
  x = gammaP[0];
  for (var i2 = 1; i2 < gammaP.length; ++i2) {
    x += gammaP[i2] / (n + i2);
  }
  var t = n + gammaG + 0.5;
  return Math.sqrt(2 * Math.PI) * Math.pow(t, n + 0.5) * Math.exp(-t) * x;
}
function lgammaNumber(n) {
  if (n < 0)
    return NaN;
  if (n === 0)
    return Infinity;
  if (!isFinite(n))
    return n;
  if (n < 0.5) {
    return Math.log(Math.PI / Math.sin(Math.PI * n)) - lgammaNumber(1 - n);
  }
  n = n - 1;
  var base = n + lgammaG + 0.5;
  var sum2 = lgammaSeries[0];
  for (var i2 = lgammaN - 1; i2 >= 1; i2--) {
    sum2 += lgammaSeries[i2] / (n + i2);
  }
  return lnSqrt2PI + (n + 0.5) * Math.log(base) - base + Math.log(sum2);
}
var gammaG, gammaP, lnSqrt2PI, lgammaG, lgammaN, lgammaSeries;
var init_probability = __esm({
  "node_modules/mathjs/lib/esm/plain/number/probability.js"() {
    init_number();
    init_product();
    gammaNumber.signature = "number";
    gammaG = 4.7421875;
    gammaP = [0.9999999999999971, 57.15623566586292, -59.59796035547549, 14.136097974741746, -0.4919138160976202, 3399464998481189e-20, 4652362892704858e-20, -9837447530487956e-20, 1580887032249125e-19, -21026444172410488e-20, 21743961811521265e-20, -1643181065367639e-19, 8441822398385275e-20, -26190838401581408e-21, 36899182659531625e-22];
    lnSqrt2PI = 0.9189385332046728;
    lgammaG = 5;
    lgammaN = 7;
    lgammaSeries = [1.000000000190015, 76.18009172947146, -86.50532032941678, 24.01409824083091, -1.231739572450155, 0.001208650973866179, -5395239384953e-18];
    lgammaNumber.signature = "number";
  }
});

// node_modules/mathjs/lib/esm/plain/number/trigonometry.js
function acosNumber(x) {
  return Math.acos(x);
}
function acoshNumber(x) {
  return acosh(x);
}
function acotNumber(x) {
  return Math.atan(1 / x);
}
function acothNumber(x) {
  return isFinite(x) ? (Math.log((x + 1) / x) + Math.log(x / (x - 1))) / 2 : 0;
}
function acscNumber(x) {
  return Math.asin(1 / x);
}
function acschNumber(x) {
  var xInv = 1 / x;
  return Math.log(xInv + Math.sqrt(xInv * xInv + 1));
}
function asecNumber(x) {
  return Math.acos(1 / x);
}
function asechNumber(x) {
  var xInv = 1 / x;
  var ret = Math.sqrt(xInv * xInv - 1);
  return Math.log(ret + xInv);
}
function asinNumber(x) {
  return Math.asin(x);
}
function asinhNumber(x) {
  return asinh(x);
}
function atanNumber(x) {
  return Math.atan(x);
}
function atan2Number(y, x) {
  return Math.atan2(y, x);
}
function atanhNumber(x) {
  return atanh(x);
}
function cosNumber(x) {
  return Math.cos(x);
}
function coshNumber(x) {
  return cosh(x);
}
function cotNumber(x) {
  return 1 / Math.tan(x);
}
function cothNumber(x) {
  var e3 = Math.exp(2 * x);
  return (e3 + 1) / (e3 - 1);
}
function cscNumber(x) {
  return 1 / Math.sin(x);
}
function cschNumber(x) {
  if (x === 0) {
    return Number.POSITIVE_INFINITY;
  } else {
    return Math.abs(2 / (Math.exp(x) - Math.exp(-x))) * sign(x);
  }
}
function secNumber(x) {
  return 1 / Math.cos(x);
}
function sechNumber(x) {
  return 2 / (Math.exp(x) + Math.exp(-x));
}
function sinNumber(x) {
  return Math.sin(x);
}
function sinhNumber(x) {
  return sinh(x);
}
function tanNumber(x) {
  return Math.tan(x);
}
function tanhNumber(x) {
  return tanh(x);
}
var n14, n24;
var init_trigonometry = __esm({
  "node_modules/mathjs/lib/esm/plain/number/trigonometry.js"() {
    init_number();
    n14 = "number";
    n24 = "number, number";
    acosNumber.signature = n14;
    acoshNumber.signature = n14;
    acotNumber.signature = n14;
    acothNumber.signature = n14;
    acscNumber.signature = n14;
    acschNumber.signature = n14;
    asecNumber.signature = n14;
    asechNumber.signature = n14;
    asinNumber.signature = n14;
    asinhNumber.signature = n14;
    atanNumber.signature = n14;
    atan2Number.signature = n24;
    atanhNumber.signature = n14;
    cosNumber.signature = n14;
    coshNumber.signature = n14;
    cotNumber.signature = n14;
    cothNumber.signature = n14;
    cscNumber.signature = n14;
    cschNumber.signature = n14;
    secNumber.signature = n14;
    sechNumber.signature = n14;
    sinNumber.signature = n14;
    sinhNumber.signature = n14;
    tanNumber.signature = n14;
    tanhNumber.signature = n14;
  }
});

// node_modules/mathjs/lib/esm/plain/number/utils.js
function isIntegerNumber(x) {
  return isInteger(x);
}
function isNegativeNumber(x) {
  return x < 0;
}
function isPositiveNumber(x) {
  return x > 0;
}
function isZeroNumber(x) {
  return x === 0;
}
function isNaNNumber(x) {
  return Number.isNaN(x);
}
var n15;
var init_utils2 = __esm({
  "node_modules/mathjs/lib/esm/plain/number/utils.js"() {
    init_number();
    n15 = "number";
    isIntegerNumber.signature = n15;
    isNegativeNumber.signature = n15;
    isPositiveNumber.signature = n15;
    isZeroNumber.signature = n15;
    isNaNNumber.signature = n15;
  }
});

// node_modules/mathjs/lib/esm/plain/number/index.js
var init_number2 = __esm({
  "node_modules/mathjs/lib/esm/plain/number/index.js"() {
    init_arithmetic();
    init_bitwise();
    init_combinations();
    init_constants();
    init_logical();
    init_relational();
    init_probability();
    init_trigonometry();
    init_utils2();
  }
});

// node_modules/mathjs/lib/esm/function/utils/isNegative.js
var name10, dependencies11, createIsNegative;
var init_isNegative = __esm({
  "node_modules/mathjs/lib/esm/function/utils/isNegative.js"() {
    init_collection();
    init_factory();
    init_number2();
    name10 = "isNegative";
    dependencies11 = ["typed"];
    createIsNegative = /* @__PURE__ */ factory(name10, dependencies11, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2(name10, {
        number: isNegativeNumber,
        BigNumber: function BigNumber2(x) {
          return x.isNeg() && !x.isZero() && !x.isNaN();
        },
        Fraction: function Fraction3(x) {
          return x.s < 0;
        },
        Unit: function Unit2(x) {
          return this(x.value);
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/utils/isNumeric.js
var name11, dependencies12, createIsNumeric;
var init_isNumeric = __esm({
  "node_modules/mathjs/lib/esm/function/utils/isNumeric.js"() {
    init_collection();
    init_factory();
    name11 = "isNumeric";
    dependencies12 = ["typed"];
    createIsNumeric = /* @__PURE__ */ factory(name11, dependencies12, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2(name11, {
        "number | BigNumber | Fraction | boolean": function numberBigNumberFractionBoolean() {
          return true;
        },
        "Complex | Unit | string | null | undefined | Node": function ComplexUnitStringNullUndefinedNode() {
          return false;
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/utils/hasNumericValue.js
var name12, dependencies13, createHasNumericValue;
var init_hasNumericValue = __esm({
  "node_modules/mathjs/lib/esm/function/utils/hasNumericValue.js"() {
    init_factory();
    name12 = "hasNumericValue";
    dependencies13 = ["typed", "isNumeric"];
    createHasNumericValue = /* @__PURE__ */ factory(name12, dependencies13, (_ref) => {
      var {
        typed: typed2,
        isNumeric: isNumeric2
      } = _ref;
      return typed2(name12, {
        string: function string2(x) {
          return x.trim().length > 0 && !isNaN(Number(x));
        },
        any: function any(x) {
          return isNumeric2(x);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/utils/isPositive.js
var name13, dependencies14, createIsPositive;
var init_isPositive = __esm({
  "node_modules/mathjs/lib/esm/function/utils/isPositive.js"() {
    init_collection();
    init_factory();
    init_number2();
    name13 = "isPositive";
    dependencies14 = ["typed"];
    createIsPositive = /* @__PURE__ */ factory(name13, dependencies14, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2(name13, {
        number: isPositiveNumber,
        BigNumber: function BigNumber2(x) {
          return !x.isNeg() && !x.isZero() && !x.isNaN();
        },
        Fraction: function Fraction3(x) {
          return x.s > 0 && x.n > 0;
        },
        Unit: function Unit2(x) {
          return this(x.value);
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/utils/isZero.js
var name14, dependencies15, createIsZero;
var init_isZero = __esm({
  "node_modules/mathjs/lib/esm/function/utils/isZero.js"() {
    init_collection();
    init_factory();
    init_number2();
    name14 = "isZero";
    dependencies15 = ["typed"];
    createIsZero = /* @__PURE__ */ factory(name14, dependencies15, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2(name14, {
        number: isZeroNumber,
        BigNumber: function BigNumber2(x) {
          return x.isZero();
        },
        Complex: function Complex3(x) {
          return x.re === 0 && x.im === 0;
        },
        Fraction: function Fraction3(x) {
          return x.d === 1 && x.n === 0;
        },
        Unit: function Unit2(x) {
          return this(x.value);
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/utils/isNaN.js
var name15, dependencies16, createIsNaN;
var init_isNaN = __esm({
  "node_modules/mathjs/lib/esm/function/utils/isNaN.js"() {
    init_collection();
    init_factory();
    init_number2();
    name15 = "isNaN";
    dependencies16 = ["typed"];
    createIsNaN = /* @__PURE__ */ factory(name15, dependencies16, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2(name15, {
        number: isNaNNumber,
        BigNumber: function BigNumber2(x) {
          return x.isNaN();
        },
        Fraction: function Fraction3(x) {
          return false;
        },
        Complex: function Complex3(x) {
          return x.isNaN();
        },
        Unit: function Unit2(x) {
          return Number.isNaN(x.value);
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, Number.isNaN);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/utils/typeOf.js
var name16, dependencies17, createTypeOf;
var init_typeOf = __esm({
  "node_modules/mathjs/lib/esm/function/utils/typeOf.js"() {
    init_factory();
    init_is();
    name16 = "typeOf";
    dependencies17 = ["typed"];
    createTypeOf = /* @__PURE__ */ factory(name16, dependencies17, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2(name16, {
        any: typeOf
      });
    });
  }
});

// node_modules/mathjs/lib/esm/utils/bignumber/nearlyEqual.js
function nearlyEqual2(x, y, epsilon) {
  if (epsilon === null || epsilon === void 0) {
    return x.eq(y);
  }
  if (x.eq(y)) {
    return true;
  }
  if (x.isNaN() || y.isNaN()) {
    return false;
  }
  if (x.isFinite() && y.isFinite()) {
    var diff2 = x.minus(y).abs();
    if (diff2.isZero()) {
      return true;
    } else {
      var max2 = x.constructor.max(x.abs(), y.abs());
      return diff2.lte(max2.times(epsilon));
    }
  }
  return false;
}
var init_nearlyEqual = __esm({
  "node_modules/mathjs/lib/esm/utils/bignumber/nearlyEqual.js"() {
  }
});

// node_modules/mathjs/lib/esm/utils/complex.js
function complexEquals(x, y, epsilon) {
  return nearlyEqual(x.re, y.re, epsilon) && nearlyEqual(x.im, y.im, epsilon);
}
var init_complex = __esm({
  "node_modules/mathjs/lib/esm/utils/complex.js"() {
    init_number();
  }
});

// node_modules/mathjs/lib/esm/function/relational/equalScalar.js
var name17, dependencies18, createEqualScalar, createEqualScalarNumber;
var init_equalScalar = __esm({
  "node_modules/mathjs/lib/esm/function/relational/equalScalar.js"() {
    init_nearlyEqual();
    init_number();
    init_factory();
    init_complex();
    name17 = "equalScalar";
    dependencies18 = ["typed", "config"];
    createEqualScalar = /* @__PURE__ */ factory(name17, dependencies18, (_ref) => {
      var {
        typed: typed2,
        config: config3
      } = _ref;
      return typed2(name17, {
        "boolean, boolean": function booleanBoolean(x, y) {
          return x === y;
        },
        "number, number": function numberNumber(x, y) {
          return nearlyEqual(x, y, config3.epsilon);
        },
        "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
          return x.eq(y) || nearlyEqual2(x, y, config3.epsilon);
        },
        "Fraction, Fraction": function FractionFraction(x, y) {
          return x.equals(y);
        },
        "Complex, Complex": function ComplexComplex(x, y) {
          return complexEquals(x, y, config3.epsilon);
        },
        "Unit, Unit": function UnitUnit(x, y) {
          if (!x.equalBase(y)) {
            throw new Error("Cannot compare units with different base");
          }
          return this(x.value, y.value);
        }
      });
    });
    createEqualScalarNumber = factory(name17, ["typed", "config"], (_ref2) => {
      var {
        typed: typed2,
        config: config3
      } = _ref2;
      return typed2(name17, {
        "number, number": function numberNumber(x, y) {
          return nearlyEqual(x, y, config3.epsilon);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/type/matrix/SparseMatrix.js
var name18, dependencies19, createSparseMatrixClass;
var init_SparseMatrix = __esm({
  "node_modules/mathjs/lib/esm/type/matrix/SparseMatrix.js"() {
    init_is();
    init_number();
    init_string();
    init_object();
    init_array();
    init_factory();
    init_DimensionError();
    name18 = "SparseMatrix";
    dependencies19 = ["typed", "equalScalar", "Matrix"];
    createSparseMatrixClass = /* @__PURE__ */ factory(name18, dependencies19, (_ref) => {
      var {
        typed: typed2,
        equalScalar: equalScalar2,
        Matrix: Matrix2
      } = _ref;
      function SparseMatrix2(data, datatype) {
        if (!(this instanceof SparseMatrix2)) {
          throw new SyntaxError("Constructor must be called with the new operator");
        }
        if (datatype && !isString2(datatype)) {
          throw new Error("Invalid datatype: " + datatype);
        }
        if (isMatrix(data)) {
          _createFromMatrix(this, data, datatype);
        } else if (data && isArray(data.index) && isArray(data.ptr) && isArray(data.size)) {
          this._values = data.values;
          this._index = data.index;
          this._ptr = data.ptr;
          this._size = data.size;
          this._datatype = datatype || data.datatype;
        } else if (isArray(data)) {
          _createFromArray(this, data, datatype);
        } else if (data) {
          throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
        } else {
          this._values = [];
          this._index = [];
          this._ptr = [0];
          this._size = [0, 0];
          this._datatype = datatype;
        }
      }
      function _createFromMatrix(matrix2, source, datatype) {
        if (source.type === "SparseMatrix") {
          matrix2._values = source._values ? clone(source._values) : void 0;
          matrix2._index = clone(source._index);
          matrix2._ptr = clone(source._ptr);
          matrix2._size = clone(source._size);
          matrix2._datatype = datatype || source._datatype;
        } else {
          _createFromArray(matrix2, source.valueOf(), datatype || source._datatype);
        }
      }
      function _createFromArray(matrix2, data, datatype) {
        matrix2._values = [];
        matrix2._index = [];
        matrix2._ptr = [];
        matrix2._datatype = datatype;
        var rows = data.length;
        var columns = 0;
        var eq = equalScalar2;
        var zero = 0;
        if (isString2(datatype)) {
          eq = typed2.find(equalScalar2, [datatype, datatype]) || equalScalar2;
          zero = typed2.convert(0, datatype);
        }
        if (rows > 0) {
          var j = 0;
          do {
            matrix2._ptr.push(matrix2._index.length);
            for (var i2 = 0; i2 < rows; i2++) {
              var row2 = data[i2];
              if (isArray(row2)) {
                if (j === 0 && columns < row2.length) {
                  columns = row2.length;
                }
                if (j < row2.length) {
                  var v = row2[j];
                  if (!eq(v, zero)) {
                    matrix2._values.push(v);
                    matrix2._index.push(i2);
                  }
                }
              } else {
                if (j === 0 && columns < 1) {
                  columns = 1;
                }
                if (!eq(row2, zero)) {
                  matrix2._values.push(row2);
                  matrix2._index.push(i2);
                }
              }
            }
            j++;
          } while (j < columns);
        }
        matrix2._ptr.push(matrix2._index.length);
        matrix2._size = [rows, columns];
      }
      SparseMatrix2.prototype = new Matrix2();
      SparseMatrix2.prototype.createSparseMatrix = function(data, datatype) {
        return new SparseMatrix2(data, datatype);
      };
      SparseMatrix2.prototype.type = "SparseMatrix";
      SparseMatrix2.prototype.isSparseMatrix = true;
      SparseMatrix2.prototype.getDataType = function() {
        return getArrayDataType(this._values, typeOf);
      };
      SparseMatrix2.prototype.storage = function() {
        return "sparse";
      };
      SparseMatrix2.prototype.datatype = function() {
        return this._datatype;
      };
      SparseMatrix2.prototype.create = function(data, datatype) {
        return new SparseMatrix2(data, datatype);
      };
      SparseMatrix2.prototype.density = function() {
        var rows = this._size[0];
        var columns = this._size[1];
        return rows !== 0 && columns !== 0 ? this._index.length / (rows * columns) : 0;
      };
      SparseMatrix2.prototype.subset = function(index2, replacement, defaultValue) {
        if (!this._values) {
          throw new Error("Cannot invoke subset on a Pattern only matrix");
        }
        switch (arguments.length) {
          case 1:
            return _getsubset(this, index2);
          case 2:
          case 3:
            return _setsubset(this, index2, replacement, defaultValue);
          default:
            throw new SyntaxError("Wrong number of arguments");
        }
      };
      function _getsubset(matrix2, idx) {
        if (!isIndex(idx)) {
          throw new TypeError("Invalid index");
        }
        var isScalar = idx.isScalar();
        if (isScalar) {
          return matrix2.get(idx.min());
        }
        var size2 = idx.size();
        if (size2.length !== matrix2._size.length) {
          throw new DimensionError(size2.length, matrix2._size.length);
        }
        var i2, ii, k, kk;
        var min2 = idx.min();
        var max2 = idx.max();
        for (i2 = 0, ii = matrix2._size.length; i2 < ii; i2++) {
          validateIndex(min2[i2], matrix2._size[i2]);
          validateIndex(max2[i2], matrix2._size[i2]);
        }
        var mvalues = matrix2._values;
        var mindex = matrix2._index;
        var mptr = matrix2._ptr;
        var rows = idx.dimension(0);
        var columns = idx.dimension(1);
        var w = [];
        var pv = [];
        rows.forEach(function(i3, r) {
          pv[i3] = r[0];
          w[i3] = true;
        });
        var values = mvalues ? [] : void 0;
        var index2 = [];
        var ptr = [];
        columns.forEach(function(j) {
          ptr.push(index2.length);
          for (k = mptr[j], kk = mptr[j + 1]; k < kk; k++) {
            i2 = mindex[k];
            if (w[i2] === true) {
              index2.push(pv[i2]);
              if (values) {
                values.push(mvalues[k]);
              }
            }
          }
        });
        ptr.push(index2.length);
        return new SparseMatrix2({
          values,
          index: index2,
          ptr,
          size: size2,
          datatype: matrix2._datatype
        });
      }
      function _setsubset(matrix2, index2, submatrix, defaultValue) {
        if (!index2 || index2.isIndex !== true) {
          throw new TypeError("Invalid index");
        }
        var iSize = index2.size();
        var isScalar = index2.isScalar();
        var sSize;
        if (isMatrix(submatrix)) {
          sSize = submatrix.size();
          submatrix = submatrix.toArray();
        } else {
          sSize = arraySize(submatrix);
        }
        if (isScalar) {
          if (sSize.length !== 0) {
            throw new TypeError("Scalar expected");
          }
          matrix2.set(index2.min(), submatrix, defaultValue);
        } else {
          if (iSize.length !== 1 && iSize.length !== 2) {
            throw new DimensionError(iSize.length, matrix2._size.length, "<");
          }
          if (sSize.length < iSize.length) {
            var i2 = 0;
            var outer = 0;
            while (iSize[i2] === 1 && sSize[i2] === 1) {
              i2++;
            }
            while (iSize[i2] === 1) {
              outer++;
              i2++;
            }
            submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
          }
          if (!deepStrictEqual(iSize, sSize)) {
            throw new DimensionError(iSize, sSize, ">");
          }
          if (iSize.length === 1) {
            var range2 = index2.dimension(0);
            range2.forEach(function(dataIndex, subIndex) {
              validateIndex(dataIndex);
              matrix2.set([dataIndex, 0], submatrix[subIndex[0]], defaultValue);
            });
          } else {
            var firstDimensionRange = index2.dimension(0);
            var secondDimensionRange = index2.dimension(1);
            firstDimensionRange.forEach(function(firstDataIndex, firstSubIndex) {
              validateIndex(firstDataIndex);
              secondDimensionRange.forEach(function(secondDataIndex, secondSubIndex) {
                validateIndex(secondDataIndex);
                matrix2.set([firstDataIndex, secondDataIndex], submatrix[firstSubIndex[0]][secondSubIndex[0]], defaultValue);
              });
            });
          }
        }
        return matrix2;
      }
      SparseMatrix2.prototype.get = function(index2) {
        if (!isArray(index2)) {
          throw new TypeError("Array expected");
        }
        if (index2.length !== this._size.length) {
          throw new DimensionError(index2.length, this._size.length);
        }
        if (!this._values) {
          throw new Error("Cannot invoke get on a Pattern only matrix");
        }
        var i2 = index2[0];
        var j = index2[1];
        validateIndex(i2, this._size[0]);
        validateIndex(j, this._size[1]);
        var k = _getValueIndex(i2, this._ptr[j], this._ptr[j + 1], this._index);
        if (k < this._ptr[j + 1] && this._index[k] === i2) {
          return this._values[k];
        }
        return 0;
      };
      SparseMatrix2.prototype.set = function(index2, v, defaultValue) {
        if (!isArray(index2)) {
          throw new TypeError("Array expected");
        }
        if (index2.length !== this._size.length) {
          throw new DimensionError(index2.length, this._size.length);
        }
        if (!this._values) {
          throw new Error("Cannot invoke set on a Pattern only matrix");
        }
        var i2 = index2[0];
        var j = index2[1];
        var rows = this._size[0];
        var columns = this._size[1];
        var eq = equalScalar2;
        var zero = 0;
        if (isString2(this._datatype)) {
          eq = typed2.find(equalScalar2, [this._datatype, this._datatype]) || equalScalar2;
          zero = typed2.convert(0, this._datatype);
        }
        if (i2 > rows - 1 || j > columns - 1) {
          _resize2(this, Math.max(i2 + 1, rows), Math.max(j + 1, columns), defaultValue);
          rows = this._size[0];
          columns = this._size[1];
        }
        validateIndex(i2, rows);
        validateIndex(j, columns);
        var k = _getValueIndex(i2, this._ptr[j], this._ptr[j + 1], this._index);
        if (k < this._ptr[j + 1] && this._index[k] === i2) {
          if (!eq(v, zero)) {
            this._values[k] = v;
          } else {
            _remove(k, j, this._values, this._index, this._ptr);
          }
        } else {
          _insert(k, i2, j, v, this._values, this._index, this._ptr);
        }
        return this;
      };
      function _getValueIndex(i2, top, bottom, index2) {
        if (bottom - top === 0) {
          return bottom;
        }
        for (var r = top; r < bottom; r++) {
          if (index2[r] === i2) {
            return r;
          }
        }
        return top;
      }
      function _remove(k, j, values, index2, ptr) {
        values.splice(k, 1);
        index2.splice(k, 1);
        for (var x = j + 1; x < ptr.length; x++) {
          ptr[x]--;
        }
      }
      function _insert(k, i2, j, v, values, index2, ptr) {
        values.splice(k, 0, v);
        index2.splice(k, 0, i2);
        for (var x = j + 1; x < ptr.length; x++) {
          ptr[x]++;
        }
      }
      SparseMatrix2.prototype.resize = function(size2, defaultValue, copy) {
        if (!isCollection(size2)) {
          throw new TypeError("Array or Matrix expected");
        }
        var sizeArray = size2.valueOf().map((value) => {
          return Array.isArray(value) && value.length === 1 ? value[0] : value;
        });
        if (sizeArray.length !== 2) {
          throw new Error("Only two dimensions matrix are supported");
        }
        sizeArray.forEach(function(value) {
          if (!isNumber2(value) || !isInteger(value) || value < 0) {
            throw new TypeError("Invalid size, must contain positive integers (size: " + format3(sizeArray) + ")");
          }
        });
        var m = copy ? this.clone() : this;
        return _resize2(m, sizeArray[0], sizeArray[1], defaultValue);
      };
      function _resize2(matrix2, rows, columns, defaultValue) {
        var value = defaultValue || 0;
        var eq = equalScalar2;
        var zero = 0;
        if (isString2(matrix2._datatype)) {
          eq = typed2.find(equalScalar2, [matrix2._datatype, matrix2._datatype]) || equalScalar2;
          zero = typed2.convert(0, matrix2._datatype);
          value = typed2.convert(value, matrix2._datatype);
        }
        var ins = !eq(value, zero);
        var r = matrix2._size[0];
        var c = matrix2._size[1];
        var i2, j, k;
        if (columns > c) {
          for (j = c; j < columns; j++) {
            matrix2._ptr[j] = matrix2._values.length;
            if (ins) {
              for (i2 = 0; i2 < r; i2++) {
                matrix2._values.push(value);
                matrix2._index.push(i2);
              }
            }
          }
          matrix2._ptr[columns] = matrix2._values.length;
        } else if (columns < c) {
          matrix2._ptr.splice(columns + 1, c - columns);
          matrix2._values.splice(matrix2._ptr[columns], matrix2._values.length);
          matrix2._index.splice(matrix2._ptr[columns], matrix2._index.length);
        }
        c = columns;
        if (rows > r) {
          if (ins) {
            var n = 0;
            for (j = 0; j < c; j++) {
              matrix2._ptr[j] = matrix2._ptr[j] + n;
              k = matrix2._ptr[j + 1] + n;
              var p = 0;
              for (i2 = r; i2 < rows; i2++, p++) {
                matrix2._values.splice(k + p, 0, value);
                matrix2._index.splice(k + p, 0, i2);
                n++;
              }
            }
            matrix2._ptr[c] = matrix2._values.length;
          }
        } else if (rows < r) {
          var d = 0;
          for (j = 0; j < c; j++) {
            matrix2._ptr[j] = matrix2._ptr[j] - d;
            var k0 = matrix2._ptr[j];
            var k1 = matrix2._ptr[j + 1] - d;
            for (k = k0; k < k1; k++) {
              i2 = matrix2._index[k];
              if (i2 > rows - 1) {
                matrix2._values.splice(k, 1);
                matrix2._index.splice(k, 1);
                d++;
              }
            }
          }
          matrix2._ptr[j] = matrix2._values.length;
        }
        matrix2._size[0] = rows;
        matrix2._size[1] = columns;
        return matrix2;
      }
      SparseMatrix2.prototype.reshape = function(sizes, copy) {
        if (!isArray(sizes)) {
          throw new TypeError("Array expected");
        }
        if (sizes.length !== 2) {
          throw new Error("Sparse matrices can only be reshaped in two dimensions");
        }
        sizes.forEach(function(value) {
          if (!isNumber2(value) || !isInteger(value) || value <= -2 || value === 0) {
            throw new TypeError("Invalid size, must contain positive integers or -1 (size: " + format3(sizes) + ")");
          }
        });
        var currentLength = this._size[0] * this._size[1];
        sizes = processSizesWildcard(sizes, currentLength);
        var newLength = sizes[0] * sizes[1];
        if (currentLength !== newLength) {
          throw new Error("Reshaping sparse matrix will result in the wrong number of elements");
        }
        var m = copy ? this.clone() : this;
        if (this._size[0] === sizes[0] && this._size[1] === sizes[1]) {
          return m;
        }
        var colIndex = [];
        for (var i2 = 0; i2 < m._ptr.length; i2++) {
          for (var j = 0; j < m._ptr[i2 + 1] - m._ptr[i2]; j++) {
            colIndex.push(i2);
          }
        }
        var values = m._values.slice();
        var rowIndex = m._index.slice();
        for (var _i = 0; _i < m._index.length; _i++) {
          var r1 = rowIndex[_i];
          var c1 = colIndex[_i];
          var flat = r1 * m._size[1] + c1;
          colIndex[_i] = flat % sizes[1];
          rowIndex[_i] = Math.floor(flat / sizes[1]);
        }
        m._values.length = 0;
        m._index.length = 0;
        m._ptr.length = sizes[1] + 1;
        m._size = sizes.slice();
        for (var _i2 = 0; _i2 < m._ptr.length; _i2++) {
          m._ptr[_i2] = 0;
        }
        for (var h = 0; h < values.length; h++) {
          var _i3 = rowIndex[h];
          var _j = colIndex[h];
          var v = values[h];
          var k = _getValueIndex(_i3, m._ptr[_j], m._ptr[_j + 1], m._index);
          _insert(k, _i3, _j, v, m._values, m._index, m._ptr);
        }
        return m;
      };
      SparseMatrix2.prototype.clone = function() {
        var m = new SparseMatrix2({
          values: this._values ? clone(this._values) : void 0,
          index: clone(this._index),
          ptr: clone(this._ptr),
          size: clone(this._size),
          datatype: this._datatype
        });
        return m;
      };
      SparseMatrix2.prototype.size = function() {
        return this._size.slice(0);
      };
      SparseMatrix2.prototype.map = function(callback, skipZeros) {
        if (!this._values) {
          throw new Error("Cannot invoke map on a Pattern only matrix");
        }
        var me = this;
        var rows = this._size[0];
        var columns = this._size[1];
        var invoke = function invoke2(v, i2, j) {
          return callback(v, [i2, j], me);
        };
        return _map3(this, 0, rows - 1, 0, columns - 1, invoke, skipZeros);
      };
      function _map3(matrix2, minRow, maxRow, minColumn, maxColumn, callback, skipZeros) {
        var values = [];
        var index2 = [];
        var ptr = [];
        var eq = equalScalar2;
        var zero = 0;
        if (isString2(matrix2._datatype)) {
          eq = typed2.find(equalScalar2, [matrix2._datatype, matrix2._datatype]) || equalScalar2;
          zero = typed2.convert(0, matrix2._datatype);
        }
        var invoke = function invoke2(v, x, y) {
          v = callback(v, x, y);
          if (!eq(v, zero)) {
            values.push(v);
            index2.push(x);
          }
        };
        for (var j = minColumn; j <= maxColumn; j++) {
          ptr.push(values.length);
          var k0 = matrix2._ptr[j];
          var k1 = matrix2._ptr[j + 1];
          if (skipZeros) {
            for (var k = k0; k < k1; k++) {
              var i2 = matrix2._index[k];
              if (i2 >= minRow && i2 <= maxRow) {
                invoke(matrix2._values[k], i2 - minRow, j - minColumn);
              }
            }
          } else {
            var _values = {};
            for (var _k = k0; _k < k1; _k++) {
              var _i4 = matrix2._index[_k];
              _values[_i4] = matrix2._values[_k];
            }
            for (var _i5 = minRow; _i5 <= maxRow; _i5++) {
              var value = _i5 in _values ? _values[_i5] : 0;
              invoke(value, _i5 - minRow, j - minColumn);
            }
          }
        }
        ptr.push(values.length);
        return new SparseMatrix2({
          values,
          index: index2,
          ptr,
          size: [maxRow - minRow + 1, maxColumn - minColumn + 1]
        });
      }
      SparseMatrix2.prototype.forEach = function(callback, skipZeros) {
        if (!this._values) {
          throw new Error("Cannot invoke forEach on a Pattern only matrix");
        }
        var me = this;
        var rows = this._size[0];
        var columns = this._size[1];
        for (var j = 0; j < columns; j++) {
          var k0 = this._ptr[j];
          var k1 = this._ptr[j + 1];
          if (skipZeros) {
            for (var k = k0; k < k1; k++) {
              var i2 = this._index[k];
              callback(this._values[k], [i2, j], me);
            }
          } else {
            var values = {};
            for (var _k2 = k0; _k2 < k1; _k2++) {
              var _i6 = this._index[_k2];
              values[_i6] = this._values[_k2];
            }
            for (var _i7 = 0; _i7 < rows; _i7++) {
              var value = _i7 in values ? values[_i7] : 0;
              callback(value, [_i7, j], me);
            }
          }
        }
      };
      SparseMatrix2.prototype[Symbol.iterator] = function* () {
        if (!this._values) {
          throw new Error("Cannot iterate a Pattern only matrix");
        }
        var columns = this._size[1];
        for (var j = 0; j < columns; j++) {
          var k0 = this._ptr[j];
          var k1 = this._ptr[j + 1];
          for (var k = k0; k < k1; k++) {
            var i2 = this._index[k];
            yield {
              value: this._values[k],
              index: [i2, j]
            };
          }
        }
      };
      SparseMatrix2.prototype.toArray = function() {
        return _toArray(this._values, this._index, this._ptr, this._size, true);
      };
      SparseMatrix2.prototype.valueOf = function() {
        return _toArray(this._values, this._index, this._ptr, this._size, false);
      };
      function _toArray(values, index2, ptr, size2, copy) {
        var rows = size2[0];
        var columns = size2[1];
        var a = [];
        var i2, j;
        for (i2 = 0; i2 < rows; i2++) {
          a[i2] = [];
          for (j = 0; j < columns; j++) {
            a[i2][j] = 0;
          }
        }
        for (j = 0; j < columns; j++) {
          var k0 = ptr[j];
          var k1 = ptr[j + 1];
          for (var k = k0; k < k1; k++) {
            i2 = index2[k];
            a[i2][j] = values ? copy ? clone(values[k]) : values[k] : 1;
          }
        }
        return a;
      }
      SparseMatrix2.prototype.format = function(options) {
        var rows = this._size[0];
        var columns = this._size[1];
        var density = this.density();
        var str = "Sparse Matrix [" + format3(rows, options) + " x " + format3(columns, options) + "] density: " + format3(density, options) + "\n";
        for (var j = 0; j < columns; j++) {
          var k0 = this._ptr[j];
          var k1 = this._ptr[j + 1];
          for (var k = k0; k < k1; k++) {
            var i2 = this._index[k];
            str += "\n    (" + format3(i2, options) + ", " + format3(j, options) + ") ==> " + (this._values ? format3(this._values[k], options) : "X");
          }
        }
        return str;
      };
      SparseMatrix2.prototype.toString = function() {
        return format3(this.toArray());
      };
      SparseMatrix2.prototype.toJSON = function() {
        return {
          mathjs: "SparseMatrix",
          values: this._values,
          index: this._index,
          ptr: this._ptr,
          size: this._size,
          datatype: this._datatype
        };
      };
      SparseMatrix2.prototype.diagonal = function(k) {
        if (k) {
          if (isBigNumber(k)) {
            k = k.toNumber();
          }
          if (!isNumber2(k) || !isInteger(k)) {
            throw new TypeError("The parameter k must be an integer number");
          }
        } else {
          k = 0;
        }
        var kSuper = k > 0 ? k : 0;
        var kSub = k < 0 ? -k : 0;
        var rows = this._size[0];
        var columns = this._size[1];
        var n = Math.min(rows - kSub, columns - kSuper);
        var values = [];
        var index2 = [];
        var ptr = [];
        ptr[0] = 0;
        for (var j = kSuper; j < columns && values.length < n; j++) {
          var k0 = this._ptr[j];
          var k1 = this._ptr[j + 1];
          for (var x = k0; x < k1; x++) {
            var i2 = this._index[x];
            if (i2 === j - kSuper + kSub) {
              values.push(this._values[x]);
              index2[values.length - 1] = i2 - kSub;
              break;
            }
          }
        }
        ptr.push(values.length);
        return new SparseMatrix2({
          values,
          index: index2,
          ptr,
          size: [n, 1]
        });
      };
      SparseMatrix2.fromJSON = function(json) {
        return new SparseMatrix2(json);
      };
      SparseMatrix2.diagonal = function(size2, value, k, defaultValue, datatype) {
        if (!isArray(size2)) {
          throw new TypeError("Array expected, size parameter");
        }
        if (size2.length !== 2) {
          throw new Error("Only two dimensions matrix are supported");
        }
        size2 = size2.map(function(s) {
          if (isBigNumber(s)) {
            s = s.toNumber();
          }
          if (!isNumber2(s) || !isInteger(s) || s < 1) {
            throw new Error("Size values must be positive integers");
          }
          return s;
        });
        if (k) {
          if (isBigNumber(k)) {
            k = k.toNumber();
          }
          if (!isNumber2(k) || !isInteger(k)) {
            throw new TypeError("The parameter k must be an integer number");
          }
        } else {
          k = 0;
        }
        var eq = equalScalar2;
        var zero = 0;
        if (isString2(datatype)) {
          eq = typed2.find(equalScalar2, [datatype, datatype]) || equalScalar2;
          zero = typed2.convert(0, datatype);
        }
        var kSuper = k > 0 ? k : 0;
        var kSub = k < 0 ? -k : 0;
        var rows = size2[0];
        var columns = size2[1];
        var n = Math.min(rows - kSub, columns - kSuper);
        var _value;
        if (isArray(value)) {
          if (value.length !== n) {
            throw new Error("Invalid value array length");
          }
          _value = function _value2(i3) {
            return value[i3];
          };
        } else if (isMatrix(value)) {
          var ms = value.size();
          if (ms.length !== 1 || ms[0] !== n) {
            throw new Error("Invalid matrix length");
          }
          _value = function _value2(i3) {
            return value.get([i3]);
          };
        } else {
          _value = function _value2() {
            return value;
          };
        }
        var values = [];
        var index2 = [];
        var ptr = [];
        for (var j = 0; j < columns; j++) {
          ptr.push(values.length);
          var i2 = j - kSuper;
          if (i2 >= 0 && i2 < n) {
            var v = _value(i2);
            if (!eq(v, zero)) {
              index2.push(i2 + kSub);
              values.push(v);
            }
          }
        }
        ptr.push(values.length);
        return new SparseMatrix2({
          values,
          index: index2,
          ptr,
          size: [rows, columns]
        });
      };
      SparseMatrix2.prototype.swapRows = function(i2, j) {
        if (!isNumber2(i2) || !isInteger(i2) || !isNumber2(j) || !isInteger(j)) {
          throw new Error("Row index must be positive integers");
        }
        if (this._size.length !== 2) {
          throw new Error("Only two dimensional matrix is supported");
        }
        validateIndex(i2, this._size[0]);
        validateIndex(j, this._size[0]);
        SparseMatrix2._swapRows(i2, j, this._size[1], this._values, this._index, this._ptr);
        return this;
      };
      SparseMatrix2._forEachRow = function(j, values, index2, ptr, callback) {
        var k0 = ptr[j];
        var k1 = ptr[j + 1];
        for (var k = k0; k < k1; k++) {
          callback(index2[k], values[k]);
        }
      };
      SparseMatrix2._swapRows = function(x, y, columns, values, index2, ptr) {
        for (var j = 0; j < columns; j++) {
          var k0 = ptr[j];
          var k1 = ptr[j + 1];
          var kx = _getValueIndex(x, k0, k1, index2);
          var ky = _getValueIndex(y, k0, k1, index2);
          if (kx < k1 && ky < k1 && index2[kx] === x && index2[ky] === y) {
            if (values) {
              var v = values[kx];
              values[kx] = values[ky];
              values[ky] = v;
            }
            continue;
          }
          if (kx < k1 && index2[kx] === x && (ky >= k1 || index2[ky] !== y)) {
            var vx = values ? values[kx] : void 0;
            index2.splice(ky, 0, y);
            if (values) {
              values.splice(ky, 0, vx);
            }
            index2.splice(ky <= kx ? kx + 1 : kx, 1);
            if (values) {
              values.splice(ky <= kx ? kx + 1 : kx, 1);
            }
            continue;
          }
          if (ky < k1 && index2[ky] === y && (kx >= k1 || index2[kx] !== x)) {
            var vy = values ? values[ky] : void 0;
            index2.splice(kx, 0, x);
            if (values) {
              values.splice(kx, 0, vy);
            }
            index2.splice(kx <= ky ? ky + 1 : ky, 1);
            if (values) {
              values.splice(kx <= ky ? ky + 1 : ky, 1);
            }
          }
        }
      };
      return SparseMatrix2;
    }, {
      isClass: true
    });
  }
});

// node_modules/mathjs/lib/esm/type/number.js
function getNonDecimalNumberParts(input) {
  var nonDecimalWithRadixMatch = input.match(/(0[box])([0-9a-fA-F]*)\.([0-9a-fA-F]*)/);
  if (nonDecimalWithRadixMatch) {
    var radix = {
      "0b": 2,
      "0o": 8,
      "0x": 16
    }[nonDecimalWithRadixMatch[1]];
    var integerPart = nonDecimalWithRadixMatch[2];
    var fractionalPart = nonDecimalWithRadixMatch[3];
    return {
      input,
      radix,
      integerPart,
      fractionalPart
    };
  } else {
    return null;
  }
}
function makeNumberFromNonDecimalParts(parts) {
  var n = parseInt(parts.integerPart, parts.radix);
  var f = 0;
  for (var i2 = 0; i2 < parts.fractionalPart.length; i2++) {
    var digitValue = parseInt(parts.fractionalPart[i2], parts.radix);
    f += digitValue / Math.pow(parts.radix, i2 + 1);
  }
  var result = n + f;
  if (isNaN(result)) {
    throw new SyntaxError('String "' + parts.input + '" is no valid number');
  }
  return result;
}
var name19, dependencies20, createNumber;
var init_number3 = __esm({
  "node_modules/mathjs/lib/esm/type/number.js"() {
    init_factory();
    init_collection();
    name19 = "number";
    dependencies20 = ["typed"];
    createNumber = /* @__PURE__ */ factory(name19, dependencies20, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      var number2 = typed2("number", {
        "": function _() {
          return 0;
        },
        number: function number3(x) {
          return x;
        },
        string: function string2(x) {
          if (x === "NaN")
            return NaN;
          var nonDecimalNumberParts = getNonDecimalNumberParts(x);
          if (nonDecimalNumberParts) {
            return makeNumberFromNonDecimalParts(nonDecimalNumberParts);
          }
          var size2 = 0;
          var wordSizeSuffixMatch = x.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
          if (wordSizeSuffixMatch) {
            size2 = Number(wordSizeSuffixMatch[2]);
            x = wordSizeSuffixMatch[1];
          }
          var num = Number(x);
          if (isNaN(num)) {
            throw new SyntaxError('String "' + x + '" is no valid number');
          }
          if (wordSizeSuffixMatch) {
            if (num > 2 ** size2 - 1) {
              throw new SyntaxError('String "'.concat(x, '" is out of range'));
            }
            if (num >= 2 ** (size2 - 1)) {
              num = num - 2 ** size2;
            }
          }
          return num;
        },
        BigNumber: function BigNumber2(x) {
          return x.toNumber();
        },
        Fraction: function Fraction3(x) {
          return x.valueOf();
        },
        Unit: function Unit2(x) {
          throw new Error("Second argument with valueless unit expected");
        },
        null: function _null2(x) {
          return 0;
        },
        "Unit, string | Unit": function UnitStringUnit(unit2, valuelessUnit) {
          return unit2.toNumber(valuelessUnit);
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
      number2.fromJSON = function(json) {
        return parseFloat(json.value);
      };
      return number2;
    });
  }
});

// node_modules/mathjs/lib/esm/type/string.js
var name20, dependencies21, createString;
var init_string2 = __esm({
  "node_modules/mathjs/lib/esm/type/string.js"() {
    init_factory();
    init_collection();
    init_number();
    name20 = "string";
    dependencies21 = ["typed"];
    createString = /* @__PURE__ */ factory(name20, dependencies21, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2(name20, {
        "": function _() {
          return "";
        },
        number: format,
        null: function _null2(x) {
          return "null";
        },
        boolean: function boolean2(x) {
          return x + "";
        },
        string: function string2(x) {
          return x;
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        },
        any: function any(x) {
          return String(x);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/type/boolean.js
var name21, dependencies22, createBoolean;
var init_boolean = __esm({
  "node_modules/mathjs/lib/esm/type/boolean.js"() {
    init_factory();
    init_collection();
    name21 = "boolean";
    dependencies22 = ["typed"];
    createBoolean = /* @__PURE__ */ factory(name21, dependencies22, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2(name21, {
        "": function _() {
          return false;
        },
        boolean: function boolean2(x) {
          return x;
        },
        number: function number2(x) {
          return !!x;
        },
        null: function _null2(x) {
          return false;
        },
        BigNumber: function BigNumber2(x) {
          return !x.isZero();
        },
        string: function string2(x) {
          var lcase = x.toLowerCase();
          if (lcase === "true") {
            return true;
          } else if (lcase === "false") {
            return false;
          }
          var num = Number(x);
          if (x !== "" && !isNaN(num)) {
            return !!num;
          }
          throw new Error('Cannot convert "' + x + '" to a boolean');
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/type/bignumber/function/bignumber.js
var name22, dependencies23, createBignumber;
var init_bignumber = __esm({
  "node_modules/mathjs/lib/esm/type/bignumber/function/bignumber.js"() {
    init_factory();
    init_collection();
    name22 = "bignumber";
    dependencies23 = ["typed", "BigNumber"];
    createBignumber = /* @__PURE__ */ factory(name22, dependencies23, (_ref) => {
      var {
        typed: typed2,
        BigNumber: BigNumber2
      } = _ref;
      return typed2("bignumber", {
        "": function _() {
          return new BigNumber2(0);
        },
        number: function number2(x) {
          return new BigNumber2(x + "");
        },
        string: function string2(x) {
          var wordSizeSuffixMatch = x.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
          if (wordSizeSuffixMatch) {
            var size2 = wordSizeSuffixMatch[2];
            var n = BigNumber2(wordSizeSuffixMatch[1]);
            var twoPowSize = new BigNumber2(2).pow(Number(size2));
            if (n.gt(twoPowSize.sub(1))) {
              throw new SyntaxError('String "'.concat(x, '" is out of range'));
            }
            var twoPowSizeSubOne = new BigNumber2(2).pow(Number(size2) - 1);
            if (n.gte(twoPowSizeSubOne)) {
              return n.sub(twoPowSize);
            } else {
              return n;
            }
          }
          return new BigNumber2(x);
        },
        BigNumber: function BigNumber3(x) {
          return x;
        },
        Fraction: function Fraction3(x) {
          return new BigNumber2(x.n).div(x.d).times(x.s);
        },
        null: function _null2(x) {
          return new BigNumber2(0);
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/type/complex/function/complex.js
var name23, dependencies24, createComplex;
var init_complex2 = __esm({
  "node_modules/mathjs/lib/esm/type/complex/function/complex.js"() {
    init_factory();
    init_collection();
    name23 = "complex";
    dependencies24 = ["typed", "Complex"];
    createComplex = /* @__PURE__ */ factory(name23, dependencies24, (_ref) => {
      var {
        typed: typed2,
        Complex: Complex3
      } = _ref;
      return typed2("complex", {
        "": function _() {
          return Complex3.ZERO;
        },
        number: function number2(x) {
          return new Complex3(x, 0);
        },
        "number, number": function numberNumber(re2, im2) {
          return new Complex3(re2, im2);
        },
        "BigNumber, BigNumber": function BigNumberBigNumber(re2, im2) {
          return new Complex3(re2.toNumber(), im2.toNumber());
        },
        Fraction: function Fraction3(x) {
          return new Complex3(x.valueOf(), 0);
        },
        Complex: function Complex4(x) {
          return x.clone();
        },
        string: function string2(x) {
          return Complex3(x);
        },
        null: function _null2(x) {
          return Complex3(0);
        },
        Object: function Object2(x) {
          if ("re" in x && "im" in x) {
            return new Complex3(x.re, x.im);
          }
          if ("r" in x && "phi" in x || "abs" in x && "arg" in x) {
            return new Complex3(x);
          }
          throw new Error("Expected object with properties (re and im) or (r and phi) or (abs and arg)");
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/type/fraction/function/fraction.js
var name24, dependencies25, createFraction;
var init_fraction = __esm({
  "node_modules/mathjs/lib/esm/type/fraction/function/fraction.js"() {
    init_factory();
    init_collection();
    name24 = "fraction";
    dependencies25 = ["typed", "Fraction"];
    createFraction = /* @__PURE__ */ factory(name24, dependencies25, (_ref) => {
      var {
        typed: typed2,
        Fraction: Fraction3
      } = _ref;
      return typed2("fraction", {
        number: function number2(x) {
          if (!isFinite(x) || isNaN(x)) {
            throw new Error(x + " cannot be represented as a fraction");
          }
          return new Fraction3(x);
        },
        string: function string2(x) {
          return new Fraction3(x);
        },
        "number, number": function numberNumber(numerator, denominator) {
          return new Fraction3(numerator, denominator);
        },
        null: function _null2(x) {
          return new Fraction3(0);
        },
        BigNumber: function BigNumber2(x) {
          return new Fraction3(x.toString());
        },
        Fraction: function Fraction4(x) {
          return x;
        },
        Object: function Object2(x) {
          return new Fraction3(x);
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/type/matrix/function/matrix.js
var name25, dependencies26, createMatrix;
var init_matrix = __esm({
  "node_modules/mathjs/lib/esm/type/matrix/function/matrix.js"() {
    init_factory();
    name25 = "matrix";
    dependencies26 = ["typed", "Matrix", "DenseMatrix", "SparseMatrix"];
    createMatrix = /* @__PURE__ */ factory(name25, dependencies26, (_ref) => {
      var {
        typed: typed2,
        Matrix: Matrix2,
        DenseMatrix: DenseMatrix2,
        SparseMatrix: SparseMatrix2
      } = _ref;
      return typed2(name25, {
        "": function _() {
          return _create([]);
        },
        string: function string2(format5) {
          return _create([], format5);
        },
        "string, string": function stringString(format5, datatype) {
          return _create([], format5, datatype);
        },
        Array: function Array2(data) {
          return _create(data);
        },
        Matrix: function Matrix3(data) {
          return _create(data, data.storage());
        },
        "Array | Matrix, string": _create,
        "Array | Matrix, string, string": _create
      });
      function _create(data, format5, datatype) {
        if (format5 === "dense" || format5 === "default" || format5 === void 0) {
          return new DenseMatrix2(data, datatype);
        }
        if (format5 === "sparse") {
          return new SparseMatrix2(data, datatype);
        }
        throw new TypeError("Unknown matrix type " + JSON.stringify(format5) + ".");
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/matrixFromFunction.js
var name26, dependencies27, createMatrixFromFunction;
var init_matrixFromFunction = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/matrixFromFunction.js"() {
    init_factory();
    name26 = "matrixFromFunction";
    dependencies27 = ["typed", "matrix", "isZero"];
    createMatrixFromFunction = /* @__PURE__ */ factory(name26, dependencies27, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        isZero: isZero2
      } = _ref;
      return typed2(name26, {
        "Array | Matrix, function, string, string": function ArrayMatrixFunctionStringString(size2, fn, format5, datatype) {
          return _create(size2, fn, format5, datatype);
        },
        "Array | Matrix, function, string": function ArrayMatrixFunctionString(size2, fn, format5) {
          return _create(size2, fn, format5);
        },
        "Matrix, function": function MatrixFunction(size2, fn) {
          return _create(size2, fn, "dense");
        },
        "Array, function": function ArrayFunction(size2, fn) {
          return _create(size2, fn, "dense").toArray();
        },
        "Array | Matrix, string, function": function ArrayMatrixStringFunction(size2, format5, fn) {
          return _create(size2, fn, format5);
        },
        "Array | Matrix, string, string, function": function ArrayMatrixStringStringFunction(size2, format5, datatype, fn) {
          return _create(size2, fn, format5, datatype);
        }
      });
      function _create(size2, fn, format5, datatype) {
        var m;
        if (datatype !== void 0) {
          m = matrix2(format5, datatype);
        } else {
          m = matrix2(format5);
        }
        m.resize(size2);
        m.forEach(function(_, index2) {
          var val = fn(index2);
          if (isZero2(val))
            return;
          m.set(index2, val);
        });
        return m;
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/matrixFromRows.js
var name27, dependencies28, createMatrixFromRows;
var init_matrixFromRows = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/matrixFromRows.js"() {
    init_factory();
    name27 = "matrixFromRows";
    dependencies28 = ["typed", "matrix", "flatten", "size"];
    createMatrixFromRows = /* @__PURE__ */ factory(name27, dependencies28, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        flatten: flatten4,
        size: size2
      } = _ref;
      return typed2(name27, {
        "...Array": function Array2(arr) {
          return _createArray(arr);
        },
        "...Matrix": function Matrix2(arr) {
          return matrix2(_createArray(arr.map((m) => m.toArray())));
        }
      });
      function _createArray(arr) {
        if (arr.length === 0)
          throw new TypeError("At least one row is needed to construct a matrix.");
        var N = checkVectorTypeAndReturnLength(arr[0]);
        var result = [];
        for (var row2 of arr) {
          var rowLength = checkVectorTypeAndReturnLength(row2);
          if (rowLength !== N) {
            throw new TypeError("The vectors had different length: " + (N | 0) + " \u2260 " + (rowLength | 0));
          }
          result.push(flatten4(row2));
        }
        return result;
      }
      function checkVectorTypeAndReturnLength(vec) {
        var s = size2(vec);
        if (s.length === 1) {
          return s[0];
        } else if (s.length === 2) {
          if (s[0] === 1) {
            return s[1];
          } else if (s[1] === 1) {
            return s[0];
          } else {
            throw new TypeError("At least one of the arguments is not a vector.");
          }
        } else {
          throw new TypeError("Only one- or two-dimensional vectors are supported.");
        }
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/matrixFromColumns.js
var name28, dependencies29, createMatrixFromColumns;
var init_matrixFromColumns = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/matrixFromColumns.js"() {
    init_factory();
    name28 = "matrixFromColumns";
    dependencies29 = ["typed", "matrix", "flatten", "size"];
    createMatrixFromColumns = /* @__PURE__ */ factory(name28, dependencies29, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        flatten: flatten4,
        size: size2
      } = _ref;
      return typed2(name28, {
        "...Array": function Array2(arr) {
          return _createArray(arr);
        },
        "...Matrix": function Matrix2(arr) {
          return matrix2(_createArray(arr.map((m) => m.toArray())));
        }
      });
      function _createArray(arr) {
        if (arr.length === 0)
          throw new TypeError("At least one column is needed to construct a matrix.");
        var N = checkVectorTypeAndReturnLength(arr[0]);
        var result = [];
        for (var i2 = 0; i2 < N; i2++) {
          result[i2] = [];
        }
        for (var col of arr) {
          var colLength = checkVectorTypeAndReturnLength(col);
          if (colLength !== N) {
            throw new TypeError("The vectors had different length: " + (N | 0) + " \u2260 " + (colLength | 0));
          }
          var f = flatten4(col);
          for (var _i = 0; _i < N; _i++) {
            result[_i].push(f[_i]);
          }
        }
        return result;
      }
      function checkVectorTypeAndReturnLength(vec) {
        var s = size2(vec);
        if (s.length === 1) {
          return s[0];
        } else if (s.length === 2) {
          if (s[0] === 1) {
            return s[1];
          } else if (s[1] === 1) {
            return s[0];
          } else {
            throw new TypeError("At least one of the arguments is not a vector.");
          }
        } else {
          throw new TypeError("Only one- or two-dimensional vectors are supported.");
        }
      }
    });
  }
});

// node_modules/mathjs/lib/esm/type/unit/function/splitUnit.js
var name29, dependencies30, createSplitUnit;
var init_splitUnit = __esm({
  "node_modules/mathjs/lib/esm/type/unit/function/splitUnit.js"() {
    init_factory();
    name29 = "splitUnit";
    dependencies30 = ["typed"];
    createSplitUnit = /* @__PURE__ */ factory(name29, dependencies30, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2(name29, {
        "Unit, Array": function UnitArray(unit2, parts) {
          return unit2.splitUnit(parts);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/unaryMinus.js
var name30, dependencies31, createUnaryMinus;
var init_unaryMinus = __esm({
  "node_modules/mathjs/lib/esm/function/arithmetic/unaryMinus.js"() {
    init_factory();
    init_collection();
    init_number2();
    name30 = "unaryMinus";
    dependencies31 = ["typed"];
    createUnaryMinus = /* @__PURE__ */ factory(name30, dependencies31, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2(name30, {
        number: unaryMinusNumber,
        Complex: function Complex3(x) {
          return x.neg();
        },
        BigNumber: function BigNumber2(x) {
          return x.neg();
        },
        Fraction: function Fraction3(x) {
          return x.neg();
        },
        Unit: function Unit2(x) {
          var res = x.clone();
          res.value = this(x.value);
          return res;
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this, true);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/unaryPlus.js
var name31, dependencies32, createUnaryPlus;
var init_unaryPlus = __esm({
  "node_modules/mathjs/lib/esm/function/arithmetic/unaryPlus.js"() {
    init_factory();
    init_collection();
    init_number2();
    name31 = "unaryPlus";
    dependencies32 = ["typed", "config", "BigNumber"];
    createUnaryPlus = /* @__PURE__ */ factory(name31, dependencies32, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        BigNumber: BigNumber2
      } = _ref;
      return typed2(name31, {
        number: unaryPlusNumber,
        Complex: function Complex3(x) {
          return x;
        },
        BigNumber: function BigNumber3(x) {
          return x;
        },
        Fraction: function Fraction3(x) {
          return x;
        },
        Unit: function Unit2(x) {
          return x.clone();
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this, true);
        },
        "boolean | string": function booleanString(x) {
          return config3.number === "BigNumber" ? new BigNumber2(+x) : +x;
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/abs.js
var name32, dependencies33, createAbs;
var init_abs = __esm({
  "node_modules/mathjs/lib/esm/function/arithmetic/abs.js"() {
    init_factory();
    init_collection();
    init_number2();
    name32 = "abs";
    dependencies33 = ["typed"];
    createAbs = /* @__PURE__ */ factory(name32, dependencies33, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2(name32, {
        number: absNumber,
        Complex: function Complex3(x) {
          return x.abs();
        },
        BigNumber: function BigNumber2(x) {
          return x.abs();
        },
        Fraction: function Fraction3(x) {
          return x.abs();
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this, true);
        },
        Unit: function Unit2(x) {
          return x.abs();
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/apply.js
function _apply(mat, dim, callback) {
  var i2, ret, tran;
  if (dim <= 0) {
    if (!Array.isArray(mat[0])) {
      return callback(mat);
    } else {
      tran = _switch2(mat);
      ret = [];
      for (i2 = 0; i2 < tran.length; i2++) {
        ret[i2] = _apply(tran[i2], dim - 1, callback);
      }
      return ret;
    }
  } else {
    ret = [];
    for (i2 = 0; i2 < mat.length; i2++) {
      ret[i2] = _apply(mat[i2], dim - 1, callback);
    }
    return ret;
  }
}
function _switch2(mat) {
  var I = mat.length;
  var J = mat[0].length;
  var i2, j;
  var ret = [];
  for (j = 0; j < J; j++) {
    var tmp = [];
    for (i2 = 0; i2 < I; i2++) {
      tmp.push(mat[i2][j]);
    }
    ret.push(tmp);
  }
  return ret;
}
var name33, dependencies34, createApply;
var init_apply = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/apply.js"() {
    init_factory();
    init_array();
    init_is();
    init_IndexError();
    name33 = "apply";
    dependencies34 = ["typed", "isInteger"];
    createApply = /* @__PURE__ */ factory(name33, dependencies34, (_ref) => {
      var {
        typed: typed2,
        isInteger: isInteger3
      } = _ref;
      return typed2(name33, {
        "Array | Matrix, number | BigNumber, function": function ArrayMatrixNumberBigNumberFunction(mat, dim, callback) {
          if (!isInteger3(dim)) {
            throw new TypeError("Integer number expected for dimension");
          }
          var size2 = Array.isArray(mat) ? arraySize(mat) : mat.size();
          if (dim < 0 || dim >= size2.length) {
            throw new IndexError(dim, size2.length);
          }
          if (isMatrix(mat)) {
            return mat.create(_apply(mat.valueOf(), dim, callback));
          } else {
            return _apply(mat, dim, callback);
          }
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/addScalar.js
var name34, dependencies35, createAddScalar;
var init_addScalar = __esm({
  "node_modules/mathjs/lib/esm/function/arithmetic/addScalar.js"() {
    init_factory();
    init_number2();
    name34 = "addScalar";
    dependencies35 = ["typed"];
    createAddScalar = /* @__PURE__ */ factory(name34, dependencies35, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2(name34, {
        "number, number": addNumber,
        "Complex, Complex": function ComplexComplex(x, y) {
          return x.add(y);
        },
        "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
          return x.plus(y);
        },
        "Fraction, Fraction": function FractionFraction(x, y) {
          return x.add(y);
        },
        "Unit, Unit": function UnitUnit(x, y) {
          if (x.value === null || x.value === void 0)
            throw new Error("Parameter x contains a unit with undefined value");
          if (y.value === null || y.value === void 0)
            throw new Error("Parameter y contains a unit with undefined value");
          if (!x.equalBase(y))
            throw new Error("Units do not match");
          var res = x.clone();
          res.value = this(res.value, y.value);
          res.fixPrefix = false;
          return res;
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/cbrt.js
var name35, dependencies36, createCbrt;
var init_cbrt = __esm({
  "node_modules/mathjs/lib/esm/function/arithmetic/cbrt.js"() {
    init_factory();
    init_is();
    init_collection();
    init_number2();
    name35 = "cbrt";
    dependencies36 = ["config", "typed", "isNegative", "unaryMinus", "matrix", "Complex", "BigNumber", "Fraction"];
    createCbrt = /* @__PURE__ */ factory(name35, dependencies36, (_ref) => {
      var {
        config: config3,
        typed: typed2,
        isNegative: isNegative2,
        unaryMinus: unaryMinus2,
        matrix: matrix2,
        Complex: Complex3,
        BigNumber: BigNumber2,
        Fraction: Fraction3
      } = _ref;
      return typed2(name35, {
        number: cbrtNumber,
        Complex: _cbrtComplex,
        "Complex, boolean": _cbrtComplex,
        BigNumber: function BigNumber3(x) {
          return x.cbrt();
        },
        Unit: _cbrtUnit,
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this, true);
        }
      });
      function _cbrtComplex(x, allRoots) {
        var arg3 = x.arg() / 3;
        var abs2 = x.abs();
        var principal = new Complex3(cbrtNumber(abs2), 0).mul(new Complex3(0, arg3).exp());
        if (allRoots) {
          var all = [principal, new Complex3(cbrtNumber(abs2), 0).mul(new Complex3(0, arg3 + Math.PI * 2 / 3).exp()), new Complex3(cbrtNumber(abs2), 0).mul(new Complex3(0, arg3 - Math.PI * 2 / 3).exp())];
          return config3.matrix === "Array" ? all : matrix2(all);
        } else {
          return principal;
        }
      }
      function _cbrtUnit(x) {
        if (x.value && isComplex(x.value)) {
          var result = x.clone();
          result.value = 1;
          result = result.pow(1 / 3);
          result.value = _cbrtComplex(x.value);
          return result;
        } else {
          var negate = isNegative2(x.value);
          if (negate) {
            x.value = unaryMinus2(x.value);
          }
          var third;
          if (isBigNumber(x.value)) {
            third = new BigNumber2(1).div(3);
          } else if (isFraction(x.value)) {
            third = new Fraction3(1, 3);
          } else {
            third = 1 / 3;
          }
          var _result = x.pow(third);
          if (negate) {
            _result.value = unaryMinus2(_result.value);
          }
          return _result;
        }
      }
    });
  }
});

// node_modules/mathjs/lib/esm/type/matrix/utils/algorithm11.js
var name36, dependencies37, createAlgorithm11;
var init_algorithm11 = __esm({
  "node_modules/mathjs/lib/esm/type/matrix/utils/algorithm11.js"() {
    init_factory();
    name36 = "algorithm11";
    dependencies37 = ["typed", "equalScalar"];
    createAlgorithm11 = /* @__PURE__ */ factory(name36, dependencies37, (_ref) => {
      var {
        typed: typed2,
        equalScalar: equalScalar2
      } = _ref;
      return function algorithm11(s, b, callback, inverse) {
        var avalues = s._values;
        var aindex = s._index;
        var aptr = s._ptr;
        var asize = s._size;
        var adt = s._datatype;
        if (!avalues) {
          throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
        }
        var rows = asize[0];
        var columns = asize[1];
        var dt;
        var eq = equalScalar2;
        var zero = 0;
        var cf = callback;
        if (typeof adt === "string") {
          dt = adt;
          eq = typed2.find(equalScalar2, [dt, dt]);
          zero = typed2.convert(0, dt);
          b = typed2.convert(b, dt);
          cf = typed2.find(callback, [dt, dt]);
        }
        var cvalues = [];
        var cindex = [];
        var cptr = [];
        for (var j = 0; j < columns; j++) {
          cptr[j] = cindex.length;
          for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
            var i2 = aindex[k];
            var v = inverse ? cf(b, avalues[k]) : cf(avalues[k], b);
            if (!eq(v, zero)) {
              cindex.push(i2);
              cvalues.push(v);
            }
          }
        }
        cptr[columns] = cindex.length;
        return s.createSparseMatrix({
          values: cvalues,
          index: cindex,
          ptr: cptr,
          size: [rows, columns],
          datatype: dt
        });
      };
    });
  }
});

// node_modules/mathjs/lib/esm/type/matrix/utils/algorithm12.js
var name37, dependencies38, createAlgorithm12;
var init_algorithm12 = __esm({
  "node_modules/mathjs/lib/esm/type/matrix/utils/algorithm12.js"() {
    init_factory();
    name37 = "algorithm12";
    dependencies38 = ["typed", "DenseMatrix"];
    createAlgorithm12 = /* @__PURE__ */ factory(name37, dependencies38, (_ref) => {
      var {
        typed: typed2,
        DenseMatrix: DenseMatrix2
      } = _ref;
      return function algorithm12(s, b, callback, inverse) {
        var avalues = s._values;
        var aindex = s._index;
        var aptr = s._ptr;
        var asize = s._size;
        var adt = s._datatype;
        if (!avalues) {
          throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
        }
        var rows = asize[0];
        var columns = asize[1];
        var dt;
        var cf = callback;
        if (typeof adt === "string") {
          dt = adt;
          b = typed2.convert(b, dt);
          cf = typed2.find(callback, [dt, dt]);
        }
        var cdata = [];
        var x = [];
        var w = [];
        for (var j = 0; j < columns; j++) {
          var mark = j + 1;
          for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
            var r = aindex[k];
            x[r] = avalues[k];
            w[r] = mark;
          }
          for (var i2 = 0; i2 < rows; i2++) {
            if (j === 0) {
              cdata[i2] = [];
            }
            if (w[i2] === mark) {
              cdata[i2][j] = inverse ? cf(b, x[i2]) : cf(x[i2], b);
            } else {
              cdata[i2][j] = inverse ? cf(b, 0) : cf(0, b);
            }
          }
        }
        return new DenseMatrix2({
          data: cdata,
          size: [rows, columns],
          datatype: dt
        });
      };
    });
  }
});

// node_modules/mathjs/lib/esm/type/matrix/utils/algorithm14.js
var name38, dependencies39, createAlgorithm14;
var init_algorithm14 = __esm({
  "node_modules/mathjs/lib/esm/type/matrix/utils/algorithm14.js"() {
    init_factory();
    init_object();
    name38 = "algorithm14";
    dependencies39 = ["typed"];
    createAlgorithm14 = /* @__PURE__ */ factory(name38, dependencies39, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return function algorithm14(a, b, callback, inverse) {
        var adata = a._data;
        var asize = a._size;
        var adt = a._datatype;
        var dt;
        var cf = callback;
        if (typeof adt === "string") {
          dt = adt;
          b = typed2.convert(b, dt);
          cf = typed2.find(callback, [dt, dt]);
        }
        var cdata = asize.length > 0 ? _iterate(cf, 0, asize, asize[0], adata, b, inverse) : [];
        return a.createDenseMatrix({
          data: cdata,
          size: clone(asize),
          datatype: dt
        });
      };
      function _iterate(f, level, s, n, av, bv, inverse) {
        var cv = [];
        if (level === s.length - 1) {
          for (var i2 = 0; i2 < n; i2++) {
            cv[i2] = inverse ? f(bv, av[i2]) : f(av[i2], bv);
          }
        } else {
          for (var j = 0; j < n; j++) {
            cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv, inverse);
          }
        }
        return cv;
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/ceil.js
var import_decimal2, name39, dependencies40, createCeilNumber, createCeil;
var init_ceil = __esm({
  "node_modules/mathjs/lib/esm/function/arithmetic/ceil.js"() {
    import_decimal2 = __toESM(require_decimal(), 1);
    init_factory();
    init_collection();
    init_number();
    init_nearlyEqual();
    init_algorithm11();
    init_algorithm12();
    init_algorithm14();
    name39 = "ceil";
    dependencies40 = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "DenseMatrix"];
    createCeilNumber = /* @__PURE__ */ factory(name39, ["typed", "config", "round"], (_ref) => {
      var {
        typed: typed2,
        config: config3,
        round: round2
      } = _ref;
      return typed2(name39, {
        number: function number2(x) {
          if (nearlyEqual(x, round2(x), config3.epsilon)) {
            return round2(x);
          } else {
            return Math.ceil(x);
          }
        },
        "number, number": function numberNumber(x, n) {
          if (nearlyEqual(x, round2(x, n), config3.epsilon)) {
            return round2(x, n);
          } else {
            var [number2, exponent] = "".concat(x, "e").split("e");
            var result = Math.ceil(Number("".concat(number2, "e").concat(Number(exponent) + n)));
            [number2, exponent] = "".concat(result, "e").split("e");
            return Number("".concat(number2, "e").concat(Number(exponent) - n));
          }
        }
      });
    });
    createCeil = /* @__PURE__ */ factory(name39, dependencies40, (_ref2) => {
      var {
        typed: typed2,
        config: config3,
        round: round2,
        matrix: matrix2,
        equalScalar: equalScalar2,
        zeros: zeros3,
        DenseMatrix: DenseMatrix2
      } = _ref2;
      var algorithm11 = createAlgorithm11({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm12 = createAlgorithm12({
        typed: typed2,
        DenseMatrix: DenseMatrix2
      });
      var algorithm14 = createAlgorithm14({
        typed: typed2
      });
      var ceilNumber = createCeilNumber({
        typed: typed2,
        config: config3,
        round: round2
      });
      return typed2("ceil", {
        number: ceilNumber.signatures.number,
        "number,number": ceilNumber.signatures["number,number"],
        Complex: function Complex3(x) {
          return x.ceil();
        },
        "Complex, number": function ComplexNumber(x, n) {
          return x.ceil(n);
        },
        "Complex, BigNumber": function ComplexBigNumber(x, n) {
          return x.ceil(n.toNumber());
        },
        BigNumber: function BigNumber2(x) {
          if (nearlyEqual2(x, round2(x), config3.epsilon)) {
            return round2(x);
          } else {
            return x.ceil();
          }
        },
        "BigNumber, BigNumber": function BigNumberBigNumber(x, n) {
          if (nearlyEqual2(x, round2(x, n), config3.epsilon)) {
            return round2(x, n);
          } else {
            return x.toDecimalPlaces(n.toNumber(), import_decimal2.default.ROUND_CEIL);
          }
        },
        Fraction: function Fraction3(x) {
          return x.ceil();
        },
        "Fraction, number": function FractionNumber(x, n) {
          return x.ceil(n);
        },
        "Fraction, BigNumber": function FractionBigNumber(x, n) {
          return x.ceil(n.toNumber());
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this, true);
        },
        "Array, number | BigNumber": function ArrayNumberBigNumber(x, n) {
          return deepMap(x, (i2) => this(i2, n), true);
        },
        "SparseMatrix, number | BigNumber": function SparseMatrixNumberBigNumber(x, y) {
          return algorithm11(x, y, this, false);
        },
        "DenseMatrix, number | BigNumber": function DenseMatrixNumberBigNumber(x, y) {
          return algorithm14(x, y, this, false);
        },
        "number | Complex | Fraction | BigNumber, Array": function numberComplexFractionBigNumberArray(x, y) {
          return algorithm14(matrix2(y), x, this, true).valueOf();
        },
        "number | Complex | Fraction | BigNumber, Matrix": function numberComplexFractionBigNumberMatrix(x, y) {
          if (equalScalar2(x, 0))
            return zeros3(y.size(), y.storage());
          if (y.storage() === "dense") {
            return algorithm14(y, x, this, true);
          }
          return algorithm12(y, x, this, true);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/cube.js
var name40, dependencies41, createCube;
var init_cube = __esm({
  "node_modules/mathjs/lib/esm/function/arithmetic/cube.js"() {
    init_factory();
    init_collection();
    init_number2();
    name40 = "cube";
    dependencies41 = ["typed"];
    createCube = /* @__PURE__ */ factory(name40, dependencies41, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2(name40, {
        number: cubeNumber,
        Complex: function Complex3(x) {
          return x.mul(x).mul(x);
        },
        BigNumber: function BigNumber2(x) {
          return x.times(x).times(x);
        },
        Fraction: function Fraction3(x) {
          return x.pow(3);
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this, true);
        },
        Unit: function Unit2(x) {
          return x.pow(3);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/exp.js
var name41, dependencies42, createExp;
var init_exp = __esm({
  "node_modules/mathjs/lib/esm/function/arithmetic/exp.js"() {
    init_factory();
    init_collection();
    init_number2();
    name41 = "exp";
    dependencies42 = ["typed"];
    createExp = /* @__PURE__ */ factory(name41, dependencies42, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2(name41, {
        number: expNumber,
        Complex: function Complex3(x) {
          return x.exp();
        },
        BigNumber: function BigNumber2(x) {
          return x.exp();
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/expm1.js
var name42, dependencies43, createExpm1;
var init_expm1 = __esm({
  "node_modules/mathjs/lib/esm/function/arithmetic/expm1.js"() {
    init_factory();
    init_collection();
    init_number2();
    name42 = "expm1";
    dependencies43 = ["typed", "Complex"];
    createExpm1 = /* @__PURE__ */ factory(name42, dependencies43, (_ref) => {
      var {
        typed: typed2,
        Complex: _Complex
      } = _ref;
      return typed2(name42, {
        number: expm1Number,
        Complex: function Complex3(x) {
          var r = Math.exp(x.re);
          return new _Complex(r * Math.cos(x.im) - 1, r * Math.sin(x.im));
        },
        BigNumber: function BigNumber2(x) {
          return x.exp().minus(1);
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/fix.js
var name43, dependencies44, createFixNumber, createFix;
var init_fix = __esm({
  "node_modules/mathjs/lib/esm/function/arithmetic/fix.js"() {
    init_factory();
    init_collection();
    init_algorithm12();
    init_algorithm14();
    name43 = "fix";
    dependencies44 = ["typed", "Complex", "matrix", "ceil", "floor", "equalScalar", "zeros", "DenseMatrix"];
    createFixNumber = /* @__PURE__ */ factory(name43, ["typed", "ceil", "floor"], (_ref) => {
      var {
        typed: typed2,
        ceil: ceil2,
        floor: floor2
      } = _ref;
      return typed2(name43, {
        number: function number2(x) {
          return x > 0 ? floor2(x) : ceil2(x);
        },
        "number, number": function numberNumber(x, n) {
          return x > 0 ? floor2(x, n) : ceil2(x, n);
        }
      });
    });
    createFix = /* @__PURE__ */ factory(name43, dependencies44, (_ref2) => {
      var {
        typed: typed2,
        Complex: _Complex,
        matrix: matrix2,
        ceil: ceil2,
        floor: floor2,
        equalScalar: equalScalar2,
        zeros: zeros3,
        DenseMatrix: DenseMatrix2
      } = _ref2;
      var algorithm12 = createAlgorithm12({
        typed: typed2,
        DenseMatrix: DenseMatrix2
      });
      var algorithm14 = createAlgorithm14({
        typed: typed2
      });
      var fixNumber = createFixNumber({
        typed: typed2,
        ceil: ceil2,
        floor: floor2
      });
      return typed2("fix", {
        number: fixNumber.signatures.number,
        "number, number | BigNumber": fixNumber.signatures["number,number"],
        Complex: function Complex3(x) {
          return new _Complex(x.re > 0 ? Math.floor(x.re) : Math.ceil(x.re), x.im > 0 ? Math.floor(x.im) : Math.ceil(x.im));
        },
        "Complex, number": function ComplexNumber(x, n) {
          return new _Complex(x.re > 0 ? floor2(x.re, n) : ceil2(x.re, n), x.im > 0 ? floor2(x.im, n) : ceil2(x.im, n));
        },
        "Complex, BigNumber": function ComplexBigNumber(x, bn) {
          var n = bn.toNumber();
          return new _Complex(x.re > 0 ? floor2(x.re, n) : ceil2(x.re, n), x.im > 0 ? floor2(x.im, n) : ceil2(x.im, n));
        },
        BigNumber: function BigNumber2(x) {
          return x.isNegative() ? ceil2(x) : floor2(x);
        },
        "BigNumber, number | BigNumber": function BigNumberNumberBigNumber(x, n) {
          return x.isNegative() ? ceil2(x, n) : floor2(x, n);
        },
        Fraction: function Fraction3(x) {
          return x.s < 0 ? x.ceil() : x.floor();
        },
        "Fraction, number | BigNumber": function FractionNumberBigNumber(x, n) {
          return x.s < 0 ? ceil2(x, n) : floor2(x, n);
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this, true);
        },
        "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(x, n) {
          return deepMap(x, (i2) => this(i2, n), true);
        },
        "number | Complex | Fraction | BigNumber, Array": function numberComplexFractionBigNumberArray(x, y) {
          return algorithm14(matrix2(y), x, this, true).valueOf();
        },
        "number | Complex | Fraction | BigNumber, Matrix": function numberComplexFractionBigNumberMatrix(x, y) {
          if (equalScalar2(x, 0))
            return zeros3(y.size(), y.storage());
          if (y.storage() === "dense") {
            return algorithm14(y, x, this, true);
          }
          return algorithm12(y, x, this, true);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/floor.js
var import_decimal3, name44, dependencies45, createFloorNumber, createFloor;
var init_floor = __esm({
  "node_modules/mathjs/lib/esm/function/arithmetic/floor.js"() {
    import_decimal3 = __toESM(require_decimal(), 1);
    init_factory();
    init_collection();
    init_number();
    init_nearlyEqual();
    init_algorithm11();
    init_algorithm12();
    init_algorithm14();
    name44 = "floor";
    dependencies45 = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "DenseMatrix"];
    createFloorNumber = /* @__PURE__ */ factory(name44, ["typed", "config", "round"], (_ref) => {
      var {
        typed: typed2,
        config: config3,
        round: round2
      } = _ref;
      return typed2(name44, {
        number: function number2(x) {
          if (nearlyEqual(x, round2(x), config3.epsilon)) {
            return round2(x);
          } else {
            return Math.floor(x);
          }
        },
        "number, number": function numberNumber(x, n) {
          if (nearlyEqual(x, round2(x, n), config3.epsilon)) {
            return round2(x, n);
          } else {
            var [number2, exponent] = "".concat(x, "e").split("e");
            var result = Math.floor(Number("".concat(number2, "e").concat(Number(exponent) + n)));
            [number2, exponent] = "".concat(result, "e").split("e");
            return Number("".concat(number2, "e").concat(Number(exponent) - n));
          }
        }
      });
    });
    createFloor = /* @__PURE__ */ factory(name44, dependencies45, (_ref2) => {
      var {
        typed: typed2,
        config: config3,
        round: round2,
        matrix: matrix2,
        equalScalar: equalScalar2,
        zeros: zeros3,
        DenseMatrix: DenseMatrix2
      } = _ref2;
      var algorithm11 = createAlgorithm11({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm12 = createAlgorithm12({
        typed: typed2,
        DenseMatrix: DenseMatrix2
      });
      var algorithm14 = createAlgorithm14({
        typed: typed2
      });
      var floorNumber = createFloorNumber({
        typed: typed2,
        config: config3,
        round: round2
      });
      return typed2("floor", {
        number: floorNumber.signatures.number,
        "number,number": floorNumber.signatures["number,number"],
        Complex: function Complex3(x) {
          return x.floor();
        },
        "Complex, number": function ComplexNumber(x, n) {
          return x.floor(n);
        },
        "Complex, BigNumber": function ComplexBigNumber(x, n) {
          return x.floor(n.toNumber());
        },
        BigNumber: function BigNumber2(x) {
          if (nearlyEqual2(x, round2(x), config3.epsilon)) {
            return round2(x);
          } else {
            return x.floor();
          }
        },
        "BigNumber, BigNumber": function BigNumberBigNumber(x, n) {
          if (nearlyEqual2(x, round2(x, n), config3.epsilon)) {
            return round2(x, n);
          } else {
            return x.toDecimalPlaces(n.toNumber(), import_decimal3.default.ROUND_FLOOR);
          }
        },
        Fraction: function Fraction3(x) {
          return x.floor();
        },
        "Fraction, number": function FractionNumber(x, n) {
          return x.floor(n);
        },
        "Fraction, BigNumber": function FractionBigNumber(x, n) {
          return x.floor(n.toNumber());
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this, true);
        },
        "Array, number | BigNumber": function ArrayNumberBigNumber(x, n) {
          return deepMap(x, (i2) => this(i2, n), true);
        },
        "SparseMatrix, number | BigNumber": function SparseMatrixNumberBigNumber(x, y) {
          return algorithm11(x, y, this, false);
        },
        "DenseMatrix, number | BigNumber": function DenseMatrixNumberBigNumber(x, y) {
          return algorithm14(x, y, this, false);
        },
        "number | Complex | Fraction | BigNumber, Array": function numberComplexFractionBigNumberArray(x, y) {
          return algorithm14(matrix2(y), x, this, true).valueOf();
        },
        "number | Complex | Fraction | BigNumber, Matrix": function numberComplexFractionBigNumberMatrix(x, y) {
          if (equalScalar2(x, 0))
            return zeros3(y.size(), y.storage());
          if (y.storage() === "dense") {
            return algorithm14(y, x, this, true);
          }
          return algorithm12(y, x, this, true);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/type/matrix/utils/algorithm01.js
var name45, dependencies46, createAlgorithm01;
var init_algorithm01 = __esm({
  "node_modules/mathjs/lib/esm/type/matrix/utils/algorithm01.js"() {
    init_factory();
    init_DimensionError();
    name45 = "algorithm01";
    dependencies46 = ["typed"];
    createAlgorithm01 = /* @__PURE__ */ factory(name45, dependencies46, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return function algorithm1(denseMatrix, sparseMatrix, callback, inverse) {
        var adata = denseMatrix._data;
        var asize = denseMatrix._size;
        var adt = denseMatrix._datatype;
        var bvalues = sparseMatrix._values;
        var bindex = sparseMatrix._index;
        var bptr = sparseMatrix._ptr;
        var bsize = sparseMatrix._size;
        var bdt = sparseMatrix._datatype;
        if (asize.length !== bsize.length) {
          throw new DimensionError(asize.length, bsize.length);
        }
        if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
          throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
        }
        if (!bvalues) {
          throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
        }
        var rows = asize[0];
        var columns = asize[1];
        var dt = typeof adt === "string" && adt === bdt ? adt : void 0;
        var cf = dt ? typed2.find(callback, [dt, dt]) : callback;
        var i2, j;
        var cdata = [];
        for (i2 = 0; i2 < rows; i2++) {
          cdata[i2] = [];
        }
        var x = [];
        var w = [];
        for (j = 0; j < columns; j++) {
          var mark = j + 1;
          for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
            i2 = bindex[k];
            x[i2] = inverse ? cf(bvalues[k], adata[i2][j]) : cf(adata[i2][j], bvalues[k]);
            w[i2] = mark;
          }
          for (i2 = 0; i2 < rows; i2++) {
            if (w[i2] === mark) {
              cdata[i2][j] = x[i2];
            } else {
              cdata[i2][j] = adata[i2][j];
            }
          }
        }
        return denseMatrix.createDenseMatrix({
          data: cdata,
          size: [rows, columns],
          datatype: dt
        });
      };
    });
  }
});

// node_modules/mathjs/lib/esm/type/matrix/utils/algorithm04.js
var name46, dependencies47, createAlgorithm04;
var init_algorithm04 = __esm({
  "node_modules/mathjs/lib/esm/type/matrix/utils/algorithm04.js"() {
    init_factory();
    init_DimensionError();
    name46 = "algorithm04";
    dependencies47 = ["typed", "equalScalar"];
    createAlgorithm04 = /* @__PURE__ */ factory(name46, dependencies47, (_ref) => {
      var {
        typed: typed2,
        equalScalar: equalScalar2
      } = _ref;
      return function algorithm04(a, b, callback) {
        var avalues = a._values;
        var aindex = a._index;
        var aptr = a._ptr;
        var asize = a._size;
        var adt = a._datatype;
        var bvalues = b._values;
        var bindex = b._index;
        var bptr = b._ptr;
        var bsize = b._size;
        var bdt = b._datatype;
        if (asize.length !== bsize.length) {
          throw new DimensionError(asize.length, bsize.length);
        }
        if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
          throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
        }
        var rows = asize[0];
        var columns = asize[1];
        var dt;
        var eq = equalScalar2;
        var zero = 0;
        var cf = callback;
        if (typeof adt === "string" && adt === bdt) {
          dt = adt;
          eq = typed2.find(equalScalar2, [dt, dt]);
          zero = typed2.convert(0, dt);
          cf = typed2.find(callback, [dt, dt]);
        }
        var cvalues = avalues && bvalues ? [] : void 0;
        var cindex = [];
        var cptr = [];
        var xa = avalues && bvalues ? [] : void 0;
        var xb = avalues && bvalues ? [] : void 0;
        var wa = [];
        var wb = [];
        var i2, j, k, k0, k1;
        for (j = 0; j < columns; j++) {
          cptr[j] = cindex.length;
          var mark = j + 1;
          for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
            i2 = aindex[k];
            cindex.push(i2);
            wa[i2] = mark;
            if (xa) {
              xa[i2] = avalues[k];
            }
          }
          for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
            i2 = bindex[k];
            if (wa[i2] === mark) {
              if (xa) {
                var v = cf(xa[i2], bvalues[k]);
                if (!eq(v, zero)) {
                  xa[i2] = v;
                } else {
                  wa[i2] = null;
                }
              }
            } else {
              cindex.push(i2);
              wb[i2] = mark;
              if (xb) {
                xb[i2] = bvalues[k];
              }
            }
          }
          if (xa && xb) {
            k = cptr[j];
            while (k < cindex.length) {
              i2 = cindex[k];
              if (wa[i2] === mark) {
                cvalues[k] = xa[i2];
                k++;
              } else if (wb[i2] === mark) {
                cvalues[k] = xb[i2];
                k++;
              } else {
                cindex.splice(k, 1);
              }
            }
          }
        }
        cptr[columns] = cindex.length;
        return a.createSparseMatrix({
          values: cvalues,
          index: cindex,
          ptr: cptr,
          size: [rows, columns],
          datatype: dt
        });
      };
    });
  }
});

// node_modules/mathjs/lib/esm/type/matrix/utils/algorithm10.js
var name47, dependencies48, createAlgorithm10;
var init_algorithm10 = __esm({
  "node_modules/mathjs/lib/esm/type/matrix/utils/algorithm10.js"() {
    init_factory();
    name47 = "algorithm10";
    dependencies48 = ["typed", "DenseMatrix"];
    createAlgorithm10 = /* @__PURE__ */ factory(name47, dependencies48, (_ref) => {
      var {
        typed: typed2,
        DenseMatrix: DenseMatrix2
      } = _ref;
      return function algorithm10(s, b, callback, inverse) {
        var avalues = s._values;
        var aindex = s._index;
        var aptr = s._ptr;
        var asize = s._size;
        var adt = s._datatype;
        if (!avalues) {
          throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
        }
        var rows = asize[0];
        var columns = asize[1];
        var dt;
        var cf = callback;
        if (typeof adt === "string") {
          dt = adt;
          b = typed2.convert(b, dt);
          cf = typed2.find(callback, [dt, dt]);
        }
        var cdata = [];
        var x = [];
        var w = [];
        for (var j = 0; j < columns; j++) {
          var mark = j + 1;
          for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
            var r = aindex[k];
            x[r] = avalues[k];
            w[r] = mark;
          }
          for (var i2 = 0; i2 < rows; i2++) {
            if (j === 0) {
              cdata[i2] = [];
            }
            if (w[i2] === mark) {
              cdata[i2][j] = inverse ? cf(b, x[i2]) : cf(x[i2], b);
            } else {
              cdata[i2][j] = b;
            }
          }
        }
        return new DenseMatrix2({
          data: cdata,
          size: [rows, columns],
          datatype: dt
        });
      };
    });
  }
});

// node_modules/mathjs/lib/esm/type/matrix/utils/algorithm13.js
var name48, dependencies49, createAlgorithm13;
var init_algorithm13 = __esm({
  "node_modules/mathjs/lib/esm/type/matrix/utils/algorithm13.js"() {
    init_factory();
    init_DimensionError();
    name48 = "algorithm13";
    dependencies49 = ["typed"];
    createAlgorithm13 = /* @__PURE__ */ factory(name48, dependencies49, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return function algorithm13(a, b, callback) {
        var adata = a._data;
        var asize = a._size;
        var adt = a._datatype;
        var bdata = b._data;
        var bsize = b._size;
        var bdt = b._datatype;
        var csize = [];
        if (asize.length !== bsize.length) {
          throw new DimensionError(asize.length, bsize.length);
        }
        for (var s = 0; s < asize.length; s++) {
          if (asize[s] !== bsize[s]) {
            throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
          }
          csize[s] = asize[s];
        }
        var dt;
        var cf = callback;
        if (typeof adt === "string" && adt === bdt) {
          dt = adt;
          cf = typed2.find(callback, [dt, dt]);
        }
        var cdata = csize.length > 0 ? _iterate(cf, 0, csize, csize[0], adata, bdata) : [];
        return a.createDenseMatrix({
          data: cdata,
          size: csize,
          datatype: dt
        });
      };
      function _iterate(f, level, s, n, av, bv) {
        var cv = [];
        if (level === s.length - 1) {
          for (var i2 = 0; i2 < n; i2++) {
            cv[i2] = f(av[i2], bv[i2]);
          }
        } else {
          for (var j = 0; j < n; j++) {
            cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv[j]);
          }
        }
        return cv;
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/gcd.js
var name49, dependencies50, createGcd;
var init_gcd = __esm({
  "node_modules/mathjs/lib/esm/function/arithmetic/gcd.js"() {
    init_factory();
    init_algorithm01();
    init_algorithm04();
    init_algorithm10();
    init_algorithm13();
    init_algorithm14();
    init_number2();
    name49 = "gcd";
    dependencies50 = ["typed", "matrix", "equalScalar", "BigNumber", "DenseMatrix"];
    createGcd = /* @__PURE__ */ factory(name49, dependencies50, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        equalScalar: equalScalar2,
        BigNumber: BigNumber2,
        DenseMatrix: DenseMatrix2
      } = _ref;
      var algorithm01 = createAlgorithm01({
        typed: typed2
      });
      var algorithm04 = createAlgorithm04({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm10 = createAlgorithm10({
        typed: typed2,
        DenseMatrix: DenseMatrix2
      });
      var algorithm13 = createAlgorithm13({
        typed: typed2
      });
      var algorithm14 = createAlgorithm14({
        typed: typed2
      });
      return typed2(name49, {
        "number, number": gcdNumber,
        "BigNumber, BigNumber": _gcdBigNumber,
        "Fraction, Fraction": function FractionFraction(x, y) {
          return x.gcd(y);
        },
        "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
          return algorithm04(x, y, this);
        },
        "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
          return algorithm01(y, x, this, true);
        },
        "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
          return algorithm01(x, y, this, false);
        },
        "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
          return algorithm13(x, y, this);
        },
        "Array, Array": function ArrayArray(x, y) {
          return this(matrix2(x), matrix2(y)).valueOf();
        },
        "Array, Matrix": function ArrayMatrix(x, y) {
          return this(matrix2(x), y);
        },
        "Matrix, Array": function MatrixArray(x, y) {
          return this(x, matrix2(y));
        },
        "SparseMatrix, number | BigNumber": function SparseMatrixNumberBigNumber(x, y) {
          return algorithm10(x, y, this, false);
        },
        "DenseMatrix, number | BigNumber": function DenseMatrixNumberBigNumber(x, y) {
          return algorithm14(x, y, this, false);
        },
        "number | BigNumber, SparseMatrix": function numberBigNumberSparseMatrix(x, y) {
          return algorithm10(y, x, this, true);
        },
        "number | BigNumber, DenseMatrix": function numberBigNumberDenseMatrix(x, y) {
          return algorithm14(y, x, this, true);
        },
        "Array, number | BigNumber": function ArrayNumberBigNumber(x, y) {
          return algorithm14(matrix2(x), y, this, false).valueOf();
        },
        "number | BigNumber, Array": function numberBigNumberArray(x, y) {
          return algorithm14(matrix2(y), x, this, true).valueOf();
        },
        "Array | Matrix | number | BigNumber, Array | Matrix | number | BigNumber, ...Array | Matrix | number | BigNumber": function ArrayMatrixNumberBigNumberArrayMatrixNumberBigNumberArrayMatrixNumberBigNumber(a, b, args) {
          var res = this(a, b);
          for (var i2 = 0; i2 < args.length; i2++) {
            res = this(res, args[i2]);
          }
          return res;
        }
      });
      function _gcdBigNumber(a, b) {
        if (!a.isInt() || !b.isInt()) {
          throw new Error("Parameters in function gcd must be integer numbers");
        }
        var zero = new BigNumber2(0);
        while (!b.isZero()) {
          var r = a.mod(b);
          a = b;
          b = r;
        }
        return a.lt(zero) ? a.neg() : a;
      }
    });
  }
});

// node_modules/mathjs/lib/esm/type/matrix/utils/algorithm02.js
var name50, dependencies51, createAlgorithm02;
var init_algorithm02 = __esm({
  "node_modules/mathjs/lib/esm/type/matrix/utils/algorithm02.js"() {
    init_factory();
    init_DimensionError();
    name50 = "algorithm02";
    dependencies51 = ["typed", "equalScalar"];
    createAlgorithm02 = /* @__PURE__ */ factory(name50, dependencies51, (_ref) => {
      var {
        typed: typed2,
        equalScalar: equalScalar2
      } = _ref;
      return function algorithm02(denseMatrix, sparseMatrix, callback, inverse) {
        var adata = denseMatrix._data;
        var asize = denseMatrix._size;
        var adt = denseMatrix._datatype;
        var bvalues = sparseMatrix._values;
        var bindex = sparseMatrix._index;
        var bptr = sparseMatrix._ptr;
        var bsize = sparseMatrix._size;
        var bdt = sparseMatrix._datatype;
        if (asize.length !== bsize.length) {
          throw new DimensionError(asize.length, bsize.length);
        }
        if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
          throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
        }
        if (!bvalues) {
          throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
        }
        var rows = asize[0];
        var columns = asize[1];
        var dt;
        var eq = equalScalar2;
        var zero = 0;
        var cf = callback;
        if (typeof adt === "string" && adt === bdt) {
          dt = adt;
          eq = typed2.find(equalScalar2, [dt, dt]);
          zero = typed2.convert(0, dt);
          cf = typed2.find(callback, [dt, dt]);
        }
        var cvalues = [];
        var cindex = [];
        var cptr = [];
        for (var j = 0; j < columns; j++) {
          cptr[j] = cindex.length;
          for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
            var i2 = bindex[k];
            var cij = inverse ? cf(bvalues[k], adata[i2][j]) : cf(adata[i2][j], bvalues[k]);
            if (!eq(cij, zero)) {
              cindex.push(i2);
              cvalues.push(cij);
            }
          }
        }
        cptr[columns] = cindex.length;
        return sparseMatrix.createSparseMatrix({
          values: cvalues,
          index: cindex,
          ptr: cptr,
          size: [rows, columns],
          datatype: dt
        });
      };
    });
  }
});

// node_modules/mathjs/lib/esm/type/matrix/utils/algorithm06.js
var name51, dependencies52, createAlgorithm06;
var init_algorithm06 = __esm({
  "node_modules/mathjs/lib/esm/type/matrix/utils/algorithm06.js"() {
    init_factory();
    init_DimensionError();
    init_collection();
    name51 = "algorithm06";
    dependencies52 = ["typed", "equalScalar"];
    createAlgorithm06 = /* @__PURE__ */ factory(name51, dependencies52, (_ref) => {
      var {
        typed: typed2,
        equalScalar: equalScalar2
      } = _ref;
      return function algorithm06(a, b, callback) {
        var avalues = a._values;
        var asize = a._size;
        var adt = a._datatype;
        var bvalues = b._values;
        var bsize = b._size;
        var bdt = b._datatype;
        if (asize.length !== bsize.length) {
          throw new DimensionError(asize.length, bsize.length);
        }
        if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
          throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
        }
        var rows = asize[0];
        var columns = asize[1];
        var dt;
        var eq = equalScalar2;
        var zero = 0;
        var cf = callback;
        if (typeof adt === "string" && adt === bdt) {
          dt = adt;
          eq = typed2.find(equalScalar2, [dt, dt]);
          zero = typed2.convert(0, dt);
          cf = typed2.find(callback, [dt, dt]);
        }
        var cvalues = avalues && bvalues ? [] : void 0;
        var cindex = [];
        var cptr = [];
        var x = cvalues ? [] : void 0;
        var w = [];
        var u = [];
        for (var j = 0; j < columns; j++) {
          cptr[j] = cindex.length;
          var mark = j + 1;
          scatter(a, j, w, x, u, mark, cindex, cf);
          scatter(b, j, w, x, u, mark, cindex, cf);
          if (x) {
            var k = cptr[j];
            while (k < cindex.length) {
              var i2 = cindex[k];
              if (u[i2] === mark) {
                var v = x[i2];
                if (!eq(v, zero)) {
                  cvalues.push(v);
                  k++;
                } else {
                  cindex.splice(k, 1);
                }
              } else {
                cindex.splice(k, 1);
              }
            }
          } else {
            var p = cptr[j];
            while (p < cindex.length) {
              var r = cindex[p];
              if (u[r] !== mark) {
                cindex.splice(p, 1);
              } else {
                p++;
              }
            }
          }
        }
        cptr[columns] = cindex.length;
        return a.createSparseMatrix({
          values: cvalues,
          index: cindex,
          ptr: cptr,
          size: [rows, columns],
          datatype: dt
        });
      };
    });
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/lcm.js
var name52, dependencies53, createLcm;
var init_lcm = __esm({
  "node_modules/mathjs/lib/esm/function/arithmetic/lcm.js"() {
    init_factory();
    init_algorithm02();
    init_algorithm06();
    init_algorithm11();
    init_algorithm13();
    init_algorithm14();
    init_number2();
    name52 = "lcm";
    dependencies53 = ["typed", "matrix", "equalScalar"];
    createLcm = /* @__PURE__ */ factory(name52, dependencies53, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        equalScalar: equalScalar2
      } = _ref;
      var algorithm02 = createAlgorithm02({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm06 = createAlgorithm06({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm11 = createAlgorithm11({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm13 = createAlgorithm13({
        typed: typed2
      });
      var algorithm14 = createAlgorithm14({
        typed: typed2
      });
      return typed2(name52, {
        "number, number": lcmNumber,
        "BigNumber, BigNumber": _lcmBigNumber,
        "Fraction, Fraction": function FractionFraction(x, y) {
          return x.lcm(y);
        },
        "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
          return algorithm06(x, y, this);
        },
        "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
          return algorithm02(y, x, this, true);
        },
        "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
          return algorithm02(x, y, this, false);
        },
        "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
          return algorithm13(x, y, this);
        },
        "Array, Array": function ArrayArray(x, y) {
          return this(matrix2(x), matrix2(y)).valueOf();
        },
        "Array, Matrix": function ArrayMatrix(x, y) {
          return this(matrix2(x), y);
        },
        "Matrix, Array": function MatrixArray(x, y) {
          return this(x, matrix2(y));
        },
        "SparseMatrix, number | BigNumber": function SparseMatrixNumberBigNumber(x, y) {
          return algorithm11(x, y, this, false);
        },
        "DenseMatrix, number | BigNumber": function DenseMatrixNumberBigNumber(x, y) {
          return algorithm14(x, y, this, false);
        },
        "number | BigNumber, SparseMatrix": function numberBigNumberSparseMatrix(x, y) {
          return algorithm11(y, x, this, true);
        },
        "number | BigNumber, DenseMatrix": function numberBigNumberDenseMatrix(x, y) {
          return algorithm14(y, x, this, true);
        },
        "Array, number | BigNumber": function ArrayNumberBigNumber(x, y) {
          return algorithm14(matrix2(x), y, this, false).valueOf();
        },
        "number | BigNumber, Array": function numberBigNumberArray(x, y) {
          return algorithm14(matrix2(y), x, this, true).valueOf();
        },
        "Array | Matrix | number | BigNumber, Array | Matrix | number | BigNumber, ...Array | Matrix | number | BigNumber": function ArrayMatrixNumberBigNumberArrayMatrixNumberBigNumberArrayMatrixNumberBigNumber(a, b, args) {
          var res = this(a, b);
          for (var i2 = 0; i2 < args.length; i2++) {
            res = this(res, args[i2]);
          }
          return res;
        }
      });
      function _lcmBigNumber(a, b) {
        if (!a.isInt() || !b.isInt()) {
          throw new Error("Parameters in function lcm must be integer numbers");
        }
        if (a.isZero()) {
          return a;
        }
        if (b.isZero()) {
          return b;
        }
        var prod2 = a.times(b);
        while (!b.isZero()) {
          var t = b;
          b = a.mod(t);
          a = t;
        }
        return prod2.div(a).abs();
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/log10.js
var name53, dependencies54, createLog10;
var init_log10 = __esm({
  "node_modules/mathjs/lib/esm/function/arithmetic/log10.js"() {
    init_factory();
    init_collection();
    init_number2();
    name53 = "log10";
    dependencies54 = ["typed", "config", "Complex"];
    createLog10 = /* @__PURE__ */ factory(name53, dependencies54, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        Complex: _Complex
      } = _ref;
      return typed2(name53, {
        number: function number2(x) {
          if (x >= 0 || config3.predictable) {
            return log10Number(x);
          } else {
            return new _Complex(x, 0).log().div(Math.LN10);
          }
        },
        Complex: function Complex3(x) {
          return new _Complex(x).log().div(Math.LN10);
        },
        BigNumber: function BigNumber2(x) {
          if (!x.isNegative() || config3.predictable) {
            return x.log();
          } else {
            return new _Complex(x.toNumber(), 0).log().div(Math.LN10);
          }
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/log2.js
var name54, dependencies55, createLog2;
var init_log2 = __esm({
  "node_modules/mathjs/lib/esm/function/arithmetic/log2.js"() {
    init_factory();
    init_collection();
    init_number2();
    name54 = "log2";
    dependencies55 = ["typed", "config", "Complex"];
    createLog2 = /* @__PURE__ */ factory(name54, dependencies55, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        Complex: Complex3
      } = _ref;
      return typed2(name54, {
        number: function number2(x) {
          if (x >= 0 || config3.predictable) {
            return log2Number(x);
          } else {
            return _log2Complex(new Complex3(x, 0));
          }
        },
        Complex: _log2Complex,
        BigNumber: function BigNumber2(x) {
          if (!x.isNegative() || config3.predictable) {
            return x.log(2);
          } else {
            return _log2Complex(new Complex3(x.toNumber(), 0));
          }
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
      function _log2Complex(x) {
        var newX = Math.sqrt(x.re * x.re + x.im * x.im);
        return new Complex3(Math.log2 ? Math.log2(newX) : Math.log(newX) / Math.LN2, Math.atan2(x.im, x.re) / Math.LN2);
      }
    });
  }
});

// node_modules/mathjs/lib/esm/type/matrix/utils/algorithm03.js
var name55, dependencies56, createAlgorithm03;
var init_algorithm03 = __esm({
  "node_modules/mathjs/lib/esm/type/matrix/utils/algorithm03.js"() {
    init_factory();
    init_DimensionError();
    name55 = "algorithm03";
    dependencies56 = ["typed"];
    createAlgorithm03 = /* @__PURE__ */ factory(name55, dependencies56, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return function algorithm03(denseMatrix, sparseMatrix, callback, inverse) {
        var adata = denseMatrix._data;
        var asize = denseMatrix._size;
        var adt = denseMatrix._datatype;
        var bvalues = sparseMatrix._values;
        var bindex = sparseMatrix._index;
        var bptr = sparseMatrix._ptr;
        var bsize = sparseMatrix._size;
        var bdt = sparseMatrix._datatype;
        if (asize.length !== bsize.length) {
          throw new DimensionError(asize.length, bsize.length);
        }
        if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
          throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
        }
        if (!bvalues) {
          throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
        }
        var rows = asize[0];
        var columns = asize[1];
        var dt;
        var zero = 0;
        var cf = callback;
        if (typeof adt === "string" && adt === bdt) {
          dt = adt;
          zero = typed2.convert(0, dt);
          cf = typed2.find(callback, [dt, dt]);
        }
        var cdata = [];
        for (var z = 0; z < rows; z++) {
          cdata[z] = [];
        }
        var x = [];
        var w = [];
        for (var j = 0; j < columns; j++) {
          var mark = j + 1;
          for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
            var i2 = bindex[k];
            x[i2] = inverse ? cf(bvalues[k], adata[i2][j]) : cf(adata[i2][j], bvalues[k]);
            w[i2] = mark;
          }
          for (var y = 0; y < rows; y++) {
            if (w[y] === mark) {
              cdata[y][j] = x[y];
            } else {
              cdata[y][j] = inverse ? cf(zero, adata[y][j]) : cf(adata[y][j], zero);
            }
          }
        }
        return denseMatrix.createDenseMatrix({
          data: cdata,
          size: [rows, columns],
          datatype: dt
        });
      };
    });
  }
});

// node_modules/mathjs/lib/esm/type/matrix/utils/algorithm05.js
var name56, dependencies57, createAlgorithm05;
var init_algorithm05 = __esm({
  "node_modules/mathjs/lib/esm/type/matrix/utils/algorithm05.js"() {
    init_factory();
    init_DimensionError();
    name56 = "algorithm05";
    dependencies57 = ["typed", "equalScalar"];
    createAlgorithm05 = /* @__PURE__ */ factory(name56, dependencies57, (_ref) => {
      var {
        typed: typed2,
        equalScalar: equalScalar2
      } = _ref;
      return function algorithm05(a, b, callback) {
        var avalues = a._values;
        var aindex = a._index;
        var aptr = a._ptr;
        var asize = a._size;
        var adt = a._datatype;
        var bvalues = b._values;
        var bindex = b._index;
        var bptr = b._ptr;
        var bsize = b._size;
        var bdt = b._datatype;
        if (asize.length !== bsize.length) {
          throw new DimensionError(asize.length, bsize.length);
        }
        if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
          throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
        }
        var rows = asize[0];
        var columns = asize[1];
        var dt;
        var eq = equalScalar2;
        var zero = 0;
        var cf = callback;
        if (typeof adt === "string" && adt === bdt) {
          dt = adt;
          eq = typed2.find(equalScalar2, [dt, dt]);
          zero = typed2.convert(0, dt);
          cf = typed2.find(callback, [dt, dt]);
        }
        var cvalues = avalues && bvalues ? [] : void 0;
        var cindex = [];
        var cptr = [];
        var xa = cvalues ? [] : void 0;
        var xb = cvalues ? [] : void 0;
        var wa = [];
        var wb = [];
        var i2, j, k, k1;
        for (j = 0; j < columns; j++) {
          cptr[j] = cindex.length;
          var mark = j + 1;
          for (k = aptr[j], k1 = aptr[j + 1]; k < k1; k++) {
            i2 = aindex[k];
            cindex.push(i2);
            wa[i2] = mark;
            if (xa) {
              xa[i2] = avalues[k];
            }
          }
          for (k = bptr[j], k1 = bptr[j + 1]; k < k1; k++) {
            i2 = bindex[k];
            if (wa[i2] !== mark) {
              cindex.push(i2);
            }
            wb[i2] = mark;
            if (xb) {
              xb[i2] = bvalues[k];
            }
          }
          if (cvalues) {
            k = cptr[j];
            while (k < cindex.length) {
              i2 = cindex[k];
              var wai = wa[i2];
              var wbi = wb[i2];
              if (wai === mark || wbi === mark) {
                var va = wai === mark ? xa[i2] : zero;
                var vb = wbi === mark ? xb[i2] : zero;
                var vc = cf(va, vb);
                if (!eq(vc, zero)) {
                  cvalues.push(vc);
                  k++;
                } else {
                  cindex.splice(k, 1);
                }
              }
            }
          }
        }
        cptr[columns] = cindex.length;
        return a.createSparseMatrix({
          values: cvalues,
          index: cindex,
          ptr: cptr,
          size: [rows, columns],
          datatype: dt
        });
      };
    });
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/mod.js
var name57, dependencies58, createMod;
var init_mod = __esm({
  "node_modules/mathjs/lib/esm/function/arithmetic/mod.js"() {
    init_factory();
    init_algorithm02();
    init_algorithm03();
    init_algorithm05();
    init_algorithm11();
    init_algorithm12();
    init_algorithm13();
    init_algorithm14();
    init_number2();
    name57 = "mod";
    dependencies58 = ["typed", "matrix", "equalScalar", "DenseMatrix"];
    createMod = /* @__PURE__ */ factory(name57, dependencies58, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        equalScalar: equalScalar2,
        DenseMatrix: DenseMatrix2
      } = _ref;
      var algorithm02 = createAlgorithm02({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm03 = createAlgorithm03({
        typed: typed2
      });
      var algorithm05 = createAlgorithm05({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm11 = createAlgorithm11({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm12 = createAlgorithm12({
        typed: typed2,
        DenseMatrix: DenseMatrix2
      });
      var algorithm13 = createAlgorithm13({
        typed: typed2
      });
      var algorithm14 = createAlgorithm14({
        typed: typed2
      });
      return typed2(name57, {
        "number, number": modNumber,
        "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
          if (y.isNeg()) {
            throw new Error("Cannot calculate mod for a negative divisor");
          }
          return y.isZero() ? x : x.mod(y);
        },
        "Fraction, Fraction": function FractionFraction(x, y) {
          if (y.compare(0) < 0) {
            throw new Error("Cannot calculate mod for a negative divisor");
          }
          return x.compare(0) >= 0 ? x.mod(y) : x.mod(y).add(y).mod(y);
        },
        "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
          return algorithm05(x, y, this, false);
        },
        "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
          return algorithm02(y, x, this, true);
        },
        "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
          return algorithm03(x, y, this, false);
        },
        "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
          return algorithm13(x, y, this);
        },
        "Array, Array": function ArrayArray(x, y) {
          return this(matrix2(x), matrix2(y)).valueOf();
        },
        "Array, Matrix": function ArrayMatrix(x, y) {
          return this(matrix2(x), y);
        },
        "Matrix, Array": function MatrixArray(x, y) {
          return this(x, matrix2(y));
        },
        "SparseMatrix, any": function SparseMatrixAny(x, y) {
          return algorithm11(x, y, this, false);
        },
        "DenseMatrix, any": function DenseMatrixAny(x, y) {
          return algorithm14(x, y, this, false);
        },
        "any, SparseMatrix": function anySparseMatrix(x, y) {
          return algorithm12(y, x, this, true);
        },
        "any, DenseMatrix": function anyDenseMatrix(x, y) {
          return algorithm14(y, x, this, true);
        },
        "Array, any": function ArrayAny(x, y) {
          return algorithm14(matrix2(x), y, this, false).valueOf();
        },
        "any, Array": function anyArray(x, y) {
          return algorithm14(matrix2(y), x, this, true).valueOf();
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/multiplyScalar.js
var name58, dependencies59, createMultiplyScalar;
var init_multiplyScalar = __esm({
  "node_modules/mathjs/lib/esm/function/arithmetic/multiplyScalar.js"() {
    init_factory();
    init_number2();
    name58 = "multiplyScalar";
    dependencies59 = ["typed"];
    createMultiplyScalar = /* @__PURE__ */ factory(name58, dependencies59, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2("multiplyScalar", {
        "number, number": multiplyNumber,
        "Complex, Complex": function ComplexComplex(x, y) {
          return x.mul(y);
        },
        "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
          return x.times(y);
        },
        "Fraction, Fraction": function FractionFraction(x, y) {
          return x.mul(y);
        },
        "number | Fraction | BigNumber | Complex, Unit": function numberFractionBigNumberComplexUnit(x, y) {
          var res = y.clone();
          res.value = res.value === null ? res._normalize(x) : this(res.value, x);
          return res;
        },
        "Unit, number | Fraction | BigNumber | Complex": function UnitNumberFractionBigNumberComplex(x, y) {
          var res = x.clone();
          res.value = res.value === null ? res._normalize(y) : this(res.value, y);
          return res;
        },
        "Unit, Unit": function UnitUnit(x, y) {
          return x.multiply(y);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/multiply.js
var name59, dependencies60, createMultiply;
var init_multiply = __esm({
  "node_modules/mathjs/lib/esm/function/arithmetic/multiply.js"() {
    init_factory();
    init_is();
    init_object();
    init_array();
    init_algorithm11();
    init_algorithm14();
    name59 = "multiply";
    dependencies60 = ["typed", "matrix", "addScalar", "multiplyScalar", "equalScalar", "dot"];
    createMultiply = /* @__PURE__ */ factory(name59, dependencies60, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        addScalar: addScalar2,
        multiplyScalar: multiplyScalar2,
        equalScalar: equalScalar2,
        dot: dot2
      } = _ref;
      var algorithm11 = createAlgorithm11({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm14 = createAlgorithm14({
        typed: typed2
      });
      function _validateMatrixDimensions(size1, size2) {
        switch (size1.length) {
          case 1:
            switch (size2.length) {
              case 1:
                if (size1[0] !== size2[0]) {
                  throw new RangeError("Dimension mismatch in multiplication. Vectors must have the same length");
                }
                break;
              case 2:
                if (size1[0] !== size2[0]) {
                  throw new RangeError("Dimension mismatch in multiplication. Vector length (" + size1[0] + ") must match Matrix rows (" + size2[0] + ")");
                }
                break;
              default:
                throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + size2.length + " dimensions)");
            }
            break;
          case 2:
            switch (size2.length) {
              case 1:
                if (size1[1] !== size2[0]) {
                  throw new RangeError("Dimension mismatch in multiplication. Matrix columns (" + size1[1] + ") must match Vector length (" + size2[0] + ")");
                }
                break;
              case 2:
                if (size1[1] !== size2[0]) {
                  throw new RangeError("Dimension mismatch in multiplication. Matrix A columns (" + size1[1] + ") must match Matrix B rows (" + size2[0] + ")");
                }
                break;
              default:
                throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + size2.length + " dimensions)");
            }
            break;
          default:
            throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix A has " + size1.length + " dimensions)");
        }
      }
      function _multiplyVectorVector(a, b, n) {
        if (n === 0) {
          throw new Error("Cannot multiply two empty vectors");
        }
        return dot2(a, b);
      }
      function _multiplyVectorMatrix(a, b) {
        if (b.storage() !== "dense") {
          throw new Error("Support for SparseMatrix not implemented");
        }
        return _multiplyVectorDenseMatrix(a, b);
      }
      function _multiplyVectorDenseMatrix(a, b) {
        var adata = a._data;
        var asize = a._size;
        var adt = a._datatype;
        var bdata = b._data;
        var bsize = b._size;
        var bdt = b._datatype;
        var alength = asize[0];
        var bcolumns = bsize[1];
        var dt;
        var af = addScalar2;
        var mf = multiplyScalar2;
        if (adt && bdt && adt === bdt && typeof adt === "string") {
          dt = adt;
          af = typed2.find(addScalar2, [dt, dt]);
          mf = typed2.find(multiplyScalar2, [dt, dt]);
        }
        var c = [];
        for (var j = 0; j < bcolumns; j++) {
          var sum2 = mf(adata[0], bdata[0][j]);
          for (var i2 = 1; i2 < alength; i2++) {
            sum2 = af(sum2, mf(adata[i2], bdata[i2][j]));
          }
          c[j] = sum2;
        }
        return a.createDenseMatrix({
          data: c,
          size: [bcolumns],
          datatype: dt
        });
      }
      var _multiplyMatrixVector = typed2("_multiplyMatrixVector", {
        "DenseMatrix, any": _multiplyDenseMatrixVector,
        "SparseMatrix, any": _multiplySparseMatrixVector
      });
      var _multiplyMatrixMatrix = typed2("_multiplyMatrixMatrix", {
        "DenseMatrix, DenseMatrix": _multiplyDenseMatrixDenseMatrix,
        "DenseMatrix, SparseMatrix": _multiplyDenseMatrixSparseMatrix,
        "SparseMatrix, DenseMatrix": _multiplySparseMatrixDenseMatrix,
        "SparseMatrix, SparseMatrix": _multiplySparseMatrixSparseMatrix
      });
      function _multiplyDenseMatrixVector(a, b) {
        var adata = a._data;
        var asize = a._size;
        var adt = a._datatype;
        var bdata = b._data;
        var bdt = b._datatype;
        var arows = asize[0];
        var acolumns = asize[1];
        var dt;
        var af = addScalar2;
        var mf = multiplyScalar2;
        if (adt && bdt && adt === bdt && typeof adt === "string") {
          dt = adt;
          af = typed2.find(addScalar2, [dt, dt]);
          mf = typed2.find(multiplyScalar2, [dt, dt]);
        }
        var c = [];
        for (var i2 = 0; i2 < arows; i2++) {
          var row2 = adata[i2];
          var sum2 = mf(row2[0], bdata[0]);
          for (var j = 1; j < acolumns; j++) {
            sum2 = af(sum2, mf(row2[j], bdata[j]));
          }
          c[i2] = sum2;
        }
        return a.createDenseMatrix({
          data: c,
          size: [arows],
          datatype: dt
        });
      }
      function _multiplyDenseMatrixDenseMatrix(a, b) {
        var adata = a._data;
        var asize = a._size;
        var adt = a._datatype;
        var bdata = b._data;
        var bsize = b._size;
        var bdt = b._datatype;
        var arows = asize[0];
        var acolumns = asize[1];
        var bcolumns = bsize[1];
        var dt;
        var af = addScalar2;
        var mf = multiplyScalar2;
        if (adt && bdt && adt === bdt && typeof adt === "string") {
          dt = adt;
          af = typed2.find(addScalar2, [dt, dt]);
          mf = typed2.find(multiplyScalar2, [dt, dt]);
        }
        var c = [];
        for (var i2 = 0; i2 < arows; i2++) {
          var row2 = adata[i2];
          c[i2] = [];
          for (var j = 0; j < bcolumns; j++) {
            var sum2 = mf(row2[0], bdata[0][j]);
            for (var x = 1; x < acolumns; x++) {
              sum2 = af(sum2, mf(row2[x], bdata[x][j]));
            }
            c[i2][j] = sum2;
          }
        }
        return a.createDenseMatrix({
          data: c,
          size: [arows, bcolumns],
          datatype: dt
        });
      }
      function _multiplyDenseMatrixSparseMatrix(a, b) {
        var adata = a._data;
        var asize = a._size;
        var adt = a._datatype;
        var bvalues = b._values;
        var bindex = b._index;
        var bptr = b._ptr;
        var bsize = b._size;
        var bdt = b._datatype;
        if (!bvalues) {
          throw new Error("Cannot multiply Dense Matrix times Pattern only Matrix");
        }
        var arows = asize[0];
        var bcolumns = bsize[1];
        var dt;
        var af = addScalar2;
        var mf = multiplyScalar2;
        var eq = equalScalar2;
        var zero = 0;
        if (adt && bdt && adt === bdt && typeof adt === "string") {
          dt = adt;
          af = typed2.find(addScalar2, [dt, dt]);
          mf = typed2.find(multiplyScalar2, [dt, dt]);
          eq = typed2.find(equalScalar2, [dt, dt]);
          zero = typed2.convert(0, dt);
        }
        var cvalues = [];
        var cindex = [];
        var cptr = [];
        var c = b.createSparseMatrix({
          values: cvalues,
          index: cindex,
          ptr: cptr,
          size: [arows, bcolumns],
          datatype: dt
        });
        for (var jb = 0; jb < bcolumns; jb++) {
          cptr[jb] = cindex.length;
          var kb0 = bptr[jb];
          var kb1 = bptr[jb + 1];
          if (kb1 > kb0) {
            var last = 0;
            for (var i2 = 0; i2 < arows; i2++) {
              var mark = i2 + 1;
              var cij = void 0;
              for (var kb = kb0; kb < kb1; kb++) {
                var ib = bindex[kb];
                if (last !== mark) {
                  cij = mf(adata[i2][ib], bvalues[kb]);
                  last = mark;
                } else {
                  cij = af(cij, mf(adata[i2][ib], bvalues[kb]));
                }
              }
              if (last === mark && !eq(cij, zero)) {
                cindex.push(i2);
                cvalues.push(cij);
              }
            }
          }
        }
        cptr[bcolumns] = cindex.length;
        return c;
      }
      function _multiplySparseMatrixVector(a, b) {
        var avalues = a._values;
        var aindex = a._index;
        var aptr = a._ptr;
        var adt = a._datatype;
        if (!avalues) {
          throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
        }
        var bdata = b._data;
        var bdt = b._datatype;
        var arows = a._size[0];
        var brows = b._size[0];
        var cvalues = [];
        var cindex = [];
        var cptr = [];
        var dt;
        var af = addScalar2;
        var mf = multiplyScalar2;
        var eq = equalScalar2;
        var zero = 0;
        if (adt && bdt && adt === bdt && typeof adt === "string") {
          dt = adt;
          af = typed2.find(addScalar2, [dt, dt]);
          mf = typed2.find(multiplyScalar2, [dt, dt]);
          eq = typed2.find(equalScalar2, [dt, dt]);
          zero = typed2.convert(0, dt);
        }
        var x = [];
        var w = [];
        cptr[0] = 0;
        for (var ib = 0; ib < brows; ib++) {
          var vbi = bdata[ib];
          if (!eq(vbi, zero)) {
            for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
              var ia = aindex[ka];
              if (!w[ia]) {
                w[ia] = true;
                cindex.push(ia);
                x[ia] = mf(vbi, avalues[ka]);
              } else {
                x[ia] = af(x[ia], mf(vbi, avalues[ka]));
              }
            }
          }
        }
        for (var p1 = cindex.length, p = 0; p < p1; p++) {
          var ic = cindex[p];
          cvalues[p] = x[ic];
        }
        cptr[1] = cindex.length;
        return a.createSparseMatrix({
          values: cvalues,
          index: cindex,
          ptr: cptr,
          size: [arows, 1],
          datatype: dt
        });
      }
      function _multiplySparseMatrixDenseMatrix(a, b) {
        var avalues = a._values;
        var aindex = a._index;
        var aptr = a._ptr;
        var adt = a._datatype;
        if (!avalues) {
          throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
        }
        var bdata = b._data;
        var bdt = b._datatype;
        var arows = a._size[0];
        var brows = b._size[0];
        var bcolumns = b._size[1];
        var dt;
        var af = addScalar2;
        var mf = multiplyScalar2;
        var eq = equalScalar2;
        var zero = 0;
        if (adt && bdt && adt === bdt && typeof adt === "string") {
          dt = adt;
          af = typed2.find(addScalar2, [dt, dt]);
          mf = typed2.find(multiplyScalar2, [dt, dt]);
          eq = typed2.find(equalScalar2, [dt, dt]);
          zero = typed2.convert(0, dt);
        }
        var cvalues = [];
        var cindex = [];
        var cptr = [];
        var c = a.createSparseMatrix({
          values: cvalues,
          index: cindex,
          ptr: cptr,
          size: [arows, bcolumns],
          datatype: dt
        });
        var x = [];
        var w = [];
        for (var jb = 0; jb < bcolumns; jb++) {
          cptr[jb] = cindex.length;
          var mark = jb + 1;
          for (var ib = 0; ib < brows; ib++) {
            var vbij = bdata[ib][jb];
            if (!eq(vbij, zero)) {
              for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
                var ia = aindex[ka];
                if (w[ia] !== mark) {
                  w[ia] = mark;
                  cindex.push(ia);
                  x[ia] = mf(vbij, avalues[ka]);
                } else {
                  x[ia] = af(x[ia], mf(vbij, avalues[ka]));
                }
              }
            }
          }
          for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
            var ic = cindex[p];
            cvalues[p] = x[ic];
          }
        }
        cptr[bcolumns] = cindex.length;
        return c;
      }
      function _multiplySparseMatrixSparseMatrix(a, b) {
        var avalues = a._values;
        var aindex = a._index;
        var aptr = a._ptr;
        var adt = a._datatype;
        var bvalues = b._values;
        var bindex = b._index;
        var bptr = b._ptr;
        var bdt = b._datatype;
        var arows = a._size[0];
        var bcolumns = b._size[1];
        var values = avalues && bvalues;
        var dt;
        var af = addScalar2;
        var mf = multiplyScalar2;
        if (adt && bdt && adt === bdt && typeof adt === "string") {
          dt = adt;
          af = typed2.find(addScalar2, [dt, dt]);
          mf = typed2.find(multiplyScalar2, [dt, dt]);
        }
        var cvalues = values ? [] : void 0;
        var cindex = [];
        var cptr = [];
        var c = a.createSparseMatrix({
          values: cvalues,
          index: cindex,
          ptr: cptr,
          size: [arows, bcolumns],
          datatype: dt
        });
        var x = values ? [] : void 0;
        var w = [];
        var ka, ka0, ka1, kb, kb0, kb1, ia, ib;
        for (var jb = 0; jb < bcolumns; jb++) {
          cptr[jb] = cindex.length;
          var mark = jb + 1;
          for (kb0 = bptr[jb], kb1 = bptr[jb + 1], kb = kb0; kb < kb1; kb++) {
            ib = bindex[kb];
            if (values) {
              for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
                ia = aindex[ka];
                if (w[ia] !== mark) {
                  w[ia] = mark;
                  cindex.push(ia);
                  x[ia] = mf(bvalues[kb], avalues[ka]);
                } else {
                  x[ia] = af(x[ia], mf(bvalues[kb], avalues[ka]));
                }
              }
            } else {
              for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
                ia = aindex[ka];
                if (w[ia] !== mark) {
                  w[ia] = mark;
                  cindex.push(ia);
                }
              }
            }
          }
          if (values) {
            for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
              var ic = cindex[p];
              cvalues[p] = x[ic];
            }
          }
        }
        cptr[bcolumns] = cindex.length;
        return c;
      }
      return typed2(name59, extend({
        "Array, Array": function ArrayArray(x, y) {
          _validateMatrixDimensions(arraySize(x), arraySize(y));
          var m = this(matrix2(x), matrix2(y));
          return isMatrix(m) ? m.valueOf() : m;
        },
        "Matrix, Matrix": function MatrixMatrix(x, y) {
          var xsize = x.size();
          var ysize = y.size();
          _validateMatrixDimensions(xsize, ysize);
          if (xsize.length === 1) {
            if (ysize.length === 1) {
              return _multiplyVectorVector(x, y, xsize[0]);
            }
            return _multiplyVectorMatrix(x, y);
          }
          if (ysize.length === 1) {
            return _multiplyMatrixVector(x, y);
          }
          return _multiplyMatrixMatrix(x, y);
        },
        "Matrix, Array": function MatrixArray(x, y) {
          return this(x, matrix2(y));
        },
        "Array, Matrix": function ArrayMatrix(x, y) {
          return this(matrix2(x, y.storage()), y);
        },
        "SparseMatrix, any": function SparseMatrixAny(x, y) {
          return algorithm11(x, y, multiplyScalar2, false);
        },
        "DenseMatrix, any": function DenseMatrixAny(x, y) {
          return algorithm14(x, y, multiplyScalar2, false);
        },
        "any, SparseMatrix": function anySparseMatrix(x, y) {
          return algorithm11(y, x, multiplyScalar2, true);
        },
        "any, DenseMatrix": function anyDenseMatrix(x, y) {
          return algorithm14(y, x, multiplyScalar2, true);
        },
        "Array, any": function ArrayAny(x, y) {
          return algorithm14(matrix2(x), y, multiplyScalar2, false).valueOf();
        },
        "any, Array": function anyArray(x, y) {
          return algorithm14(matrix2(y), x, multiplyScalar2, true).valueOf();
        },
        "any, any": multiplyScalar2,
        "any, any, ...any": function anyAnyAny(x, y, rest) {
          var result = this(x, y);
          for (var i2 = 0; i2 < rest.length; i2++) {
            result = this(result, rest[i2]);
          }
          return result;
        }
      }, multiplyScalar2.signatures));
    });
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/nthRoot.js
var name60, dependencies61, createNthRoot;
var init_nthRoot = __esm({
  "node_modules/mathjs/lib/esm/function/arithmetic/nthRoot.js"() {
    init_factory();
    init_algorithm01();
    init_algorithm02();
    init_algorithm06();
    init_algorithm11();
    init_algorithm13();
    init_algorithm14();
    init_number2();
    name60 = "nthRoot";
    dependencies61 = ["typed", "matrix", "equalScalar", "BigNumber"];
    createNthRoot = /* @__PURE__ */ factory(name60, dependencies61, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        equalScalar: equalScalar2,
        BigNumber: _BigNumber
      } = _ref;
      var algorithm01 = createAlgorithm01({
        typed: typed2
      });
      var algorithm02 = createAlgorithm02({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm06 = createAlgorithm06({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm11 = createAlgorithm11({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm13 = createAlgorithm13({
        typed: typed2
      });
      var algorithm14 = createAlgorithm14({
        typed: typed2
      });
      var complexErr = "Complex number not supported in function nthRoot. Use nthRoots instead.";
      return typed2(name60, {
        number: nthRootNumber,
        "number, number": nthRootNumber,
        BigNumber: function BigNumber2(x) {
          return _bigNthRoot(x, new _BigNumber(2));
        },
        Complex: function Complex3(x) {
          throw new Error(complexErr);
        },
        "Complex, number": function ComplexNumber(x, y) {
          throw new Error(complexErr);
        },
        "BigNumber, BigNumber": _bigNthRoot,
        "Array | Matrix": function ArrayMatrix(x) {
          return this(x, 2);
        },
        "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
          if (y.density() === 1) {
            return algorithm06(x, y, this);
          } else {
            throw new Error("Root must be non-zero");
          }
        },
        "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
          return algorithm02(y, x, this, true);
        },
        "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
          if (y.density() === 1) {
            return algorithm01(x, y, this, false);
          } else {
            throw new Error("Root must be non-zero");
          }
        },
        "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
          return algorithm13(x, y, this);
        },
        "Array, Array": function ArrayArray(x, y) {
          return this(matrix2(x), matrix2(y)).valueOf();
        },
        "Array, Matrix": function ArrayMatrix(x, y) {
          return this(matrix2(x), y);
        },
        "Matrix, Array": function MatrixArray(x, y) {
          return this(x, matrix2(y));
        },
        "SparseMatrix, number | BigNumber": function SparseMatrixNumberBigNumber(x, y) {
          return algorithm11(x, y, this, false);
        },
        "DenseMatrix, number | BigNumber": function DenseMatrixNumberBigNumber(x, y) {
          return algorithm14(x, y, this, false);
        },
        "number | BigNumber, SparseMatrix": function numberBigNumberSparseMatrix(x, y) {
          if (y.density() === 1) {
            return algorithm11(y, x, this, true);
          } else {
            throw new Error("Root must be non-zero");
          }
        },
        "number | BigNumber, DenseMatrix": function numberBigNumberDenseMatrix(x, y) {
          return algorithm14(y, x, this, true);
        },
        "Array, number | BigNumber": function ArrayNumberBigNumber(x, y) {
          return this(matrix2(x), y).valueOf();
        },
        "number | BigNumber, Array": function numberBigNumberArray(x, y) {
          return this(x, matrix2(y)).valueOf();
        }
      });
      function _bigNthRoot(a, root) {
        var precision = _BigNumber.precision;
        var Big = _BigNumber.clone({
          precision: precision + 2
        });
        var zero = new _BigNumber(0);
        var one = new Big(1);
        var inv2 = root.isNegative();
        if (inv2) {
          root = root.neg();
        }
        if (root.isZero()) {
          throw new Error("Root must be non-zero");
        }
        if (a.isNegative() && !root.abs().mod(2).equals(1)) {
          throw new Error("Root must be odd when a is negative.");
        }
        if (a.isZero()) {
          return inv2 ? new Big(Infinity) : 0;
        }
        if (!a.isFinite()) {
          return inv2 ? zero : a;
        }
        var x = a.abs().pow(one.div(root));
        x = a.isNeg() ? x.neg() : x;
        return new _BigNumber((inv2 ? one.div(x) : x).toPrecision(precision));
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/sign.js
var name61, dependencies62, createSign;
var init_sign = __esm({
  "node_modules/mathjs/lib/esm/function/arithmetic/sign.js"() {
    init_factory();
    init_collection();
    init_number2();
    name61 = "sign";
    dependencies62 = ["typed", "BigNumber", "Fraction", "complex"];
    createSign = /* @__PURE__ */ factory(name61, dependencies62, (_ref) => {
      var {
        typed: typed2,
        BigNumber: _BigNumber,
        complex: complex2,
        Fraction: _Fraction
      } = _ref;
      return typed2(name61, {
        number: signNumber,
        Complex: function Complex3(x) {
          return x.im === 0 ? complex2(signNumber(x.re)) : x.sign();
        },
        BigNumber: function BigNumber2(x) {
          return new _BigNumber(x.cmp(0));
        },
        Fraction: function Fraction3(x) {
          return new _Fraction(x.s, 1);
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this, true);
        },
        Unit: function Unit2(x) {
          if (!x._isDerived() && x.units[0].unit.offset !== 0) {
            throw new TypeError("sign is ambiguous for units with offset");
          }
          return this(x.value);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/sqrt.js
var name62, dependencies63, createSqrt;
var init_sqrt = __esm({
  "node_modules/mathjs/lib/esm/function/arithmetic/sqrt.js"() {
    init_factory();
    init_collection();
    name62 = "sqrt";
    dependencies63 = ["config", "typed", "Complex"];
    createSqrt = /* @__PURE__ */ factory(name62, dependencies63, (_ref) => {
      var {
        config: config3,
        typed: typed2,
        Complex: Complex3
      } = _ref;
      return typed2("sqrt", {
        number: _sqrtNumber,
        Complex: function Complex4(x) {
          return x.sqrt();
        },
        BigNumber: function BigNumber2(x) {
          if (!x.isNegative() || config3.predictable) {
            return x.sqrt();
          } else {
            return _sqrtNumber(x.toNumber());
          }
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this, true);
        },
        Unit: function Unit2(x) {
          return x.pow(0.5);
        }
      });
      function _sqrtNumber(x) {
        if (isNaN(x)) {
          return NaN;
        } else if (x >= 0 || config3.predictable) {
          return Math.sqrt(x);
        } else {
          return new Complex3(x, 0).sqrt();
        }
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/square.js
var name63, dependencies64, createSquare;
var init_square = __esm({
  "node_modules/mathjs/lib/esm/function/arithmetic/square.js"() {
    init_factory();
    init_collection();
    init_number2();
    name63 = "square";
    dependencies64 = ["typed"];
    createSquare = /* @__PURE__ */ factory(name63, dependencies64, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2(name63, {
        number: squareNumber,
        Complex: function Complex3(x) {
          return x.mul(x);
        },
        BigNumber: function BigNumber2(x) {
          return x.times(x);
        },
        Fraction: function Fraction3(x) {
          return x.mul(x);
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this, true);
        },
        Unit: function Unit2(x) {
          return x.pow(2);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/subtract.js
function checkEqualDimensions(x, y) {
  var xsize = x.size();
  var ysize = y.size();
  if (xsize.length !== ysize.length) {
    throw new DimensionError(xsize.length, ysize.length);
  }
}
var name64, dependencies65, createSubtract;
var init_subtract = __esm({
  "node_modules/mathjs/lib/esm/function/arithmetic/subtract.js"() {
    init_factory();
    init_DimensionError();
    init_algorithm01();
    init_algorithm03();
    init_algorithm05();
    init_algorithm10();
    init_algorithm13();
    init_algorithm14();
    name64 = "subtract";
    dependencies65 = ["typed", "matrix", "equalScalar", "addScalar", "unaryMinus", "DenseMatrix"];
    createSubtract = /* @__PURE__ */ factory(name64, dependencies65, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        equalScalar: equalScalar2,
        addScalar: addScalar2,
        unaryMinus: unaryMinus2,
        DenseMatrix: DenseMatrix2
      } = _ref;
      var algorithm01 = createAlgorithm01({
        typed: typed2
      });
      var algorithm03 = createAlgorithm03({
        typed: typed2
      });
      var algorithm05 = createAlgorithm05({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm10 = createAlgorithm10({
        typed: typed2,
        DenseMatrix: DenseMatrix2
      });
      var algorithm13 = createAlgorithm13({
        typed: typed2
      });
      var algorithm14 = createAlgorithm14({
        typed: typed2
      });
      return typed2(name64, {
        "number, number": function numberNumber(x, y) {
          return x - y;
        },
        "Complex, Complex": function ComplexComplex(x, y) {
          return x.sub(y);
        },
        "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
          return x.minus(y);
        },
        "Fraction, Fraction": function FractionFraction(x, y) {
          return x.sub(y);
        },
        "Unit, Unit": function UnitUnit(x, y) {
          if (x.value === null) {
            throw new Error("Parameter x contains a unit with undefined value");
          }
          if (y.value === null) {
            throw new Error("Parameter y contains a unit with undefined value");
          }
          if (!x.equalBase(y)) {
            throw new Error("Units do not match");
          }
          var res = x.clone();
          res.value = this(res.value, y.value);
          res.fixPrefix = false;
          return res;
        },
        "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
          checkEqualDimensions(x, y);
          return algorithm05(x, y, this);
        },
        "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
          checkEqualDimensions(x, y);
          return algorithm03(y, x, this, true);
        },
        "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
          checkEqualDimensions(x, y);
          return algorithm01(x, y, this, false);
        },
        "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
          checkEqualDimensions(x, y);
          return algorithm13(x, y, this);
        },
        "Array, Array": function ArrayArray(x, y) {
          return this(matrix2(x), matrix2(y)).valueOf();
        },
        "Array, Matrix": function ArrayMatrix(x, y) {
          return this(matrix2(x), y);
        },
        "Matrix, Array": function MatrixArray(x, y) {
          return this(x, matrix2(y));
        },
        "SparseMatrix, any": function SparseMatrixAny(x, y) {
          return algorithm10(x, unaryMinus2(y), addScalar2);
        },
        "DenseMatrix, any": function DenseMatrixAny(x, y) {
          return algorithm14(x, y, this);
        },
        "any, SparseMatrix": function anySparseMatrix(x, y) {
          return algorithm10(y, x, this, true);
        },
        "any, DenseMatrix": function anyDenseMatrix(x, y) {
          return algorithm14(y, x, this, true);
        },
        "Array, any": function ArrayAny(x, y) {
          return algorithm14(matrix2(x), y, this, false).valueOf();
        },
        "any, Array": function anyArray(x, y) {
          return algorithm14(matrix2(y), x, this, true).valueOf();
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/xgcd.js
var name65, dependencies66, createXgcd;
var init_xgcd = __esm({
  "node_modules/mathjs/lib/esm/function/arithmetic/xgcd.js"() {
    init_factory();
    init_number2();
    name65 = "xgcd";
    dependencies66 = ["typed", "config", "matrix", "BigNumber"];
    createXgcd = /* @__PURE__ */ factory(name65, dependencies66, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        matrix: matrix2,
        BigNumber: BigNumber2
      } = _ref;
      return typed2(name65, {
        "number, number": function numberNumber(a, b) {
          var res = xgcdNumber(a, b);
          return config3.matrix === "Array" ? res : matrix2(res);
        },
        "BigNumber, BigNumber": _xgcdBigNumber
      });
      function _xgcdBigNumber(a, b) {
        var t;
        var q;
        var r;
        var zero = new BigNumber2(0);
        var one = new BigNumber2(1);
        var x = zero;
        var lastx = one;
        var y = one;
        var lasty = zero;
        if (!a.isInt() || !b.isInt()) {
          throw new Error("Parameters in function xgcd must be integer numbers");
        }
        while (!b.isZero()) {
          q = a.div(b).floor();
          r = a.mod(b);
          t = x;
          x = lastx.minus(q.times(x));
          lastx = t;
          t = y;
          y = lasty.minus(q.times(y));
          lasty = t;
          a = b;
          b = r;
        }
        var res;
        if (a.lt(zero)) {
          res = [a.neg(), lastx.neg(), lasty.neg()];
        } else {
          res = [a, !a.isZero() ? lastx : 0, lasty];
        }
        return config3.matrix === "Array" ? res : matrix2(res);
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/invmod.js
var name66, dependencies67, createInvmod;
var init_invmod = __esm({
  "node_modules/mathjs/lib/esm/function/arithmetic/invmod.js"() {
    init_factory();
    name66 = "invmod";
    dependencies67 = ["typed", "config", "BigNumber", "xgcd", "equal", "smaller", "mod", "add", "isInteger"];
    createInvmod = /* @__PURE__ */ factory(name66, dependencies67, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        BigNumber: BigNumber2,
        xgcd: xgcd2,
        equal: equal2,
        smaller: smaller2,
        mod: mod2,
        add: add2,
        isInteger: isInteger3
      } = _ref;
      return typed2(name66, {
        "number, number": invmod2,
        "BigNumber, BigNumber": invmod2
      });
      function invmod2(a, b) {
        if (!isInteger3(a) || !isInteger3(b))
          throw new Error("Parameters in function invmod must be integer numbers");
        a = mod2(a, b);
        if (equal2(b, 0))
          throw new Error("Divisor must be non zero");
        var res = xgcd2(a, b);
        res = res.valueOf();
        var [gcd2, inv2] = res;
        if (!equal2(gcd2, BigNumber2(1)))
          return NaN;
        inv2 = mod2(inv2, b);
        if (smaller2(inv2, BigNumber2(0)))
          inv2 = add2(inv2, b);
        return inv2;
      }
    });
  }
});

// node_modules/mathjs/lib/esm/type/matrix/utils/algorithm09.js
var name67, dependencies68, createAlgorithm09;
var init_algorithm09 = __esm({
  "node_modules/mathjs/lib/esm/type/matrix/utils/algorithm09.js"() {
    init_factory();
    init_DimensionError();
    name67 = "algorithm09";
    dependencies68 = ["typed", "equalScalar"];
    createAlgorithm09 = /* @__PURE__ */ factory(name67, dependencies68, (_ref) => {
      var {
        typed: typed2,
        equalScalar: equalScalar2
      } = _ref;
      return function algorithm09(a, b, callback) {
        var avalues = a._values;
        var aindex = a._index;
        var aptr = a._ptr;
        var asize = a._size;
        var adt = a._datatype;
        var bvalues = b._values;
        var bindex = b._index;
        var bptr = b._ptr;
        var bsize = b._size;
        var bdt = b._datatype;
        if (asize.length !== bsize.length) {
          throw new DimensionError(asize.length, bsize.length);
        }
        if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
          throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
        }
        var rows = asize[0];
        var columns = asize[1];
        var dt;
        var eq = equalScalar2;
        var zero = 0;
        var cf = callback;
        if (typeof adt === "string" && adt === bdt) {
          dt = adt;
          eq = typed2.find(equalScalar2, [dt, dt]);
          zero = typed2.convert(0, dt);
          cf = typed2.find(callback, [dt, dt]);
        }
        var cvalues = avalues && bvalues ? [] : void 0;
        var cindex = [];
        var cptr = [];
        var x = cvalues ? [] : void 0;
        var w = [];
        var i2, j, k, k0, k1;
        for (j = 0; j < columns; j++) {
          cptr[j] = cindex.length;
          var mark = j + 1;
          if (x) {
            for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
              i2 = bindex[k];
              w[i2] = mark;
              x[i2] = bvalues[k];
            }
          }
          for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
            i2 = aindex[k];
            if (x) {
              var vb = w[i2] === mark ? x[i2] : zero;
              var vc = cf(avalues[k], vb);
              if (!eq(vc, zero)) {
                cindex.push(i2);
                cvalues.push(vc);
              }
            } else {
              cindex.push(i2);
            }
          }
        }
        cptr[columns] = cindex.length;
        return a.createSparseMatrix({
          values: cvalues,
          index: cindex,
          ptr: cptr,
          size: [rows, columns],
          datatype: dt
        });
      };
    });
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/dotMultiply.js
var name68, dependencies69, createDotMultiply;
var init_dotMultiply = __esm({
  "node_modules/mathjs/lib/esm/function/arithmetic/dotMultiply.js"() {
    init_factory();
    init_algorithm02();
    init_algorithm09();
    init_algorithm11();
    init_algorithm13();
    init_algorithm14();
    name68 = "dotMultiply";
    dependencies69 = ["typed", "matrix", "equalScalar", "multiplyScalar"];
    createDotMultiply = /* @__PURE__ */ factory(name68, dependencies69, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        equalScalar: equalScalar2,
        multiplyScalar: multiplyScalar2
      } = _ref;
      var algorithm02 = createAlgorithm02({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm09 = createAlgorithm09({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm11 = createAlgorithm11({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm13 = createAlgorithm13({
        typed: typed2
      });
      var algorithm14 = createAlgorithm14({
        typed: typed2
      });
      return typed2(name68, {
        "any, any": multiplyScalar2,
        "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
          return algorithm09(x, y, multiplyScalar2, false);
        },
        "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
          return algorithm02(y, x, multiplyScalar2, true);
        },
        "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
          return algorithm02(x, y, multiplyScalar2, false);
        },
        "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
          return algorithm13(x, y, multiplyScalar2);
        },
        "Array, Array": function ArrayArray(x, y) {
          return this(matrix2(x), matrix2(y)).valueOf();
        },
        "Array, Matrix": function ArrayMatrix(x, y) {
          return this(matrix2(x), y);
        },
        "Matrix, Array": function MatrixArray(x, y) {
          return this(x, matrix2(y));
        },
        "SparseMatrix, any": function SparseMatrixAny(x, y) {
          return algorithm11(x, y, multiplyScalar2, false);
        },
        "DenseMatrix, any": function DenseMatrixAny(x, y) {
          return algorithm14(x, y, multiplyScalar2, false);
        },
        "any, SparseMatrix": function anySparseMatrix(x, y) {
          return algorithm11(y, x, multiplyScalar2, true);
        },
        "any, DenseMatrix": function anyDenseMatrix(x, y) {
          return algorithm14(y, x, multiplyScalar2, true);
        },
        "Array, any": function ArrayAny(x, y) {
          return algorithm14(matrix2(x), y, multiplyScalar2, false).valueOf();
        },
        "any, Array": function anyArray(x, y) {
          return algorithm14(matrix2(y), x, multiplyScalar2, true).valueOf();
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/utils/bignumber/bitwise.js
function bitAndBigNumber(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function bitAnd");
  }
  var BigNumber2 = x.constructor;
  if (x.isNaN() || y.isNaN()) {
    return new BigNumber2(NaN);
  }
  if (x.isZero() || y.eq(-1) || x.eq(y)) {
    return x;
  }
  if (y.isZero() || x.eq(-1)) {
    return y;
  }
  if (!x.isFinite() || !y.isFinite()) {
    if (!x.isFinite() && !y.isFinite()) {
      if (x.isNegative() === y.isNegative()) {
        return x;
      }
      return new BigNumber2(0);
    }
    if (!x.isFinite()) {
      if (y.isNegative()) {
        return x;
      }
      if (x.isNegative()) {
        return new BigNumber2(0);
      }
      return y;
    }
    if (!y.isFinite()) {
      if (x.isNegative()) {
        return y;
      }
      if (y.isNegative()) {
        return new BigNumber2(0);
      }
      return x;
    }
  }
  return bitwise(x, y, function(a, b) {
    return a & b;
  });
}
function bitNotBigNumber(x) {
  if (x.isFinite() && !x.isInteger()) {
    throw new Error("Integer expected in function bitNot");
  }
  var BigNumber2 = x.constructor;
  var prevPrec = BigNumber2.precision;
  BigNumber2.config({
    precision: 1e9
  });
  var result = x.plus(new BigNumber2(1));
  result.s = -result.s || null;
  BigNumber2.config({
    precision: prevPrec
  });
  return result;
}
function bitOrBigNumber(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function bitOr");
  }
  var BigNumber2 = x.constructor;
  if (x.isNaN() || y.isNaN()) {
    return new BigNumber2(NaN);
  }
  var negOne = new BigNumber2(-1);
  if (x.isZero() || y.eq(negOne) || x.eq(y)) {
    return y;
  }
  if (y.isZero() || x.eq(negOne)) {
    return x;
  }
  if (!x.isFinite() || !y.isFinite()) {
    if (!x.isFinite() && !x.isNegative() && y.isNegative() || x.isNegative() && !y.isNegative() && !y.isFinite()) {
      return negOne;
    }
    if (x.isNegative() && y.isNegative()) {
      return x.isFinite() ? x : y;
    }
    return x.isFinite() ? y : x;
  }
  return bitwise(x, y, function(a, b) {
    return a | b;
  });
}
function bitwise(x, y, func) {
  var BigNumber2 = x.constructor;
  var xBits, yBits;
  var xSign = +(x.s < 0);
  var ySign = +(y.s < 0);
  if (xSign) {
    xBits = decCoefficientToBinaryString(bitNotBigNumber(x));
    for (var i2 = 0; i2 < xBits.length; ++i2) {
      xBits[i2] ^= 1;
    }
  } else {
    xBits = decCoefficientToBinaryString(x);
  }
  if (ySign) {
    yBits = decCoefficientToBinaryString(bitNotBigNumber(y));
    for (var _i = 0; _i < yBits.length; ++_i) {
      yBits[_i] ^= 1;
    }
  } else {
    yBits = decCoefficientToBinaryString(y);
  }
  var minBits, maxBits, minSign;
  if (xBits.length <= yBits.length) {
    minBits = xBits;
    maxBits = yBits;
    minSign = xSign;
  } else {
    minBits = yBits;
    maxBits = xBits;
    minSign = ySign;
  }
  var shortLen = minBits.length;
  var longLen = maxBits.length;
  var expFuncVal = func(xSign, ySign) ^ 1;
  var outVal = new BigNumber2(expFuncVal ^ 1);
  var twoPower = new BigNumber2(1);
  var two = new BigNumber2(2);
  var prevPrec = BigNumber2.precision;
  BigNumber2.config({
    precision: 1e9
  });
  while (shortLen > 0) {
    if (func(minBits[--shortLen], maxBits[--longLen]) === expFuncVal) {
      outVal = outVal.plus(twoPower);
    }
    twoPower = twoPower.times(two);
  }
  while (longLen > 0) {
    if (func(minSign, maxBits[--longLen]) === expFuncVal) {
      outVal = outVal.plus(twoPower);
    }
    twoPower = twoPower.times(two);
  }
  BigNumber2.config({
    precision: prevPrec
  });
  if (expFuncVal === 0) {
    outVal.s = -outVal.s;
  }
  return outVal;
}
function decCoefficientToBinaryString(x) {
  var a = x.d;
  var r = a[0] + "";
  for (var i2 = 1; i2 < a.length; ++i2) {
    var s = a[i2] + "";
    for (var z = 7 - s.length; z--; ) {
      s = "0" + s;
    }
    r += s;
  }
  var j = r.length;
  while (r.charAt(j) === "0") {
    j--;
  }
  var xe = x.e;
  var str = r.slice(0, j + 1 || 1);
  var strL = str.length;
  if (xe > 0) {
    if (++xe > strL) {
      xe -= strL;
      while (xe--) {
        str += "0";
      }
    } else if (xe < strL) {
      str = str.slice(0, xe) + "." + str.slice(xe);
    }
  }
  var arr = [0];
  for (var _i2 = 0; _i2 < str.length; ) {
    var arrL = arr.length;
    while (arrL--) {
      arr[arrL] *= 10;
    }
    arr[0] += parseInt(str.charAt(_i2++));
    for (var _j = 0; _j < arr.length; ++_j) {
      if (arr[_j] > 1) {
        if (arr[_j + 1] === null || arr[_j + 1] === void 0) {
          arr[_j + 1] = 0;
        }
        arr[_j + 1] += arr[_j] >> 1;
        arr[_j] &= 1;
      }
    }
  }
  return arr.reverse();
}
function bitXor(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function bitXor");
  }
  var BigNumber2 = x.constructor;
  if (x.isNaN() || y.isNaN()) {
    return new BigNumber2(NaN);
  }
  if (x.isZero()) {
    return y;
  }
  if (y.isZero()) {
    return x;
  }
  if (x.eq(y)) {
    return new BigNumber2(0);
  }
  var negOne = new BigNumber2(-1);
  if (x.eq(negOne)) {
    return bitNotBigNumber(y);
  }
  if (y.eq(negOne)) {
    return bitNotBigNumber(x);
  }
  if (!x.isFinite() || !y.isFinite()) {
    if (!x.isFinite() && !y.isFinite()) {
      return negOne;
    }
    return new BigNumber2(x.isNegative() === y.isNegative() ? Infinity : -Infinity);
  }
  return bitwise(x, y, function(a, b) {
    return a ^ b;
  });
}
function leftShiftBigNumber(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function leftShift");
  }
  var BigNumber2 = x.constructor;
  if (x.isNaN() || y.isNaN() || y.isNegative() && !y.isZero()) {
    return new BigNumber2(NaN);
  }
  if (x.isZero() || y.isZero()) {
    return x;
  }
  if (!x.isFinite() && !y.isFinite()) {
    return new BigNumber2(NaN);
  }
  if (y.lt(55)) {
    return x.times(Math.pow(2, y.toNumber()) + "");
  }
  return x.times(new BigNumber2(2).pow(y));
}
function rightArithShiftBigNumber(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function rightArithShift");
  }
  var BigNumber2 = x.constructor;
  if (x.isNaN() || y.isNaN() || y.isNegative() && !y.isZero()) {
    return new BigNumber2(NaN);
  }
  if (x.isZero() || y.isZero()) {
    return x;
  }
  if (!y.isFinite()) {
    if (x.isNegative()) {
      return new BigNumber2(-1);
    }
    if (!x.isFinite()) {
      return new BigNumber2(NaN);
    }
    return new BigNumber2(0);
  }
  if (y.lt(55)) {
    return x.div(Math.pow(2, y.toNumber()) + "").floor();
  }
  return x.div(new BigNumber2(2).pow(y)).floor();
}
var init_bitwise2 = __esm({
  "node_modules/mathjs/lib/esm/utils/bignumber/bitwise.js"() {
  }
});

// node_modules/mathjs/lib/esm/function/bitwise/bitAnd.js
var name69, dependencies70, createBitAnd;
var init_bitAnd = __esm({
  "node_modules/mathjs/lib/esm/function/bitwise/bitAnd.js"() {
    init_bitwise2();
    init_algorithm02();
    init_algorithm11();
    init_algorithm13();
    init_algorithm14();
    init_algorithm06();
    init_factory();
    init_number2();
    name69 = "bitAnd";
    dependencies70 = ["typed", "matrix", "equalScalar"];
    createBitAnd = /* @__PURE__ */ factory(name69, dependencies70, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        equalScalar: equalScalar2
      } = _ref;
      var algorithm02 = createAlgorithm02({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm06 = createAlgorithm06({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm11 = createAlgorithm11({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm13 = createAlgorithm13({
        typed: typed2
      });
      var algorithm14 = createAlgorithm14({
        typed: typed2
      });
      return typed2(name69, {
        "number, number": bitAndNumber,
        "BigNumber, BigNumber": bitAndBigNumber,
        "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
          return algorithm06(x, y, this, false);
        },
        "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
          return algorithm02(y, x, this, true);
        },
        "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
          return algorithm02(x, y, this, false);
        },
        "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
          return algorithm13(x, y, this);
        },
        "Array, Array": function ArrayArray(x, y) {
          return this(matrix2(x), matrix2(y)).valueOf();
        },
        "Array, Matrix": function ArrayMatrix(x, y) {
          return this(matrix2(x), y);
        },
        "Matrix, Array": function MatrixArray(x, y) {
          return this(x, matrix2(y));
        },
        "SparseMatrix, any": function SparseMatrixAny(x, y) {
          return algorithm11(x, y, this, false);
        },
        "DenseMatrix, any": function DenseMatrixAny(x, y) {
          return algorithm14(x, y, this, false);
        },
        "any, SparseMatrix": function anySparseMatrix(x, y) {
          return algorithm11(y, x, this, true);
        },
        "any, DenseMatrix": function anyDenseMatrix(x, y) {
          return algorithm14(y, x, this, true);
        },
        "Array, any": function ArrayAny(x, y) {
          return algorithm14(matrix2(x), y, this, false).valueOf();
        },
        "any, Array": function anyArray(x, y) {
          return algorithm14(matrix2(y), x, this, true).valueOf();
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/bitwise/bitNot.js
var name70, dependencies71, createBitNot;
var init_bitNot = __esm({
  "node_modules/mathjs/lib/esm/function/bitwise/bitNot.js"() {
    init_bitwise2();
    init_collection();
    init_factory();
    init_number2();
    name70 = "bitNot";
    dependencies71 = ["typed"];
    createBitNot = /* @__PURE__ */ factory(name70, dependencies71, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2(name70, {
        number: bitNotNumber,
        BigNumber: bitNotBigNumber,
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/bitwise/bitOr.js
var name71, dependencies72, createBitOr;
var init_bitOr = __esm({
  "node_modules/mathjs/lib/esm/function/bitwise/bitOr.js"() {
    init_bitwise2();
    init_factory();
    init_algorithm14();
    init_algorithm13();
    init_algorithm10();
    init_algorithm04();
    init_algorithm01();
    init_number2();
    name71 = "bitOr";
    dependencies72 = ["typed", "matrix", "equalScalar", "DenseMatrix"];
    createBitOr = /* @__PURE__ */ factory(name71, dependencies72, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        equalScalar: equalScalar2,
        DenseMatrix: DenseMatrix2
      } = _ref;
      var algorithm01 = createAlgorithm01({
        typed: typed2
      });
      var algorithm04 = createAlgorithm04({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm10 = createAlgorithm10({
        typed: typed2,
        DenseMatrix: DenseMatrix2
      });
      var algorithm13 = createAlgorithm13({
        typed: typed2
      });
      var algorithm14 = createAlgorithm14({
        typed: typed2
      });
      return typed2(name71, {
        "number, number": bitOrNumber,
        "BigNumber, BigNumber": bitOrBigNumber,
        "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
          return algorithm04(x, y, this);
        },
        "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
          return algorithm01(y, x, this, true);
        },
        "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
          return algorithm01(x, y, this, false);
        },
        "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
          return algorithm13(x, y, this);
        },
        "Array, Array": function ArrayArray(x, y) {
          return this(matrix2(x), matrix2(y)).valueOf();
        },
        "Array, Matrix": function ArrayMatrix(x, y) {
          return this(matrix2(x), y);
        },
        "Matrix, Array": function MatrixArray(x, y) {
          return this(x, matrix2(y));
        },
        "SparseMatrix, any": function SparseMatrixAny(x, y) {
          return algorithm10(x, y, this, false);
        },
        "DenseMatrix, any": function DenseMatrixAny(x, y) {
          return algorithm14(x, y, this, false);
        },
        "any, SparseMatrix": function anySparseMatrix(x, y) {
          return algorithm10(y, x, this, true);
        },
        "any, DenseMatrix": function anyDenseMatrix(x, y) {
          return algorithm14(y, x, this, true);
        },
        "Array, any": function ArrayAny(x, y) {
          return algorithm14(matrix2(x), y, this, false).valueOf();
        },
        "any, Array": function anyArray(x, y) {
          return algorithm14(matrix2(y), x, this, true).valueOf();
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/type/matrix/utils/algorithm07.js
var name72, dependencies73, createAlgorithm07;
var init_algorithm07 = __esm({
  "node_modules/mathjs/lib/esm/type/matrix/utils/algorithm07.js"() {
    init_factory();
    init_DimensionError();
    name72 = "algorithm07";
    dependencies73 = ["typed", "DenseMatrix"];
    createAlgorithm07 = /* @__PURE__ */ factory(name72, dependencies73, (_ref) => {
      var {
        typed: typed2,
        DenseMatrix: DenseMatrix2
      } = _ref;
      return function algorithm07(a, b, callback) {
        var asize = a._size;
        var adt = a._datatype;
        var bsize = b._size;
        var bdt = b._datatype;
        if (asize.length !== bsize.length) {
          throw new DimensionError(asize.length, bsize.length);
        }
        if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
          throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
        }
        var rows = asize[0];
        var columns = asize[1];
        var dt;
        var zero = 0;
        var cf = callback;
        if (typeof adt === "string" && adt === bdt) {
          dt = adt;
          zero = typed2.convert(0, dt);
          cf = typed2.find(callback, [dt, dt]);
        }
        var i2, j;
        var cdata = [];
        for (i2 = 0; i2 < rows; i2++) {
          cdata[i2] = [];
        }
        var xa = [];
        var xb = [];
        var wa = [];
        var wb = [];
        for (j = 0; j < columns; j++) {
          var mark = j + 1;
          _scatter(a, j, wa, xa, mark);
          _scatter(b, j, wb, xb, mark);
          for (i2 = 0; i2 < rows; i2++) {
            var va = wa[i2] === mark ? xa[i2] : zero;
            var vb = wb[i2] === mark ? xb[i2] : zero;
            cdata[i2][j] = cf(va, vb);
          }
        }
        return new DenseMatrix2({
          data: cdata,
          size: [rows, columns],
          datatype: dt
        });
      };
      function _scatter(m, j, w, x, mark) {
        var values = m._values;
        var index2 = m._index;
        var ptr = m._ptr;
        for (var k = ptr[j], k1 = ptr[j + 1]; k < k1; k++) {
          var i2 = index2[k];
          w[i2] = mark;
          x[i2] = values[k];
        }
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/bitwise/bitXor.js
var name73, dependencies74, createBitXor;
var init_bitXor = __esm({
  "node_modules/mathjs/lib/esm/function/bitwise/bitXor.js"() {
    init_bitwise2();
    init_algorithm03();
    init_algorithm07();
    init_algorithm12();
    init_algorithm13();
    init_algorithm14();
    init_factory();
    init_number2();
    name73 = "bitXor";
    dependencies74 = ["typed", "matrix", "DenseMatrix"];
    createBitXor = /* @__PURE__ */ factory(name73, dependencies74, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        DenseMatrix: DenseMatrix2
      } = _ref;
      var algorithm03 = createAlgorithm03({
        typed: typed2
      });
      var algorithm07 = createAlgorithm07({
        typed: typed2,
        DenseMatrix: DenseMatrix2
      });
      var algorithm12 = createAlgorithm12({
        typed: typed2,
        DenseMatrix: DenseMatrix2
      });
      var algorithm13 = createAlgorithm13({
        typed: typed2
      });
      var algorithm14 = createAlgorithm14({
        typed: typed2
      });
      return typed2(name73, {
        "number, number": bitXorNumber,
        "BigNumber, BigNumber": bitXor,
        "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
          return algorithm07(x, y, this);
        },
        "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
          return algorithm03(y, x, this, true);
        },
        "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
          return algorithm03(x, y, this, false);
        },
        "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
          return algorithm13(x, y, this);
        },
        "Array, Array": function ArrayArray(x, y) {
          return this(matrix2(x), matrix2(y)).valueOf();
        },
        "Array, Matrix": function ArrayMatrix(x, y) {
          return this(matrix2(x), y);
        },
        "Matrix, Array": function MatrixArray(x, y) {
          return this(x, matrix2(y));
        },
        "SparseMatrix, any": function SparseMatrixAny(x, y) {
          return algorithm12(x, y, this, false);
        },
        "DenseMatrix, any": function DenseMatrixAny(x, y) {
          return algorithm14(x, y, this, false);
        },
        "any, SparseMatrix": function anySparseMatrix(x, y) {
          return algorithm12(y, x, this, true);
        },
        "any, DenseMatrix": function anyDenseMatrix(x, y) {
          return algorithm14(y, x, this, true);
        },
        "Array, any": function ArrayAny(x, y) {
          return algorithm14(matrix2(x), y, this, false).valueOf();
        },
        "any, Array": function anyArray(x, y) {
          return algorithm14(matrix2(y), x, this, true).valueOf();
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/complex/arg.js
var name74, dependencies75, createArg;
var init_arg = __esm({
  "node_modules/mathjs/lib/esm/function/complex/arg.js"() {
    init_factory();
    init_collection();
    name74 = "arg";
    dependencies75 = ["typed"];
    createArg = /* @__PURE__ */ factory(name74, dependencies75, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2(name74, {
        number: function number2(x) {
          return Math.atan2(0, x);
        },
        BigNumber: function BigNumber2(x) {
          return x.constructor.atan2(0, x);
        },
        Complex: function Complex3(x) {
          return x.arg();
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/complex/conj.js
var name75, dependencies76, createConj;
var init_conj = __esm({
  "node_modules/mathjs/lib/esm/function/complex/conj.js"() {
    init_factory();
    init_collection();
    name75 = "conj";
    dependencies76 = ["typed"];
    createConj = /* @__PURE__ */ factory(name75, dependencies76, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2(name75, {
        number: function number2(x) {
          return x;
        },
        BigNumber: function BigNumber2(x) {
          return x;
        },
        Complex: function Complex3(x) {
          return x.conjugate();
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/complex/im.js
var name76, dependencies77, createIm;
var init_im = __esm({
  "node_modules/mathjs/lib/esm/function/complex/im.js"() {
    init_factory();
    init_collection();
    name76 = "im";
    dependencies77 = ["typed"];
    createIm = /* @__PURE__ */ factory(name76, dependencies77, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2(name76, {
        number: function number2(x) {
          return 0;
        },
        BigNumber: function BigNumber2(x) {
          return x.mul(0);
        },
        Fraction: function Fraction3(x) {
          return x.mul(0);
        },
        Complex: function Complex3(x) {
          return x.im;
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/complex/re.js
var name77, dependencies78, createRe;
var init_re = __esm({
  "node_modules/mathjs/lib/esm/function/complex/re.js"() {
    init_factory();
    init_collection();
    name77 = "re";
    dependencies78 = ["typed"];
    createRe = /* @__PURE__ */ factory(name77, dependencies78, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2(name77, {
        number: function number2(x) {
          return x;
        },
        BigNumber: function BigNumber2(x) {
          return x;
        },
        Fraction: function Fraction3(x) {
          return x;
        },
        Complex: function Complex3(x) {
          return x.re;
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/logical/not.js
var name78, dependencies79, createNot;
var init_not = __esm({
  "node_modules/mathjs/lib/esm/function/logical/not.js"() {
    init_collection();
    init_factory();
    init_number2();
    name78 = "not";
    dependencies79 = ["typed"];
    createNot = /* @__PURE__ */ factory(name78, dependencies79, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2(name78, {
        number: notNumber,
        Complex: function Complex3(x) {
          return x.re === 0 && x.im === 0;
        },
        BigNumber: function BigNumber2(x) {
          return x.isZero() || x.isNaN();
        },
        Unit: function Unit2(x) {
          return x.value !== null ? this(x.value) : true;
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/logical/or.js
var name79, dependencies80, createOr;
var init_or = __esm({
  "node_modules/mathjs/lib/esm/function/logical/or.js"() {
    init_algorithm03();
    init_algorithm12();
    init_algorithm13();
    init_algorithm14();
    init_algorithm05();
    init_factory();
    init_number2();
    name79 = "or";
    dependencies80 = ["typed", "matrix", "equalScalar", "DenseMatrix"];
    createOr = /* @__PURE__ */ factory(name79, dependencies80, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        equalScalar: equalScalar2,
        DenseMatrix: DenseMatrix2
      } = _ref;
      var algorithm03 = createAlgorithm03({
        typed: typed2
      });
      var algorithm05 = createAlgorithm05({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm12 = createAlgorithm12({
        typed: typed2,
        DenseMatrix: DenseMatrix2
      });
      var algorithm13 = createAlgorithm13({
        typed: typed2
      });
      var algorithm14 = createAlgorithm14({
        typed: typed2
      });
      return typed2(name79, {
        "number, number": orNumber,
        "Complex, Complex": function ComplexComplex(x, y) {
          return x.re !== 0 || x.im !== 0 || y.re !== 0 || y.im !== 0;
        },
        "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
          return !x.isZero() && !x.isNaN() || !y.isZero() && !y.isNaN();
        },
        "Unit, Unit": function UnitUnit(x, y) {
          return this(x.value || 0, y.value || 0);
        },
        "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
          return algorithm05(x, y, this);
        },
        "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
          return algorithm03(y, x, this, true);
        },
        "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
          return algorithm03(x, y, this, false);
        },
        "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
          return algorithm13(x, y, this);
        },
        "Array, Array": function ArrayArray(x, y) {
          return this(matrix2(x), matrix2(y)).valueOf();
        },
        "Array, Matrix": function ArrayMatrix(x, y) {
          return this(matrix2(x), y);
        },
        "Matrix, Array": function MatrixArray(x, y) {
          return this(x, matrix2(y));
        },
        "SparseMatrix, any": function SparseMatrixAny(x, y) {
          return algorithm12(x, y, this, false);
        },
        "DenseMatrix, any": function DenseMatrixAny(x, y) {
          return algorithm14(x, y, this, false);
        },
        "any, SparseMatrix": function anySparseMatrix(x, y) {
          return algorithm12(y, x, this, true);
        },
        "any, DenseMatrix": function anyDenseMatrix(x, y) {
          return algorithm14(y, x, this, true);
        },
        "Array, any": function ArrayAny(x, y) {
          return algorithm14(matrix2(x), y, this, false).valueOf();
        },
        "any, Array": function anyArray(x, y) {
          return algorithm14(matrix2(y), x, this, true).valueOf();
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/logical/xor.js
var name80, dependencies81, createXor;
var init_xor = __esm({
  "node_modules/mathjs/lib/esm/function/logical/xor.js"() {
    init_algorithm03();
    init_algorithm07();
    init_algorithm12();
    init_algorithm13();
    init_algorithm14();
    init_factory();
    init_number2();
    name80 = "xor";
    dependencies81 = ["typed", "matrix", "DenseMatrix"];
    createXor = /* @__PURE__ */ factory(name80, dependencies81, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        DenseMatrix: DenseMatrix2
      } = _ref;
      var algorithm03 = createAlgorithm03({
        typed: typed2
      });
      var algorithm07 = createAlgorithm07({
        typed: typed2,
        DenseMatrix: DenseMatrix2
      });
      var algorithm12 = createAlgorithm12({
        typed: typed2,
        DenseMatrix: DenseMatrix2
      });
      var algorithm13 = createAlgorithm13({
        typed: typed2
      });
      var algorithm14 = createAlgorithm14({
        typed: typed2
      });
      return typed2(name80, {
        "number, number": xorNumber,
        "Complex, Complex": function ComplexComplex(x, y) {
          return (x.re !== 0 || x.im !== 0) !== (y.re !== 0 || y.im !== 0);
        },
        "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
          return (!x.isZero() && !x.isNaN()) !== (!y.isZero() && !y.isNaN());
        },
        "Unit, Unit": function UnitUnit(x, y) {
          return this(x.value || 0, y.value || 0);
        },
        "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
          return algorithm07(x, y, this);
        },
        "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
          return algorithm03(y, x, this, true);
        },
        "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
          return algorithm03(x, y, this, false);
        },
        "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
          return algorithm13(x, y, this);
        },
        "Array, Array": function ArrayArray(x, y) {
          return this(matrix2(x), matrix2(y)).valueOf();
        },
        "Array, Matrix": function ArrayMatrix(x, y) {
          return this(matrix2(x), y);
        },
        "Matrix, Array": function MatrixArray(x, y) {
          return this(x, matrix2(y));
        },
        "SparseMatrix, any": function SparseMatrixAny(x, y) {
          return algorithm12(x, y, this, false);
        },
        "DenseMatrix, any": function DenseMatrixAny(x, y) {
          return algorithm14(x, y, this, false);
        },
        "any, SparseMatrix": function anySparseMatrix(x, y) {
          return algorithm12(y, x, this, true);
        },
        "any, DenseMatrix": function anyDenseMatrix(x, y) {
          return algorithm14(y, x, this, true);
        },
        "Array, any": function ArrayAny(x, y) {
          return algorithm14(matrix2(x), y, this, false).valueOf();
        },
        "any, Array": function anyArray(x, y) {
          return algorithm14(matrix2(y), x, this, true).valueOf();
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/concat.js
function _concat(a, b, concatDim, dim) {
  if (dim < concatDim) {
    if (a.length !== b.length) {
      throw new DimensionError(a.length, b.length);
    }
    var c = [];
    for (var i2 = 0; i2 < a.length; i2++) {
      c[i2] = _concat(a[i2], b[i2], concatDim, dim + 1);
    }
    return c;
  } else {
    return a.concat(b);
  }
}
var name81, dependencies82, createConcat;
var init_concat = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/concat.js"() {
    init_is();
    init_object();
    init_array();
    init_IndexError();
    init_DimensionError();
    init_factory();
    name81 = "concat";
    dependencies82 = ["typed", "matrix", "isInteger"];
    createConcat = /* @__PURE__ */ factory(name81, dependencies82, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        isInteger: isInteger3
      } = _ref;
      return typed2(name81, {
        "...Array | Matrix | number | BigNumber": function ArrayMatrixNumberBigNumber(args) {
          var i2;
          var len = args.length;
          var dim = -1;
          var prevDim;
          var asMatrix = false;
          var matrices = [];
          for (i2 = 0; i2 < len; i2++) {
            var arg2 = args[i2];
            if (isMatrix(arg2)) {
              asMatrix = true;
            }
            if (isNumber2(arg2) || isBigNumber(arg2)) {
              if (i2 !== len - 1) {
                throw new Error("Dimension must be specified as last argument");
              }
              prevDim = dim;
              dim = arg2.valueOf();
              if (!isInteger3(dim)) {
                throw new TypeError("Integer number expected for dimension");
              }
              if (dim < 0 || i2 > 0 && dim > prevDim) {
                throw new IndexError(dim, prevDim + 1);
              }
            } else {
              var m = clone(arg2).valueOf();
              var size2 = arraySize(m);
              matrices[i2] = m;
              prevDim = dim;
              dim = size2.length - 1;
              if (i2 > 0 && dim !== prevDim) {
                throw new DimensionError(prevDim + 1, dim + 1);
              }
            }
          }
          if (matrices.length === 0) {
            throw new SyntaxError("At least one matrix expected");
          }
          var res = matrices.shift();
          while (matrices.length) {
            res = _concat(res, matrices.shift(), dim, 0);
          }
          return asMatrix ? matrix2(res) : res;
        },
        "...string": function string2(args) {
          return args.join("");
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/column.js
var name82, dependencies83, createColumn;
var init_column = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/column.js"() {
    init_factory();
    init_object();
    init_array();
    name82 = "column";
    dependencies83 = ["typed", "Index", "matrix", "range"];
    createColumn = /* @__PURE__ */ factory(name82, dependencies83, (_ref) => {
      var {
        typed: typed2,
        Index: Index2,
        matrix: matrix2,
        range: range2
      } = _ref;
      return typed2(name82, {
        "Matrix, number": _column,
        "Array, number": function ArrayNumber(value, column2) {
          return _column(matrix2(clone(value)), column2).valueOf();
        }
      });
      function _column(value, column2) {
        if (value.size().length !== 2) {
          throw new Error("Only two dimensional matrix is supported");
        }
        validateIndex(column2, value.size()[1]);
        var rowRange = range2(0, value.size()[0]);
        var index2 = new Index2(rowRange, column2);
        return value.subset(index2);
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/count.js
var name83, dependencies84, createCount;
var init_count = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/count.js"() {
    init_factory();
    name83 = "count";
    dependencies84 = ["typed", "size", "prod"];
    createCount = /* @__PURE__ */ factory(name83, dependencies84, (_ref) => {
      var {
        typed: typed2,
        size: size2,
        prod: prod2
      } = _ref;
      return typed2(name83, {
        string: function string2(x) {
          return x.length;
        },
        "Matrix | Array": function MatrixArray(x) {
          return prod2(size2(x));
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/cross.js
var name84, dependencies85, createCross;
var init_cross = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/cross.js"() {
    init_array();
    init_factory();
    name84 = "cross";
    dependencies85 = ["typed", "matrix", "subtract", "multiply"];
    createCross = /* @__PURE__ */ factory(name84, dependencies85, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        subtract: subtract2,
        multiply: multiply2
      } = _ref;
      return typed2(name84, {
        "Matrix, Matrix": function MatrixMatrix(x, y) {
          return matrix2(_cross(x.toArray(), y.toArray()));
        },
        "Matrix, Array": function MatrixArray(x, y) {
          return matrix2(_cross(x.toArray(), y));
        },
        "Array, Matrix": function ArrayMatrix(x, y) {
          return matrix2(_cross(x, y.toArray()));
        },
        "Array, Array": _cross
      });
      function _cross(x, y) {
        var highestDimension = Math.max(arraySize(x).length, arraySize(y).length);
        x = squeeze(x);
        y = squeeze(y);
        var xSize = arraySize(x);
        var ySize = arraySize(y);
        if (xSize.length !== 1 || ySize.length !== 1 || xSize[0] !== 3 || ySize[0] !== 3) {
          throw new RangeError("Vectors with length 3 expected (Size A = [" + xSize.join(", ") + "], B = [" + ySize.join(", ") + "])");
        }
        var product3 = [subtract2(multiply2(x[1], y[2]), multiply2(x[2], y[1])), subtract2(multiply2(x[2], y[0]), multiply2(x[0], y[2])), subtract2(multiply2(x[0], y[1]), multiply2(x[1], y[0]))];
        if (highestDimension > 1) {
          return [product3];
        } else {
          return product3;
        }
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/diag.js
var name85, dependencies86, createDiag;
var init_diag = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/diag.js"() {
    init_is();
    init_array();
    init_number();
    init_factory();
    name85 = "diag";
    dependencies86 = ["typed", "matrix", "DenseMatrix", "SparseMatrix"];
    createDiag = /* @__PURE__ */ factory(name85, dependencies86, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        DenseMatrix: DenseMatrix2,
        SparseMatrix: SparseMatrix2
      } = _ref;
      return typed2(name85, {
        Array: function Array2(x) {
          return _diag(x, 0, arraySize(x), null);
        },
        "Array, number": function ArrayNumber(x, k) {
          return _diag(x, k, arraySize(x), null);
        },
        "Array, BigNumber": function ArrayBigNumber(x, k) {
          return _diag(x, k.toNumber(), arraySize(x), null);
        },
        "Array, string": function ArrayString(x, format5) {
          return _diag(x, 0, arraySize(x), format5);
        },
        "Array, number, string": function ArrayNumberString(x, k, format5) {
          return _diag(x, k, arraySize(x), format5);
        },
        "Array, BigNumber, string": function ArrayBigNumberString(x, k, format5) {
          return _diag(x, k.toNumber(), arraySize(x), format5);
        },
        Matrix: function Matrix2(x) {
          return _diag(x, 0, x.size(), x.storage());
        },
        "Matrix, number": function MatrixNumber(x, k) {
          return _diag(x, k, x.size(), x.storage());
        },
        "Matrix, BigNumber": function MatrixBigNumber(x, k) {
          return _diag(x, k.toNumber(), x.size(), x.storage());
        },
        "Matrix, string": function MatrixString(x, format5) {
          return _diag(x, 0, x.size(), format5);
        },
        "Matrix, number, string": function MatrixNumberString(x, k, format5) {
          return _diag(x, k, x.size(), format5);
        },
        "Matrix, BigNumber, string": function MatrixBigNumberString(x, k, format5) {
          return _diag(x, k.toNumber(), x.size(), format5);
        }
      });
      function _diag(x, k, size2, format5) {
        if (!isInteger(k)) {
          throw new TypeError("Second parameter in function diag must be an integer");
        }
        var kSuper = k > 0 ? k : 0;
        var kSub = k < 0 ? -k : 0;
        switch (size2.length) {
          case 1:
            return _createDiagonalMatrix(x, k, format5, size2[0], kSub, kSuper);
          case 2:
            return _getDiagonal(x, k, format5, size2, kSub, kSuper);
        }
        throw new RangeError("Matrix for function diag must be 2 dimensional");
      }
      function _createDiagonalMatrix(x, k, format5, l, kSub, kSuper) {
        var ms = [l + kSub, l + kSuper];
        if (format5 && format5 !== "sparse" && format5 !== "dense") {
          throw new TypeError("Unknown matrix type ".concat(format5, '"'));
        }
        var m = format5 === "sparse" ? SparseMatrix2.diagonal(ms, x, k) : DenseMatrix2.diagonal(ms, x, k);
        return format5 !== null ? m : m.valueOf();
      }
      function _getDiagonal(x, k, format5, s, kSub, kSuper) {
        if (isMatrix(x)) {
          var dm = x.diagonal(k);
          if (format5 !== null) {
            if (format5 !== dm.storage()) {
              return matrix2(dm, format5);
            }
            return dm;
          }
          return dm.valueOf();
        }
        var n = Math.min(s[0] - kSub, s[1] - kSuper);
        var vector = [];
        for (var i2 = 0; i2 < n; i2++) {
          vector[i2] = x[i2 + kSub][i2 + kSuper];
        }
        return format5 !== null ? matrix2(vector) : vector;
      }
    });
  }
});

// node_modules/mathjs/lib/esm/utils/lruQueue.js
function lruQueue(limit) {
  var size2 = 0;
  var base = 1;
  var queue = /* @__PURE__ */ Object.create(null);
  var map3 = /* @__PURE__ */ Object.create(null);
  var index2 = 0;
  var del = function del2(id) {
    var oldIndex = map3[id];
    if (!oldIndex)
      return;
    delete queue[oldIndex];
    delete map3[id];
    --size2;
    if (base !== oldIndex)
      return;
    if (!size2) {
      index2 = 0;
      base = 1;
      return;
    }
    while (!hasOwnProperty.call(queue, ++base)) {
      continue;
    }
  };
  limit = Math.abs(limit);
  return {
    hit: function hit(id) {
      var oldIndex = map3[id];
      var nuIndex = ++index2;
      queue[nuIndex] = id;
      map3[id] = nuIndex;
      if (!oldIndex) {
        ++size2;
        if (size2 <= limit)
          return void 0;
        id = queue[base];
        del(id);
        return id;
      }
      delete queue[oldIndex];
      if (base !== oldIndex)
        return void 0;
      while (!hasOwnProperty.call(queue, ++base)) {
        continue;
      }
      return void 0;
    },
    delete: del,
    clear: function clear() {
      size2 = index2 = 0;
      base = 1;
      queue = /* @__PURE__ */ Object.create(null);
      map3 = /* @__PURE__ */ Object.create(null);
    }
  };
}
var init_lruQueue = __esm({
  "node_modules/mathjs/lib/esm/utils/lruQueue.js"() {
  }
});

// node_modules/mathjs/lib/esm/utils/function.js
function memoize(fn) {
  var {
    hasher: hasher2,
    limit
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  limit = limit == null ? Number.POSITIVE_INFINITY : limit;
  hasher2 = hasher2 == null ? JSON.stringify : hasher2;
  return function memoize2() {
    if (typeof memoize2.cache !== "object") {
      memoize2.cache = {
        values: /* @__PURE__ */ new Map(),
        lru: lruQueue(limit || Number.POSITIVE_INFINITY)
      };
    }
    var args = [];
    for (var i2 = 0; i2 < arguments.length; i2++) {
      args[i2] = arguments[i2];
    }
    var hash = hasher2(args);
    if (memoize2.cache.values.has(hash)) {
      memoize2.cache.lru.hit(hash);
      return memoize2.cache.values.get(hash);
    }
    var newVal = fn.apply(fn, args);
    memoize2.cache.values.set(hash, newVal);
    memoize2.cache.values.delete(memoize2.cache.lru.hit(hash));
    return newVal;
  };
}
function maxArgumentCount(fn) {
  return Object.keys(fn.signatures || {}).reduce(function(args, signature) {
    var count2 = (signature.match(/,/g) || []).length + 1;
    return Math.max(args, count2);
  }, -1);
}
var init_function = __esm({
  "node_modules/mathjs/lib/esm/utils/function.js"() {
    init_lruQueue();
  }
});

// node_modules/mathjs/lib/esm/function/matrix/filter.js
function _filterCallback(x, callback) {
  var args = maxArgumentCount(callback);
  return filter(x, function(value, index2, array) {
    if (args === 1) {
      return callback(value);
    } else if (args === 2) {
      return callback(value, [index2]);
    } else {
      return callback(value, [index2], array);
    }
  });
}
var name86, dependencies87, createFilter;
var init_filter = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/filter.js"() {
    init_array();
    init_function();
    init_factory();
    name86 = "filter";
    dependencies87 = ["typed"];
    createFilter = /* @__PURE__ */ factory(name86, dependencies87, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2("filter", {
        "Array, function": _filterCallback,
        "Matrix, function": function MatrixFunction(x, test) {
          return x.create(_filterCallback(x.toArray(), test));
        },
        "Array, RegExp": filterRegExp,
        "Matrix, RegExp": function MatrixRegExp(x, test) {
          return x.create(filterRegExp(x.toArray(), test));
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/flatten.js
var name87, dependencies88, createFlatten;
var init_flatten = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/flatten.js"() {
    init_object();
    init_array();
    init_factory();
    name87 = "flatten";
    dependencies88 = ["typed", "matrix"];
    createFlatten = /* @__PURE__ */ factory(name87, dependencies88, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2
      } = _ref;
      return typed2(name87, {
        Array: function Array2(x) {
          return flatten(clone(x));
        },
        Matrix: function Matrix2(x) {
          var flat = flatten(clone(x.toArray()));
          return matrix2(flat);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/forEach.js
function _forEach(array, callback) {
  var args = maxArgumentCount(callback);
  var recurse = function recurse2(value, index2) {
    if (Array.isArray(value)) {
      forEach(value, function(child2, i2) {
        recurse2(child2, index2.concat(i2));
      });
    } else {
      if (args === 1) {
        callback(value);
      } else if (args === 2) {
        callback(value, index2);
      } else {
        callback(value, index2, array);
      }
    }
  };
  recurse(array, []);
}
var name88, dependencies89, createForEach;
var init_forEach = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/forEach.js"() {
    init_function();
    init_array();
    init_factory();
    name88 = "forEach";
    dependencies89 = ["typed"];
    createForEach = /* @__PURE__ */ factory(name88, dependencies89, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2(name88, {
        "Array, function": _forEach,
        "Matrix, function": function MatrixFunction(x, callback) {
          return x.forEach(callback);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/getMatrixDataType.js
var name89, dependencies90, createGetMatrixDataType;
var init_getMatrixDataType = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/getMatrixDataType.js"() {
    init_factory();
    init_array();
    init_is();
    name89 = "getMatrixDataType";
    dependencies90 = ["typed"];
    createGetMatrixDataType = /* @__PURE__ */ factory(name89, dependencies90, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2(name89, {
        Array: function Array2(x) {
          return getArrayDataType(x, typeOf);
        },
        Matrix: function Matrix2(x) {
          return x.getDataType();
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/identity.js
var name90, dependencies91, createIdentity;
var init_identity = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/identity.js"() {
    init_is();
    init_array();
    init_number();
    init_factory();
    name90 = "identity";
    dependencies91 = ["typed", "config", "matrix", "BigNumber", "DenseMatrix", "SparseMatrix"];
    createIdentity = /* @__PURE__ */ factory(name90, dependencies91, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        matrix: matrix2,
        BigNumber: BigNumber2,
        DenseMatrix: DenseMatrix2,
        SparseMatrix: SparseMatrix2
      } = _ref;
      return typed2(name90, {
        "": function _() {
          return config3.matrix === "Matrix" ? matrix2([]) : [];
        },
        string: function string2(format5) {
          return matrix2(format5);
        },
        "number | BigNumber": function numberBigNumber(rows) {
          return _identity(rows, rows, config3.matrix === "Matrix" ? "dense" : void 0);
        },
        "number | BigNumber, string": function numberBigNumberString(rows, format5) {
          return _identity(rows, rows, format5);
        },
        "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(rows, cols) {
          return _identity(rows, cols, config3.matrix === "Matrix" ? "dense" : void 0);
        },
        "number | BigNumber, number | BigNumber, string": function numberBigNumberNumberBigNumberString(rows, cols, format5) {
          return _identity(rows, cols, format5);
        },
        Array: function Array2(size2) {
          return _identityVector(size2);
        },
        "Array, string": function ArrayString(size2, format5) {
          return _identityVector(size2, format5);
        },
        Matrix: function Matrix2(size2) {
          return _identityVector(size2.valueOf(), size2.storage());
        },
        "Matrix, string": function MatrixString(size2, format5) {
          return _identityVector(size2.valueOf(), format5);
        }
      });
      function _identityVector(size2, format5) {
        switch (size2.length) {
          case 0:
            return format5 ? matrix2(format5) : [];
          case 1:
            return _identity(size2[0], size2[0], format5);
          case 2:
            return _identity(size2[0], size2[1], format5);
          default:
            throw new Error("Vector containing two values expected");
        }
      }
      function _identity(rows, cols, format5) {
        var Big = isBigNumber(rows) || isBigNumber(cols) ? BigNumber2 : null;
        if (isBigNumber(rows))
          rows = rows.toNumber();
        if (isBigNumber(cols))
          cols = cols.toNumber();
        if (!isInteger(rows) || rows < 1) {
          throw new Error("Parameters in function identity must be positive integers");
        }
        if (!isInteger(cols) || cols < 1) {
          throw new Error("Parameters in function identity must be positive integers");
        }
        var one = Big ? new BigNumber2(1) : 1;
        var defaultValue = Big ? new Big(0) : 0;
        var size2 = [rows, cols];
        if (format5) {
          if (format5 === "sparse") {
            return SparseMatrix2.diagonal(size2, one, 0, defaultValue);
          }
          if (format5 === "dense") {
            return DenseMatrix2.diagonal(size2, one, 0, defaultValue);
          }
          throw new TypeError('Unknown matrix type "'.concat(format5, '"'));
        }
        var res = resize([], size2, defaultValue);
        var minimum = rows < cols ? rows : cols;
        for (var d = 0; d < minimum; d++) {
          res[d][d] = one;
        }
        return res;
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/kron.js
var name91, dependencies92, createKron;
var init_kron = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/kron.js"() {
    init_array();
    init_factory();
    name91 = "kron";
    dependencies92 = ["typed", "matrix", "multiplyScalar"];
    createKron = /* @__PURE__ */ factory(name91, dependencies92, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        multiplyScalar: multiplyScalar2
      } = _ref;
      return typed2(name91, {
        "Matrix, Matrix": function MatrixMatrix(x, y) {
          return matrix2(_kron(x.toArray(), y.toArray()));
        },
        "Matrix, Array": function MatrixArray(x, y) {
          return matrix2(_kron(x.toArray(), y));
        },
        "Array, Matrix": function ArrayMatrix(x, y) {
          return matrix2(_kron(x, y.toArray()));
        },
        "Array, Array": _kron
      });
      function _kron(a, b) {
        if (arraySize(a).length === 1) {
          a = [a];
        }
        if (arraySize(b).length === 1) {
          b = [b];
        }
        if (arraySize(a).length > 2 || arraySize(b).length > 2) {
          throw new RangeError("Vectors with dimensions greater then 2 are not supported expected (Size x = " + JSON.stringify(a.length) + ", y = " + JSON.stringify(b.length) + ")");
        }
        var t = [];
        var r = [];
        return a.map(function(a2) {
          return b.map(function(b2) {
            r = [];
            t.push(r);
            return a2.map(function(y) {
              return b2.map(function(x) {
                return r.push(multiplyScalar2(y, x));
              });
            });
          });
        }) && t;
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/map.js
function _map(array, callback) {
  var args = maxArgumentCount(callback);
  var recurse = function recurse2(value, index2) {
    if (Array.isArray(value)) {
      return value.map(function(child2, i2) {
        return recurse2(child2, index2.concat(i2));
      });
    } else {
      try {
        if (args === 1) {
          return callback(value);
        } else if (args === 2) {
          return callback(value, index2);
        } else {
          return callback(value, index2, array);
        }
      } catch (err) {
        if (err instanceof TypeError && "data" in err && err.data.category === "wrongType") {
          var newmsg = "map attempted to call '".concat(err.data.fn, "(").concat(value);
          var indexString = JSON.stringify(index2);
          if (args === 2) {
            newmsg += "," + indexString;
          } else if (args !== 1) {
            newmsg += ",".concat(indexString, ",").concat(array);
          }
          newmsg += ")' but argument ".concat(err.data.index + 1, " of type ");
          newmsg += "".concat(err.data.actual, " does not match expected type ");
          newmsg += err.data.expected.join(" or ");
          throw new TypeError(newmsg);
        }
        throw err;
      }
    }
  };
  return recurse(array, []);
}
var name92, dependencies93, createMap2;
var init_map2 = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/map.js"() {
    init_function();
    init_factory();
    name92 = "map";
    dependencies93 = ["typed"];
    createMap2 = /* @__PURE__ */ factory(name92, dependencies93, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2(name92, {
        "Array, function": _map,
        "Matrix, function": function MatrixFunction(x, callback) {
          return x.map(callback);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/diff.js
var name93, dependencies94, createDiff;
var init_diff = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/diff.js"() {
    init_factory();
    init_number();
    init_is();
    name93 = "diff";
    dependencies94 = ["typed", "matrix", "subtract", "number"];
    createDiff = /* @__PURE__ */ factory(name93, dependencies94, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        subtract: subtract2,
        number: number2
      } = _ref;
      return typed2(name93, {
        "Array | Matrix": function ArrayMatrix(arr) {
          if (isMatrix(arr)) {
            return matrix2(_diff(arr.toArray()));
          } else {
            return _diff(arr);
          }
        },
        "Array | Matrix, number": function ArrayMatrixNumber(arr, dim) {
          if (!isInteger(dim))
            throw new RangeError("Dimension must be a whole number");
          if (isMatrix(arr)) {
            return matrix2(_recursive(arr.toArray(), dim));
          } else {
            return _recursive(arr, dim);
          }
        },
        "Array | Matrix, BigNumber": function ArrayMatrixBigNumber(arr, dim) {
          return this(arr, number2(dim));
        }
      });
      function _recursive(arr, dim) {
        if (isMatrix(arr)) {
          arr = arr.toArray();
        }
        if (!Array.isArray(arr)) {
          throw RangeError("Array/Matrix does not have that many dimensions");
        }
        if (dim > 0) {
          var result = [];
          arr.forEach((element) => {
            result.push(_recursive(element, dim - 1));
          });
          return result;
        } else if (dim === 0) {
          return _diff(arr);
        } else {
          throw RangeError("Cannot have negative dimension");
        }
      }
      function _diff(arr) {
        var result = [];
        var size2 = arr.length;
        if (size2 < 2) {
          return arr;
        }
        for (var i2 = 1; i2 < size2; i2++) {
          result.push(_ElementDiff(arr[i2 - 1], arr[i2]));
        }
        return result;
      }
      function _ElementDiff(obj1, obj2) {
        if (isMatrix(obj1))
          obj1 = obj1.toArray();
        if (isMatrix(obj2))
          obj2 = obj2.toArray();
        var obj1IsArray = Array.isArray(obj1);
        var obj2IsArray = Array.isArray(obj2);
        if (obj1IsArray && obj2IsArray) {
          return _ArrayDiff(obj1, obj2);
        }
        if (!obj1IsArray && !obj2IsArray) {
          return subtract2(obj2, obj1);
        }
        throw TypeError("Cannot calculate difference between 1 array and 1 non-array");
      }
      function _ArrayDiff(arr1, arr2) {
        if (arr1.length !== arr2.length) {
          throw RangeError("Not all sub-arrays have the same length");
        }
        var result = [];
        var size2 = arr1.length;
        for (var i2 = 0; i2 < size2; i2++) {
          result.push(_ElementDiff(arr1[i2], arr2[i2]));
        }
        return result;
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/ones.js
var name94, dependencies95, createOnes;
var init_ones = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/ones.js"() {
    init_is();
    init_number();
    init_array();
    init_factory();
    name94 = "ones";
    dependencies95 = ["typed", "config", "matrix", "BigNumber"];
    createOnes = /* @__PURE__ */ factory(name94, dependencies95, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        matrix: matrix2,
        BigNumber: BigNumber2
      } = _ref;
      return typed2("ones", {
        "": function _() {
          return config3.matrix === "Array" ? _ones([]) : _ones([], "default");
        },
        "...number | BigNumber | string": function numberBigNumberString(size2) {
          var last = size2[size2.length - 1];
          if (typeof last === "string") {
            var format5 = size2.pop();
            return _ones(size2, format5);
          } else if (config3.matrix === "Array") {
            return _ones(size2);
          } else {
            return _ones(size2, "default");
          }
        },
        Array: _ones,
        Matrix: function Matrix2(size2) {
          var format5 = size2.storage();
          return _ones(size2.valueOf(), format5);
        },
        "Array | Matrix, string": function ArrayMatrixString(size2, format5) {
          return _ones(size2.valueOf(), format5);
        }
      });
      function _ones(size2, format5) {
        var hasBigNumbers = _normalize(size2);
        var defaultValue = hasBigNumbers ? new BigNumber2(1) : 1;
        _validate2(size2);
        if (format5) {
          var m = matrix2(format5);
          if (size2.length > 0) {
            return m.resize(size2, defaultValue);
          }
          return m;
        } else {
          var arr = [];
          if (size2.length > 0) {
            return resize(arr, size2, defaultValue);
          }
          return arr;
        }
      }
      function _normalize(size2) {
        var hasBigNumbers = false;
        size2.forEach(function(value, index2, arr) {
          if (isBigNumber(value)) {
            hasBigNumbers = true;
            arr[index2] = value.toNumber();
          }
        });
        return hasBigNumbers;
      }
      function _validate2(size2) {
        size2.forEach(function(value) {
          if (typeof value !== "number" || !isInteger(value) || value < 0) {
            throw new Error("Parameters in function ones must be positive integers");
          }
        });
      }
    });
  }
});

// node_modules/mathjs/lib/esm/utils/noop.js
function noBignumber() {
  throw new Error('No "bignumber" implementation available');
}
function noFraction() {
  throw new Error('No "fraction" implementation available');
}
function noMatrix() {
  throw new Error('No "matrix" implementation available');
}
var init_noop = __esm({
  "node_modules/mathjs/lib/esm/utils/noop.js"() {
  }
});

// node_modules/mathjs/lib/esm/function/matrix/range.js
var name95, dependencies96, createRange;
var init_range = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/range.js"() {
    init_factory();
    init_noop();
    name95 = "range";
    dependencies96 = ["typed", "config", "?matrix", "?bignumber", "smaller", "smallerEq", "larger", "largerEq"];
    createRange = /* @__PURE__ */ factory(name95, dependencies96, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        matrix: matrix2,
        bignumber: bignumber2,
        smaller: smaller2,
        smallerEq: smallerEq2,
        larger: larger2,
        largerEq: largerEq2
      } = _ref;
      return typed2(name95, {
        string: _strRange,
        "string, boolean": _strRange,
        "number, number": function numberNumber(start, end) {
          return _out(_rangeEx(start, end, 1));
        },
        "number, number, number": function numberNumberNumber(start, end, step) {
          return _out(_rangeEx(start, end, step));
        },
        "number, number, boolean": function numberNumberBoolean(start, end, includeEnd) {
          return includeEnd ? _out(_rangeInc(start, end, 1)) : _out(_rangeEx(start, end, 1));
        },
        "number, number, number, boolean": function numberNumberNumberBoolean(start, end, step, includeEnd) {
          return includeEnd ? _out(_rangeInc(start, end, step)) : _out(_rangeEx(start, end, step));
        },
        "BigNumber, BigNumber": function BigNumberBigNumber(start, end) {
          var BigNumber2 = start.constructor;
          return _out(_bigRangeEx(start, end, new BigNumber2(1)));
        },
        "BigNumber, BigNumber, BigNumber": function BigNumberBigNumberBigNumber(start, end, step) {
          return _out(_bigRangeEx(start, end, step));
        },
        "BigNumber, BigNumber, boolean": function BigNumberBigNumberBoolean(start, end, includeEnd) {
          var BigNumber2 = start.constructor;
          return includeEnd ? _out(_bigRangeInc(start, end, new BigNumber2(1))) : _out(_bigRangeEx(start, end, new BigNumber2(1)));
        },
        "BigNumber, BigNumber, BigNumber, boolean": function BigNumberBigNumberBigNumberBoolean(start, end, step, includeEnd) {
          return includeEnd ? _out(_bigRangeInc(start, end, step)) : _out(_bigRangeEx(start, end, step));
        }
      });
      function _out(arr) {
        if (config3.matrix === "Matrix") {
          return matrix2 ? matrix2(arr) : noMatrix();
        }
        return arr;
      }
      function _strRange(str, includeEnd) {
        var r = _parse(str);
        if (!r) {
          throw new SyntaxError('String "' + str + '" is no valid range');
        }
        var fn;
        if (config3.number === "BigNumber") {
          if (bignumber2 === void 0) {
            noBignumber();
          }
          fn = includeEnd ? _bigRangeInc : _bigRangeEx;
          return _out(fn(bignumber2(r.start), bignumber2(r.end), bignumber2(r.step)));
        } else {
          fn = includeEnd ? _rangeInc : _rangeEx;
          return _out(fn(r.start, r.end, r.step));
        }
      }
      function _rangeEx(start, end, step) {
        var array = [];
        var x = start;
        if (step > 0) {
          while (smaller2(x, end)) {
            array.push(x);
            x += step;
          }
        } else if (step < 0) {
          while (larger2(x, end)) {
            array.push(x);
            x += step;
          }
        }
        return array;
      }
      function _rangeInc(start, end, step) {
        var array = [];
        var x = start;
        if (step > 0) {
          while (smallerEq2(x, end)) {
            array.push(x);
            x += step;
          }
        } else if (step < 0) {
          while (largerEq2(x, end)) {
            array.push(x);
            x += step;
          }
        }
        return array;
      }
      function _bigRangeEx(start, end, step) {
        var zero = bignumber2(0);
        var array = [];
        var x = start;
        if (step.gt(zero)) {
          while (smaller2(x, end)) {
            array.push(x);
            x = x.plus(step);
          }
        } else if (step.lt(zero)) {
          while (larger2(x, end)) {
            array.push(x);
            x = x.plus(step);
          }
        }
        return array;
      }
      function _bigRangeInc(start, end, step) {
        var zero = bignumber2(0);
        var array = [];
        var x = start;
        if (step.gt(zero)) {
          while (smallerEq2(x, end)) {
            array.push(x);
            x = x.plus(step);
          }
        } else if (step.lt(zero)) {
          while (largerEq2(x, end)) {
            array.push(x);
            x = x.plus(step);
          }
        }
        return array;
      }
      function _parse(str) {
        var args = str.split(":");
        var nums = args.map(function(arg2) {
          return Number(arg2);
        });
        var invalid = nums.some(function(num) {
          return isNaN(num);
        });
        if (invalid) {
          return null;
        }
        switch (nums.length) {
          case 2:
            return {
              start: nums[0],
              end: nums[1],
              step: 1
            };
          case 3:
            return {
              start: nums[0],
              end: nums[2],
              step: nums[1]
            };
          default:
            return null;
        }
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/reshape.js
var name96, dependencies97, createReshape;
var init_reshape = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/reshape.js"() {
    init_array();
    init_factory();
    name96 = "reshape";
    dependencies97 = ["typed", "isInteger", "matrix"];
    createReshape = /* @__PURE__ */ factory(name96, dependencies97, (_ref) => {
      var {
        typed: typed2,
        isInteger: isInteger3
      } = _ref;
      return typed2(name96, {
        "Matrix, Array": function MatrixArray(x, sizes) {
          return x.reshape(sizes);
        },
        "Array, Array": function ArrayArray(x, sizes) {
          sizes.forEach(function(size2) {
            if (!isInteger3(size2)) {
              throw new TypeError("Invalid size for dimension: " + size2);
            }
          });
          return reshape(x, sizes);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/error/ArgumentsError.js
function ArgumentsError(fn, count2, min2, max2) {
  if (!(this instanceof ArgumentsError)) {
    throw new SyntaxError("Constructor must be called with the new operator");
  }
  this.fn = fn;
  this.count = count2;
  this.min = min2;
  this.max = max2;
  this.message = "Wrong number of arguments in function " + fn + " (" + count2 + " provided, " + min2 + (max2 !== void 0 && max2 !== null ? "-" + max2 : "") + " expected)";
  this.stack = new Error().stack;
}
var init_ArgumentsError = __esm({
  "node_modules/mathjs/lib/esm/error/ArgumentsError.js"() {
    ArgumentsError.prototype = new Error();
    ArgumentsError.prototype.constructor = Error;
    ArgumentsError.prototype.name = "ArgumentsError";
    ArgumentsError.prototype.isArgumentsError = true;
  }
});

// node_modules/mathjs/lib/esm/function/matrix/resize.js
var name97, dependencies98, createResize;
var init_resize = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/resize.js"() {
    init_is();
    init_DimensionError();
    init_ArgumentsError();
    init_number();
    init_string();
    init_object();
    init_array();
    init_factory();
    name97 = "resize";
    dependencies98 = ["config", "matrix"];
    createResize = /* @__PURE__ */ factory(name97, dependencies98, (_ref) => {
      var {
        config: config3,
        matrix: matrix2
      } = _ref;
      return function resize3(x, size2, defaultValue) {
        if (arguments.length !== 2 && arguments.length !== 3) {
          throw new ArgumentsError("resize", arguments.length, 2, 3);
        }
        if (isMatrix(size2)) {
          size2 = size2.valueOf();
        }
        if (isBigNumber(size2[0])) {
          size2 = size2.map(function(value) {
            return !isBigNumber(value) ? value : value.toNumber();
          });
        }
        if (isMatrix(x)) {
          return x.resize(size2, defaultValue, true);
        }
        if (typeof x === "string") {
          return _resizeString(x, size2, defaultValue);
        }
        var asMatrix = Array.isArray(x) ? false : config3.matrix !== "Array";
        if (size2.length === 0) {
          while (Array.isArray(x)) {
            x = x[0];
          }
          return clone(x);
        } else {
          if (!Array.isArray(x)) {
            x = [x];
          }
          x = clone(x);
          var res = resize(x, size2, defaultValue);
          return asMatrix ? matrix2(res) : res;
        }
      };
      function _resizeString(str, size2, defaultChar) {
        if (defaultChar !== void 0) {
          if (typeof defaultChar !== "string" || defaultChar.length !== 1) {
            throw new TypeError("Single character expected as defaultValue");
          }
        } else {
          defaultChar = " ";
        }
        if (size2.length !== 1) {
          throw new DimensionError(size2.length, 1);
        }
        var len = size2[0];
        if (typeof len !== "number" || !isInteger(len)) {
          throw new TypeError("Invalid size, must contain positive integers (size: " + format3(size2) + ")");
        }
        if (str.length > len) {
          return str.substring(0, len);
        } else if (str.length < len) {
          var res = str;
          for (var i2 = 0, ii = len - str.length; i2 < ii; i2++) {
            res += defaultChar;
          }
          return res;
        } else {
          return str;
        }
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/rotate.js
var name98, dependencies99, createRotate;
var init_rotate = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/rotate.js"() {
    init_factory();
    init_array();
    name98 = "rotate";
    dependencies99 = ["typed", "multiply", "rotationMatrix"];
    createRotate = /* @__PURE__ */ factory(name98, dependencies99, (_ref) => {
      var {
        typed: typed2,
        multiply: multiply2,
        rotationMatrix: rotationMatrix2
      } = _ref;
      return typed2(name98, {
        "Array , number | BigNumber | Complex | Unit": function ArrayNumberBigNumberComplexUnit(w, theta) {
          _validateSize(w, 2);
          var matrixRes = multiply2(rotationMatrix2(theta), w);
          return matrixRes.toArray();
        },
        "Matrix , number | BigNumber | Complex | Unit": function MatrixNumberBigNumberComplexUnit(w, theta) {
          _validateSize(w, 2);
          return multiply2(rotationMatrix2(theta), w);
        },
        "Array, number | BigNumber | Complex | Unit, Array | Matrix": function ArrayNumberBigNumberComplexUnitArrayMatrix(w, theta, v) {
          _validateSize(w, 3);
          var matrixRes = multiply2(rotationMatrix2(theta, v), w);
          return matrixRes;
        },
        "Matrix, number | BigNumber | Complex | Unit, Array | Matrix": function MatrixNumberBigNumberComplexUnitArrayMatrix(w, theta, v) {
          _validateSize(w, 3);
          return multiply2(rotationMatrix2(theta, v), w);
        }
      });
      function _validateSize(v, expectedSize) {
        var actualSize = Array.isArray(v) ? arraySize(v) : v.size();
        if (actualSize.length > 2) {
          throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
        }
        if (actualSize.length === 2 && actualSize[1] !== 1) {
          throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
        }
        if (actualSize[0] !== expectedSize) {
          throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
        }
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/rotationMatrix.js
var name99, dependencies100, createRotationMatrix;
var init_rotationMatrix = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/rotationMatrix.js"() {
    init_is();
    init_factory();
    name99 = "rotationMatrix";
    dependencies100 = ["typed", "config", "multiplyScalar", "addScalar", "unaryMinus", "norm", "matrix", "BigNumber", "DenseMatrix", "SparseMatrix", "cos", "sin"];
    createRotationMatrix = /* @__PURE__ */ factory(name99, dependencies100, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        multiplyScalar: multiplyScalar2,
        addScalar: addScalar2,
        unaryMinus: unaryMinus2,
        norm: norm2,
        BigNumber: BigNumber2,
        matrix: matrix2,
        DenseMatrix: DenseMatrix2,
        SparseMatrix: SparseMatrix2,
        cos: cos2,
        sin: sin2
      } = _ref;
      return typed2(name99, {
        "": function _() {
          return config3.matrix === "Matrix" ? matrix2([]) : [];
        },
        string: function string2(format5) {
          return matrix2(format5);
        },
        "number | BigNumber | Complex | Unit": function numberBigNumberComplexUnit(theta) {
          return _rotationMatrix2x2(theta, config3.matrix === "Matrix" ? "dense" : void 0);
        },
        "number | BigNumber | Complex | Unit, string": function numberBigNumberComplexUnitString(theta, format5) {
          return _rotationMatrix2x2(theta, format5);
        },
        "number | BigNumber | Complex | Unit, Array": function numberBigNumberComplexUnitArray(theta, v) {
          var matrixV = matrix2(v);
          _validateVector(matrixV);
          return _rotationMatrix3x3(theta, matrixV, void 0);
        },
        "number | BigNumber | Complex | Unit, Matrix": function numberBigNumberComplexUnitMatrix(theta, v) {
          _validateVector(v);
          var storageType = v.storage() || (config3.matrix === "Matrix" ? "dense" : void 0);
          return _rotationMatrix3x3(theta, v, storageType);
        },
        "number | BigNumber | Complex | Unit, Array, string": function numberBigNumberComplexUnitArrayString(theta, v, format5) {
          var matrixV = matrix2(v);
          _validateVector(matrixV);
          return _rotationMatrix3x3(theta, matrixV, format5);
        },
        "number | BigNumber | Complex | Unit, Matrix, string": function numberBigNumberComplexUnitMatrixString(theta, v, format5) {
          _validateVector(v);
          return _rotationMatrix3x3(theta, v, format5);
        }
      });
      function _rotationMatrix2x2(theta, format5) {
        var Big = isBigNumber(theta);
        var minusOne = Big ? new BigNumber2(-1) : -1;
        var cosTheta = cos2(theta);
        var sinTheta = sin2(theta);
        var data = [[cosTheta, multiplyScalar2(minusOne, sinTheta)], [sinTheta, cosTheta]];
        return _convertToFormat(data, format5);
      }
      function _validateVector(v) {
        var size2 = v.size();
        if (size2.length < 1 || size2[0] !== 3) {
          throw new RangeError("Vector must be of dimensions 1x3");
        }
      }
      function _mul(array) {
        return array.reduce((p, curr) => multiplyScalar2(p, curr));
      }
      function _convertToFormat(data, format5) {
        if (format5) {
          if (format5 === "sparse") {
            return new SparseMatrix2(data);
          }
          if (format5 === "dense") {
            return new DenseMatrix2(data);
          }
          throw new TypeError('Unknown matrix type "'.concat(format5, '"'));
        }
        return data;
      }
      function _rotationMatrix3x3(theta, v, format5) {
        var normV = norm2(v);
        if (normV === 0) {
          throw new RangeError("Rotation around zero vector");
        }
        var Big = isBigNumber(theta) ? BigNumber2 : null;
        var one = Big ? new Big(1) : 1;
        var minusOne = Big ? new Big(-1) : -1;
        var vx = Big ? new Big(v.get([0]) / normV) : v.get([0]) / normV;
        var vy = Big ? new Big(v.get([1]) / normV) : v.get([1]) / normV;
        var vz = Big ? new Big(v.get([2]) / normV) : v.get([2]) / normV;
        var c = cos2(theta);
        var oneMinusC = addScalar2(one, unaryMinus2(c));
        var s = sin2(theta);
        var r11 = addScalar2(c, _mul([vx, vx, oneMinusC]));
        var r12 = addScalar2(_mul([vx, vy, oneMinusC]), _mul([minusOne, vz, s]));
        var r13 = addScalar2(_mul([vx, vz, oneMinusC]), _mul([vy, s]));
        var r21 = addScalar2(_mul([vx, vy, oneMinusC]), _mul([vz, s]));
        var r22 = addScalar2(c, _mul([vy, vy, oneMinusC]));
        var r23 = addScalar2(_mul([vy, vz, oneMinusC]), _mul([minusOne, vx, s]));
        var r31 = addScalar2(_mul([vx, vz, oneMinusC]), _mul([minusOne, vy, s]));
        var r32 = addScalar2(_mul([vy, vz, oneMinusC]), _mul([vx, s]));
        var r33 = addScalar2(c, _mul([vz, vz, oneMinusC]));
        var data = [[r11, r12, r13], [r21, r22, r23], [r31, r32, r33]];
        return _convertToFormat(data, format5);
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/row.js
var name100, dependencies101, createRow;
var init_row = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/row.js"() {
    init_factory();
    init_object();
    init_array();
    name100 = "row";
    dependencies101 = ["typed", "Index", "matrix", "range"];
    createRow = /* @__PURE__ */ factory(name100, dependencies101, (_ref) => {
      var {
        typed: typed2,
        Index: Index2,
        matrix: matrix2,
        range: range2
      } = _ref;
      return typed2(name100, {
        "Matrix, number": _row,
        "Array, number": function ArrayNumber(value, row2) {
          return _row(matrix2(clone(value)), row2).valueOf();
        }
      });
      function _row(value, row2) {
        if (value.size().length !== 2) {
          throw new Error("Only two dimensional matrix is supported");
        }
        validateIndex(row2, value.size()[0]);
        var columnRange = range2(0, value.size()[1]);
        var index2 = new Index2(row2, columnRange);
        return value.subset(index2);
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/size.js
var name101, dependencies102, createSize;
var init_size = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/size.js"() {
    init_array();
    init_factory();
    init_noop();
    name101 = "size";
    dependencies102 = ["typed", "config", "?matrix"];
    createSize = /* @__PURE__ */ factory(name101, dependencies102, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        matrix: matrix2
      } = _ref;
      return typed2(name101, {
        Matrix: function Matrix2(x) {
          return x.create(x.size());
        },
        Array: arraySize,
        string: function string2(x) {
          return config3.matrix === "Array" ? [x.length] : matrix2([x.length]);
        },
        "number | Complex | BigNumber | Unit | boolean | null": function numberComplexBigNumberUnitBooleanNull(x) {
          return config3.matrix === "Array" ? [] : matrix2 ? matrix2([]) : noMatrix();
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/squeeze.js
var name102, dependencies103, createSqueeze;
var init_squeeze = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/squeeze.js"() {
    init_object();
    init_array();
    init_factory();
    name102 = "squeeze";
    dependencies103 = ["typed", "matrix"];
    createSqueeze = /* @__PURE__ */ factory(name102, dependencies103, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2
      } = _ref;
      return typed2(name102, {
        Array: function Array2(x) {
          return squeeze(clone(x));
        },
        Matrix: function Matrix2(x) {
          var res = squeeze(x.toArray());
          return Array.isArray(res) ? matrix2(res) : res;
        },
        any: function any(x) {
          return clone(x);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/subset.js
function _getSubstring(str, index2) {
  if (!isIndex(index2)) {
    throw new TypeError("Index expected");
  }
  if (index2.size().length !== 1) {
    throw new DimensionError(index2.size().length, 1);
  }
  var strLen = str.length;
  validateIndex(index2.min()[0], strLen);
  validateIndex(index2.max()[0], strLen);
  var range2 = index2.dimension(0);
  var substr = "";
  range2.forEach(function(v) {
    substr += str.charAt(v);
  });
  return substr;
}
function _setSubstring(str, index2, replacement, defaultValue) {
  if (!index2 || index2.isIndex !== true) {
    throw new TypeError("Index expected");
  }
  if (index2.size().length !== 1) {
    throw new DimensionError(index2.size().length, 1);
  }
  if (defaultValue !== void 0) {
    if (typeof defaultValue !== "string" || defaultValue.length !== 1) {
      throw new TypeError("Single character expected as defaultValue");
    }
  } else {
    defaultValue = " ";
  }
  var range2 = index2.dimension(0);
  var len = range2.size()[0];
  if (len !== replacement.length) {
    throw new DimensionError(range2.size()[0], replacement.length);
  }
  var strLen = str.length;
  validateIndex(index2.min()[0]);
  validateIndex(index2.max()[0]);
  var chars = [];
  for (var i2 = 0; i2 < strLen; i2++) {
    chars[i2] = str.charAt(i2);
  }
  range2.forEach(function(v, i3) {
    chars[v] = replacement.charAt(i3[0]);
  });
  if (chars.length > strLen) {
    for (var _i = strLen - 1, _len = chars.length; _i < _len; _i++) {
      if (!chars[_i]) {
        chars[_i] = defaultValue;
      }
    }
  }
  return chars.join("");
}
function _getObjectProperty(object, index2) {
  if (index2.size().length !== 1) {
    throw new DimensionError(index2.size(), 1);
  }
  var key = index2.dimension(0);
  if (typeof key !== "string") {
    throw new TypeError("String expected as index to retrieve an object property");
  }
  return getSafeProperty(object, key);
}
function _setObjectProperty(object, index2, replacement) {
  if (index2.size().length !== 1) {
    throw new DimensionError(index2.size(), 1);
  }
  var key = index2.dimension(0);
  if (typeof key !== "string") {
    throw new TypeError("String expected as index to retrieve an object property");
  }
  var updated = clone(object);
  setSafeProperty(updated, key, replacement);
  return updated;
}
var name103, dependencies104, createSubset;
var init_subset = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/subset.js"() {
    init_is();
    init_object();
    init_array();
    init_customs();
    init_DimensionError();
    init_factory();
    name103 = "subset";
    dependencies104 = ["typed", "matrix"];
    createSubset = /* @__PURE__ */ factory(name103, dependencies104, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2
      } = _ref;
      return typed2(name103, {
        "Array, Index": function ArrayIndex(value, index2) {
          var m = matrix2(value);
          var subset2 = m.subset(index2);
          return index2.isScalar() ? subset2 : subset2.valueOf();
        },
        "Matrix, Index": function MatrixIndex(value, index2) {
          return value.subset(index2);
        },
        "Object, Index": _getObjectProperty,
        "string, Index": _getSubstring,
        "Array, Index, any": function ArrayIndexAny(value, index2, replacement) {
          return matrix2(clone(value)).subset(index2, replacement, void 0).valueOf();
        },
        "Array, Index, any, any": function ArrayIndexAnyAny(value, index2, replacement, defaultValue) {
          return matrix2(clone(value)).subset(index2, replacement, defaultValue).valueOf();
        },
        "Matrix, Index, any": function MatrixIndexAny(value, index2, replacement) {
          return value.clone().subset(index2, replacement);
        },
        "Matrix, Index, any, any": function MatrixIndexAnyAny(value, index2, replacement, defaultValue) {
          return value.clone().subset(index2, replacement, defaultValue);
        },
        "string, Index, string": _setSubstring,
        "string, Index, string, string": _setSubstring,
        "Object, Index, any": _setObjectProperty
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/transpose.js
var name104, dependencies105, createTranspose;
var init_transpose = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/transpose.js"() {
    init_object();
    init_string();
    init_factory();
    name104 = "transpose";
    dependencies105 = ["typed", "matrix"];
    createTranspose = /* @__PURE__ */ factory(name104, dependencies105, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2
      } = _ref;
      return typed2("transpose", {
        Array: function Array2(x) {
          return this(matrix2(x)).valueOf();
        },
        Matrix: function Matrix2(x) {
          var size2 = x.size();
          var c;
          switch (size2.length) {
            case 1:
              c = x.clone();
              break;
            case 2:
              {
                var rows = size2[0];
                var columns = size2[1];
                if (columns === 0) {
                  throw new RangeError("Cannot transpose a 2D matrix with no columns (size: " + format3(size2) + ")");
                }
                switch (x.storage()) {
                  case "dense":
                    c = _denseTranspose(x, rows, columns);
                    break;
                  case "sparse":
                    c = _sparseTranspose(x, rows, columns);
                    break;
                }
              }
              break;
            default:
              throw new RangeError("Matrix must be a vector or two dimensional (size: " + format3(this._size) + ")");
          }
          return c;
        },
        any: function any(x) {
          return clone(x);
        }
      });
      function _denseTranspose(m, rows, columns) {
        var data = m._data;
        var transposed = [];
        var transposedRow;
        for (var j = 0; j < columns; j++) {
          transposedRow = transposed[j] = [];
          for (var i2 = 0; i2 < rows; i2++) {
            transposedRow[i2] = clone(data[i2][j]);
          }
        }
        return m.createDenseMatrix({
          data: transposed,
          size: [columns, rows],
          datatype: m._datatype
        });
      }
      function _sparseTranspose(m, rows, columns) {
        var values = m._values;
        var index2 = m._index;
        var ptr = m._ptr;
        var cvalues = values ? [] : void 0;
        var cindex = [];
        var cptr = [];
        var w = [];
        for (var x = 0; x < rows; x++) {
          w[x] = 0;
        }
        var p, l, j;
        for (p = 0, l = index2.length; p < l; p++) {
          w[index2[p]]++;
        }
        var sum2 = 0;
        for (var i2 = 0; i2 < rows; i2++) {
          cptr.push(sum2);
          sum2 += w[i2];
          w[i2] = cptr[i2];
        }
        cptr.push(sum2);
        for (j = 0; j < columns; j++) {
          for (var k0 = ptr[j], k1 = ptr[j + 1], k = k0; k < k1; k++) {
            var q = w[index2[k]]++;
            cindex[q] = j;
            if (values) {
              cvalues[q] = clone(values[k]);
            }
          }
        }
        return m.createSparseMatrix({
          values: cvalues,
          index: cindex,
          ptr: cptr,
          size: [columns, rows],
          datatype: m._datatype
        });
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/ctranspose.js
var name105, dependencies106, createCtranspose;
var init_ctranspose = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/ctranspose.js"() {
    init_factory();
    name105 = "ctranspose";
    dependencies106 = ["typed", "transpose", "conj"];
    createCtranspose = /* @__PURE__ */ factory(name105, dependencies106, (_ref) => {
      var {
        typed: typed2,
        transpose: transpose2,
        conj: conj2
      } = _ref;
      return typed2(name105, {
        any: function any(x) {
          return conj2(transpose2(x));
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/zeros.js
var name106, dependencies107, createZeros;
var init_zeros = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/zeros.js"() {
    init_is();
    init_number();
    init_array();
    init_factory();
    name106 = "zeros";
    dependencies107 = ["typed", "config", "matrix", "BigNumber"];
    createZeros = /* @__PURE__ */ factory(name106, dependencies107, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        matrix: matrix2,
        BigNumber: BigNumber2
      } = _ref;
      return typed2(name106, {
        "": function _() {
          return config3.matrix === "Array" ? _zeros([]) : _zeros([], "default");
        },
        "...number | BigNumber | string": function numberBigNumberString(size2) {
          var last = size2[size2.length - 1];
          if (typeof last === "string") {
            var format5 = size2.pop();
            return _zeros(size2, format5);
          } else if (config3.matrix === "Array") {
            return _zeros(size2);
          } else {
            return _zeros(size2, "default");
          }
        },
        Array: _zeros,
        Matrix: function Matrix2(size2) {
          var format5 = size2.storage();
          return _zeros(size2.valueOf(), format5);
        },
        "Array | Matrix, string": function ArrayMatrixString(size2, format5) {
          return _zeros(size2.valueOf(), format5);
        }
      });
      function _zeros(size2, format5) {
        var hasBigNumbers = _normalize(size2);
        var defaultValue = hasBigNumbers ? new BigNumber2(0) : 0;
        _validate2(size2);
        if (format5) {
          var m = matrix2(format5);
          if (size2.length > 0) {
            return m.resize(size2, defaultValue);
          }
          return m;
        } else {
          var arr = [];
          if (size2.length > 0) {
            return resize(arr, size2, defaultValue);
          }
          return arr;
        }
      }
      function _normalize(size2) {
        var hasBigNumbers = false;
        size2.forEach(function(value, index2, arr) {
          if (isBigNumber(value)) {
            hasBigNumbers = true;
            arr[index2] = value.toNumber();
          }
        });
        return hasBigNumbers;
      }
      function _validate2(size2) {
        size2.forEach(function(value) {
          if (typeof value !== "number" || !isInteger(value) || value < 0) {
            throw new Error("Parameters in function zeros must be positive integers");
          }
        });
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/fft.js
var name107, dependencies108, createFft;
var init_fft = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/fft.js"() {
    init_array();
    init_factory();
    name107 = "fft";
    dependencies108 = ["typed", "matrix", "addScalar", "multiplyScalar", "divideScalar", "exp", "tau", "i"];
    createFft = /* @__PURE__ */ factory(name107, dependencies108, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        addScalar: addScalar2,
        multiplyScalar: multiplyScalar2,
        divideScalar: divideScalar2,
        exp: exp2,
        tau: tau3,
        i: I
      } = _ref;
      return typed2(name107, {
        Array: _ndFft,
        Matrix: function Matrix2(matrix3) {
          return matrix3.create(_ndFft(matrix3.toArray()));
        }
      });
      function _ndFft(arr) {
        var size2 = arraySize(arr);
        if (size2.length === 1)
          return _fft(arr, size2[0]);
        return _1dFft(arr.map((slice) => _ndFft(slice, size2.slice(1))), 0);
      }
      function _1dFft(arr, dim) {
        var size2 = arraySize(arr);
        if (dim !== 0)
          return new Array(size2[0]).fill(0).map((_, i2) => _1dFft(arr[i2], dim - 1));
        if (size2.length === 1)
          return _fft(arr);
        function _transpose(arr2) {
          var size3 = arraySize(arr2);
          return new Array(size3[1]).fill(0).map((_, j) => new Array(size3[0]).fill(0).map((_2, i2) => arr2[i2][j]));
        }
        return _transpose(_1dFft(_transpose(arr), 1));
      }
      function _fft(arr) {
        var len = arr.length;
        if (len === 1)
          return [arr[0]];
        if (len % 2 === 0) {
          var ret = [..._fft(arr.filter((_, i2) => i2 % 2 === 0), len / 2), ..._fft(arr.filter((_, i2) => i2 % 2 === 1), len / 2)];
          for (var k = 0; k < len / 2; k++) {
            var p = ret[k];
            var q = multiplyScalar2(ret[k + len / 2], exp2(multiplyScalar2(multiplyScalar2(tau3, I), divideScalar2(-k, len))));
            ret[k] = addScalar2(p, q);
            ret[k + len / 2] = addScalar2(p, multiplyScalar2(-1, q));
          }
          return ret;
        }
        throw new Error("Can only calculate FFT of power-of-two size");
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/ifft.js
var name108, dependencies109, createIfft;
var init_ifft = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/ifft.js"() {
    init_array();
    init_factory();
    init_is();
    name108 = "ifft";
    dependencies109 = ["typed", "fft", "dotDivide", "conj"];
    createIfft = /* @__PURE__ */ factory(name108, dependencies109, (_ref) => {
      var {
        typed: typed2,
        fft: fft2,
        dotDivide: dotDivide2,
        conj: conj2
      } = _ref;
      return typed2(name108, {
        "Array | Matrix": function ArrayMatrix(arr) {
          var size2 = isMatrix(arr) ? arr.size() : arraySize(arr);
          return dotDivide2(conj2(fft2(conj2(arr))), size2.reduce((acc, curr) => acc * curr, 1));
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/special/erf.js
var name109, dependencies110, createErf, THRESH, SQRPI, P, Q, MAX_NUM;
var init_erf = __esm({
  "node_modules/mathjs/lib/esm/function/special/erf.js"() {
    init_collection();
    init_number();
    init_factory();
    name109 = "erf";
    dependencies110 = ["typed"];
    createErf = /* @__PURE__ */ factory(name109, dependencies110, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2("name", {
        number: function number2(x) {
          var y = Math.abs(x);
          if (y >= MAX_NUM) {
            return sign(x);
          }
          if (y <= THRESH) {
            return sign(x) * erf1(y);
          }
          if (y <= 4) {
            return sign(x) * (1 - erfc2(y));
          }
          return sign(x) * (1 - erfc3(y));
        },
        "Array | Matrix": function ArrayMatrix(n) {
          return deepMap(n, this);
        }
      });
      function erf1(y) {
        var ysq = y * y;
        var xnum = P[0][4] * ysq;
        var xden = ysq;
        var i2;
        for (i2 = 0; i2 < 3; i2 += 1) {
          xnum = (xnum + P[0][i2]) * ysq;
          xden = (xden + Q[0][i2]) * ysq;
        }
        return y * (xnum + P[0][3]) / (xden + Q[0][3]);
      }
      function erfc2(y) {
        var xnum = P[1][8] * y;
        var xden = y;
        var i2;
        for (i2 = 0; i2 < 7; i2 += 1) {
          xnum = (xnum + P[1][i2]) * y;
          xden = (xden + Q[1][i2]) * y;
        }
        var result = (xnum + P[1][7]) / (xden + Q[1][7]);
        var ysq = parseInt(y * 16) / 16;
        var del = (y - ysq) * (y + ysq);
        return Math.exp(-ysq * ysq) * Math.exp(-del) * result;
      }
      function erfc3(y) {
        var ysq = 1 / (y * y);
        var xnum = P[2][5] * ysq;
        var xden = ysq;
        var i2;
        for (i2 = 0; i2 < 4; i2 += 1) {
          xnum = (xnum + P[2][i2]) * ysq;
          xden = (xden + Q[2][i2]) * ysq;
        }
        var result = ysq * (xnum + P[2][4]) / (xden + Q[2][4]);
        result = (SQRPI - result) / y;
        ysq = parseInt(y * 16) / 16;
        var del = (y - ysq) * (y + ysq);
        return Math.exp(-ysq * ysq) * Math.exp(-del) * result;
      }
    });
    THRESH = 0.46875;
    SQRPI = 0.5641895835477563;
    P = [[3.1611237438705655, 113.86415415105016, 377.485237685302, 3209.3775891384694, 0.18577770618460315], [0.5641884969886701, 8.883149794388377, 66.11919063714163, 298.6351381974001, 881.952221241769, 1712.0476126340707, 2051.0783778260716, 1230.3393547979972, 21531153547440383e-24], [0.30532663496123236, 0.36034489994980445, 0.12578172611122926, 0.016083785148742275, 6587491615298378e-19, 0.016315387137302097]];
    Q = [[23.601290952344122, 244.02463793444417, 1282.6165260773723, 2844.236833439171], [15.744926110709835, 117.6939508913125, 537.1811018620099, 1621.3895745666903, 3290.7992357334597, 4362.619090143247, 3439.3676741437216, 1230.3393548037495], [2.568520192289822, 1.8729528499234604, 0.5279051029514285, 0.06051834131244132, 0.0023352049762686918]];
    MAX_NUM = Math.pow(2, 53);
  }
});

// node_modules/mathjs/lib/esm/function/statistics/mode.js
var name110, dependencies111, createMode;
var init_mode = __esm({
  "node_modules/mathjs/lib/esm/function/statistics/mode.js"() {
    init_array();
    init_factory();
    name110 = "mode";
    dependencies111 = ["typed", "isNaN", "isNumeric"];
    createMode = /* @__PURE__ */ factory(name110, dependencies111, (_ref) => {
      var {
        typed: typed2,
        isNaN: isNaN3,
        isNumeric: isNumeric2
      } = _ref;
      return typed2(name110, {
        "Array | Matrix": _mode,
        "...": function _(args) {
          return _mode(args);
        }
      });
      function _mode(values) {
        values = flatten(values.valueOf());
        var num = values.length;
        if (num === 0) {
          throw new Error("Cannot calculate mode of an empty array");
        }
        var count2 = {};
        var mode2 = [];
        var max2 = 0;
        for (var i2 = 0; i2 < values.length; i2++) {
          var value = values[i2];
          if (isNumeric2(value) && isNaN3(value)) {
            throw new Error("Cannot calculate mode of an array containing NaN values");
          }
          if (!(value in count2)) {
            count2[value] = 0;
          }
          count2[value]++;
          if (count2[value] === max2) {
            mode2.push(value);
          } else if (count2[value] > max2) {
            max2 = count2[value];
            mode2 = [value];
          }
        }
        return mode2;
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/statistics/utils/improveErrorMessage.js
function improveErrorMessage(err, fnName, value) {
  var details;
  if (String(err).indexOf("Unexpected type") !== -1) {
    details = arguments.length > 2 ? " (type: " + typeOf(value) + ", value: " + JSON.stringify(value) + ")" : " (type: " + err.data.actual + ")";
    return new TypeError("Cannot calculate " + fnName + ", unexpected type of argument" + details);
  }
  if (String(err).indexOf("complex numbers") !== -1) {
    details = arguments.length > 2 ? " (type: " + typeOf(value) + ", value: " + JSON.stringify(value) + ")" : "";
    return new TypeError("Cannot calculate " + fnName + ", no ordering relation is defined for complex numbers" + details);
  }
  return err;
}
var init_improveErrorMessage = __esm({
  "node_modules/mathjs/lib/esm/function/statistics/utils/improveErrorMessage.js"() {
    init_is();
  }
});

// node_modules/mathjs/lib/esm/function/statistics/prod.js
var name111, dependencies112, createProd;
var init_prod = __esm({
  "node_modules/mathjs/lib/esm/function/statistics/prod.js"() {
    init_collection();
    init_factory();
    init_improveErrorMessage();
    name111 = "prod";
    dependencies112 = ["typed", "config", "multiplyScalar", "numeric"];
    createProd = /* @__PURE__ */ factory(name111, dependencies112, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        multiplyScalar: multiplyScalar2,
        numeric: numeric3
      } = _ref;
      return typed2(name111, {
        "Array | Matrix": _prod,
        "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
          throw new Error("prod(A, dim) is not yet supported");
        },
        "...": function _(args) {
          return _prod(args);
        }
      });
      function _prod(array) {
        var prod2;
        deepForEach(array, function(value) {
          try {
            prod2 = prod2 === void 0 ? value : multiplyScalar2(prod2, value);
          } catch (err) {
            throw improveErrorMessage(err, "prod", value);
          }
        });
        if (typeof prod2 === "string") {
          prod2 = numeric3(prod2, config3.number);
        }
        if (prod2 === void 0) {
          throw new Error("Cannot calculate prod of an empty array");
        }
        return prod2;
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/string/format.js
var name112, dependencies113, createFormat;
var init_format = __esm({
  "node_modules/mathjs/lib/esm/function/string/format.js"() {
    init_string();
    init_factory();
    name112 = "format";
    dependencies113 = ["typed"];
    createFormat = /* @__PURE__ */ factory(name112, dependencies113, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2(name112, {
        any: format3,
        "any, Object | function | number": format3
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/string/bin.js
var name113, dependencies114, createBin;
var init_bin = __esm({
  "node_modules/mathjs/lib/esm/function/string/bin.js"() {
    init_factory();
    name113 = "bin";
    dependencies114 = ["typed", "format"];
    createBin = factory(name113, dependencies114, (_ref) => {
      var {
        typed: typed2,
        format: format5
      } = _ref;
      return typed2(name113, {
        "number | BigNumber": function numberBigNumber(n) {
          return format5(n, {
            notation: "bin"
          });
        },
        "number | BigNumber, number": function numberBigNumberNumber(n, wordSize) {
          return format5(n, {
            notation: "bin",
            wordSize
          });
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/string/oct.js
var name114, dependencies115, createOct;
var init_oct = __esm({
  "node_modules/mathjs/lib/esm/function/string/oct.js"() {
    init_factory();
    name114 = "oct";
    dependencies115 = ["typed", "format"];
    createOct = factory(name114, dependencies115, (_ref) => {
      var {
        typed: typed2,
        format: format5
      } = _ref;
      return typed2(name114, {
        "number | BigNumber": function numberBigNumber(n) {
          return format5(n, {
            notation: "oct"
          });
        },
        "number | BigNumber, number": function numberBigNumberNumber(n, wordSize) {
          return format5(n, {
            notation: "oct",
            wordSize
          });
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/string/hex.js
var name115, dependencies116, createHex;
var init_hex = __esm({
  "node_modules/mathjs/lib/esm/function/string/hex.js"() {
    init_factory();
    name115 = "hex";
    dependencies116 = ["typed", "format"];
    createHex = factory(name115, dependencies116, (_ref) => {
      var {
        typed: typed2,
        format: format5
      } = _ref;
      return typed2(name115, {
        "number | BigNumber": function numberBigNumber(n) {
          return format5(n, {
            notation: "hex"
          });
        },
        "number | BigNumber, number": function numberBigNumberNumber(n, wordSize) {
          return format5(n, {
            notation: "hex",
            wordSize
          });
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/string/print.js
function _print(template, values, options) {
  return template.replace(/\$([\w.]+)/g, function(original, key) {
    var keys = key.split(".");
    var value = values[keys.shift()];
    while (keys.length && value !== void 0) {
      var k = keys.shift();
      value = k ? value[k] : value + ".";
    }
    if (value !== void 0) {
      if (!isString2(value)) {
        return format3(value, options);
      } else {
        return value;
      }
    }
    return original;
  });
}
var name116, dependencies117, createPrint;
var init_print = __esm({
  "node_modules/mathjs/lib/esm/function/string/print.js"() {
    init_string();
    init_is();
    init_factory();
    name116 = "print";
    dependencies117 = ["typed"];
    createPrint = /* @__PURE__ */ factory(name116, dependencies117, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2(name116, {
        "string, Object | Array": _print,
        "string, Object | Array, number | Object": _print
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/unit/to.js
var name117, dependencies118, createTo;
var init_to = __esm({
  "node_modules/mathjs/lib/esm/function/unit/to.js"() {
    init_factory();
    init_algorithm13();
    init_algorithm14();
    name117 = "to";
    dependencies118 = ["typed", "matrix"];
    createTo = /* @__PURE__ */ factory(name117, dependencies118, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2
      } = _ref;
      var algorithm13 = createAlgorithm13({
        typed: typed2
      });
      var algorithm14 = createAlgorithm14({
        typed: typed2
      });
      return typed2(name117, {
        "Unit, Unit | string": function UnitUnitString(x, unit2) {
          return x.to(unit2);
        },
        "Matrix, Matrix": function MatrixMatrix(x, y) {
          return algorithm13(x, y, this);
        },
        "Array, Array": function ArrayArray(x, y) {
          return this(matrix2(x), matrix2(y)).valueOf();
        },
        "Array, Matrix": function ArrayMatrix(x, y) {
          return this(matrix2(x), y);
        },
        "Matrix, Array": function MatrixArray(x, y) {
          return this(x, matrix2(y));
        },
        "Matrix, any": function MatrixAny(x, y) {
          return algorithm14(x, y, this, false);
        },
        "any, Matrix": function anyMatrix(x, y) {
          return algorithm14(y, x, this, true);
        },
        "Array, any": function ArrayAny(x, y) {
          return algorithm14(matrix2(x), y, this, false).valueOf();
        },
        "any, Array": function anyArray(x, y) {
          return algorithm14(matrix2(y), x, this, true).valueOf();
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/utils/isPrime.js
var name118, dependencies119, createIsPrime;
var init_isPrime = __esm({
  "node_modules/mathjs/lib/esm/function/utils/isPrime.js"() {
    init_collection();
    init_factory();
    name118 = "isPrime";
    dependencies119 = ["typed"];
    createIsPrime = /* @__PURE__ */ factory(name118, dependencies119, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2(name118, {
        number: function number2(x) {
          if (x * 0 !== 0) {
            return false;
          }
          if (x <= 3) {
            return x > 1;
          }
          if (x % 2 === 0 || x % 3 === 0) {
            return false;
          }
          for (var i2 = 5; i2 * i2 <= x; i2 += 6) {
            if (x % i2 === 0 || x % (i2 + 2) === 0) {
              return false;
            }
          }
          return true;
        },
        BigNumber: function BigNumber2(n) {
          if (n.toNumber() * 0 !== 0) {
            return false;
          }
          if (n.lte(3))
            return n.gt(1);
          if (n.mod(2).eq(0) || n.mod(3).eq(0))
            return false;
          if (n.lt(Math.pow(2, 32))) {
            var x = n.toNumber();
            for (var i2 = 5; i2 * i2 <= x; i2 += 6) {
              if (x % i2 === 0 || x % (i2 + 2) === 0) {
                return false;
              }
            }
            return true;
          }
          function modPow(base, exponent, modulus) {
            var accumulator = 1;
            while (!exponent.eq(0)) {
              if (exponent.mod(2).eq(0)) {
                exponent = exponent.div(2);
                base = base.mul(base).mod(modulus);
              } else {
                exponent = exponent.sub(1);
                accumulator = base.mul(accumulator).mod(modulus);
              }
            }
            return accumulator;
          }
          var Decimal4 = n.constructor.clone({
            precision: n.toFixed(0).length * 2
          });
          n = new Decimal4(n);
          var r = 0;
          var d = n.sub(1);
          while (d.mod(2).eq(0)) {
            d = d.div(2);
            r += 1;
          }
          var bases = null;
          if (n.lt("3317044064679887385961981")) {
            bases = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41].filter((x2) => x2 < n);
          } else {
            var max2 = Math.min(n.toNumber() - 2, Math.floor(2 * Math.pow(n.toFixed(0).length * Math.log(10), 2)));
            bases = [];
            for (var _i = 2; _i <= max2; _i += 1) {
              bases.push(max2);
            }
          }
          for (var _i2 = 0; _i2 < bases.length; _i2 += 1) {
            var a = bases[_i2];
            var adn = modPow(n.sub(n).add(a), d, n);
            if (!adn.eq(1)) {
              for (var _i3 = 0, _x = adn; !_x.eq(n.sub(1)); _i3 += 1, _x = _x.mul(_x).mod(n)) {
                if (_i3 === r - 1) {
                  return false;
                }
              }
            }
          }
          return true;
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/utils/numeric.js
var name119, dependencies120, createNumeric;
var init_numeric = __esm({
  "node_modules/mathjs/lib/esm/function/utils/numeric.js"() {
    init_is();
    init_factory();
    init_noop();
    name119 = "numeric";
    dependencies120 = ["number", "?bignumber", "?fraction"];
    createNumeric = /* @__PURE__ */ factory(name119, dependencies120, (_ref) => {
      var {
        number: _number,
        bignumber: bignumber2,
        fraction: fraction2
      } = _ref;
      var validInputTypes = {
        string: true,
        number: true,
        BigNumber: true,
        Fraction: true
      };
      var validOutputTypes = {
        number: (x) => _number(x),
        BigNumber: bignumber2 ? (x) => bignumber2(x) : noBignumber,
        Fraction: fraction2 ? (x) => fraction2(x) : noFraction
      };
      return function numeric3(value, outputType) {
        var inputType = typeOf(value);
        if (!(inputType in validInputTypes)) {
          throw new TypeError("Cannot convert " + value + ' of type "' + inputType + '"; valid input types are ' + Object.keys(validInputTypes).join(", "));
        }
        if (!(outputType in validOutputTypes)) {
          throw new TypeError("Cannot convert " + value + ' to type "' + outputType + '"; valid output types are ' + Object.keys(validOutputTypes).join(", "));
        }
        if (outputType === inputType) {
          return value;
        } else {
          return validOutputTypes[outputType](value);
        }
      };
    });
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/divideScalar.js
var name120, dependencies121, createDivideScalar;
var init_divideScalar = __esm({
  "node_modules/mathjs/lib/esm/function/arithmetic/divideScalar.js"() {
    init_factory();
    init_is();
    name120 = "divideScalar";
    dependencies121 = ["typed", "numeric"];
    createDivideScalar = /* @__PURE__ */ factory(name120, dependencies121, (_ref) => {
      var {
        typed: typed2,
        numeric: numeric3
      } = _ref;
      return typed2(name120, {
        "number, number": function numberNumber(x, y) {
          return x / y;
        },
        "Complex, Complex": function ComplexComplex(x, y) {
          return x.div(y);
        },
        "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
          return x.div(y);
        },
        "Fraction, Fraction": function FractionFraction(x, y) {
          return x.div(y);
        },
        "Unit, number | Fraction | BigNumber": function UnitNumberFractionBigNumber(x, y) {
          var res = x.clone();
          var one = numeric3(1, typeOf(y));
          res.value = this(res.value === null ? res._normalize(one) : res.value, y);
          return res;
        },
        "number | Fraction | BigNumber, Unit": function numberFractionBigNumberUnit(x, y) {
          var res = y.clone();
          res = res.pow(-1);
          var one = numeric3(1, typeOf(x));
          res.value = this(x, y.value === null ? y._normalize(one) : y.value);
          return res;
        },
        "Unit, Unit": function UnitUnit(x, y) {
          return x.divide(y);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/pow.js
var name121, dependencies122, createPow;
var init_pow = __esm({
  "node_modules/mathjs/lib/esm/function/arithmetic/pow.js"() {
    init_factory();
    init_number();
    init_array();
    init_number2();
    name121 = "pow";
    dependencies122 = ["typed", "config", "identity", "multiply", "matrix", "inv", "fraction", "number", "Complex"];
    createPow = /* @__PURE__ */ factory(name121, dependencies122, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        identity: identity2,
        multiply: multiply2,
        matrix: matrix2,
        inv: inv2,
        number: number2,
        fraction: fraction2,
        Complex: Complex3
      } = _ref;
      return typed2(name121, {
        "number, number": _pow,
        "Complex, Complex": function ComplexComplex(x, y) {
          return x.pow(y);
        },
        "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
          if (y.isInteger() || x >= 0 || config3.predictable) {
            return x.pow(y);
          } else {
            return new Complex3(x.toNumber(), 0).pow(y.toNumber(), 0);
          }
        },
        "Fraction, Fraction": function FractionFraction(x, y) {
          var result = x.pow(y);
          if (result != null) {
            return result;
          }
          if (config3.predictable) {
            throw new Error("Result of pow is non-rational and cannot be expressed as a fraction");
          } else {
            return _pow(x.valueOf(), y.valueOf());
          }
        },
        "Array, number": _powArray,
        "Array, BigNumber": function ArrayBigNumber(x, y) {
          return _powArray(x, y.toNumber());
        },
        "Matrix, number": _powMatrix,
        "Matrix, BigNumber": function MatrixBigNumber(x, y) {
          return _powMatrix(x, y.toNumber());
        },
        "Unit, number | BigNumber": function UnitNumberBigNumber(x, y) {
          return x.pow(y);
        }
      });
      function _pow(x, y) {
        if (config3.predictable && !isInteger(y) && x < 0) {
          try {
            var yFrac = fraction2(y);
            var yNum = number2(yFrac);
            if (y === yNum || Math.abs((y - yNum) / y) < 1e-14) {
              if (yFrac.d % 2 === 1) {
                return (yFrac.n % 2 === 0 ? 1 : -1) * Math.pow(-x, y);
              }
            }
          } catch (ex) {
          }
        }
        if (config3.predictable && (x < -1 && y === Infinity || x > -1 && x < 0 && y === -Infinity)) {
          return NaN;
        }
        if (isInteger(y) || x >= 0 || config3.predictable) {
          return powNumber(x, y);
        } else {
          if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {
            return 0;
          }
          return new Complex3(x, 0).pow(y, 0);
        }
      }
      function _powArray(x, y) {
        if (!isInteger(y)) {
          throw new TypeError("For A^b, b must be an integer (value is " + y + ")");
        }
        var s = arraySize(x);
        if (s.length !== 2) {
          throw new Error("For A^b, A must be 2 dimensional (A has " + s.length + " dimensions)");
        }
        if (s[0] !== s[1]) {
          throw new Error("For A^b, A must be square (size is " + s[0] + "x" + s[1] + ")");
        }
        if (y < 0) {
          try {
            return _powArray(inv2(x), -y);
          } catch (error) {
            if (error.message === "Cannot calculate inverse, determinant is zero") {
              throw new TypeError("For A^b, when A is not invertible, b must be a positive integer (value is " + y + ")");
            }
            throw error;
          }
        }
        var res = identity2(s[0]).valueOf();
        var px = x;
        while (y >= 1) {
          if ((y & 1) === 1) {
            res = multiply2(px, res);
          }
          y >>= 1;
          px = multiply2(px, px);
        }
        return res;
      }
      function _powMatrix(x, y) {
        return matrix2(_powArray(x.valueOf(), y));
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/round.js
var NO_INT, name122, dependencies123, createRound;
var init_round = __esm({
  "node_modules/mathjs/lib/esm/function/arithmetic/round.js"() {
    init_factory();
    init_collection();
    init_algorithm11();
    init_algorithm12();
    init_algorithm14();
    init_number2();
    NO_INT = "Number of decimals in function round must be an integer";
    name122 = "round";
    dependencies123 = ["typed", "matrix", "equalScalar", "zeros", "BigNumber", "DenseMatrix"];
    createRound = /* @__PURE__ */ factory(name122, dependencies123, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        equalScalar: equalScalar2,
        zeros: zeros3,
        BigNumber: BigNumber2,
        DenseMatrix: DenseMatrix2
      } = _ref;
      var algorithm11 = createAlgorithm11({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm12 = createAlgorithm12({
        typed: typed2,
        DenseMatrix: DenseMatrix2
      });
      var algorithm14 = createAlgorithm14({
        typed: typed2
      });
      return typed2(name122, {
        number: roundNumber,
        "number, number": roundNumber,
        "number, BigNumber": function numberBigNumber(x, n) {
          if (!n.isInteger()) {
            throw new TypeError(NO_INT);
          }
          return new BigNumber2(x).toDecimalPlaces(n.toNumber());
        },
        Complex: function Complex3(x) {
          return x.round();
        },
        "Complex, number": function ComplexNumber(x, n) {
          if (n % 1) {
            throw new TypeError(NO_INT);
          }
          return x.round(n);
        },
        "Complex, BigNumber": function ComplexBigNumber(x, n) {
          if (!n.isInteger()) {
            throw new TypeError(NO_INT);
          }
          var _n = n.toNumber();
          return x.round(_n);
        },
        BigNumber: function BigNumber3(x) {
          return x.toDecimalPlaces(0);
        },
        "BigNumber, BigNumber": function BigNumberBigNumber(x, n) {
          if (!n.isInteger()) {
            throw new TypeError(NO_INT);
          }
          return x.toDecimalPlaces(n.toNumber());
        },
        Fraction: function Fraction3(x) {
          return x.round();
        },
        "Fraction, number": function FractionNumber(x, n) {
          if (n % 1) {
            throw new TypeError(NO_INT);
          }
          return x.round(n);
        },
        "Fraction, BigNumber": function FractionBigNumber(x, n) {
          if (!n.isInteger()) {
            throw new TypeError(NO_INT);
          }
          return x.round(n.toNumber());
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this, true);
        },
        "SparseMatrix, number | BigNumber": function SparseMatrixNumberBigNumber(x, y) {
          return algorithm11(x, y, this, false);
        },
        "DenseMatrix, number | BigNumber": function DenseMatrixNumberBigNumber(x, y) {
          return algorithm14(x, y, this, false);
        },
        "Array, number | BigNumber": function ArrayNumberBigNumber(x, y) {
          return algorithm14(matrix2(x), y, this, false).valueOf();
        },
        "number | Complex | BigNumber | Fraction, SparseMatrix": function numberComplexBigNumberFractionSparseMatrix(x, y) {
          if (equalScalar2(x, 0)) {
            return zeros3(y.size(), y.storage());
          }
          return algorithm12(y, x, this, true);
        },
        "number | Complex | BigNumber | Fraction, DenseMatrix": function numberComplexBigNumberFractionDenseMatrix(x, y) {
          if (equalScalar2(x, 0)) {
            return zeros3(y.size(), y.storage());
          }
          return algorithm14(y, x, this, true);
        },
        "number | Complex | BigNumber | Fraction, Array": function numberComplexBigNumberFractionArray(x, y) {
          return algorithm14(matrix2(y), x, this, true).valueOf();
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/log.js
var name123, dependencies124, createLog;
var init_log = __esm({
  "node_modules/mathjs/lib/esm/function/arithmetic/log.js"() {
    init_factory();
    init_collection();
    init_number2();
    name123 = "log";
    dependencies124 = ["config", "typed", "divideScalar", "Complex"];
    createLog = /* @__PURE__ */ factory(name123, dependencies124, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        divideScalar: divideScalar2,
        Complex: Complex3
      } = _ref;
      return typed2(name123, {
        number: function number2(x) {
          if (x >= 0 || config3.predictable) {
            return logNumber(x);
          } else {
            return new Complex3(x, 0).log();
          }
        },
        Complex: function Complex4(x) {
          return x.log();
        },
        BigNumber: function BigNumber2(x) {
          if (!x.isNegative() || config3.predictable) {
            return x.ln();
          } else {
            return new Complex3(x.toNumber(), 0).log();
          }
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        },
        "any, any": function anyAny(x, base) {
          return divideScalar2(this(x), this(base));
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/log1p.js
var name124, dependencies125, createLog1p;
var init_log1p = __esm({
  "node_modules/mathjs/lib/esm/function/arithmetic/log1p.js"() {
    init_factory();
    init_collection();
    init_number();
    name124 = "log1p";
    dependencies125 = ["typed", "config", "divideScalar", "log", "Complex"];
    createLog1p = /* @__PURE__ */ factory(name124, dependencies125, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        divideScalar: divideScalar2,
        log: log3,
        Complex: Complex3
      } = _ref;
      return typed2(name124, {
        number: function number2(x) {
          if (x >= -1 || config3.predictable) {
            return log1p(x);
          } else {
            return _log1pComplex(new Complex3(x, 0));
          }
        },
        Complex: _log1pComplex,
        BigNumber: function BigNumber2(x) {
          var y = x.plus(1);
          if (!y.isNegative() || config3.predictable) {
            return y.ln();
          } else {
            return _log1pComplex(new Complex3(x.toNumber(), 0));
          }
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        },
        "any, any": function anyAny(x, base) {
          return divideScalar2(this(x), log3(base));
        }
      });
      function _log1pComplex(x) {
        var xRe1p = x.re + 1;
        return new Complex3(Math.log(Math.sqrt(xRe1p * xRe1p + x.im * x.im)), Math.atan2(x.im, xRe1p));
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/nthRoots.js
var name125, dependencies126, createNthRoots;
var init_nthRoots = __esm({
  "node_modules/mathjs/lib/esm/function/arithmetic/nthRoots.js"() {
    init_factory();
    name125 = "nthRoots";
    dependencies126 = ["config", "typed", "divideScalar", "Complex"];
    createNthRoots = /* @__PURE__ */ factory(name125, dependencies126, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        divideScalar: divideScalar2,
        Complex: Complex3
      } = _ref;
      var _calculateExactResult = [function realPos(val) {
        return new Complex3(val, 0);
      }, function imagPos(val) {
        return new Complex3(0, val);
      }, function realNeg(val) {
        return new Complex3(-val, 0);
      }, function imagNeg(val) {
        return new Complex3(0, -val);
      }];
      function _nthComplexRoots(a, root) {
        if (root < 0)
          throw new Error("Root must be greater than zero");
        if (root === 0)
          throw new Error("Root must be non-zero");
        if (root % 1 !== 0)
          throw new Error("Root must be an integer");
        if (a === 0 || a.abs() === 0)
          return [new Complex3(0, 0)];
        var aIsNumeric = typeof a === "number";
        var offset;
        if (aIsNumeric || a.re === 0 || a.im === 0) {
          if (aIsNumeric) {
            offset = 2 * +(a < 0);
          } else if (a.im === 0) {
            offset = 2 * +(a.re < 0);
          } else {
            offset = 2 * +(a.im < 0) + 1;
          }
        }
        var arg2 = a.arg();
        var abs2 = a.abs();
        var roots = [];
        var r = Math.pow(abs2, 1 / root);
        for (var k = 0; k < root; k++) {
          var halfPiFactor = (offset + 4 * k) / root;
          if (halfPiFactor === Math.round(halfPiFactor)) {
            roots.push(_calculateExactResult[halfPiFactor % 4](r));
            continue;
          }
          roots.push(new Complex3({
            r,
            phi: (arg2 + 2 * Math.PI * k) / root
          }));
        }
        return roots;
      }
      return typed2(name125, {
        Complex: function Complex4(x) {
          return _nthComplexRoots(x, 2);
        },
        "Complex, number": _nthComplexRoots
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/dotPow.js
var name126, dependencies127, createDotPow;
var init_dotPow = __esm({
  "node_modules/mathjs/lib/esm/function/arithmetic/dotPow.js"() {
    init_factory();
    init_algorithm03();
    init_algorithm07();
    init_algorithm11();
    init_algorithm12();
    init_algorithm13();
    init_algorithm14();
    name126 = "dotPow";
    dependencies127 = ["typed", "equalScalar", "matrix", "pow", "DenseMatrix"];
    createDotPow = /* @__PURE__ */ factory(name126, dependencies127, (_ref) => {
      var {
        typed: typed2,
        equalScalar: equalScalar2,
        matrix: matrix2,
        pow: pow2,
        DenseMatrix: DenseMatrix2
      } = _ref;
      var algorithm03 = createAlgorithm03({
        typed: typed2
      });
      var algorithm07 = createAlgorithm07({
        typed: typed2,
        DenseMatrix: DenseMatrix2
      });
      var algorithm11 = createAlgorithm11({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm12 = createAlgorithm12({
        typed: typed2,
        DenseMatrix: DenseMatrix2
      });
      var algorithm13 = createAlgorithm13({
        typed: typed2
      });
      var algorithm14 = createAlgorithm14({
        typed: typed2
      });
      return typed2(name126, {
        "any, any": pow2,
        "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
          return algorithm07(x, y, pow2, false);
        },
        "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
          return algorithm03(y, x, pow2, true);
        },
        "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
          return algorithm03(x, y, pow2, false);
        },
        "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
          return algorithm13(x, y, pow2);
        },
        "Array, Array": function ArrayArray(x, y) {
          return this(matrix2(x), matrix2(y)).valueOf();
        },
        "Array, Matrix": function ArrayMatrix(x, y) {
          return this(matrix2(x), y);
        },
        "Matrix, Array": function MatrixArray(x, y) {
          return this(x, matrix2(y));
        },
        "SparseMatrix, any": function SparseMatrixAny(x, y) {
          return algorithm11(x, y, this, false);
        },
        "DenseMatrix, any": function DenseMatrixAny(x, y) {
          return algorithm14(x, y, this, false);
        },
        "any, SparseMatrix": function anySparseMatrix(x, y) {
          return algorithm12(y, x, this, true);
        },
        "any, DenseMatrix": function anyDenseMatrix(x, y) {
          return algorithm14(y, x, this, true);
        },
        "Array, any": function ArrayAny(x, y) {
          return algorithm14(matrix2(x), y, this, false).valueOf();
        },
        "any, Array": function anyArray(x, y) {
          return algorithm14(matrix2(y), x, this, true).valueOf();
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/dotDivide.js
var name127, dependencies128, createDotDivide;
var init_dotDivide = __esm({
  "node_modules/mathjs/lib/esm/function/arithmetic/dotDivide.js"() {
    init_factory();
    init_algorithm02();
    init_algorithm03();
    init_algorithm07();
    init_algorithm11();
    init_algorithm12();
    init_algorithm13();
    init_algorithm14();
    name127 = "dotDivide";
    dependencies128 = ["typed", "matrix", "equalScalar", "divideScalar", "DenseMatrix"];
    createDotDivide = /* @__PURE__ */ factory(name127, dependencies128, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        equalScalar: equalScalar2,
        divideScalar: divideScalar2,
        DenseMatrix: DenseMatrix2
      } = _ref;
      var algorithm02 = createAlgorithm02({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm03 = createAlgorithm03({
        typed: typed2
      });
      var algorithm07 = createAlgorithm07({
        typed: typed2,
        DenseMatrix: DenseMatrix2
      });
      var algorithm11 = createAlgorithm11({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm12 = createAlgorithm12({
        typed: typed2,
        DenseMatrix: DenseMatrix2
      });
      var algorithm13 = createAlgorithm13({
        typed: typed2
      });
      var algorithm14 = createAlgorithm14({
        typed: typed2
      });
      return typed2(name127, {
        "any, any": divideScalar2,
        "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
          return algorithm07(x, y, divideScalar2, false);
        },
        "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
          return algorithm02(y, x, divideScalar2, true);
        },
        "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
          return algorithm03(x, y, divideScalar2, false);
        },
        "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
          return algorithm13(x, y, divideScalar2);
        },
        "Array, Array": function ArrayArray(x, y) {
          return this(matrix2(x), matrix2(y)).valueOf();
        },
        "Array, Matrix": function ArrayMatrix(x, y) {
          return this(matrix2(x), y);
        },
        "Matrix, Array": function MatrixArray(x, y) {
          return this(x, matrix2(y));
        },
        "SparseMatrix, any": function SparseMatrixAny(x, y) {
          return algorithm11(x, y, divideScalar2, false);
        },
        "DenseMatrix, any": function DenseMatrixAny(x, y) {
          return algorithm14(x, y, divideScalar2, false);
        },
        "any, SparseMatrix": function anySparseMatrix(x, y) {
          return algorithm12(y, x, divideScalar2, true);
        },
        "any, DenseMatrix": function anyDenseMatrix(x, y) {
          return algorithm14(y, x, divideScalar2, true);
        },
        "Array, any": function ArrayAny(x, y) {
          return algorithm14(matrix2(x), y, divideScalar2, false).valueOf();
        },
        "any, Array": function anyArray(x, y) {
          return algorithm14(matrix2(y), x, divideScalar2, true).valueOf();
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/algebra/solver/utils/solveValidation.js
function createSolveValidation(_ref) {
  var {
    DenseMatrix: DenseMatrix2
  } = _ref;
  return function solveValidation(m, b, copy) {
    var mSize = m.size();
    if (mSize.length !== 2) {
      throw new RangeError("Matrix must be two dimensional (size: " + format3(mSize) + ")");
    }
    var rows = mSize[0];
    var columns = mSize[1];
    if (rows !== columns) {
      throw new RangeError("Matrix must be square (size: " + format3(mSize) + ")");
    }
    var data = [];
    if (isMatrix(b)) {
      var bSize = b.size();
      var bdata = b._data;
      if (bSize.length === 1) {
        if (bSize[0] !== rows) {
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        }
        for (var i2 = 0; i2 < rows; i2++) {
          data[i2] = [bdata[i2]];
        }
        return new DenseMatrix2({
          data,
          size: [rows, 1],
          datatype: b._datatype
        });
      }
      if (bSize.length === 2) {
        if (bSize[0] !== rows || bSize[1] !== 1) {
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        }
        if (isDenseMatrix(b)) {
          if (copy) {
            data = [];
            for (var _i = 0; _i < rows; _i++) {
              data[_i] = [bdata[_i][0]];
            }
            return new DenseMatrix2({
              data,
              size: [rows, 1],
              datatype: b._datatype
            });
          }
          return b;
        }
        if (isSparseMatrix(b)) {
          for (var _i2 = 0; _i2 < rows; _i2++) {
            data[_i2] = [0];
          }
          var values = b._values;
          var index2 = b._index;
          var ptr = b._ptr;
          for (var k1 = ptr[1], k = ptr[0]; k < k1; k++) {
            var _i3 = index2[k];
            data[_i3][0] = values[k];
          }
          return new DenseMatrix2({
            data,
            size: [rows, 1],
            datatype: b._datatype
          });
        }
      }
      throw new RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.");
    }
    if (isArray(b)) {
      var bsize = arraySize(b);
      if (bsize.length === 1) {
        if (bsize[0] !== rows) {
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        }
        for (var _i4 = 0; _i4 < rows; _i4++) {
          data[_i4] = [b[_i4]];
        }
        return new DenseMatrix2({
          data,
          size: [rows, 1]
        });
      }
      if (bsize.length === 2) {
        if (bsize[0] !== rows || bsize[1] !== 1) {
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        }
        for (var _i5 = 0; _i5 < rows; _i5++) {
          data[_i5] = [b[_i5][0]];
        }
        return new DenseMatrix2({
          data,
          size: [rows, 1]
        });
      }
      throw new RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.");
    }
  };
}
var init_solveValidation = __esm({
  "node_modules/mathjs/lib/esm/function/algebra/solver/utils/solveValidation.js"() {
    init_is();
    init_array();
    init_string();
  }
});

// node_modules/mathjs/lib/esm/function/algebra/solver/lsolve.js
var name128, dependencies129, createLsolve;
var init_lsolve = __esm({
  "node_modules/mathjs/lib/esm/function/algebra/solver/lsolve.js"() {
    init_factory();
    init_solveValidation();
    name128 = "lsolve";
    dependencies129 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtract", "equalScalar", "DenseMatrix"];
    createLsolve = /* @__PURE__ */ factory(name128, dependencies129, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        divideScalar: divideScalar2,
        multiplyScalar: multiplyScalar2,
        subtract: subtract2,
        equalScalar: equalScalar2,
        DenseMatrix: DenseMatrix2
      } = _ref;
      var solveValidation = createSolveValidation({
        DenseMatrix: DenseMatrix2
      });
      return typed2(name128, {
        "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
          return _sparseForwardSubstitution(m, b);
        },
        "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
          return _denseForwardSubstitution(m, b);
        },
        "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
          var m = matrix2(a);
          var r = _denseForwardSubstitution(m, b);
          return r.valueOf();
        }
      });
      function _denseForwardSubstitution(m, b) {
        b = solveValidation(m, b, true);
        var bdata = b._data;
        var rows = m._size[0];
        var columns = m._size[1];
        var x = [];
        var mdata = m._data;
        for (var j = 0; j < columns; j++) {
          var bj = bdata[j][0] || 0;
          var xj = void 0;
          if (!equalScalar2(bj, 0)) {
            var vjj = mdata[j][j];
            if (equalScalar2(vjj, 0)) {
              throw new Error("Linear system cannot be solved since matrix is singular");
            }
            xj = divideScalar2(bj, vjj);
            for (var i2 = j + 1; i2 < rows; i2++) {
              bdata[i2] = [subtract2(bdata[i2][0] || 0, multiplyScalar2(xj, mdata[i2][j]))];
            }
          } else {
            xj = 0;
          }
          x[j] = [xj];
        }
        return new DenseMatrix2({
          data: x,
          size: [rows, 1]
        });
      }
      function _sparseForwardSubstitution(m, b) {
        b = solveValidation(m, b, true);
        var bdata = b._data;
        var rows = m._size[0];
        var columns = m._size[1];
        var values = m._values;
        var index2 = m._index;
        var ptr = m._ptr;
        var x = [];
        for (var j = 0; j < columns; j++) {
          var bj = bdata[j][0] || 0;
          if (!equalScalar2(bj, 0)) {
            var vjj = 0;
            var jValues = [];
            var jIndices = [];
            var firstIndex = ptr[j];
            var lastIndex = ptr[j + 1];
            for (var k = firstIndex; k < lastIndex; k++) {
              var i2 = index2[k];
              if (i2 === j) {
                vjj = values[k];
              } else if (i2 > j) {
                jValues.push(values[k]);
                jIndices.push(i2);
              }
            }
            if (equalScalar2(vjj, 0)) {
              throw new Error("Linear system cannot be solved since matrix is singular");
            }
            var xj = divideScalar2(bj, vjj);
            for (var _k = 0, l = jIndices.length; _k < l; _k++) {
              var _i = jIndices[_k];
              bdata[_i] = [subtract2(bdata[_i][0] || 0, multiplyScalar2(xj, jValues[_k]))];
            }
            x[j] = [xj];
          } else {
            x[j] = [0];
          }
        }
        return new DenseMatrix2({
          data: x,
          size: [rows, 1]
        });
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/algebra/solver/usolve.js
var name129, dependencies130, createUsolve;
var init_usolve = __esm({
  "node_modules/mathjs/lib/esm/function/algebra/solver/usolve.js"() {
    init_factory();
    init_solveValidation();
    name129 = "usolve";
    dependencies130 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtract", "equalScalar", "DenseMatrix"];
    createUsolve = /* @__PURE__ */ factory(name129, dependencies130, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        divideScalar: divideScalar2,
        multiplyScalar: multiplyScalar2,
        subtract: subtract2,
        equalScalar: equalScalar2,
        DenseMatrix: DenseMatrix2
      } = _ref;
      var solveValidation = createSolveValidation({
        DenseMatrix: DenseMatrix2
      });
      return typed2(name129, {
        "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
          return _sparseBackwardSubstitution(m, b);
        },
        "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
          return _denseBackwardSubstitution(m, b);
        },
        "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
          var m = matrix2(a);
          var r = _denseBackwardSubstitution(m, b);
          return r.valueOf();
        }
      });
      function _denseBackwardSubstitution(m, b) {
        b = solveValidation(m, b, true);
        var bdata = b._data;
        var rows = m._size[0];
        var columns = m._size[1];
        var x = [];
        var mdata = m._data;
        for (var j = columns - 1; j >= 0; j--) {
          var bj = bdata[j][0] || 0;
          var xj = void 0;
          if (!equalScalar2(bj, 0)) {
            var vjj = mdata[j][j];
            if (equalScalar2(vjj, 0)) {
              throw new Error("Linear system cannot be solved since matrix is singular");
            }
            xj = divideScalar2(bj, vjj);
            for (var i2 = j - 1; i2 >= 0; i2--) {
              bdata[i2] = [subtract2(bdata[i2][0] || 0, multiplyScalar2(xj, mdata[i2][j]))];
            }
          } else {
            xj = 0;
          }
          x[j] = [xj];
        }
        return new DenseMatrix2({
          data: x,
          size: [rows, 1]
        });
      }
      function _sparseBackwardSubstitution(m, b) {
        b = solveValidation(m, b, true);
        var bdata = b._data;
        var rows = m._size[0];
        var columns = m._size[1];
        var values = m._values;
        var index2 = m._index;
        var ptr = m._ptr;
        var x = [];
        for (var j = columns - 1; j >= 0; j--) {
          var bj = bdata[j][0] || 0;
          if (!equalScalar2(bj, 0)) {
            var vjj = 0;
            var jValues = [];
            var jIndices = [];
            var firstIndex = ptr[j];
            var lastIndex = ptr[j + 1];
            for (var k = lastIndex - 1; k >= firstIndex; k--) {
              var i2 = index2[k];
              if (i2 === j) {
                vjj = values[k];
              } else if (i2 < j) {
                jValues.push(values[k]);
                jIndices.push(i2);
              }
            }
            if (equalScalar2(vjj, 0)) {
              throw new Error("Linear system cannot be solved since matrix is singular");
            }
            var xj = divideScalar2(bj, vjj);
            for (var _k = 0, _lastIndex = jIndices.length; _k < _lastIndex; _k++) {
              var _i = jIndices[_k];
              bdata[_i] = [subtract2(bdata[_i][0], multiplyScalar2(xj, jValues[_k]))];
            }
            x[j] = [xj];
          } else {
            x[j] = [0];
          }
        }
        return new DenseMatrix2({
          data: x,
          size: [rows, 1]
        });
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/algebra/solver/lsolveAll.js
var name130, dependencies131, createLsolveAll;
var init_lsolveAll = __esm({
  "node_modules/mathjs/lib/esm/function/algebra/solver/lsolveAll.js"() {
    init_factory();
    init_solveValidation();
    name130 = "lsolveAll";
    dependencies131 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtract", "equalScalar", "DenseMatrix"];
    createLsolveAll = /* @__PURE__ */ factory(name130, dependencies131, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        divideScalar: divideScalar2,
        multiplyScalar: multiplyScalar2,
        subtract: subtract2,
        equalScalar: equalScalar2,
        DenseMatrix: DenseMatrix2
      } = _ref;
      var solveValidation = createSolveValidation({
        DenseMatrix: DenseMatrix2
      });
      return typed2(name130, {
        "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
          return _sparseForwardSubstitution(m, b);
        },
        "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
          return _denseForwardSubstitution(m, b);
        },
        "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
          var m = matrix2(a);
          var R = _denseForwardSubstitution(m, b);
          return R.map((r) => r.valueOf());
        }
      });
      function _denseForwardSubstitution(m, b_) {
        var B = [solveValidation(m, b_, true)._data.map((e3) => e3[0])];
        var M = m._data;
        var rows = m._size[0];
        var columns = m._size[1];
        for (var i2 = 0; i2 < columns; i2++) {
          var L = B.length;
          for (var k = 0; k < L; k++) {
            var b = B[k];
            if (!equalScalar2(M[i2][i2], 0)) {
              b[i2] = divideScalar2(b[i2], M[i2][i2]);
              for (var j = i2 + 1; j < columns; j++) {
                b[j] = subtract2(b[j], multiplyScalar2(b[i2], M[j][i2]));
              }
            } else if (!equalScalar2(b[i2], 0)) {
              if (k === 0) {
                return [];
              } else {
                B.splice(k, 1);
                k -= 1;
                L -= 1;
              }
            } else if (k === 0) {
              var bNew = [...b];
              bNew[i2] = 1;
              for (var _j = i2 + 1; _j < columns; _j++) {
                bNew[_j] = subtract2(bNew[_j], M[_j][i2]);
              }
              B.push(bNew);
            }
          }
        }
        return B.map((x) => new DenseMatrix2({
          data: x.map((e3) => [e3]),
          size: [rows, 1]
        }));
      }
      function _sparseForwardSubstitution(m, b_) {
        var B = [solveValidation(m, b_, true)._data.map((e3) => e3[0])];
        var rows = m._size[0];
        var columns = m._size[1];
        var values = m._values;
        var index2 = m._index;
        var ptr = m._ptr;
        for (var i2 = 0; i2 < columns; i2++) {
          var L = B.length;
          for (var k = 0; k < L; k++) {
            var b = B[k];
            var iValues = [];
            var iIndices = [];
            var firstIndex = ptr[i2];
            var lastIndex = ptr[i2 + 1];
            var Mii = 0;
            for (var j = firstIndex; j < lastIndex; j++) {
              var J = index2[j];
              if (J === i2) {
                Mii = values[j];
              } else if (J > i2) {
                iValues.push(values[j]);
                iIndices.push(J);
              }
            }
            if (!equalScalar2(Mii, 0)) {
              b[i2] = divideScalar2(b[i2], Mii);
              for (var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++) {
                var _J = iIndices[_j2];
                b[_J] = subtract2(b[_J], multiplyScalar2(b[i2], iValues[_j2]));
              }
            } else if (!equalScalar2(b[i2], 0)) {
              if (k === 0) {
                return [];
              } else {
                B.splice(k, 1);
                k -= 1;
                L -= 1;
              }
            } else if (k === 0) {
              var bNew = [...b];
              bNew[i2] = 1;
              for (var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++) {
                var _J2 = iIndices[_j3];
                bNew[_J2] = subtract2(bNew[_J2], iValues[_j3]);
              }
              B.push(bNew);
            }
          }
        }
        return B.map((x) => new DenseMatrix2({
          data: x.map((e3) => [e3]),
          size: [rows, 1]
        }));
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/algebra/solver/usolveAll.js
var name131, dependencies132, createUsolveAll;
var init_usolveAll = __esm({
  "node_modules/mathjs/lib/esm/function/algebra/solver/usolveAll.js"() {
    init_factory();
    init_solveValidation();
    name131 = "usolveAll";
    dependencies132 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtract", "equalScalar", "DenseMatrix"];
    createUsolveAll = /* @__PURE__ */ factory(name131, dependencies132, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        divideScalar: divideScalar2,
        multiplyScalar: multiplyScalar2,
        subtract: subtract2,
        equalScalar: equalScalar2,
        DenseMatrix: DenseMatrix2
      } = _ref;
      var solveValidation = createSolveValidation({
        DenseMatrix: DenseMatrix2
      });
      return typed2(name131, {
        "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
          return _sparseBackwardSubstitution(m, b);
        },
        "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
          return _denseBackwardSubstitution(m, b);
        },
        "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
          var m = matrix2(a);
          var R = _denseBackwardSubstitution(m, b);
          return R.map((r) => r.valueOf());
        }
      });
      function _denseBackwardSubstitution(m, b_) {
        var B = [solveValidation(m, b_, true)._data.map((e3) => e3[0])];
        var M = m._data;
        var rows = m._size[0];
        var columns = m._size[1];
        for (var i2 = columns - 1; i2 >= 0; i2--) {
          var L = B.length;
          for (var k = 0; k < L; k++) {
            var b = B[k];
            if (!equalScalar2(M[i2][i2], 0)) {
              b[i2] = divideScalar2(b[i2], M[i2][i2]);
              for (var j = i2 - 1; j >= 0; j--) {
                b[j] = subtract2(b[j], multiplyScalar2(b[i2], M[j][i2]));
              }
            } else if (!equalScalar2(b[i2], 0)) {
              if (k === 0) {
                return [];
              } else {
                B.splice(k, 1);
                k -= 1;
                L -= 1;
              }
            } else if (k === 0) {
              var bNew = [...b];
              bNew[i2] = 1;
              for (var _j = i2 - 1; _j >= 0; _j--) {
                bNew[_j] = subtract2(bNew[_j], M[_j][i2]);
              }
              B.push(bNew);
            }
          }
        }
        return B.map((x) => new DenseMatrix2({
          data: x.map((e3) => [e3]),
          size: [rows, 1]
        }));
      }
      function _sparseBackwardSubstitution(m, b_) {
        var B = [solveValidation(m, b_, true)._data.map((e3) => e3[0])];
        var rows = m._size[0];
        var columns = m._size[1];
        var values = m._values;
        var index2 = m._index;
        var ptr = m._ptr;
        for (var i2 = columns - 1; i2 >= 0; i2--) {
          var L = B.length;
          for (var k = 0; k < L; k++) {
            var b = B[k];
            var iValues = [];
            var iIndices = [];
            var firstIndex = ptr[i2];
            var lastIndex = ptr[i2 + 1];
            var Mii = 0;
            for (var j = lastIndex - 1; j >= firstIndex; j--) {
              var J = index2[j];
              if (J === i2) {
                Mii = values[j];
              } else if (J < i2) {
                iValues.push(values[j]);
                iIndices.push(J);
              }
            }
            if (!equalScalar2(Mii, 0)) {
              b[i2] = divideScalar2(b[i2], Mii);
              for (var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++) {
                var _J = iIndices[_j2];
                b[_J] = subtract2(b[_J], multiplyScalar2(b[i2], iValues[_j2]));
              }
            } else if (!equalScalar2(b[i2], 0)) {
              if (k === 0) {
                return [];
              } else {
                B.splice(k, 1);
                k -= 1;
                L -= 1;
              }
            } else if (k === 0) {
              var bNew = [...b];
              bNew[i2] = 1;
              for (var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++) {
                var _J2 = iIndices[_j3];
                bNew[_J2] = subtract2(bNew[_J2], iValues[_j3]);
              }
              B.push(bNew);
            }
          }
        }
        return B.map((x) => new DenseMatrix2({
          data: x.map((e3) => [e3]),
          size: [rows, 1]
        }));
      }
    });
  }
});

// node_modules/mathjs/lib/esm/type/matrix/utils/algorithm08.js
var name132, dependencies133, createAlgorithm08;
var init_algorithm08 = __esm({
  "node_modules/mathjs/lib/esm/type/matrix/utils/algorithm08.js"() {
    init_factory();
    init_DimensionError();
    name132 = "algorithm08";
    dependencies133 = ["typed", "equalScalar"];
    createAlgorithm08 = /* @__PURE__ */ factory(name132, dependencies133, (_ref) => {
      var {
        typed: typed2,
        equalScalar: equalScalar2
      } = _ref;
      return function algorithm08(a, b, callback) {
        var avalues = a._values;
        var aindex = a._index;
        var aptr = a._ptr;
        var asize = a._size;
        var adt = a._datatype;
        var bvalues = b._values;
        var bindex = b._index;
        var bptr = b._ptr;
        var bsize = b._size;
        var bdt = b._datatype;
        if (asize.length !== bsize.length) {
          throw new DimensionError(asize.length, bsize.length);
        }
        if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
          throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
        }
        if (!avalues || !bvalues) {
          throw new Error("Cannot perform operation on Pattern Sparse Matrices");
        }
        var rows = asize[0];
        var columns = asize[1];
        var dt;
        var eq = equalScalar2;
        var zero = 0;
        var cf = callback;
        if (typeof adt === "string" && adt === bdt) {
          dt = adt;
          eq = typed2.find(equalScalar2, [dt, dt]);
          zero = typed2.convert(0, dt);
          cf = typed2.find(callback, [dt, dt]);
        }
        var cvalues = [];
        var cindex = [];
        var cptr = [];
        var x = [];
        var w = [];
        var k, k0, k1, i2;
        for (var j = 0; j < columns; j++) {
          cptr[j] = cindex.length;
          var mark = j + 1;
          for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
            i2 = aindex[k];
            w[i2] = mark;
            x[i2] = avalues[k];
            cindex.push(i2);
          }
          for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
            i2 = bindex[k];
            if (w[i2] === mark) {
              x[i2] = cf(x[i2], bvalues[k]);
            }
          }
          k = cptr[j];
          while (k < cindex.length) {
            i2 = cindex[k];
            var v = x[i2];
            if (!eq(v, zero)) {
              cvalues.push(v);
              k++;
            } else {
              cindex.splice(k, 1);
            }
          }
        }
        cptr[columns] = cindex.length;
        return a.createSparseMatrix({
          values: cvalues,
          index: cindex,
          ptr: cptr,
          size: [rows, columns],
          datatype: dt
        });
      };
    });
  }
});

// node_modules/mathjs/lib/esm/function/bitwise/leftShift.js
var name133, dependencies134, createLeftShift;
var init_leftShift = __esm({
  "node_modules/mathjs/lib/esm/function/bitwise/leftShift.js"() {
    init_algorithm02();
    init_algorithm11();
    init_algorithm13();
    init_algorithm14();
    init_algorithm01();
    init_algorithm10();
    init_algorithm08();
    init_factory();
    init_number2();
    init_bitwise2();
    name133 = "leftShift";
    dependencies134 = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix"];
    createLeftShift = /* @__PURE__ */ factory(name133, dependencies134, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        equalScalar: equalScalar2,
        zeros: zeros3,
        DenseMatrix: DenseMatrix2
      } = _ref;
      var algorithm01 = createAlgorithm01({
        typed: typed2
      });
      var algorithm02 = createAlgorithm02({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm08 = createAlgorithm08({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm10 = createAlgorithm10({
        typed: typed2,
        DenseMatrix: DenseMatrix2
      });
      var algorithm11 = createAlgorithm11({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm13 = createAlgorithm13({
        typed: typed2
      });
      var algorithm14 = createAlgorithm14({
        typed: typed2
      });
      return typed2(name133, {
        "number, number": leftShiftNumber,
        "BigNumber, BigNumber": leftShiftBigNumber,
        "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
          return algorithm08(x, y, this, false);
        },
        "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
          return algorithm02(y, x, this, true);
        },
        "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
          return algorithm01(x, y, this, false);
        },
        "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
          return algorithm13(x, y, this);
        },
        "Array, Array": function ArrayArray(x, y) {
          return this(matrix2(x), matrix2(y)).valueOf();
        },
        "Array, Matrix": function ArrayMatrix(x, y) {
          return this(matrix2(x), y);
        },
        "Matrix, Array": function MatrixArray(x, y) {
          return this(x, matrix2(y));
        },
        "SparseMatrix, number | BigNumber": function SparseMatrixNumberBigNumber(x, y) {
          if (equalScalar2(y, 0)) {
            return x.clone();
          }
          return algorithm11(x, y, this, false);
        },
        "DenseMatrix, number | BigNumber": function DenseMatrixNumberBigNumber(x, y) {
          if (equalScalar2(y, 0)) {
            return x.clone();
          }
          return algorithm14(x, y, this, false);
        },
        "number | BigNumber, SparseMatrix": function numberBigNumberSparseMatrix(x, y) {
          if (equalScalar2(x, 0)) {
            return zeros3(y.size(), y.storage());
          }
          return algorithm10(y, x, this, true);
        },
        "number | BigNumber, DenseMatrix": function numberBigNumberDenseMatrix(x, y) {
          if (equalScalar2(x, 0)) {
            return zeros3(y.size(), y.storage());
          }
          return algorithm14(y, x, this, true);
        },
        "Array, number | BigNumber": function ArrayNumberBigNumber(x, y) {
          return this(matrix2(x), y).valueOf();
        },
        "number | BigNumber, Array": function numberBigNumberArray(x, y) {
          return this(x, matrix2(y)).valueOf();
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/bitwise/rightArithShift.js
var name134, dependencies135, createRightArithShift;
var init_rightArithShift = __esm({
  "node_modules/mathjs/lib/esm/function/bitwise/rightArithShift.js"() {
    init_bitwise2();
    init_algorithm02();
    init_algorithm11();
    init_algorithm13();
    init_algorithm14();
    init_algorithm01();
    init_algorithm10();
    init_algorithm08();
    init_factory();
    init_number2();
    name134 = "rightArithShift";
    dependencies135 = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix"];
    createRightArithShift = /* @__PURE__ */ factory(name134, dependencies135, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        equalScalar: equalScalar2,
        zeros: zeros3,
        DenseMatrix: DenseMatrix2
      } = _ref;
      var algorithm01 = createAlgorithm01({
        typed: typed2
      });
      var algorithm02 = createAlgorithm02({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm08 = createAlgorithm08({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm10 = createAlgorithm10({
        typed: typed2,
        DenseMatrix: DenseMatrix2
      });
      var algorithm11 = createAlgorithm11({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm13 = createAlgorithm13({
        typed: typed2
      });
      var algorithm14 = createAlgorithm14({
        typed: typed2
      });
      return typed2(name134, {
        "number, number": rightArithShiftNumber,
        "BigNumber, BigNumber": rightArithShiftBigNumber,
        "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
          return algorithm08(x, y, this, false);
        },
        "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
          return algorithm02(y, x, this, true);
        },
        "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
          return algorithm01(x, y, this, false);
        },
        "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
          return algorithm13(x, y, this);
        },
        "Array, Array": function ArrayArray(x, y) {
          return this(matrix2(x), matrix2(y)).valueOf();
        },
        "Array, Matrix": function ArrayMatrix(x, y) {
          return this(matrix2(x), y);
        },
        "Matrix, Array": function MatrixArray(x, y) {
          return this(x, matrix2(y));
        },
        "SparseMatrix, number | BigNumber": function SparseMatrixNumberBigNumber(x, y) {
          if (equalScalar2(y, 0)) {
            return x.clone();
          }
          return algorithm11(x, y, this, false);
        },
        "DenseMatrix, number | BigNumber": function DenseMatrixNumberBigNumber(x, y) {
          if (equalScalar2(y, 0)) {
            return x.clone();
          }
          return algorithm14(x, y, this, false);
        },
        "number | BigNumber, SparseMatrix": function numberBigNumberSparseMatrix(x, y) {
          if (equalScalar2(x, 0)) {
            return zeros3(y.size(), y.storage());
          }
          return algorithm10(y, x, this, true);
        },
        "number | BigNumber, DenseMatrix": function numberBigNumberDenseMatrix(x, y) {
          if (equalScalar2(x, 0)) {
            return zeros3(y.size(), y.storage());
          }
          return algorithm14(y, x, this, true);
        },
        "Array, number | BigNumber": function ArrayNumberBigNumber(x, y) {
          return this(matrix2(x), y).valueOf();
        },
        "number | BigNumber, Array": function numberBigNumberArray(x, y) {
          return this(x, matrix2(y)).valueOf();
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/bitwise/rightLogShift.js
var name135, dependencies136, createRightLogShift;
var init_rightLogShift = __esm({
  "node_modules/mathjs/lib/esm/function/bitwise/rightLogShift.js"() {
    init_algorithm02();
    init_algorithm11();
    init_algorithm13();
    init_algorithm14();
    init_algorithm01();
    init_algorithm10();
    init_algorithm08();
    init_factory();
    init_number2();
    name135 = "rightLogShift";
    dependencies136 = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix"];
    createRightLogShift = /* @__PURE__ */ factory(name135, dependencies136, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        equalScalar: equalScalar2,
        zeros: zeros3,
        DenseMatrix: DenseMatrix2
      } = _ref;
      var algorithm01 = createAlgorithm01({
        typed: typed2
      });
      var algorithm02 = createAlgorithm02({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm08 = createAlgorithm08({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm10 = createAlgorithm10({
        typed: typed2,
        DenseMatrix: DenseMatrix2
      });
      var algorithm11 = createAlgorithm11({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm13 = createAlgorithm13({
        typed: typed2
      });
      var algorithm14 = createAlgorithm14({
        typed: typed2
      });
      return typed2(name135, {
        "number, number": rightLogShiftNumber,
        "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
          return algorithm08(x, y, this, false);
        },
        "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
          return algorithm02(y, x, this, true);
        },
        "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
          return algorithm01(x, y, this, false);
        },
        "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
          return algorithm13(x, y, this);
        },
        "Array, Array": function ArrayArray(x, y) {
          return this(matrix2(x), matrix2(y)).valueOf();
        },
        "Array, Matrix": function ArrayMatrix(x, y) {
          return this(matrix2(x), y);
        },
        "Matrix, Array": function MatrixArray(x, y) {
          return this(x, matrix2(y));
        },
        "SparseMatrix, number | BigNumber": function SparseMatrixNumberBigNumber(x, y) {
          if (equalScalar2(y, 0)) {
            return x.clone();
          }
          return algorithm11(x, y, this, false);
        },
        "DenseMatrix, number | BigNumber": function DenseMatrixNumberBigNumber(x, y) {
          if (equalScalar2(y, 0)) {
            return x.clone();
          }
          return algorithm14(x, y, this, false);
        },
        "number | BigNumber, SparseMatrix": function numberBigNumberSparseMatrix(x, y) {
          if (equalScalar2(x, 0)) {
            return zeros3(y.size(), y.storage());
          }
          return algorithm10(y, x, this, true);
        },
        "number | BigNumber, DenseMatrix": function numberBigNumberDenseMatrix(x, y) {
          if (equalScalar2(x, 0)) {
            return zeros3(y.size(), y.storage());
          }
          return algorithm14(y, x, this, true);
        },
        "Array, number | BigNumber": function ArrayNumberBigNumber(x, y) {
          return this(matrix2(x), y).valueOf();
        },
        "number | BigNumber, Array": function numberBigNumberArray(x, y) {
          return this(x, matrix2(y)).valueOf();
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/logical/and.js
var name136, dependencies137, createAnd;
var init_and = __esm({
  "node_modules/mathjs/lib/esm/function/logical/and.js"() {
    init_algorithm02();
    init_algorithm11();
    init_algorithm13();
    init_algorithm14();
    init_algorithm06();
    init_factory();
    init_number2();
    name136 = "and";
    dependencies137 = ["typed", "matrix", "equalScalar", "zeros", "not"];
    createAnd = /* @__PURE__ */ factory(name136, dependencies137, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        equalScalar: equalScalar2,
        zeros: zeros3,
        not: not2
      } = _ref;
      var algorithm02 = createAlgorithm02({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm06 = createAlgorithm06({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm11 = createAlgorithm11({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm13 = createAlgorithm13({
        typed: typed2
      });
      var algorithm14 = createAlgorithm14({
        typed: typed2
      });
      return typed2(name136, {
        "number, number": andNumber,
        "Complex, Complex": function ComplexComplex(x, y) {
          return (x.re !== 0 || x.im !== 0) && (y.re !== 0 || y.im !== 0);
        },
        "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
          return !x.isZero() && !y.isZero() && !x.isNaN() && !y.isNaN();
        },
        "Unit, Unit": function UnitUnit(x, y) {
          return this(x.value || 0, y.value || 0);
        },
        "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
          return algorithm06(x, y, this, false);
        },
        "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
          return algorithm02(y, x, this, true);
        },
        "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
          return algorithm02(x, y, this, false);
        },
        "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
          return algorithm13(x, y, this);
        },
        "Array, Array": function ArrayArray(x, y) {
          return this(matrix2(x), matrix2(y)).valueOf();
        },
        "Array, Matrix": function ArrayMatrix(x, y) {
          return this(matrix2(x), y);
        },
        "Matrix, Array": function MatrixArray(x, y) {
          return this(x, matrix2(y));
        },
        "SparseMatrix, any": function SparseMatrixAny(x, y) {
          if (not2(y)) {
            return zeros3(x.size(), x.storage());
          }
          return algorithm11(x, y, this, false);
        },
        "DenseMatrix, any": function DenseMatrixAny(x, y) {
          if (not2(y)) {
            return zeros3(x.size(), x.storage());
          }
          return algorithm14(x, y, this, false);
        },
        "any, SparseMatrix": function anySparseMatrix(x, y) {
          if (not2(x)) {
            return zeros3(x.size(), x.storage());
          }
          return algorithm11(y, x, this, true);
        },
        "any, DenseMatrix": function anyDenseMatrix(x, y) {
          if (not2(x)) {
            return zeros3(x.size(), x.storage());
          }
          return algorithm14(y, x, this, true);
        },
        "Array, any": function ArrayAny(x, y) {
          return this(matrix2(x), y).valueOf();
        },
        "any, Array": function anyArray(x, y) {
          return this(x, matrix2(y)).valueOf();
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/relational/compare.js
var name137, dependencies138, createCompare;
var init_compare = __esm({
  "node_modules/mathjs/lib/esm/function/relational/compare.js"() {
    init_nearlyEqual();
    init_number();
    init_factory();
    init_algorithm03();
    init_algorithm12();
    init_algorithm14();
    init_algorithm13();
    init_algorithm05();
    name137 = "compare";
    dependencies138 = ["typed", "config", "matrix", "equalScalar", "BigNumber", "Fraction", "DenseMatrix"];
    createCompare = /* @__PURE__ */ factory(name137, dependencies138, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        equalScalar: equalScalar2,
        matrix: matrix2,
        BigNumber: BigNumber2,
        Fraction: Fraction3,
        DenseMatrix: DenseMatrix2
      } = _ref;
      var algorithm03 = createAlgorithm03({
        typed: typed2
      });
      var algorithm05 = createAlgorithm05({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm12 = createAlgorithm12({
        typed: typed2,
        DenseMatrix: DenseMatrix2
      });
      var algorithm13 = createAlgorithm13({
        typed: typed2
      });
      var algorithm14 = createAlgorithm14({
        typed: typed2
      });
      return typed2(name137, {
        "boolean, boolean": function booleanBoolean(x, y) {
          return x === y ? 0 : x > y ? 1 : -1;
        },
        "number, number": function numberNumber(x, y) {
          return nearlyEqual(x, y, config3.epsilon) ? 0 : x > y ? 1 : -1;
        },
        "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
          return nearlyEqual2(x, y, config3.epsilon) ? new BigNumber2(0) : new BigNumber2(x.cmp(y));
        },
        "Fraction, Fraction": function FractionFraction(x, y) {
          return new Fraction3(x.compare(y));
        },
        "Complex, Complex": function ComplexComplex() {
          throw new TypeError("No ordering relation is defined for complex numbers");
        },
        "Unit, Unit": function UnitUnit(x, y) {
          if (!x.equalBase(y)) {
            throw new Error("Cannot compare units with different base");
          }
          return this(x.value, y.value);
        },
        "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
          return algorithm05(x, y, this);
        },
        "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
          return algorithm03(y, x, this, true);
        },
        "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
          return algorithm03(x, y, this, false);
        },
        "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
          return algorithm13(x, y, this);
        },
        "Array, Array": function ArrayArray(x, y) {
          return this(matrix2(x), matrix2(y)).valueOf();
        },
        "Array, Matrix": function ArrayMatrix(x, y) {
          return this(matrix2(x), y);
        },
        "Matrix, Array": function MatrixArray(x, y) {
          return this(x, matrix2(y));
        },
        "SparseMatrix, any": function SparseMatrixAny(x, y) {
          return algorithm12(x, y, this, false);
        },
        "DenseMatrix, any": function DenseMatrixAny(x, y) {
          return algorithm14(x, y, this, false);
        },
        "any, SparseMatrix": function anySparseMatrix(x, y) {
          return algorithm12(y, x, this, true);
        },
        "any, DenseMatrix": function anyDenseMatrix(x, y) {
          return algorithm14(y, x, this, true);
        },
        "Array, any": function ArrayAny(x, y) {
          return algorithm14(matrix2(x), y, this, false).valueOf();
        },
        "any, Array": function anyArray(x, y) {
          return algorithm14(matrix2(y), x, this, true).valueOf();
        }
      });
    });
  }
});

// node_modules/javascript-natural-sort/naturalSort.js
var require_naturalSort = __commonJS({
  "node_modules/javascript-natural-sort/naturalSort.js"(exports, module) {
    module.exports = function naturalSort2(a, b) {
      "use strict";
      var re2 = /(^([+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?)?$|^0x[0-9a-f]+$|\d+)/gi, sre = /(^[ ]*|[ ]*$)/g, dre = /(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[\/\-]\d{1,4}[\/\-]\d{1,4}|^\w+, \w+ \d+, \d{4})/, hre = /^0x[0-9a-f]+$/i, ore = /^0/, i2 = function(s) {
        return naturalSort2.insensitive && ("" + s).toLowerCase() || "" + s;
      }, x = i2(a).replace(sre, "") || "", y = i2(b).replace(sre, "") || "", xN = x.replace(re2, "\0$1\0").replace(/\0$/, "").replace(/^\0/, "").split("\0"), yN = y.replace(re2, "\0$1\0").replace(/\0$/, "").replace(/^\0/, "").split("\0"), xD = parseInt(x.match(hre), 16) || xN.length !== 1 && x.match(dre) && Date.parse(x), yD = parseInt(y.match(hre), 16) || xD && y.match(dre) && Date.parse(y) || null, oFxNcL, oFyNcL;
      if (yD) {
        if (xD < yD) {
          return -1;
        } else if (xD > yD) {
          return 1;
        }
      }
      for (var cLoc = 0, numS = Math.max(xN.length, yN.length); cLoc < numS; cLoc++) {
        oFxNcL = !(xN[cLoc] || "").match(ore) && parseFloat(xN[cLoc]) || xN[cLoc] || 0;
        oFyNcL = !(yN[cLoc] || "").match(ore) && parseFloat(yN[cLoc]) || yN[cLoc] || 0;
        if (isNaN(oFxNcL) !== isNaN(oFyNcL)) {
          return isNaN(oFxNcL) ? 1 : -1;
        } else if (typeof oFxNcL !== typeof oFyNcL) {
          oFxNcL += "";
          oFyNcL += "";
        }
        if (oFxNcL < oFyNcL) {
          return -1;
        }
        if (oFxNcL > oFyNcL) {
          return 1;
        }
      }
      return 0;
    };
  }
});

// node_modules/mathjs/lib/esm/function/relational/compareNatural.js
function compareComplexNumbers(x, y) {
  if (x.re > y.re) {
    return 1;
  }
  if (x.re < y.re) {
    return -1;
  }
  if (x.im > y.im) {
    return 1;
  }
  if (x.im < y.im) {
    return -1;
  }
  return 0;
}
var import_javascript_natural_sort, name138, dependencies139, createCompareNatural;
var init_compareNatural = __esm({
  "node_modules/mathjs/lib/esm/function/relational/compareNatural.js"() {
    import_javascript_natural_sort = __toESM(require_naturalSort(), 1);
    init_is();
    init_factory();
    name138 = "compareNatural";
    dependencies139 = ["typed", "compare"];
    createCompareNatural = /* @__PURE__ */ factory(name138, dependencies139, (_ref) => {
      var {
        typed: typed2,
        compare: compare2
      } = _ref;
      var compareBooleans = compare2.signatures["boolean,boolean"];
      return typed2(name138, {
        "any, any": function anyAny(x, y) {
          var typeX = typeOf(x);
          var typeY = typeOf(y);
          var c;
          if ((typeX === "number" || typeX === "BigNumber" || typeX === "Fraction") && (typeY === "number" || typeY === "BigNumber" || typeY === "Fraction")) {
            c = compare2(x, y);
            if (c.toString() !== "0") {
              return c > 0 ? 1 : -1;
            } else {
              return (0, import_javascript_natural_sort.default)(typeX, typeY);
            }
          }
          if (typeX === "Array" || typeX === "Matrix" || typeY === "Array" || typeY === "Matrix") {
            c = compareMatricesAndArrays(this, x, y);
            if (c !== 0) {
              return c;
            } else {
              return (0, import_javascript_natural_sort.default)(typeX, typeY);
            }
          }
          if (typeX !== typeY) {
            return (0, import_javascript_natural_sort.default)(typeX, typeY);
          }
          if (typeX === "Complex") {
            return compareComplexNumbers(x, y);
          }
          if (typeX === "Unit") {
            if (x.equalBase(y)) {
              return this(x.value, y.value);
            }
            return compareArrays(this, x.formatUnits(), y.formatUnits());
          }
          if (typeX === "boolean") {
            return compareBooleans(x, y);
          }
          if (typeX === "string") {
            return (0, import_javascript_natural_sort.default)(x, y);
          }
          if (typeX === "Object") {
            return compareObjects(this, x, y);
          }
          if (typeX === "null") {
            return 0;
          }
          if (typeX === "undefined") {
            return 0;
          }
          throw new TypeError('Unsupported type of value "' + typeX + '"');
        }
      });
      function compareMatricesAndArrays(compareNatural2, x, y) {
        if (isSparseMatrix(x) && isSparseMatrix(y)) {
          return compareArrays(compareNatural2, x.toJSON().values, y.toJSON().values);
        }
        if (isSparseMatrix(x)) {
          return compareMatricesAndArrays(compareNatural2, x.toArray(), y);
        }
        if (isSparseMatrix(y)) {
          return compareMatricesAndArrays(compareNatural2, x, y.toArray());
        }
        if (isDenseMatrix(x)) {
          return compareMatricesAndArrays(compareNatural2, x.toJSON().data, y);
        }
        if (isDenseMatrix(y)) {
          return compareMatricesAndArrays(compareNatural2, x, y.toJSON().data);
        }
        if (!Array.isArray(x)) {
          return compareMatricesAndArrays(compareNatural2, [x], y);
        }
        if (!Array.isArray(y)) {
          return compareMatricesAndArrays(compareNatural2, x, [y]);
        }
        return compareArrays(compareNatural2, x, y);
      }
      function compareArrays(compareNatural2, x, y) {
        for (var i2 = 0, ii = Math.min(x.length, y.length); i2 < ii; i2++) {
          var v = compareNatural2(x[i2], y[i2]);
          if (v !== 0) {
            return v;
          }
        }
        if (x.length > y.length) {
          return 1;
        }
        if (x.length < y.length) {
          return -1;
        }
        return 0;
      }
      function compareObjects(compareNatural2, x, y) {
        var keysX = Object.keys(x);
        var keysY = Object.keys(y);
        keysX.sort(import_javascript_natural_sort.default);
        keysY.sort(import_javascript_natural_sort.default);
        var c = compareArrays(compareNatural2, keysX, keysY);
        if (c !== 0) {
          return c;
        }
        for (var i2 = 0; i2 < keysX.length; i2++) {
          var v = compareNatural2(x[keysX[i2]], y[keysY[i2]]);
          if (v !== 0) {
            return v;
          }
        }
        return 0;
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/relational/compareText.js
var name139, dependencies140, createCompareText;
var init_compareText = __esm({
  "node_modules/mathjs/lib/esm/function/relational/compareText.js"() {
    init_string();
    init_factory();
    init_algorithm14();
    init_algorithm13();
    name139 = "compareText";
    dependencies140 = ["typed", "matrix"];
    createCompareText = /* @__PURE__ */ factory(name139, dependencies140, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2
      } = _ref;
      var algorithm13 = createAlgorithm13({
        typed: typed2
      });
      var algorithm14 = createAlgorithm14({
        typed: typed2
      });
      return typed2(name139, {
        "any, any": compareText,
        "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
          return algorithm13(x, y, compareText);
        },
        "Array, Array": function ArrayArray(x, y) {
          return this(matrix2(x), matrix2(y)).valueOf();
        },
        "Array, Matrix": function ArrayMatrix(x, y) {
          return this(matrix2(x), y);
        },
        "Matrix, Array": function MatrixArray(x, y) {
          return this(x, matrix2(y));
        },
        "DenseMatrix, any": function DenseMatrixAny(x, y) {
          return algorithm14(x, y, compareText, false);
        },
        "any, DenseMatrix": function anyDenseMatrix(x, y) {
          return algorithm14(y, x, compareText, true);
        },
        "Array, any": function ArrayAny(x, y) {
          return algorithm14(matrix2(x), y, compareText, false).valueOf();
        },
        "any, Array": function anyArray(x, y) {
          return algorithm14(matrix2(y), x, compareText, true).valueOf();
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/relational/equal.js
var name140, dependencies141, createEqual, createEqualNumber;
var init_equal = __esm({
  "node_modules/mathjs/lib/esm/function/relational/equal.js"() {
    init_factory();
    init_algorithm03();
    init_algorithm07();
    init_algorithm12();
    init_algorithm13();
    init_algorithm14();
    name140 = "equal";
    dependencies141 = ["typed", "matrix", "equalScalar", "DenseMatrix"];
    createEqual = /* @__PURE__ */ factory(name140, dependencies141, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        equalScalar: equalScalar2,
        DenseMatrix: DenseMatrix2
      } = _ref;
      var algorithm03 = createAlgorithm03({
        typed: typed2
      });
      var algorithm07 = createAlgorithm07({
        typed: typed2,
        DenseMatrix: DenseMatrix2
      });
      var algorithm12 = createAlgorithm12({
        typed: typed2,
        DenseMatrix: DenseMatrix2
      });
      var algorithm13 = createAlgorithm13({
        typed: typed2
      });
      var algorithm14 = createAlgorithm14({
        typed: typed2
      });
      return typed2(name140, {
        "any, any": function anyAny(x, y) {
          if (x === null) {
            return y === null;
          }
          if (y === null) {
            return x === null;
          }
          if (x === void 0) {
            return y === void 0;
          }
          if (y === void 0) {
            return x === void 0;
          }
          return equalScalar2(x, y);
        },
        "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
          return algorithm07(x, y, equalScalar2);
        },
        "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
          return algorithm03(y, x, equalScalar2, true);
        },
        "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
          return algorithm03(x, y, equalScalar2, false);
        },
        "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
          return algorithm13(x, y, equalScalar2);
        },
        "Array, Array": function ArrayArray(x, y) {
          return this(matrix2(x), matrix2(y)).valueOf();
        },
        "Array, Matrix": function ArrayMatrix(x, y) {
          return this(matrix2(x), y);
        },
        "Matrix, Array": function MatrixArray(x, y) {
          return this(x, matrix2(y));
        },
        "SparseMatrix, any": function SparseMatrixAny(x, y) {
          return algorithm12(x, y, equalScalar2, false);
        },
        "DenseMatrix, any": function DenseMatrixAny(x, y) {
          return algorithm14(x, y, equalScalar2, false);
        },
        "any, SparseMatrix": function anySparseMatrix(x, y) {
          return algorithm12(y, x, equalScalar2, true);
        },
        "any, DenseMatrix": function anyDenseMatrix(x, y) {
          return algorithm14(y, x, equalScalar2, true);
        },
        "Array, any": function ArrayAny(x, y) {
          return algorithm14(matrix2(x), y, equalScalar2, false).valueOf();
        },
        "any, Array": function anyArray(x, y) {
          return algorithm14(matrix2(y), x, equalScalar2, true).valueOf();
        }
      });
    });
    createEqualNumber = factory(name140, ["typed", "equalScalar"], (_ref2) => {
      var {
        typed: typed2,
        equalScalar: equalScalar2
      } = _ref2;
      return typed2(name140, {
        "any, any": function anyAny(x, y) {
          if (x === null) {
            return y === null;
          }
          if (y === null) {
            return x === null;
          }
          if (x === void 0) {
            return y === void 0;
          }
          if (y === void 0) {
            return x === void 0;
          }
          return equalScalar2(x, y);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/relational/equalText.js
var name141, dependencies142, createEqualText;
var init_equalText = __esm({
  "node_modules/mathjs/lib/esm/function/relational/equalText.js"() {
    init_factory();
    name141 = "equalText";
    dependencies142 = ["typed", "compareText", "isZero"];
    createEqualText = /* @__PURE__ */ factory(name141, dependencies142, (_ref) => {
      var {
        typed: typed2,
        compareText: compareText3,
        isZero: isZero2
      } = _ref;
      return typed2(name141, {
        "any, any": function anyAny(x, y) {
          return isZero2(compareText3(x, y));
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/relational/smaller.js
var name142, dependencies143, createSmaller;
var init_smaller = __esm({
  "node_modules/mathjs/lib/esm/function/relational/smaller.js"() {
    init_nearlyEqual();
    init_number();
    init_factory();
    init_algorithm03();
    init_algorithm07();
    init_algorithm12();
    init_algorithm14();
    init_algorithm13();
    name142 = "smaller";
    dependencies143 = ["typed", "config", "matrix", "DenseMatrix"];
    createSmaller = /* @__PURE__ */ factory(name142, dependencies143, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        matrix: matrix2,
        DenseMatrix: DenseMatrix2
      } = _ref;
      var algorithm03 = createAlgorithm03({
        typed: typed2
      });
      var algorithm07 = createAlgorithm07({
        typed: typed2,
        DenseMatrix: DenseMatrix2
      });
      var algorithm12 = createAlgorithm12({
        typed: typed2,
        DenseMatrix: DenseMatrix2
      });
      var algorithm13 = createAlgorithm13({
        typed: typed2
      });
      var algorithm14 = createAlgorithm14({
        typed: typed2
      });
      return typed2(name142, {
        "boolean, boolean": function booleanBoolean(x, y) {
          return x < y;
        },
        "number, number": function numberNumber(x, y) {
          return x < y && !nearlyEqual(x, y, config3.epsilon);
        },
        "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
          return x.lt(y) && !nearlyEqual2(x, y, config3.epsilon);
        },
        "Fraction, Fraction": function FractionFraction(x, y) {
          return x.compare(y) === -1;
        },
        "Complex, Complex": function ComplexComplex(x, y) {
          throw new TypeError("No ordering relation is defined for complex numbers");
        },
        "Unit, Unit": function UnitUnit(x, y) {
          if (!x.equalBase(y)) {
            throw new Error("Cannot compare units with different base");
          }
          return this(x.value, y.value);
        },
        "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
          return algorithm07(x, y, this);
        },
        "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
          return algorithm03(y, x, this, true);
        },
        "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
          return algorithm03(x, y, this, false);
        },
        "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
          return algorithm13(x, y, this);
        },
        "Array, Array": function ArrayArray(x, y) {
          return this(matrix2(x), matrix2(y)).valueOf();
        },
        "Array, Matrix": function ArrayMatrix(x, y) {
          return this(matrix2(x), y);
        },
        "Matrix, Array": function MatrixArray(x, y) {
          return this(x, matrix2(y));
        },
        "SparseMatrix, any": function SparseMatrixAny(x, y) {
          return algorithm12(x, y, this, false);
        },
        "DenseMatrix, any": function DenseMatrixAny(x, y) {
          return algorithm14(x, y, this, false);
        },
        "any, SparseMatrix": function anySparseMatrix(x, y) {
          return algorithm12(y, x, this, true);
        },
        "any, DenseMatrix": function anyDenseMatrix(x, y) {
          return algorithm14(y, x, this, true);
        },
        "Array, any": function ArrayAny(x, y) {
          return algorithm14(matrix2(x), y, this, false).valueOf();
        },
        "any, Array": function anyArray(x, y) {
          return algorithm14(matrix2(y), x, this, true).valueOf();
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/relational/smallerEq.js
var name143, dependencies144, createSmallerEq;
var init_smallerEq = __esm({
  "node_modules/mathjs/lib/esm/function/relational/smallerEq.js"() {
    init_nearlyEqual();
    init_number();
    init_factory();
    init_algorithm03();
    init_algorithm07();
    init_algorithm12();
    init_algorithm14();
    init_algorithm13();
    name143 = "smallerEq";
    dependencies144 = ["typed", "config", "matrix", "DenseMatrix"];
    createSmallerEq = /* @__PURE__ */ factory(name143, dependencies144, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        matrix: matrix2,
        DenseMatrix: DenseMatrix2
      } = _ref;
      var algorithm03 = createAlgorithm03({
        typed: typed2
      });
      var algorithm07 = createAlgorithm07({
        typed: typed2,
        DenseMatrix: DenseMatrix2
      });
      var algorithm12 = createAlgorithm12({
        typed: typed2,
        DenseMatrix: DenseMatrix2
      });
      var algorithm13 = createAlgorithm13({
        typed: typed2
      });
      var algorithm14 = createAlgorithm14({
        typed: typed2
      });
      return typed2(name143, {
        "boolean, boolean": function booleanBoolean(x, y) {
          return x <= y;
        },
        "number, number": function numberNumber(x, y) {
          return x <= y || nearlyEqual(x, y, config3.epsilon);
        },
        "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
          return x.lte(y) || nearlyEqual2(x, y, config3.epsilon);
        },
        "Fraction, Fraction": function FractionFraction(x, y) {
          return x.compare(y) !== 1;
        },
        "Complex, Complex": function ComplexComplex() {
          throw new TypeError("No ordering relation is defined for complex numbers");
        },
        "Unit, Unit": function UnitUnit(x, y) {
          if (!x.equalBase(y)) {
            throw new Error("Cannot compare units with different base");
          }
          return this(x.value, y.value);
        },
        "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
          return algorithm07(x, y, this);
        },
        "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
          return algorithm03(y, x, this, true);
        },
        "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
          return algorithm03(x, y, this, false);
        },
        "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
          return algorithm13(x, y, this);
        },
        "Array, Array": function ArrayArray(x, y) {
          return this(matrix2(x), matrix2(y)).valueOf();
        },
        "Array, Matrix": function ArrayMatrix(x, y) {
          return this(matrix2(x), y);
        },
        "Matrix, Array": function MatrixArray(x, y) {
          return this(x, matrix2(y));
        },
        "SparseMatrix, any": function SparseMatrixAny(x, y) {
          return algorithm12(x, y, this, false);
        },
        "DenseMatrix, any": function DenseMatrixAny(x, y) {
          return algorithm14(x, y, this, false);
        },
        "any, SparseMatrix": function anySparseMatrix(x, y) {
          return algorithm12(y, x, this, true);
        },
        "any, DenseMatrix": function anyDenseMatrix(x, y) {
          return algorithm14(y, x, this, true);
        },
        "Array, any": function ArrayAny(x, y) {
          return algorithm14(matrix2(x), y, this, false).valueOf();
        },
        "any, Array": function anyArray(x, y) {
          return algorithm14(matrix2(y), x, this, true).valueOf();
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/relational/larger.js
var name144, dependencies145, createLarger;
var init_larger = __esm({
  "node_modules/mathjs/lib/esm/function/relational/larger.js"() {
    init_nearlyEqual();
    init_number();
    init_factory();
    init_algorithm03();
    init_algorithm07();
    init_algorithm12();
    init_algorithm14();
    init_algorithm13();
    name144 = "larger";
    dependencies145 = ["typed", "config", "matrix", "DenseMatrix"];
    createLarger = /* @__PURE__ */ factory(name144, dependencies145, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        matrix: matrix2,
        DenseMatrix: DenseMatrix2
      } = _ref;
      var algorithm03 = createAlgorithm03({
        typed: typed2
      });
      var algorithm07 = createAlgorithm07({
        typed: typed2,
        DenseMatrix: DenseMatrix2
      });
      var algorithm12 = createAlgorithm12({
        typed: typed2,
        DenseMatrix: DenseMatrix2
      });
      var algorithm13 = createAlgorithm13({
        typed: typed2
      });
      var algorithm14 = createAlgorithm14({
        typed: typed2
      });
      return typed2(name144, {
        "boolean, boolean": function booleanBoolean(x, y) {
          return x > y;
        },
        "number, number": function numberNumber(x, y) {
          return x > y && !nearlyEqual(x, y, config3.epsilon);
        },
        "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
          return x.gt(y) && !nearlyEqual2(x, y, config3.epsilon);
        },
        "Fraction, Fraction": function FractionFraction(x, y) {
          return x.compare(y) === 1;
        },
        "Complex, Complex": function ComplexComplex() {
          throw new TypeError("No ordering relation is defined for complex numbers");
        },
        "Unit, Unit": function UnitUnit(x, y) {
          if (!x.equalBase(y)) {
            throw new Error("Cannot compare units with different base");
          }
          return this(x.value, y.value);
        },
        "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
          return algorithm07(x, y, this);
        },
        "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
          return algorithm03(y, x, this, true);
        },
        "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
          return algorithm03(x, y, this, false);
        },
        "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
          return algorithm13(x, y, this);
        },
        "Array, Array": function ArrayArray(x, y) {
          return this(matrix2(x), matrix2(y)).valueOf();
        },
        "Array, Matrix": function ArrayMatrix(x, y) {
          return this(matrix2(x), y);
        },
        "Matrix, Array": function MatrixArray(x, y) {
          return this(x, matrix2(y));
        },
        "SparseMatrix, any": function SparseMatrixAny(x, y) {
          return algorithm12(x, y, this, false);
        },
        "DenseMatrix, any": function DenseMatrixAny(x, y) {
          return algorithm14(x, y, this, false);
        },
        "any, SparseMatrix": function anySparseMatrix(x, y) {
          return algorithm12(y, x, this, true);
        },
        "any, DenseMatrix": function anyDenseMatrix(x, y) {
          return algorithm14(y, x, this, true);
        },
        "Array, any": function ArrayAny(x, y) {
          return algorithm14(matrix2(x), y, this, false).valueOf();
        },
        "any, Array": function anyArray(x, y) {
          return algorithm14(matrix2(y), x, this, true).valueOf();
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/relational/largerEq.js
var name145, dependencies146, createLargerEq;
var init_largerEq = __esm({
  "node_modules/mathjs/lib/esm/function/relational/largerEq.js"() {
    init_nearlyEqual();
    init_number();
    init_factory();
    init_algorithm03();
    init_algorithm07();
    init_algorithm12();
    init_algorithm14();
    init_algorithm13();
    name145 = "largerEq";
    dependencies146 = ["typed", "config", "matrix", "DenseMatrix"];
    createLargerEq = /* @__PURE__ */ factory(name145, dependencies146, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        matrix: matrix2,
        DenseMatrix: DenseMatrix2
      } = _ref;
      var algorithm03 = createAlgorithm03({
        typed: typed2
      });
      var algorithm07 = createAlgorithm07({
        typed: typed2,
        DenseMatrix: DenseMatrix2
      });
      var algorithm12 = createAlgorithm12({
        typed: typed2,
        DenseMatrix: DenseMatrix2
      });
      var algorithm13 = createAlgorithm13({
        typed: typed2
      });
      var algorithm14 = createAlgorithm14({
        typed: typed2
      });
      return typed2(name145, {
        "boolean, boolean": function booleanBoolean(x, y) {
          return x >= y;
        },
        "number, number": function numberNumber(x, y) {
          return x >= y || nearlyEqual(x, y, config3.epsilon);
        },
        "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
          return x.gte(y) || nearlyEqual2(x, y, config3.epsilon);
        },
        "Fraction, Fraction": function FractionFraction(x, y) {
          return x.compare(y) !== -1;
        },
        "Complex, Complex": function ComplexComplex() {
          throw new TypeError("No ordering relation is defined for complex numbers");
        },
        "Unit, Unit": function UnitUnit(x, y) {
          if (!x.equalBase(y)) {
            throw new Error("Cannot compare units with different base");
          }
          return this(x.value, y.value);
        },
        "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
          return algorithm07(x, y, this);
        },
        "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
          return algorithm03(y, x, this, true);
        },
        "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
          return algorithm03(x, y, this, false);
        },
        "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
          return algorithm13(x, y, this);
        },
        "Array, Array": function ArrayArray(x, y) {
          return this(matrix2(x), matrix2(y)).valueOf();
        },
        "Array, Matrix": function ArrayMatrix(x, y) {
          return this(matrix2(x), y);
        },
        "Matrix, Array": function MatrixArray(x, y) {
          return this(x, matrix2(y));
        },
        "SparseMatrix, any": function SparseMatrixAny(x, y) {
          return algorithm12(x, y, this, false);
        },
        "DenseMatrix, any": function DenseMatrixAny(x, y) {
          return algorithm14(x, y, this, false);
        },
        "any, SparseMatrix": function anySparseMatrix(x, y) {
          return algorithm12(y, x, this, true);
        },
        "any, DenseMatrix": function anyDenseMatrix(x, y) {
          return algorithm14(y, x, this, true);
        },
        "Array, any": function ArrayAny(x, y) {
          return algorithm14(matrix2(x), y, this, false).valueOf();
        },
        "any, Array": function anyArray(x, y) {
          return algorithm14(matrix2(y), x, this, true).valueOf();
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/relational/deepEqual.js
var name146, dependencies147, createDeepEqual;
var init_deepEqual = __esm({
  "node_modules/mathjs/lib/esm/function/relational/deepEqual.js"() {
    init_factory();
    name146 = "deepEqual";
    dependencies147 = ["typed", "equal"];
    createDeepEqual = /* @__PURE__ */ factory(name146, dependencies147, (_ref) => {
      var {
        typed: typed2,
        equal: equal2
      } = _ref;
      return typed2(name146, {
        "any, any": function anyAny(x, y) {
          return _deepEqual(x.valueOf(), y.valueOf());
        }
      });
      function _deepEqual(x, y) {
        if (Array.isArray(x)) {
          if (Array.isArray(y)) {
            var len = x.length;
            if (len !== y.length) {
              return false;
            }
            for (var i2 = 0; i2 < len; i2++) {
              if (!_deepEqual(x[i2], y[i2])) {
                return false;
              }
            }
            return true;
          } else {
            return false;
          }
        } else {
          if (Array.isArray(y)) {
            return false;
          } else {
            return equal2(x, y);
          }
        }
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/relational/unequal.js
var name147, dependencies148, createUnequal, createUnequalNumber;
var init_unequal = __esm({
  "node_modules/mathjs/lib/esm/function/relational/unequal.js"() {
    init_factory();
    init_algorithm03();
    init_algorithm07();
    init_algorithm12();
    init_algorithm14();
    init_algorithm13();
    name147 = "unequal";
    dependencies148 = ["typed", "config", "equalScalar", "matrix", "DenseMatrix"];
    createUnequal = /* @__PURE__ */ factory(name147, dependencies148, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        equalScalar: equalScalar2,
        matrix: matrix2,
        DenseMatrix: DenseMatrix2
      } = _ref;
      var algorithm03 = createAlgorithm03({
        typed: typed2
      });
      var algorithm07 = createAlgorithm07({
        typed: typed2,
        DenseMatrix: DenseMatrix2
      });
      var algorithm12 = createAlgorithm12({
        typed: typed2,
        DenseMatrix: DenseMatrix2
      });
      var algorithm13 = createAlgorithm13({
        typed: typed2
      });
      var algorithm14 = createAlgorithm14({
        typed: typed2
      });
      return typed2("unequal", {
        "any, any": function anyAny(x, y) {
          if (x === null) {
            return y !== null;
          }
          if (y === null) {
            return x !== null;
          }
          if (x === void 0) {
            return y !== void 0;
          }
          if (y === void 0) {
            return x !== void 0;
          }
          return _unequal(x, y);
        },
        "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
          return algorithm07(x, y, _unequal);
        },
        "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
          return algorithm03(y, x, _unequal, true);
        },
        "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
          return algorithm03(x, y, _unequal, false);
        },
        "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
          return algorithm13(x, y, _unequal);
        },
        "Array, Array": function ArrayArray(x, y) {
          return this(matrix2(x), matrix2(y)).valueOf();
        },
        "Array, Matrix": function ArrayMatrix(x, y) {
          return this(matrix2(x), y);
        },
        "Matrix, Array": function MatrixArray(x, y) {
          return this(x, matrix2(y));
        },
        "SparseMatrix, any": function SparseMatrixAny(x, y) {
          return algorithm12(x, y, _unequal, false);
        },
        "DenseMatrix, any": function DenseMatrixAny(x, y) {
          return algorithm14(x, y, _unequal, false);
        },
        "any, SparseMatrix": function anySparseMatrix(x, y) {
          return algorithm12(y, x, _unequal, true);
        },
        "any, DenseMatrix": function anyDenseMatrix(x, y) {
          return algorithm14(y, x, _unequal, true);
        },
        "Array, any": function ArrayAny(x, y) {
          return algorithm14(matrix2(x), y, _unequal, false).valueOf();
        },
        "any, Array": function anyArray(x, y) {
          return algorithm14(matrix2(y), x, _unequal, true).valueOf();
        }
      });
      function _unequal(x, y) {
        return !equalScalar2(x, y);
      }
    });
    createUnequalNumber = factory(name147, ["typed", "equalScalar"], (_ref2) => {
      var {
        typed: typed2,
        equalScalar: equalScalar2
      } = _ref2;
      return typed2(name147, {
        "any, any": function anyAny(x, y) {
          if (x === null) {
            return y !== null;
          }
          if (y === null) {
            return x !== null;
          }
          if (x === void 0) {
            return y !== void 0;
          }
          if (y === void 0) {
            return x !== void 0;
          }
          return !equalScalar2(x, y);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/partitionSelect.js
var name148, dependencies149, createPartitionSelect;
var init_partitionSelect = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/partitionSelect.js"() {
    init_is();
    init_number();
    init_factory();
    name148 = "partitionSelect";
    dependencies149 = ["typed", "isNumeric", "isNaN", "compare"];
    createPartitionSelect = /* @__PURE__ */ factory(name148, dependencies149, (_ref) => {
      var {
        typed: typed2,
        isNumeric: isNumeric2,
        isNaN: isNaN3,
        compare: compare2
      } = _ref;
      var asc = compare2;
      var desc = (a, b) => -compare2(a, b);
      return typed2(name148, {
        "Array | Matrix, number": function ArrayMatrixNumber(x, k) {
          return _partitionSelect(x, k, asc);
        },
        "Array | Matrix, number, string": function ArrayMatrixNumberString(x, k, compare3) {
          if (compare3 === "asc") {
            return _partitionSelect(x, k, asc);
          } else if (compare3 === "desc") {
            return _partitionSelect(x, k, desc);
          } else {
            throw new Error('Compare string must be "asc" or "desc"');
          }
        },
        "Array | Matrix, number, function": _partitionSelect
      });
      function _partitionSelect(x, k, compare3) {
        if (!isInteger(k) || k < 0) {
          throw new Error("k must be a non-negative integer");
        }
        if (isMatrix(x)) {
          var size2 = x.size();
          if (size2.length > 1) {
            throw new Error("Only one dimensional matrices supported");
          }
          return quickSelect(x.valueOf(), k, compare3);
        }
        if (Array.isArray(x)) {
          return quickSelect(x, k, compare3);
        }
      }
      function quickSelect(arr, k, compare3) {
        if (k >= arr.length) {
          throw new Error("k out of bounds");
        }
        for (var i2 = 0; i2 < arr.length; i2++) {
          if (isNumeric2(arr[i2]) && isNaN3(arr[i2])) {
            return arr[i2];
          }
        }
        var from = 0;
        var to2 = arr.length - 1;
        while (from < to2) {
          var r = from;
          var w = to2;
          var pivot = arr[Math.floor(Math.random() * (to2 - from + 1)) + from];
          while (r < w) {
            if (compare3(arr[r], pivot) >= 0) {
              var tmp = arr[w];
              arr[w] = arr[r];
              arr[r] = tmp;
              --w;
            } else {
              ++r;
            }
          }
          if (compare3(arr[r], pivot) > 0) {
            --r;
          }
          if (k <= r) {
            to2 = r;
          } else {
            from = r + 1;
          }
        }
        return arr[k];
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/sort.js
var name149, dependencies150, createSort;
var init_sort = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/sort.js"() {
    init_array();
    init_factory();
    name149 = "sort";
    dependencies150 = ["typed", "matrix", "compare", "compareNatural"];
    createSort = /* @__PURE__ */ factory(name149, dependencies150, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        compare: compare2,
        compareNatural: compareNatural2
      } = _ref;
      var compareAsc = compare2;
      var compareDesc = (a, b) => -compare2(a, b);
      return typed2(name149, {
        Array: function Array2(x) {
          _arrayIsVector(x);
          return x.sort(compareAsc);
        },
        Matrix: function Matrix2(x) {
          _matrixIsVector(x);
          return matrix2(x.toArray().sort(compareAsc), x.storage());
        },
        "Array, function": function ArrayFunction(x, _comparator2) {
          _arrayIsVector(x);
          return x.sort(_comparator2);
        },
        "Matrix, function": function MatrixFunction(x, _comparator2) {
          _matrixIsVector(x);
          return matrix2(x.toArray().sort(_comparator2), x.storage());
        },
        "Array, string": function ArrayString(x, order) {
          _arrayIsVector(x);
          return x.sort(_comparator(order));
        },
        "Matrix, string": function MatrixString(x, order) {
          _matrixIsVector(x);
          return matrix2(x.toArray().sort(_comparator(order)), x.storage());
        }
      });
      function _comparator(order) {
        if (order === "asc") {
          return compareAsc;
        } else if (order === "desc") {
          return compareDesc;
        } else if (order === "natural") {
          return compareNatural2;
        } else {
          throw new Error('String "asc", "desc", or "natural" expected');
        }
      }
      function _arrayIsVector(array) {
        if (arraySize(array).length !== 1) {
          throw new Error("One dimensional array expected");
        }
      }
      function _matrixIsVector(matrix3) {
        if (matrix3.size().length !== 1) {
          throw new Error("One dimensional matrix expected");
        }
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/statistics/max.js
var name150, dependencies151, createMax;
var init_max = __esm({
  "node_modules/mathjs/lib/esm/function/statistics/max.js"() {
    init_collection();
    init_factory();
    init_improveErrorMessage();
    name150 = "max";
    dependencies151 = ["typed", "config", "numeric", "larger"];
    createMax = /* @__PURE__ */ factory(name150, dependencies151, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        numeric: numeric3,
        larger: larger2
      } = _ref;
      return typed2(name150, {
        "Array | Matrix": _max,
        "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
          return reduce(array, dim.valueOf(), _largest);
        },
        "...": function _(args) {
          if (containsCollections(args)) {
            throw new TypeError("Scalar values expected in function max");
          }
          return _max(args);
        }
      });
      function _largest(x, y) {
        try {
          return larger2(x, y) ? x : y;
        } catch (err) {
          throw improveErrorMessage(err, "max", y);
        }
      }
      function _max(array) {
        var res;
        deepForEach(array, function(value) {
          try {
            if (isNaN(value) && typeof value === "number") {
              res = NaN;
            } else if (res === void 0 || larger2(value, res)) {
              res = value;
            }
          } catch (err) {
            throw improveErrorMessage(err, "max", value);
          }
        });
        if (res === void 0) {
          throw new Error("Cannot calculate max of an empty array");
        }
        if (typeof res === "string") {
          res = numeric3(res, config3.number);
        }
        return res;
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/statistics/min.js
var name151, dependencies152, createMin;
var init_min = __esm({
  "node_modules/mathjs/lib/esm/function/statistics/min.js"() {
    init_collection();
    init_factory();
    init_improveErrorMessage();
    name151 = "min";
    dependencies152 = ["typed", "config", "numeric", "smaller"];
    createMin = /* @__PURE__ */ factory(name151, dependencies152, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        numeric: numeric3,
        smaller: smaller2
      } = _ref;
      return typed2(name151, {
        "Array | Matrix": _min,
        "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
          return reduce(array, dim.valueOf(), _smallest);
        },
        "...": function _(args) {
          if (containsCollections(args)) {
            throw new TypeError("Scalar values expected in function min");
          }
          return _min(args);
        }
      });
      function _smallest(x, y) {
        try {
          return smaller2(x, y) ? x : y;
        } catch (err) {
          throw improveErrorMessage(err, "min", y);
        }
      }
      function _min(array) {
        var min2;
        deepForEach(array, function(value) {
          try {
            if (isNaN(value) && typeof value === "number") {
              min2 = NaN;
            } else if (min2 === void 0 || smaller2(value, min2)) {
              min2 = value;
            }
          } catch (err) {
            throw improveErrorMessage(err, "min", value);
          }
        });
        if (min2 === void 0) {
          throw new Error("Cannot calculate min of an empty array");
        }
        if (typeof min2 === "string") {
          min2 = numeric3(min2, config3.number);
        }
        return min2;
      }
    });
  }
});

// node_modules/mathjs/lib/esm/type/matrix/ImmutableDenseMatrix.js
var name152, dependencies153, createImmutableDenseMatrixClass;
var init_ImmutableDenseMatrix = __esm({
  "node_modules/mathjs/lib/esm/type/matrix/ImmutableDenseMatrix.js"() {
    init_is();
    init_object();
    init_factory();
    name152 = "ImmutableDenseMatrix";
    dependencies153 = ["smaller", "DenseMatrix"];
    createImmutableDenseMatrixClass = /* @__PURE__ */ factory(name152, dependencies153, (_ref) => {
      var {
        smaller: smaller2,
        DenseMatrix: DenseMatrix2
      } = _ref;
      function ImmutableDenseMatrix2(data, datatype) {
        if (!(this instanceof ImmutableDenseMatrix2)) {
          throw new SyntaxError("Constructor must be called with the new operator");
        }
        if (datatype && !isString2(datatype)) {
          throw new Error("Invalid datatype: " + datatype);
        }
        if (isMatrix(data) || isArray(data)) {
          var matrix2 = new DenseMatrix2(data, datatype);
          this._data = matrix2._data;
          this._size = matrix2._size;
          this._datatype = matrix2._datatype;
          this._min = null;
          this._max = null;
        } else if (data && isArray(data.data) && isArray(data.size)) {
          this._data = data.data;
          this._size = data.size;
          this._datatype = data.datatype;
          this._min = typeof data.min !== "undefined" ? data.min : null;
          this._max = typeof data.max !== "undefined" ? data.max : null;
        } else if (data) {
          throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
        } else {
          this._data = [];
          this._size = [0];
          this._datatype = datatype;
          this._min = null;
          this._max = null;
        }
      }
      ImmutableDenseMatrix2.prototype = new DenseMatrix2();
      ImmutableDenseMatrix2.prototype.type = "ImmutableDenseMatrix";
      ImmutableDenseMatrix2.prototype.isImmutableDenseMatrix = true;
      ImmutableDenseMatrix2.prototype.subset = function(index2) {
        switch (arguments.length) {
          case 1: {
            var m = DenseMatrix2.prototype.subset.call(this, index2);
            if (isMatrix(m)) {
              return new ImmutableDenseMatrix2({
                data: m._data,
                size: m._size,
                datatype: m._datatype
              });
            }
            return m;
          }
          case 2:
          case 3:
            throw new Error("Cannot invoke set subset on an Immutable Matrix instance");
          default:
            throw new SyntaxError("Wrong number of arguments");
        }
      };
      ImmutableDenseMatrix2.prototype.set = function() {
        throw new Error("Cannot invoke set on an Immutable Matrix instance");
      };
      ImmutableDenseMatrix2.prototype.resize = function() {
        throw new Error("Cannot invoke resize on an Immutable Matrix instance");
      };
      ImmutableDenseMatrix2.prototype.reshape = function() {
        throw new Error("Cannot invoke reshape on an Immutable Matrix instance");
      };
      ImmutableDenseMatrix2.prototype.clone = function() {
        return new ImmutableDenseMatrix2({
          data: clone(this._data),
          size: clone(this._size),
          datatype: this._datatype
        });
      };
      ImmutableDenseMatrix2.prototype.toJSON = function() {
        return {
          mathjs: "ImmutableDenseMatrix",
          data: this._data,
          size: this._size,
          datatype: this._datatype
        };
      };
      ImmutableDenseMatrix2.fromJSON = function(json) {
        return new ImmutableDenseMatrix2(json);
      };
      ImmutableDenseMatrix2.prototype.swapRows = function() {
        throw new Error("Cannot invoke swapRows on an Immutable Matrix instance");
      };
      ImmutableDenseMatrix2.prototype.min = function() {
        if (this._min === null) {
          var m = null;
          this.forEach(function(v) {
            if (m === null || smaller2(v, m)) {
              m = v;
            }
          });
          this._min = m !== null ? m : void 0;
        }
        return this._min;
      };
      ImmutableDenseMatrix2.prototype.max = function() {
        if (this._max === null) {
          var m = null;
          this.forEach(function(v) {
            if (m === null || smaller2(m, v)) {
              m = v;
            }
          });
          this._max = m !== null ? m : void 0;
        }
        return this._max;
      };
      return ImmutableDenseMatrix2;
    }, {
      isClass: true
    });
  }
});

// node_modules/mathjs/lib/esm/type/matrix/MatrixIndex.js
var name153, dependencies154, createIndexClass;
var init_MatrixIndex = __esm({
  "node_modules/mathjs/lib/esm/type/matrix/MatrixIndex.js"() {
    init_is();
    init_object();
    init_number();
    init_factory();
    name153 = "Index";
    dependencies154 = ["ImmutableDenseMatrix"];
    createIndexClass = /* @__PURE__ */ factory(name153, dependencies154, (_ref) => {
      var {
        ImmutableDenseMatrix: ImmutableDenseMatrix2
      } = _ref;
      function Index2(ranges) {
        if (!(this instanceof Index2)) {
          throw new SyntaxError("Constructor must be called with the new operator");
        }
        this._dimensions = [];
        this._isScalar = true;
        for (var i2 = 0, ii = arguments.length; i2 < ii; i2++) {
          var arg2 = arguments[i2];
          if (isRange(arg2)) {
            this._dimensions.push(arg2);
            this._isScalar = false;
          } else if (Array.isArray(arg2) || isMatrix(arg2)) {
            var m = _createImmutableMatrix(arg2.valueOf());
            this._dimensions.push(m);
            var size2 = m.size();
            if (size2.length !== 1 || size2[0] !== 1) {
              this._isScalar = false;
            }
          } else if (typeof arg2 === "number") {
            this._dimensions.push(_createImmutableMatrix([arg2]));
          } else if (typeof arg2 === "string") {
            this._dimensions.push(arg2);
          } else {
            throw new TypeError("Dimension must be an Array, Matrix, number, string, or Range");
          }
        }
      }
      Index2.prototype.type = "Index";
      Index2.prototype.isIndex = true;
      function _createImmutableMatrix(arg2) {
        for (var i2 = 0, l = arg2.length; i2 < l; i2++) {
          if (typeof arg2[i2] !== "number" || !isInteger(arg2[i2])) {
            throw new TypeError("Index parameters must be positive integer numbers");
          }
        }
        return new ImmutableDenseMatrix2(arg2);
      }
      Index2.prototype.clone = function() {
        var index2 = new Index2();
        index2._dimensions = clone(this._dimensions);
        index2._isScalar = this._isScalar;
        return index2;
      };
      Index2.create = function(ranges) {
        var index2 = new Index2();
        Index2.apply(index2, ranges);
        return index2;
      };
      Index2.prototype.size = function() {
        var size2 = [];
        for (var i2 = 0, ii = this._dimensions.length; i2 < ii; i2++) {
          var d = this._dimensions[i2];
          size2[i2] = typeof d === "string" ? 1 : d.size()[0];
        }
        return size2;
      };
      Index2.prototype.max = function() {
        var values = [];
        for (var i2 = 0, ii = this._dimensions.length; i2 < ii; i2++) {
          var range2 = this._dimensions[i2];
          values[i2] = typeof range2 === "string" ? range2 : range2.max();
        }
        return values;
      };
      Index2.prototype.min = function() {
        var values = [];
        for (var i2 = 0, ii = this._dimensions.length; i2 < ii; i2++) {
          var range2 = this._dimensions[i2];
          values[i2] = typeof range2 === "string" ? range2 : range2.min();
        }
        return values;
      };
      Index2.prototype.forEach = function(callback) {
        for (var i2 = 0, ii = this._dimensions.length; i2 < ii; i2++) {
          callback(this._dimensions[i2], i2, this);
        }
      };
      Index2.prototype.dimension = function(dim) {
        return this._dimensions[dim] || null;
      };
      Index2.prototype.isObjectProperty = function() {
        return this._dimensions.length === 1 && typeof this._dimensions[0] === "string";
      };
      Index2.prototype.getObjectProperty = function() {
        return this.isObjectProperty() ? this._dimensions[0] : null;
      };
      Index2.prototype.isScalar = function() {
        return this._isScalar;
      };
      Index2.prototype.toArray = function() {
        var array = [];
        for (var i2 = 0, ii = this._dimensions.length; i2 < ii; i2++) {
          var dimension = this._dimensions[i2];
          array.push(typeof dimension === "string" ? dimension : dimension.toArray());
        }
        return array;
      };
      Index2.prototype.valueOf = Index2.prototype.toArray;
      Index2.prototype.toString = function() {
        var strings = [];
        for (var i2 = 0, ii = this._dimensions.length; i2 < ii; i2++) {
          var dimension = this._dimensions[i2];
          if (typeof dimension === "string") {
            strings.push(JSON.stringify(dimension));
          } else {
            strings.push(dimension.toString());
          }
        }
        return "[" + strings.join(", ") + "]";
      };
      Index2.prototype.toJSON = function() {
        return {
          mathjs: "Index",
          dimensions: this._dimensions
        };
      };
      Index2.fromJSON = function(json) {
        return Index2.create(json.dimensions);
      };
      return Index2;
    }, {
      isClass: true
    });
  }
});

// node_modules/mathjs/lib/esm/type/matrix/FibonacciHeap.js
var name154, dependencies155, createFibonacciHeapClass;
var init_FibonacciHeap = __esm({
  "node_modules/mathjs/lib/esm/type/matrix/FibonacciHeap.js"() {
    init_factory();
    name154 = "FibonacciHeap";
    dependencies155 = ["smaller", "larger"];
    createFibonacciHeapClass = /* @__PURE__ */ factory(name154, dependencies155, (_ref) => {
      var {
        smaller: smaller2,
        larger: larger2
      } = _ref;
      var oneOverLogPhi = 1 / Math.log((1 + Math.sqrt(5)) / 2);
      function FibonacciHeap2() {
        if (!(this instanceof FibonacciHeap2)) {
          throw new SyntaxError("Constructor must be called with the new operator");
        }
        this._minimum = null;
        this._size = 0;
      }
      FibonacciHeap2.prototype.type = "FibonacciHeap";
      FibonacciHeap2.prototype.isFibonacciHeap = true;
      FibonacciHeap2.prototype.insert = function(key, value) {
        var node = {
          key,
          value,
          degree: 0
        };
        if (this._minimum) {
          var minimum = this._minimum;
          node.left = minimum;
          node.right = minimum.right;
          minimum.right = node;
          node.right.left = node;
          if (smaller2(key, minimum.key)) {
            this._minimum = node;
          }
        } else {
          node.left = node;
          node.right = node;
          this._minimum = node;
        }
        this._size++;
        return node;
      };
      FibonacciHeap2.prototype.size = function() {
        return this._size;
      };
      FibonacciHeap2.prototype.clear = function() {
        this._minimum = null;
        this._size = 0;
      };
      FibonacciHeap2.prototype.isEmpty = function() {
        return this._size === 0;
      };
      FibonacciHeap2.prototype.extractMinimum = function() {
        var node = this._minimum;
        if (node === null) {
          return node;
        }
        var minimum = this._minimum;
        var numberOfChildren = node.degree;
        var x = node.child;
        while (numberOfChildren > 0) {
          var tempRight = x.right;
          x.left.right = x.right;
          x.right.left = x.left;
          x.left = minimum;
          x.right = minimum.right;
          minimum.right = x;
          x.right.left = x;
          x.parent = null;
          x = tempRight;
          numberOfChildren--;
        }
        node.left.right = node.right;
        node.right.left = node.left;
        if (node === node.right) {
          minimum = null;
        } else {
          minimum = node.right;
          minimum = _findMinimumNode(minimum, this._size);
        }
        this._size--;
        this._minimum = minimum;
        return node;
      };
      FibonacciHeap2.prototype.remove = function(node) {
        this._minimum = _decreaseKey(this._minimum, node, -1);
        this.extractMinimum();
      };
      function _decreaseKey(minimum, node, key) {
        node.key = key;
        var parent2 = node.parent;
        if (parent2 && smaller2(node.key, parent2.key)) {
          _cut(minimum, node, parent2);
          _cascadingCut(minimum, parent2);
        }
        if (smaller2(node.key, minimum.key)) {
          minimum = node;
        }
        return minimum;
      }
      function _cut(minimum, node, parent2) {
        node.left.right = node.right;
        node.right.left = node.left;
        parent2.degree--;
        if (parent2.child === node) {
          parent2.child = node.right;
        }
        if (parent2.degree === 0) {
          parent2.child = null;
        }
        node.left = minimum;
        node.right = minimum.right;
        minimum.right = node;
        node.right.left = node;
        node.parent = null;
        node.mark = false;
      }
      function _cascadingCut(minimum, node) {
        var parent2 = node.parent;
        if (!parent2) {
          return;
        }
        if (!node.mark) {
          node.mark = true;
        } else {
          _cut(minimum, node, parent2);
          _cascadingCut(parent2);
        }
      }
      var _linkNodes = function _linkNodes2(node, parent2) {
        node.left.right = node.right;
        node.right.left = node.left;
        node.parent = parent2;
        if (!parent2.child) {
          parent2.child = node;
          node.right = node;
          node.left = node;
        } else {
          node.left = parent2.child;
          node.right = parent2.child.right;
          parent2.child.right = node;
          node.right.left = node;
        }
        parent2.degree++;
        node.mark = false;
      };
      function _findMinimumNode(minimum, size2) {
        var arraySize2 = Math.floor(Math.log(size2) * oneOverLogPhi) + 1;
        var array = new Array(arraySize2);
        var numRoots = 0;
        var x = minimum;
        if (x) {
          numRoots++;
          x = x.right;
          while (x !== minimum) {
            numRoots++;
            x = x.right;
          }
        }
        var y;
        while (numRoots > 0) {
          var d = x.degree;
          var next = x.right;
          while (true) {
            y = array[d];
            if (!y) {
              break;
            }
            if (larger2(x.key, y.key)) {
              var temp = y;
              y = x;
              x = temp;
            }
            _linkNodes(y, x);
            array[d] = null;
            d++;
          }
          array[d] = x;
          x = next;
          numRoots--;
        }
        minimum = null;
        for (var i2 = 0; i2 < arraySize2; i2++) {
          y = array[i2];
          if (!y) {
            continue;
          }
          if (minimum) {
            y.left.right = y.right;
            y.right.left = y.left;
            y.left = minimum;
            y.right = minimum.right;
            minimum.right = y;
            y.right.left = y;
            if (smaller2(y.key, minimum.key)) {
              minimum = y;
            }
          } else {
            minimum = y;
          }
        }
        return minimum;
      }
      return FibonacciHeap2;
    }, {
      isClass: true
    });
  }
});

// node_modules/mathjs/lib/esm/type/matrix/Spa.js
var name155, dependencies156, createSpaClass;
var init_Spa = __esm({
  "node_modules/mathjs/lib/esm/type/matrix/Spa.js"() {
    init_factory();
    name155 = "Spa";
    dependencies156 = ["addScalar", "equalScalar", "FibonacciHeap"];
    createSpaClass = /* @__PURE__ */ factory(name155, dependencies156, (_ref) => {
      var {
        addScalar: addScalar2,
        equalScalar: equalScalar2,
        FibonacciHeap: FibonacciHeap2
      } = _ref;
      function Spa2() {
        if (!(this instanceof Spa2)) {
          throw new SyntaxError("Constructor must be called with the new operator");
        }
        this._values = [];
        this._heap = new FibonacciHeap2();
      }
      Spa2.prototype.type = "Spa";
      Spa2.prototype.isSpa = true;
      Spa2.prototype.set = function(i2, v) {
        if (!this._values[i2]) {
          var node = this._heap.insert(i2, v);
          this._values[i2] = node;
        } else {
          this._values[i2].value = v;
        }
      };
      Spa2.prototype.get = function(i2) {
        var node = this._values[i2];
        if (node) {
          return node.value;
        }
        return 0;
      };
      Spa2.prototype.accumulate = function(i2, v) {
        var node = this._values[i2];
        if (!node) {
          node = this._heap.insert(i2, v);
          this._values[i2] = node;
        } else {
          node.value = addScalar2(node.value, v);
        }
      };
      Spa2.prototype.forEach = function(from, to2, callback) {
        var heap = this._heap;
        var values = this._values;
        var nodes = [];
        var node = heap.extractMinimum();
        if (node) {
          nodes.push(node);
        }
        while (node && node.key <= to2) {
          if (node.key >= from) {
            if (!equalScalar2(node.value, 0)) {
              callback(node.key, node.value, this);
            }
          }
          node = heap.extractMinimum();
          if (node) {
            nodes.push(node);
          }
        }
        for (var i2 = 0; i2 < nodes.length; i2++) {
          var n = nodes[i2];
          node = heap.insert(n.key, n.value);
          values[node.key] = node;
        }
      };
      Spa2.prototype.swap = function(i2, j) {
        var nodei = this._values[i2];
        var nodej = this._values[j];
        if (!nodei && nodej) {
          nodei = this._heap.insert(i2, nodej.value);
          this._heap.remove(nodej);
          this._values[i2] = nodei;
          this._values[j] = void 0;
        } else if (nodei && !nodej) {
          nodej = this._heap.insert(j, nodei.value);
          this._heap.remove(nodei);
          this._values[j] = nodej;
          this._values[i2] = void 0;
        } else if (nodei && nodej) {
          var v = nodei.value;
          nodei.value = nodej.value;
          nodej.value = v;
        }
      };
      return Spa2;
    }, {
      isClass: true
    });
  }
});

// node_modules/@babel/runtime/helpers/defineProperty.js
var require_defineProperty = __commonJS({
  "node_modules/@babel/runtime/helpers/defineProperty.js"(exports, module) {
    function _defineProperty3(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    module.exports = _defineProperty3, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/mathjs/lib/esm/utils/bignumber/constants.js
function hasher(args) {
  return args[0].precision;
}
var createBigNumberE, createBigNumberPhi, createBigNumberPi, createBigNumberTau;
var init_constants2 = __esm({
  "node_modules/mathjs/lib/esm/utils/bignumber/constants.js"() {
    init_function();
    createBigNumberE = memoize(function(BigNumber2) {
      return new BigNumber2(1).exp();
    }, {
      hasher
    });
    createBigNumberPhi = memoize(function(BigNumber2) {
      return new BigNumber2(1).plus(new BigNumber2(5).sqrt()).div(2);
    }, {
      hasher
    });
    createBigNumberPi = memoize(function(BigNumber2) {
      return BigNumber2.acos(-1);
    }, {
      hasher
    });
    createBigNumberTau = memoize(function(BigNumber2) {
      return createBigNumberPi(BigNumber2).times(2);
    }, {
      hasher
    });
  }
});

// node_modules/mathjs/lib/esm/type/unit/Unit.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      (0, import_defineProperty.default)(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var import_extends2, import_defineProperty, name156, dependencies157, createUnitClass;
var init_Unit = __esm({
  "node_modules/mathjs/lib/esm/type/unit/Unit.js"() {
    import_extends2 = __toESM(require_extends(), 1);
    import_defineProperty = __toESM(require_defineProperty(), 1);
    init_is();
    init_factory();
    init_function();
    init_string();
    init_object();
    init_constants2();
    name156 = "Unit";
    dependencies157 = ["?on", "config", "addScalar", "subtract", "multiplyScalar", "divideScalar", "pow", "abs", "fix", "round", "equal", "isNumeric", "format", "number", "Complex", "BigNumber", "Fraction"];
    createUnitClass = /* @__PURE__ */ factory(name156, dependencies157, (_ref) => {
      var {
        on,
        config: config3,
        addScalar: addScalar2,
        subtract: subtract2,
        multiplyScalar: multiplyScalar2,
        divideScalar: divideScalar2,
        pow: pow2,
        abs: abs2,
        fix: fix2,
        round: round2,
        equal: equal2,
        isNumeric: isNumeric2,
        format: format5,
        number: number2,
        Complex: Complex3,
        BigNumber: _BigNumber,
        Fraction: _Fraction
      } = _ref;
      var toNumber = number2;
      function Unit2(value, name296) {
        if (!(this instanceof Unit2)) {
          throw new Error("Constructor must be called with the new operator");
        }
        if (!(value === null || value === void 0 || isNumeric2(value) || isComplex(value))) {
          throw new TypeError("First parameter in Unit constructor must be number, BigNumber, Fraction, Complex, or undefined");
        }
        if (name296 !== void 0 && (typeof name296 !== "string" || name296 === "")) {
          throw new TypeError("Second parameter in Unit constructor must be a string");
        }
        if (name296 !== void 0) {
          var u = Unit2.parse(name296);
          this.units = u.units;
          this.dimensions = u.dimensions;
        } else {
          this.units = [{
            unit: UNIT_NONE,
            prefix: PREFIXES.NONE,
            power: 0
          }];
          this.dimensions = [];
          for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
            this.dimensions[i2] = 0;
          }
        }
        this.value = value !== void 0 && value !== null ? this._normalize(value) : null;
        this.fixPrefix = false;
        this.skipAutomaticSimplification = true;
      }
      Unit2.prototype.type = "Unit";
      Unit2.prototype.isUnit = true;
      var text, index2, c;
      function skipWhitespace() {
        while (c === " " || c === "	") {
          next();
        }
      }
      function isDigitDot(c2) {
        return c2 >= "0" && c2 <= "9" || c2 === ".";
      }
      function isDigit(c2) {
        return c2 >= "0" && c2 <= "9";
      }
      function next() {
        index2++;
        c = text.charAt(index2);
      }
      function revert(oldIndex) {
        index2 = oldIndex;
        c = text.charAt(index2);
      }
      function parseNumber() {
        var number3 = "";
        var oldIndex = index2;
        if (c === "+") {
          next();
        } else if (c === "-") {
          number3 += c;
          next();
        }
        if (!isDigitDot(c)) {
          revert(oldIndex);
          return null;
        }
        if (c === ".") {
          number3 += c;
          next();
          if (!isDigit(c)) {
            revert(oldIndex);
            return null;
          }
        } else {
          while (isDigit(c)) {
            number3 += c;
            next();
          }
          if (c === ".") {
            number3 += c;
            next();
          }
        }
        while (isDigit(c)) {
          number3 += c;
          next();
        }
        if (c === "E" || c === "e") {
          var tentativeNumber = "";
          var tentativeIndex = index2;
          tentativeNumber += c;
          next();
          if (c === "+" || c === "-") {
            tentativeNumber += c;
            next();
          }
          if (!isDigit(c)) {
            revert(tentativeIndex);
            return number3;
          }
          number3 = number3 + tentativeNumber;
          while (isDigit(c)) {
            number3 += c;
            next();
          }
        }
        return number3;
      }
      function parseUnit() {
        var unitName = "";
        while (isDigit(c) || Unit2.isValidAlpha(c)) {
          unitName += c;
          next();
        }
        var firstC = unitName.charAt(0);
        if (Unit2.isValidAlpha(firstC)) {
          return unitName;
        } else {
          return null;
        }
      }
      function parseCharacter(toFind) {
        if (c === toFind) {
          next();
          return toFind;
        } else {
          return null;
        }
      }
      Unit2.parse = function(str, options) {
        options = options || {};
        text = str;
        index2 = -1;
        c = "";
        if (typeof text !== "string") {
          throw new TypeError("Invalid argument in Unit.parse, string expected");
        }
        var unit3 = new Unit2();
        unit3.units = [];
        var powerMultiplierCurrent = 1;
        var expectingUnit = false;
        next();
        skipWhitespace();
        var valueStr = parseNumber();
        var value = null;
        if (valueStr) {
          if (config3.number === "BigNumber") {
            value = new _BigNumber(valueStr);
          } else if (config3.number === "Fraction") {
            try {
              value = new _Fraction(valueStr);
            } catch (err) {
              value = parseFloat(valueStr);
            }
          } else {
            value = parseFloat(valueStr);
          }
          skipWhitespace();
          if (parseCharacter("*")) {
            powerMultiplierCurrent = 1;
            expectingUnit = true;
          } else if (parseCharacter("/")) {
            powerMultiplierCurrent = -1;
            expectingUnit = true;
          }
        }
        var powerMultiplierStack = [];
        var powerMultiplierStackProduct = 1;
        while (true) {
          skipWhitespace();
          while (c === "(") {
            powerMultiplierStack.push(powerMultiplierCurrent);
            powerMultiplierStackProduct *= powerMultiplierCurrent;
            powerMultiplierCurrent = 1;
            next();
            skipWhitespace();
          }
          var uStr = void 0;
          if (c) {
            var oldC = c;
            uStr = parseUnit();
            if (uStr === null) {
              throw new SyntaxError('Unexpected "' + oldC + '" in "' + text + '" at index ' + index2.toString());
            }
          } else {
            break;
          }
          var res = _findUnit(uStr);
          if (res === null) {
            throw new SyntaxError('Unit "' + uStr + '" not found.');
          }
          var power = powerMultiplierCurrent * powerMultiplierStackProduct;
          skipWhitespace();
          if (parseCharacter("^")) {
            skipWhitespace();
            var p = parseNumber();
            if (p === null) {
              throw new SyntaxError('In "' + str + '", "^" must be followed by a floating-point number');
            }
            power *= p;
          }
          unit3.units.push({
            unit: res.unit,
            prefix: res.prefix,
            power
          });
          for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
            unit3.dimensions[i2] += (res.unit.dimensions[i2] || 0) * power;
          }
          skipWhitespace();
          while (c === ")") {
            if (powerMultiplierStack.length === 0) {
              throw new SyntaxError('Unmatched ")" in "' + text + '" at index ' + index2.toString());
            }
            powerMultiplierStackProduct /= powerMultiplierStack.pop();
            next();
            skipWhitespace();
          }
          expectingUnit = false;
          if (parseCharacter("*")) {
            powerMultiplierCurrent = 1;
            expectingUnit = true;
          } else if (parseCharacter("/")) {
            powerMultiplierCurrent = -1;
            expectingUnit = true;
          } else {
            powerMultiplierCurrent = 1;
          }
          if (res.unit.base) {
            var baseDim = res.unit.base.key;
            UNIT_SYSTEMS.auto[baseDim] = {
              unit: res.unit,
              prefix: res.prefix
            };
          }
        }
        skipWhitespace();
        if (c) {
          throw new SyntaxError('Could not parse: "' + str + '"');
        }
        if (expectingUnit) {
          throw new SyntaxError('Trailing characters: "' + str + '"');
        }
        if (powerMultiplierStack.length !== 0) {
          throw new SyntaxError('Unmatched "(" in "' + text + '"');
        }
        if (unit3.units.length === 0 && !options.allowNoUnits) {
          throw new SyntaxError('"' + str + '" contains no units');
        }
        unit3.value = value !== void 0 ? unit3._normalize(value) : null;
        return unit3;
      };
      Unit2.prototype.clone = function() {
        var unit3 = new Unit2();
        unit3.fixPrefix = this.fixPrefix;
        unit3.skipAutomaticSimplification = this.skipAutomaticSimplification;
        unit3.value = clone(this.value);
        unit3.dimensions = this.dimensions.slice(0);
        unit3.units = [];
        for (var i2 = 0; i2 < this.units.length; i2++) {
          unit3.units[i2] = {};
          for (var p in this.units[i2]) {
            if (hasOwnProperty2(this.units[i2], p)) {
              unit3.units[i2][p] = this.units[i2][p];
            }
          }
        }
        return unit3;
      };
      Unit2.prototype._isDerived = function() {
        if (this.units.length === 0) {
          return false;
        }
        return this.units.length > 1 || Math.abs(this.units[0].power - 1) > 1e-15;
      };
      Unit2.prototype._normalize = function(value) {
        if (value === null || value === void 0 || this.units.length === 0) {
          return value;
        }
        var res = value;
        var convert = Unit2._getNumberConverter(typeOf(value));
        for (var i2 = 0; i2 < this.units.length; i2++) {
          var unitValue = convert(this.units[i2].unit.value);
          var unitPrefixValue = convert(this.units[i2].prefix.value);
          var unitPower = convert(this.units[i2].power);
          res = multiplyScalar2(res, pow2(multiplyScalar2(unitValue, unitPrefixValue), unitPower));
        }
        return res;
      };
      Unit2.prototype._denormalize = function(value, prefixValue) {
        if (value === null || value === void 0 || this.units.length === 0) {
          return value;
        }
        var res = value;
        var convert = Unit2._getNumberConverter(typeOf(value));
        for (var i2 = 0; i2 < this.units.length; i2++) {
          var unitValue = convert(this.units[i2].unit.value);
          var unitPrefixValue = convert(this.units[i2].prefix.value);
          var unitPower = convert(this.units[i2].power);
          res = divideScalar2(res, pow2(multiplyScalar2(unitValue, unitPrefixValue), unitPower));
        }
        return res;
      };
      var _findUnit = memoize((str) => {
        if (hasOwnProperty2(UNITS, str)) {
          var unit3 = UNITS[str];
          var prefix = unit3.prefixes[""];
          return {
            unit: unit3,
            prefix
          };
        }
        for (var _name in UNITS) {
          if (hasOwnProperty2(UNITS, _name)) {
            if (endsWith(str, _name)) {
              var _unit = UNITS[_name];
              var prefixLen = str.length - _name.length;
              var prefixName = str.substring(0, prefixLen);
              var _prefix = hasOwnProperty2(_unit.prefixes, prefixName) ? _unit.prefixes[prefixName] : void 0;
              if (_prefix !== void 0) {
                return {
                  unit: _unit,
                  prefix: _prefix
                };
              }
            }
          }
        }
        return null;
      }, {
        hasher: (args) => args[0],
        limit: 100
      });
      Unit2.isValuelessUnit = function(name296) {
        return _findUnit(name296) !== null;
      };
      Unit2.prototype.hasBase = function(base) {
        if (typeof base === "string") {
          base = BASE_UNITS[base];
        }
        if (!base) {
          return false;
        }
        for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
          if (Math.abs((this.dimensions[i2] || 0) - (base.dimensions[i2] || 0)) > 1e-12) {
            return false;
          }
        }
        return true;
      };
      Unit2.prototype.equalBase = function(other) {
        for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
          if (Math.abs((this.dimensions[i2] || 0) - (other.dimensions[i2] || 0)) > 1e-12) {
            return false;
          }
        }
        return true;
      };
      Unit2.prototype.equals = function(other) {
        return this.equalBase(other) && equal2(this.value, other.value);
      };
      Unit2.prototype.multiply = function(other) {
        var res = this.clone();
        for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
          res.dimensions[i2] = (this.dimensions[i2] || 0) + (other.dimensions[i2] || 0);
        }
        for (var _i = 0; _i < other.units.length; _i++) {
          var inverted = _objectSpread({}, other.units[_i]);
          res.units.push(inverted);
        }
        if (this.value !== null || other.value !== null) {
          var valThis = this.value === null ? this._normalize(1) : this.value;
          var valOther = other.value === null ? other._normalize(1) : other.value;
          res.value = multiplyScalar2(valThis, valOther);
        } else {
          res.value = null;
        }
        res.skipAutomaticSimplification = false;
        return getNumericIfUnitless(res);
      };
      Unit2.prototype.divide = function(other) {
        var res = this.clone();
        for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
          res.dimensions[i2] = (this.dimensions[i2] || 0) - (other.dimensions[i2] || 0);
        }
        for (var _i2 = 0; _i2 < other.units.length; _i2++) {
          var inverted = _objectSpread(_objectSpread({}, other.units[_i2]), {}, {
            power: -other.units[_i2].power
          });
          res.units.push(inverted);
        }
        if (this.value !== null || other.value !== null) {
          var valThis = this.value === null ? this._normalize(1) : this.value;
          var valOther = other.value === null ? other._normalize(1) : other.value;
          res.value = divideScalar2(valThis, valOther);
        } else {
          res.value = null;
        }
        res.skipAutomaticSimplification = false;
        return getNumericIfUnitless(res);
      };
      Unit2.prototype.pow = function(p) {
        var res = this.clone();
        for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
          res.dimensions[i2] = (this.dimensions[i2] || 0) * p;
        }
        for (var _i3 = 0; _i3 < res.units.length; _i3++) {
          res.units[_i3].power *= p;
        }
        if (res.value !== null) {
          res.value = pow2(res.value, p);
        } else {
          res.value = null;
        }
        res.skipAutomaticSimplification = false;
        return getNumericIfUnitless(res);
      };
      function getNumericIfUnitless(unit3) {
        if (unit3.equalBase(BASE_UNITS.NONE) && unit3.value !== null && !config3.predictable) {
          return unit3.value;
        } else {
          return unit3;
        }
      }
      Unit2.prototype.abs = function() {
        var ret = this.clone();
        if (ret.value !== null) {
          if (ret._isDerived() || ret.units[0].unit.offset === 0) {
            ret.value = abs2(ret.value);
          } else {
            var convert = Unit2._getNumberConverter(typeOf(ret.value));
            var unitValue = convert(ret.units[0].unit.value);
            var nominalOffset = convert(ret.units[0].unit.offset);
            var unitOffset = multiplyScalar2(unitValue, nominalOffset);
            ret.value = subtract2(abs2(addScalar2(ret.value, unitOffset)), unitOffset);
          }
        }
        for (var i2 in ret.units) {
          if (ret.units[i2].unit.name === "VA" || ret.units[i2].unit.name === "VAR") {
            ret.units[i2].unit = UNITS.W;
          }
        }
        return ret;
      };
      Unit2.prototype.to = function(valuelessUnit) {
        var value = this.value === null ? this._normalize(1) : this.value;
        var other;
        if (typeof valuelessUnit === "string") {
          other = Unit2.parse(valuelessUnit);
        } else if (isUnit(valuelessUnit)) {
          other = valuelessUnit.clone();
        } else {
          throw new Error("String or Unit expected as parameter");
        }
        if (!this.equalBase(other)) {
          throw new Error("Units do not match ('".concat(other.toString(), "' != '").concat(this.toString(), "')"));
        }
        if (other.value !== null) {
          throw new Error("Cannot convert to a unit with a value");
        }
        if (this.value === null || this._isDerived() || this.units[0].unit.offset === other.units[0].unit.offset) {
          other.value = clone(value);
        } else {
          var convert = Unit2._getNumberConverter(typeOf(value));
          var thisUnitValue = convert(this.units[0].unit.value);
          var thisNominalOffset = convert(this.units[0].unit.offset);
          var thisUnitOffset = multiplyScalar2(thisUnitValue, thisNominalOffset);
          var otherUnitValue = convert(other.units[0].unit.value);
          var otherNominalOffset = convert(other.units[0].unit.offset);
          var otherUnitOffset = multiplyScalar2(otherUnitValue, otherNominalOffset);
          other.value = subtract2(addScalar2(value, thisUnitOffset), otherUnitOffset);
        }
        other.fixPrefix = true;
        other.skipAutomaticSimplification = true;
        return other;
      };
      Unit2.prototype.toNumber = function(valuelessUnit) {
        return toNumber(this.toNumeric(valuelessUnit));
      };
      Unit2.prototype.toNumeric = function(valuelessUnit) {
        var other;
        if (valuelessUnit) {
          other = this.to(valuelessUnit);
        } else {
          other = this.clone();
        }
        if (other._isDerived() || other.units.length === 0) {
          return other._denormalize(other.value);
        } else {
          return other._denormalize(other.value, other.units[0].prefix.value);
        }
      };
      Unit2.prototype.toString = function() {
        return this.format();
      };
      Unit2.prototype.toJSON = function() {
        return {
          mathjs: "Unit",
          value: this._denormalize(this.value),
          unit: this.formatUnits(),
          fixPrefix: this.fixPrefix
        };
      };
      Unit2.fromJSON = function(json) {
        var unit3 = new Unit2(json.value, json.unit);
        unit3.fixPrefix = json.fixPrefix || false;
        return unit3;
      };
      Unit2.prototype.valueOf = Unit2.prototype.toString;
      Unit2.prototype.simplify = function() {
        var ret = this.clone();
        var proposedUnitList = [];
        var matchingBase;
        for (var key2 in currentUnitSystem) {
          if (hasOwnProperty2(currentUnitSystem, key2)) {
            if (ret.hasBase(BASE_UNITS[key2])) {
              matchingBase = key2;
              break;
            }
          }
        }
        if (matchingBase === "NONE") {
          ret.units = [];
        } else {
          var matchingUnit;
          if (matchingBase) {
            if (hasOwnProperty2(currentUnitSystem, matchingBase)) {
              matchingUnit = currentUnitSystem[matchingBase];
            }
          }
          if (matchingUnit) {
            ret.units = [{
              unit: matchingUnit.unit,
              prefix: matchingUnit.prefix,
              power: 1
            }];
          } else {
            var missingBaseDim = false;
            for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
              var baseDim = BASE_DIMENSIONS[i2];
              if (Math.abs(ret.dimensions[i2] || 0) > 1e-12) {
                if (hasOwnProperty2(currentUnitSystem, baseDim)) {
                  proposedUnitList.push({
                    unit: currentUnitSystem[baseDim].unit,
                    prefix: currentUnitSystem[baseDim].prefix,
                    power: ret.dimensions[i2] || 0
                  });
                } else {
                  missingBaseDim = true;
                }
              }
            }
            if (proposedUnitList.length < ret.units.length && !missingBaseDim) {
              ret.units = proposedUnitList;
            }
          }
        }
        return ret;
      };
      Unit2.prototype.toSI = function() {
        var ret = this.clone();
        var proposedUnitList = [];
        for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
          var baseDim = BASE_DIMENSIONS[i2];
          if (Math.abs(ret.dimensions[i2] || 0) > 1e-12) {
            if (hasOwnProperty2(UNIT_SYSTEMS.si, baseDim)) {
              proposedUnitList.push({
                unit: UNIT_SYSTEMS.si[baseDim].unit,
                prefix: UNIT_SYSTEMS.si[baseDim].prefix,
                power: ret.dimensions[i2] || 0
              });
            } else {
              throw new Error("Cannot express custom unit " + baseDim + " in SI units");
            }
          }
        }
        ret.units = proposedUnitList;
        ret.fixPrefix = true;
        ret.skipAutomaticSimplification = true;
        return ret;
      };
      Unit2.prototype.formatUnits = function() {
        var strNum = "";
        var strDen = "";
        var nNum = 0;
        var nDen = 0;
        for (var i2 = 0; i2 < this.units.length; i2++) {
          if (this.units[i2].power > 0) {
            nNum++;
            strNum += " " + this.units[i2].prefix.name + this.units[i2].unit.name;
            if (Math.abs(this.units[i2].power - 1) > 1e-15) {
              strNum += "^" + this.units[i2].power;
            }
          } else if (this.units[i2].power < 0) {
            nDen++;
          }
        }
        if (nDen > 0) {
          for (var _i4 = 0; _i4 < this.units.length; _i4++) {
            if (this.units[_i4].power < 0) {
              if (nNum > 0) {
                strDen += " " + this.units[_i4].prefix.name + this.units[_i4].unit.name;
                if (Math.abs(this.units[_i4].power + 1) > 1e-15) {
                  strDen += "^" + -this.units[_i4].power;
                }
              } else {
                strDen += " " + this.units[_i4].prefix.name + this.units[_i4].unit.name;
                strDen += "^" + this.units[_i4].power;
              }
            }
          }
        }
        strNum = strNum.substr(1);
        strDen = strDen.substr(1);
        if (nNum > 1 && nDen > 0) {
          strNum = "(" + strNum + ")";
        }
        if (nDen > 1 && nNum > 0) {
          strDen = "(" + strDen + ")";
        }
        var str = strNum;
        if (nNum > 0 && nDen > 0) {
          str += " / ";
        }
        str += strDen;
        return str;
      };
      Unit2.prototype.format = function(options) {
        var simp = this.skipAutomaticSimplification || this.value === null ? this.clone() : this.simplify();
        var isImaginary = false;
        if (typeof simp.value !== "undefined" && simp.value !== null && isComplex(simp.value)) {
          isImaginary = Math.abs(simp.value.re) < 1e-14;
        }
        for (var i2 in simp.units) {
          if (hasOwnProperty2(simp.units, i2)) {
            if (simp.units[i2].unit) {
              if (simp.units[i2].unit.name === "VA" && isImaginary) {
                simp.units[i2].unit = UNITS.VAR;
              } else if (simp.units[i2].unit.name === "VAR" && !isImaginary) {
                simp.units[i2].unit = UNITS.VA;
              }
            }
          }
        }
        if (simp.units.length === 1 && !simp.fixPrefix) {
          if (Math.abs(simp.units[0].power - Math.round(simp.units[0].power)) < 1e-14) {
            simp.units[0].prefix = simp._bestPrefix();
          }
        }
        var value = simp._denormalize(simp.value);
        var str = simp.value !== null ? format5(value, options || {}) : "";
        var unitStr = simp.formatUnits();
        if (simp.value && isComplex(simp.value)) {
          str = "(" + str + ")";
        }
        if (unitStr.length > 0 && str.length > 0) {
          str += " ";
        }
        str += unitStr;
        return str;
      };
      Unit2.prototype._bestPrefix = function() {
        if (this.units.length !== 1) {
          throw new Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");
        }
        if (Math.abs(this.units[0].power - Math.round(this.units[0].power)) >= 1e-14) {
          throw new Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");
        }
        var absValue = this.value !== null ? abs2(this.value) : 0;
        var absUnitValue = abs2(this.units[0].unit.value);
        var bestPrefix = this.units[0].prefix;
        if (absValue === 0) {
          return bestPrefix;
        }
        var power = this.units[0].power;
        var bestDiff = Math.log(absValue / Math.pow(bestPrefix.value * absUnitValue, power)) / Math.LN10 - 1.2;
        if (bestDiff > -2.200001 && bestDiff < 1.800001)
          return bestPrefix;
        bestDiff = Math.abs(bestDiff);
        var prefixes = this.units[0].unit.prefixes;
        for (var p in prefixes) {
          if (hasOwnProperty2(prefixes, p)) {
            var prefix = prefixes[p];
            if (prefix.scientific) {
              var diff2 = Math.abs(Math.log(absValue / Math.pow(prefix.value * absUnitValue, power)) / Math.LN10 - 1.2);
              if (diff2 < bestDiff || diff2 === bestDiff && prefix.name.length < bestPrefix.name.length) {
                bestPrefix = prefix;
                bestDiff = diff2;
              }
            }
          }
        }
        return bestPrefix;
      };
      Unit2.prototype.splitUnit = function(parts) {
        var x = this.clone();
        var ret = [];
        for (var i2 = 0; i2 < parts.length; i2++) {
          x = x.to(parts[i2]);
          if (i2 === parts.length - 1)
            break;
          var xNumeric = x.toNumeric();
          var xRounded = round2(xNumeric);
          var xFixed = void 0;
          var isNearlyEqual = equal2(xRounded, xNumeric);
          if (isNearlyEqual) {
            xFixed = xRounded;
          } else {
            xFixed = fix2(x.toNumeric());
          }
          var y = new Unit2(xFixed, parts[i2].toString());
          ret.push(y);
          x = subtract2(x, y);
        }
        var testSum = 0;
        for (var _i5 = 0; _i5 < ret.length; _i5++) {
          testSum = addScalar2(testSum, ret[_i5].value);
        }
        if (equal2(testSum, this.value)) {
          x.value = 0;
        }
        ret.push(x);
        return ret;
      };
      var PREFIXES = {
        NONE: {
          "": {
            name: "",
            value: 1,
            scientific: true
          }
        },
        SHORT: {
          "": {
            name: "",
            value: 1,
            scientific: true
          },
          da: {
            name: "da",
            value: 10,
            scientific: false
          },
          h: {
            name: "h",
            value: 100,
            scientific: false
          },
          k: {
            name: "k",
            value: 1e3,
            scientific: true
          },
          M: {
            name: "M",
            value: 1e6,
            scientific: true
          },
          G: {
            name: "G",
            value: 1e9,
            scientific: true
          },
          T: {
            name: "T",
            value: 1e12,
            scientific: true
          },
          P: {
            name: "P",
            value: 1e15,
            scientific: true
          },
          E: {
            name: "E",
            value: 1e18,
            scientific: true
          },
          Z: {
            name: "Z",
            value: 1e21,
            scientific: true
          },
          Y: {
            name: "Y",
            value: 1e24,
            scientific: true
          },
          d: {
            name: "d",
            value: 0.1,
            scientific: false
          },
          c: {
            name: "c",
            value: 0.01,
            scientific: false
          },
          m: {
            name: "m",
            value: 1e-3,
            scientific: true
          },
          u: {
            name: "u",
            value: 1e-6,
            scientific: true
          },
          n: {
            name: "n",
            value: 1e-9,
            scientific: true
          },
          p: {
            name: "p",
            value: 1e-12,
            scientific: true
          },
          f: {
            name: "f",
            value: 1e-15,
            scientific: true
          },
          a: {
            name: "a",
            value: 1e-18,
            scientific: true
          },
          z: {
            name: "z",
            value: 1e-21,
            scientific: true
          },
          y: {
            name: "y",
            value: 1e-24,
            scientific: true
          }
        },
        LONG: {
          "": {
            name: "",
            value: 1,
            scientific: true
          },
          deca: {
            name: "deca",
            value: 10,
            scientific: false
          },
          hecto: {
            name: "hecto",
            value: 100,
            scientific: false
          },
          kilo: {
            name: "kilo",
            value: 1e3,
            scientific: true
          },
          mega: {
            name: "mega",
            value: 1e6,
            scientific: true
          },
          giga: {
            name: "giga",
            value: 1e9,
            scientific: true
          },
          tera: {
            name: "tera",
            value: 1e12,
            scientific: true
          },
          peta: {
            name: "peta",
            value: 1e15,
            scientific: true
          },
          exa: {
            name: "exa",
            value: 1e18,
            scientific: true
          },
          zetta: {
            name: "zetta",
            value: 1e21,
            scientific: true
          },
          yotta: {
            name: "yotta",
            value: 1e24,
            scientific: true
          },
          deci: {
            name: "deci",
            value: 0.1,
            scientific: false
          },
          centi: {
            name: "centi",
            value: 0.01,
            scientific: false
          },
          milli: {
            name: "milli",
            value: 1e-3,
            scientific: true
          },
          micro: {
            name: "micro",
            value: 1e-6,
            scientific: true
          },
          nano: {
            name: "nano",
            value: 1e-9,
            scientific: true
          },
          pico: {
            name: "pico",
            value: 1e-12,
            scientific: true
          },
          femto: {
            name: "femto",
            value: 1e-15,
            scientific: true
          },
          atto: {
            name: "atto",
            value: 1e-18,
            scientific: true
          },
          zepto: {
            name: "zepto",
            value: 1e-21,
            scientific: true
          },
          yocto: {
            name: "yocto",
            value: 1e-24,
            scientific: true
          }
        },
        SQUARED: {
          "": {
            name: "",
            value: 1,
            scientific: true
          },
          da: {
            name: "da",
            value: 100,
            scientific: false
          },
          h: {
            name: "h",
            value: 1e4,
            scientific: false
          },
          k: {
            name: "k",
            value: 1e6,
            scientific: true
          },
          M: {
            name: "M",
            value: 1e12,
            scientific: true
          },
          G: {
            name: "G",
            value: 1e18,
            scientific: true
          },
          T: {
            name: "T",
            value: 1e24,
            scientific: true
          },
          P: {
            name: "P",
            value: 1e30,
            scientific: true
          },
          E: {
            name: "E",
            value: 1e36,
            scientific: true
          },
          Z: {
            name: "Z",
            value: 1e42,
            scientific: true
          },
          Y: {
            name: "Y",
            value: 1e48,
            scientific: true
          },
          d: {
            name: "d",
            value: 0.01,
            scientific: false
          },
          c: {
            name: "c",
            value: 1e-4,
            scientific: false
          },
          m: {
            name: "m",
            value: 1e-6,
            scientific: true
          },
          u: {
            name: "u",
            value: 1e-12,
            scientific: true
          },
          n: {
            name: "n",
            value: 1e-18,
            scientific: true
          },
          p: {
            name: "p",
            value: 1e-24,
            scientific: true
          },
          f: {
            name: "f",
            value: 1e-30,
            scientific: true
          },
          a: {
            name: "a",
            value: 1e-36,
            scientific: true
          },
          z: {
            name: "z",
            value: 1e-42,
            scientific: true
          },
          y: {
            name: "y",
            value: 1e-48,
            scientific: true
          }
        },
        CUBIC: {
          "": {
            name: "",
            value: 1,
            scientific: true
          },
          da: {
            name: "da",
            value: 1e3,
            scientific: false
          },
          h: {
            name: "h",
            value: 1e6,
            scientific: false
          },
          k: {
            name: "k",
            value: 1e9,
            scientific: true
          },
          M: {
            name: "M",
            value: 1e18,
            scientific: true
          },
          G: {
            name: "G",
            value: 1e27,
            scientific: true
          },
          T: {
            name: "T",
            value: 1e36,
            scientific: true
          },
          P: {
            name: "P",
            value: 1e45,
            scientific: true
          },
          E: {
            name: "E",
            value: 1e54,
            scientific: true
          },
          Z: {
            name: "Z",
            value: 1e63,
            scientific: true
          },
          Y: {
            name: "Y",
            value: 1e72,
            scientific: true
          },
          d: {
            name: "d",
            value: 1e-3,
            scientific: false
          },
          c: {
            name: "c",
            value: 1e-6,
            scientific: false
          },
          m: {
            name: "m",
            value: 1e-9,
            scientific: true
          },
          u: {
            name: "u",
            value: 1e-18,
            scientific: true
          },
          n: {
            name: "n",
            value: 1e-27,
            scientific: true
          },
          p: {
            name: "p",
            value: 1e-36,
            scientific: true
          },
          f: {
            name: "f",
            value: 1e-45,
            scientific: true
          },
          a: {
            name: "a",
            value: 1e-54,
            scientific: true
          },
          z: {
            name: "z",
            value: 1e-63,
            scientific: true
          },
          y: {
            name: "y",
            value: 1e-72,
            scientific: true
          }
        },
        BINARY_SHORT_SI: {
          "": {
            name: "",
            value: 1,
            scientific: true
          },
          k: {
            name: "k",
            value: 1e3,
            scientific: true
          },
          M: {
            name: "M",
            value: 1e6,
            scientific: true
          },
          G: {
            name: "G",
            value: 1e9,
            scientific: true
          },
          T: {
            name: "T",
            value: 1e12,
            scientific: true
          },
          P: {
            name: "P",
            value: 1e15,
            scientific: true
          },
          E: {
            name: "E",
            value: 1e18,
            scientific: true
          },
          Z: {
            name: "Z",
            value: 1e21,
            scientific: true
          },
          Y: {
            name: "Y",
            value: 1e24,
            scientific: true
          }
        },
        BINARY_SHORT_IEC: {
          "": {
            name: "",
            value: 1,
            scientific: true
          },
          Ki: {
            name: "Ki",
            value: 1024,
            scientific: true
          },
          Mi: {
            name: "Mi",
            value: Math.pow(1024, 2),
            scientific: true
          },
          Gi: {
            name: "Gi",
            value: Math.pow(1024, 3),
            scientific: true
          },
          Ti: {
            name: "Ti",
            value: Math.pow(1024, 4),
            scientific: true
          },
          Pi: {
            name: "Pi",
            value: Math.pow(1024, 5),
            scientific: true
          },
          Ei: {
            name: "Ei",
            value: Math.pow(1024, 6),
            scientific: true
          },
          Zi: {
            name: "Zi",
            value: Math.pow(1024, 7),
            scientific: true
          },
          Yi: {
            name: "Yi",
            value: Math.pow(1024, 8),
            scientific: true
          }
        },
        BINARY_LONG_SI: {
          "": {
            name: "",
            value: 1,
            scientific: true
          },
          kilo: {
            name: "kilo",
            value: 1e3,
            scientific: true
          },
          mega: {
            name: "mega",
            value: 1e6,
            scientific: true
          },
          giga: {
            name: "giga",
            value: 1e9,
            scientific: true
          },
          tera: {
            name: "tera",
            value: 1e12,
            scientific: true
          },
          peta: {
            name: "peta",
            value: 1e15,
            scientific: true
          },
          exa: {
            name: "exa",
            value: 1e18,
            scientific: true
          },
          zetta: {
            name: "zetta",
            value: 1e21,
            scientific: true
          },
          yotta: {
            name: "yotta",
            value: 1e24,
            scientific: true
          }
        },
        BINARY_LONG_IEC: {
          "": {
            name: "",
            value: 1,
            scientific: true
          },
          kibi: {
            name: "kibi",
            value: 1024,
            scientific: true
          },
          mebi: {
            name: "mebi",
            value: Math.pow(1024, 2),
            scientific: true
          },
          gibi: {
            name: "gibi",
            value: Math.pow(1024, 3),
            scientific: true
          },
          tebi: {
            name: "tebi",
            value: Math.pow(1024, 4),
            scientific: true
          },
          pebi: {
            name: "pebi",
            value: Math.pow(1024, 5),
            scientific: true
          },
          exi: {
            name: "exi",
            value: Math.pow(1024, 6),
            scientific: true
          },
          zebi: {
            name: "zebi",
            value: Math.pow(1024, 7),
            scientific: true
          },
          yobi: {
            name: "yobi",
            value: Math.pow(1024, 8),
            scientific: true
          }
        },
        BTU: {
          "": {
            name: "",
            value: 1,
            scientific: true
          },
          MM: {
            name: "MM",
            value: 1e6,
            scientific: true
          }
        }
      };
      PREFIXES.SHORTLONG = (0, import_extends2.default)({}, PREFIXES.SHORT, PREFIXES.LONG);
      PREFIXES.BINARY_SHORT = (0, import_extends2.default)({}, PREFIXES.BINARY_SHORT_SI, PREFIXES.BINARY_SHORT_IEC);
      PREFIXES.BINARY_LONG = (0, import_extends2.default)({}, PREFIXES.BINARY_LONG_SI, PREFIXES.BINARY_LONG_IEC);
      var BASE_DIMENSIONS = ["MASS", "LENGTH", "TIME", "CURRENT", "TEMPERATURE", "LUMINOUS_INTENSITY", "AMOUNT_OF_SUBSTANCE", "ANGLE", "BIT"];
      var BASE_UNITS = {
        NONE: {
          dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 0]
        },
        MASS: {
          dimensions: [1, 0, 0, 0, 0, 0, 0, 0, 0]
        },
        LENGTH: {
          dimensions: [0, 1, 0, 0, 0, 0, 0, 0, 0]
        },
        TIME: {
          dimensions: [0, 0, 1, 0, 0, 0, 0, 0, 0]
        },
        CURRENT: {
          dimensions: [0, 0, 0, 1, 0, 0, 0, 0, 0]
        },
        TEMPERATURE: {
          dimensions: [0, 0, 0, 0, 1, 0, 0, 0, 0]
        },
        LUMINOUS_INTENSITY: {
          dimensions: [0, 0, 0, 0, 0, 1, 0, 0, 0]
        },
        AMOUNT_OF_SUBSTANCE: {
          dimensions: [0, 0, 0, 0, 0, 0, 1, 0, 0]
        },
        FORCE: {
          dimensions: [1, 1, -2, 0, 0, 0, 0, 0, 0]
        },
        SURFACE: {
          dimensions: [0, 2, 0, 0, 0, 0, 0, 0, 0]
        },
        VOLUME: {
          dimensions: [0, 3, 0, 0, 0, 0, 0, 0, 0]
        },
        ENERGY: {
          dimensions: [1, 2, -2, 0, 0, 0, 0, 0, 0]
        },
        POWER: {
          dimensions: [1, 2, -3, 0, 0, 0, 0, 0, 0]
        },
        PRESSURE: {
          dimensions: [1, -1, -2, 0, 0, 0, 0, 0, 0]
        },
        ELECTRIC_CHARGE: {
          dimensions: [0, 0, 1, 1, 0, 0, 0, 0, 0]
        },
        ELECTRIC_CAPACITANCE: {
          dimensions: [-1, -2, 4, 2, 0, 0, 0, 0, 0]
        },
        ELECTRIC_POTENTIAL: {
          dimensions: [1, 2, -3, -1, 0, 0, 0, 0, 0]
        },
        ELECTRIC_RESISTANCE: {
          dimensions: [1, 2, -3, -2, 0, 0, 0, 0, 0]
        },
        ELECTRIC_INDUCTANCE: {
          dimensions: [1, 2, -2, -2, 0, 0, 0, 0, 0]
        },
        ELECTRIC_CONDUCTANCE: {
          dimensions: [-1, -2, 3, 2, 0, 0, 0, 0, 0]
        },
        MAGNETIC_FLUX: {
          dimensions: [1, 2, -2, -1, 0, 0, 0, 0, 0]
        },
        MAGNETIC_FLUX_DENSITY: {
          dimensions: [1, 0, -2, -1, 0, 0, 0, 0, 0]
        },
        FREQUENCY: {
          dimensions: [0, 0, -1, 0, 0, 0, 0, 0, 0]
        },
        ANGLE: {
          dimensions: [0, 0, 0, 0, 0, 0, 0, 1, 0]
        },
        BIT: {
          dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 1]
        }
      };
      for (var key in BASE_UNITS) {
        if (hasOwnProperty2(BASE_UNITS, key)) {
          BASE_UNITS[key].key = key;
        }
      }
      var BASE_UNIT_NONE = {};
      var UNIT_NONE = {
        name: "",
        base: BASE_UNIT_NONE,
        value: 1,
        offset: 0,
        dimensions: BASE_DIMENSIONS.map((x) => 0)
      };
      var UNITS = {
        meter: {
          name: "meter",
          base: BASE_UNITS.LENGTH,
          prefixes: PREFIXES.LONG,
          value: 1,
          offset: 0
        },
        inch: {
          name: "inch",
          base: BASE_UNITS.LENGTH,
          prefixes: PREFIXES.NONE,
          value: 0.0254,
          offset: 0
        },
        foot: {
          name: "foot",
          base: BASE_UNITS.LENGTH,
          prefixes: PREFIXES.NONE,
          value: 0.3048,
          offset: 0
        },
        yard: {
          name: "yard",
          base: BASE_UNITS.LENGTH,
          prefixes: PREFIXES.NONE,
          value: 0.9144,
          offset: 0
        },
        mile: {
          name: "mile",
          base: BASE_UNITS.LENGTH,
          prefixes: PREFIXES.NONE,
          value: 1609.344,
          offset: 0
        },
        link: {
          name: "link",
          base: BASE_UNITS.LENGTH,
          prefixes: PREFIXES.NONE,
          value: 0.201168,
          offset: 0
        },
        rod: {
          name: "rod",
          base: BASE_UNITS.LENGTH,
          prefixes: PREFIXES.NONE,
          value: 5.0292,
          offset: 0
        },
        chain: {
          name: "chain",
          base: BASE_UNITS.LENGTH,
          prefixes: PREFIXES.NONE,
          value: 20.1168,
          offset: 0
        },
        angstrom: {
          name: "angstrom",
          base: BASE_UNITS.LENGTH,
          prefixes: PREFIXES.NONE,
          value: 1e-10,
          offset: 0
        },
        m: {
          name: "m",
          base: BASE_UNITS.LENGTH,
          prefixes: PREFIXES.SHORT,
          value: 1,
          offset: 0
        },
        in: {
          name: "in",
          base: BASE_UNITS.LENGTH,
          prefixes: PREFIXES.NONE,
          value: 0.0254,
          offset: 0
        },
        ft: {
          name: "ft",
          base: BASE_UNITS.LENGTH,
          prefixes: PREFIXES.NONE,
          value: 0.3048,
          offset: 0
        },
        yd: {
          name: "yd",
          base: BASE_UNITS.LENGTH,
          prefixes: PREFIXES.NONE,
          value: 0.9144,
          offset: 0
        },
        mi: {
          name: "mi",
          base: BASE_UNITS.LENGTH,
          prefixes: PREFIXES.NONE,
          value: 1609.344,
          offset: 0
        },
        li: {
          name: "li",
          base: BASE_UNITS.LENGTH,
          prefixes: PREFIXES.NONE,
          value: 0.201168,
          offset: 0
        },
        rd: {
          name: "rd",
          base: BASE_UNITS.LENGTH,
          prefixes: PREFIXES.NONE,
          value: 5.02921,
          offset: 0
        },
        ch: {
          name: "ch",
          base: BASE_UNITS.LENGTH,
          prefixes: PREFIXES.NONE,
          value: 20.1168,
          offset: 0
        },
        mil: {
          name: "mil",
          base: BASE_UNITS.LENGTH,
          prefixes: PREFIXES.NONE,
          value: 254e-7,
          offset: 0
        },
        m2: {
          name: "m2",
          base: BASE_UNITS.SURFACE,
          prefixes: PREFIXES.SQUARED,
          value: 1,
          offset: 0
        },
        sqin: {
          name: "sqin",
          base: BASE_UNITS.SURFACE,
          prefixes: PREFIXES.NONE,
          value: 64516e-8,
          offset: 0
        },
        sqft: {
          name: "sqft",
          base: BASE_UNITS.SURFACE,
          prefixes: PREFIXES.NONE,
          value: 0.09290304,
          offset: 0
        },
        sqyd: {
          name: "sqyd",
          base: BASE_UNITS.SURFACE,
          prefixes: PREFIXES.NONE,
          value: 0.83612736,
          offset: 0
        },
        sqmi: {
          name: "sqmi",
          base: BASE_UNITS.SURFACE,
          prefixes: PREFIXES.NONE,
          value: 2589988110336e-6,
          offset: 0
        },
        sqrd: {
          name: "sqrd",
          base: BASE_UNITS.SURFACE,
          prefixes: PREFIXES.NONE,
          value: 25.29295,
          offset: 0
        },
        sqch: {
          name: "sqch",
          base: BASE_UNITS.SURFACE,
          prefixes: PREFIXES.NONE,
          value: 404.6873,
          offset: 0
        },
        sqmil: {
          name: "sqmil",
          base: BASE_UNITS.SURFACE,
          prefixes: PREFIXES.NONE,
          value: 64516e-14,
          offset: 0
        },
        acre: {
          name: "acre",
          base: BASE_UNITS.SURFACE,
          prefixes: PREFIXES.NONE,
          value: 4046.86,
          offset: 0
        },
        hectare: {
          name: "hectare",
          base: BASE_UNITS.SURFACE,
          prefixes: PREFIXES.NONE,
          value: 1e4,
          offset: 0
        },
        m3: {
          name: "m3",
          base: BASE_UNITS.VOLUME,
          prefixes: PREFIXES.CUBIC,
          value: 1,
          offset: 0
        },
        L: {
          name: "L",
          base: BASE_UNITS.VOLUME,
          prefixes: PREFIXES.SHORT,
          value: 1e-3,
          offset: 0
        },
        l: {
          name: "l",
          base: BASE_UNITS.VOLUME,
          prefixes: PREFIXES.SHORT,
          value: 1e-3,
          offset: 0
        },
        litre: {
          name: "litre",
          base: BASE_UNITS.VOLUME,
          prefixes: PREFIXES.LONG,
          value: 1e-3,
          offset: 0
        },
        cuin: {
          name: "cuin",
          base: BASE_UNITS.VOLUME,
          prefixes: PREFIXES.NONE,
          value: 16387064e-12,
          offset: 0
        },
        cuft: {
          name: "cuft",
          base: BASE_UNITS.VOLUME,
          prefixes: PREFIXES.NONE,
          value: 0.028316846592,
          offset: 0
        },
        cuyd: {
          name: "cuyd",
          base: BASE_UNITS.VOLUME,
          prefixes: PREFIXES.NONE,
          value: 0.764554857984,
          offset: 0
        },
        teaspoon: {
          name: "teaspoon",
          base: BASE_UNITS.VOLUME,
          prefixes: PREFIXES.NONE,
          value: 5e-6,
          offset: 0
        },
        tablespoon: {
          name: "tablespoon",
          base: BASE_UNITS.VOLUME,
          prefixes: PREFIXES.NONE,
          value: 15e-6,
          offset: 0
        },
        drop: {
          name: "drop",
          base: BASE_UNITS.VOLUME,
          prefixes: PREFIXES.NONE,
          value: 5e-8,
          offset: 0
        },
        gtt: {
          name: "gtt",
          base: BASE_UNITS.VOLUME,
          prefixes: PREFIXES.NONE,
          value: 5e-8,
          offset: 0
        },
        minim: {
          name: "minim",
          base: BASE_UNITS.VOLUME,
          prefixes: PREFIXES.NONE,
          value: 6161152e-14,
          offset: 0
        },
        fluiddram: {
          name: "fluiddram",
          base: BASE_UNITS.VOLUME,
          prefixes: PREFIXES.NONE,
          value: 36966911e-13,
          offset: 0
        },
        fluidounce: {
          name: "fluidounce",
          base: BASE_UNITS.VOLUME,
          prefixes: PREFIXES.NONE,
          value: 2957353e-11,
          offset: 0
        },
        gill: {
          name: "gill",
          base: BASE_UNITS.VOLUME,
          prefixes: PREFIXES.NONE,
          value: 1182941e-10,
          offset: 0
        },
        cc: {
          name: "cc",
          base: BASE_UNITS.VOLUME,
          prefixes: PREFIXES.NONE,
          value: 1e-6,
          offset: 0
        },
        cup: {
          name: "cup",
          base: BASE_UNITS.VOLUME,
          prefixes: PREFIXES.NONE,
          value: 2365882e-10,
          offset: 0
        },
        pint: {
          name: "pint",
          base: BASE_UNITS.VOLUME,
          prefixes: PREFIXES.NONE,
          value: 4731765e-10,
          offset: 0
        },
        quart: {
          name: "quart",
          base: BASE_UNITS.VOLUME,
          prefixes: PREFIXES.NONE,
          value: 9463529e-10,
          offset: 0
        },
        gallon: {
          name: "gallon",
          base: BASE_UNITS.VOLUME,
          prefixes: PREFIXES.NONE,
          value: 3785412e-9,
          offset: 0
        },
        beerbarrel: {
          name: "beerbarrel",
          base: BASE_UNITS.VOLUME,
          prefixes: PREFIXES.NONE,
          value: 0.1173478,
          offset: 0
        },
        oilbarrel: {
          name: "oilbarrel",
          base: BASE_UNITS.VOLUME,
          prefixes: PREFIXES.NONE,
          value: 0.1589873,
          offset: 0
        },
        hogshead: {
          name: "hogshead",
          base: BASE_UNITS.VOLUME,
          prefixes: PREFIXES.NONE,
          value: 0.238481,
          offset: 0
        },
        fldr: {
          name: "fldr",
          base: BASE_UNITS.VOLUME,
          prefixes: PREFIXES.NONE,
          value: 36966911e-13,
          offset: 0
        },
        floz: {
          name: "floz",
          base: BASE_UNITS.VOLUME,
          prefixes: PREFIXES.NONE,
          value: 2957353e-11,
          offset: 0
        },
        gi: {
          name: "gi",
          base: BASE_UNITS.VOLUME,
          prefixes: PREFIXES.NONE,
          value: 1182941e-10,
          offset: 0
        },
        cp: {
          name: "cp",
          base: BASE_UNITS.VOLUME,
          prefixes: PREFIXES.NONE,
          value: 2365882e-10,
          offset: 0
        },
        pt: {
          name: "pt",
          base: BASE_UNITS.VOLUME,
          prefixes: PREFIXES.NONE,
          value: 4731765e-10,
          offset: 0
        },
        qt: {
          name: "qt",
          base: BASE_UNITS.VOLUME,
          prefixes: PREFIXES.NONE,
          value: 9463529e-10,
          offset: 0
        },
        gal: {
          name: "gal",
          base: BASE_UNITS.VOLUME,
          prefixes: PREFIXES.NONE,
          value: 3785412e-9,
          offset: 0
        },
        bbl: {
          name: "bbl",
          base: BASE_UNITS.VOLUME,
          prefixes: PREFIXES.NONE,
          value: 0.1173478,
          offset: 0
        },
        obl: {
          name: "obl",
          base: BASE_UNITS.VOLUME,
          prefixes: PREFIXES.NONE,
          value: 0.1589873,
          offset: 0
        },
        g: {
          name: "g",
          base: BASE_UNITS.MASS,
          prefixes: PREFIXES.SHORT,
          value: 1e-3,
          offset: 0
        },
        gram: {
          name: "gram",
          base: BASE_UNITS.MASS,
          prefixes: PREFIXES.LONG,
          value: 1e-3,
          offset: 0
        },
        ton: {
          name: "ton",
          base: BASE_UNITS.MASS,
          prefixes: PREFIXES.SHORT,
          value: 907.18474,
          offset: 0
        },
        t: {
          name: "t",
          base: BASE_UNITS.MASS,
          prefixes: PREFIXES.SHORT,
          value: 1e3,
          offset: 0
        },
        tonne: {
          name: "tonne",
          base: BASE_UNITS.MASS,
          prefixes: PREFIXES.LONG,
          value: 1e3,
          offset: 0
        },
        grain: {
          name: "grain",
          base: BASE_UNITS.MASS,
          prefixes: PREFIXES.NONE,
          value: 6479891e-11,
          offset: 0
        },
        dram: {
          name: "dram",
          base: BASE_UNITS.MASS,
          prefixes: PREFIXES.NONE,
          value: 0.0017718451953125,
          offset: 0
        },
        ounce: {
          name: "ounce",
          base: BASE_UNITS.MASS,
          prefixes: PREFIXES.NONE,
          value: 0.028349523125,
          offset: 0
        },
        poundmass: {
          name: "poundmass",
          base: BASE_UNITS.MASS,
          prefixes: PREFIXES.NONE,
          value: 0.45359237,
          offset: 0
        },
        hundredweight: {
          name: "hundredweight",
          base: BASE_UNITS.MASS,
          prefixes: PREFIXES.NONE,
          value: 45.359237,
          offset: 0
        },
        stick: {
          name: "stick",
          base: BASE_UNITS.MASS,
          prefixes: PREFIXES.NONE,
          value: 0.115,
          offset: 0
        },
        stone: {
          name: "stone",
          base: BASE_UNITS.MASS,
          prefixes: PREFIXES.NONE,
          value: 6.35029318,
          offset: 0
        },
        gr: {
          name: "gr",
          base: BASE_UNITS.MASS,
          prefixes: PREFIXES.NONE,
          value: 6479891e-11,
          offset: 0
        },
        dr: {
          name: "dr",
          base: BASE_UNITS.MASS,
          prefixes: PREFIXES.NONE,
          value: 0.0017718451953125,
          offset: 0
        },
        oz: {
          name: "oz",
          base: BASE_UNITS.MASS,
          prefixes: PREFIXES.NONE,
          value: 0.028349523125,
          offset: 0
        },
        lbm: {
          name: "lbm",
          base: BASE_UNITS.MASS,
          prefixes: PREFIXES.NONE,
          value: 0.45359237,
          offset: 0
        },
        cwt: {
          name: "cwt",
          base: BASE_UNITS.MASS,
          prefixes: PREFIXES.NONE,
          value: 45.359237,
          offset: 0
        },
        s: {
          name: "s",
          base: BASE_UNITS.TIME,
          prefixes: PREFIXES.SHORT,
          value: 1,
          offset: 0
        },
        min: {
          name: "min",
          base: BASE_UNITS.TIME,
          prefixes: PREFIXES.NONE,
          value: 60,
          offset: 0
        },
        h: {
          name: "h",
          base: BASE_UNITS.TIME,
          prefixes: PREFIXES.NONE,
          value: 3600,
          offset: 0
        },
        second: {
          name: "second",
          base: BASE_UNITS.TIME,
          prefixes: PREFIXES.LONG,
          value: 1,
          offset: 0
        },
        sec: {
          name: "sec",
          base: BASE_UNITS.TIME,
          prefixes: PREFIXES.LONG,
          value: 1,
          offset: 0
        },
        minute: {
          name: "minute",
          base: BASE_UNITS.TIME,
          prefixes: PREFIXES.NONE,
          value: 60,
          offset: 0
        },
        hour: {
          name: "hour",
          base: BASE_UNITS.TIME,
          prefixes: PREFIXES.NONE,
          value: 3600,
          offset: 0
        },
        day: {
          name: "day",
          base: BASE_UNITS.TIME,
          prefixes: PREFIXES.NONE,
          value: 86400,
          offset: 0
        },
        week: {
          name: "week",
          base: BASE_UNITS.TIME,
          prefixes: PREFIXES.NONE,
          value: 7 * 86400,
          offset: 0
        },
        month: {
          name: "month",
          base: BASE_UNITS.TIME,
          prefixes: PREFIXES.NONE,
          value: 2629800,
          offset: 0
        },
        year: {
          name: "year",
          base: BASE_UNITS.TIME,
          prefixes: PREFIXES.NONE,
          value: 31557600,
          offset: 0
        },
        decade: {
          name: "decade",
          base: BASE_UNITS.TIME,
          prefixes: PREFIXES.NONE,
          value: 315576e3,
          offset: 0
        },
        century: {
          name: "century",
          base: BASE_UNITS.TIME,
          prefixes: PREFIXES.NONE,
          value: 315576e4,
          offset: 0
        },
        millennium: {
          name: "millennium",
          base: BASE_UNITS.TIME,
          prefixes: PREFIXES.NONE,
          value: 315576e5,
          offset: 0
        },
        hertz: {
          name: "Hertz",
          base: BASE_UNITS.FREQUENCY,
          prefixes: PREFIXES.LONG,
          value: 1,
          offset: 0,
          reciprocal: true
        },
        Hz: {
          name: "Hz",
          base: BASE_UNITS.FREQUENCY,
          prefixes: PREFIXES.SHORT,
          value: 1,
          offset: 0,
          reciprocal: true
        },
        rad: {
          name: "rad",
          base: BASE_UNITS.ANGLE,
          prefixes: PREFIXES.SHORT,
          value: 1,
          offset: 0
        },
        radian: {
          name: "radian",
          base: BASE_UNITS.ANGLE,
          prefixes: PREFIXES.LONG,
          value: 1,
          offset: 0
        },
        deg: {
          name: "deg",
          base: BASE_UNITS.ANGLE,
          prefixes: PREFIXES.SHORT,
          value: null,
          offset: 0
        },
        degree: {
          name: "degree",
          base: BASE_UNITS.ANGLE,
          prefixes: PREFIXES.LONG,
          value: null,
          offset: 0
        },
        grad: {
          name: "grad",
          base: BASE_UNITS.ANGLE,
          prefixes: PREFIXES.SHORT,
          value: null,
          offset: 0
        },
        gradian: {
          name: "gradian",
          base: BASE_UNITS.ANGLE,
          prefixes: PREFIXES.LONG,
          value: null,
          offset: 0
        },
        cycle: {
          name: "cycle",
          base: BASE_UNITS.ANGLE,
          prefixes: PREFIXES.NONE,
          value: null,
          offset: 0
        },
        arcsec: {
          name: "arcsec",
          base: BASE_UNITS.ANGLE,
          prefixes: PREFIXES.NONE,
          value: null,
          offset: 0
        },
        arcmin: {
          name: "arcmin",
          base: BASE_UNITS.ANGLE,
          prefixes: PREFIXES.NONE,
          value: null,
          offset: 0
        },
        A: {
          name: "A",
          base: BASE_UNITS.CURRENT,
          prefixes: PREFIXES.SHORT,
          value: 1,
          offset: 0
        },
        ampere: {
          name: "ampere",
          base: BASE_UNITS.CURRENT,
          prefixes: PREFIXES.LONG,
          value: 1,
          offset: 0
        },
        K: {
          name: "K",
          base: BASE_UNITS.TEMPERATURE,
          prefixes: PREFIXES.NONE,
          value: 1,
          offset: 0
        },
        degC: {
          name: "degC",
          base: BASE_UNITS.TEMPERATURE,
          prefixes: PREFIXES.NONE,
          value: 1,
          offset: 273.15
        },
        degF: {
          name: "degF",
          base: BASE_UNITS.TEMPERATURE,
          prefixes: PREFIXES.NONE,
          value: 1 / 1.8,
          offset: 459.67
        },
        degR: {
          name: "degR",
          base: BASE_UNITS.TEMPERATURE,
          prefixes: PREFIXES.NONE,
          value: 1 / 1.8,
          offset: 0
        },
        kelvin: {
          name: "kelvin",
          base: BASE_UNITS.TEMPERATURE,
          prefixes: PREFIXES.NONE,
          value: 1,
          offset: 0
        },
        celsius: {
          name: "celsius",
          base: BASE_UNITS.TEMPERATURE,
          prefixes: PREFIXES.NONE,
          value: 1,
          offset: 273.15
        },
        fahrenheit: {
          name: "fahrenheit",
          base: BASE_UNITS.TEMPERATURE,
          prefixes: PREFIXES.NONE,
          value: 1 / 1.8,
          offset: 459.67
        },
        rankine: {
          name: "rankine",
          base: BASE_UNITS.TEMPERATURE,
          prefixes: PREFIXES.NONE,
          value: 1 / 1.8,
          offset: 0
        },
        mol: {
          name: "mol",
          base: BASE_UNITS.AMOUNT_OF_SUBSTANCE,
          prefixes: PREFIXES.SHORT,
          value: 1,
          offset: 0
        },
        mole: {
          name: "mole",
          base: BASE_UNITS.AMOUNT_OF_SUBSTANCE,
          prefixes: PREFIXES.LONG,
          value: 1,
          offset: 0
        },
        cd: {
          name: "cd",
          base: BASE_UNITS.LUMINOUS_INTENSITY,
          prefixes: PREFIXES.SHORT,
          value: 1,
          offset: 0
        },
        candela: {
          name: "candela",
          base: BASE_UNITS.LUMINOUS_INTENSITY,
          prefixes: PREFIXES.LONG,
          value: 1,
          offset: 0
        },
        N: {
          name: "N",
          base: BASE_UNITS.FORCE,
          prefixes: PREFIXES.SHORT,
          value: 1,
          offset: 0
        },
        newton: {
          name: "newton",
          base: BASE_UNITS.FORCE,
          prefixes: PREFIXES.LONG,
          value: 1,
          offset: 0
        },
        dyn: {
          name: "dyn",
          base: BASE_UNITS.FORCE,
          prefixes: PREFIXES.SHORT,
          value: 1e-5,
          offset: 0
        },
        dyne: {
          name: "dyne",
          base: BASE_UNITS.FORCE,
          prefixes: PREFIXES.LONG,
          value: 1e-5,
          offset: 0
        },
        lbf: {
          name: "lbf",
          base: BASE_UNITS.FORCE,
          prefixes: PREFIXES.NONE,
          value: 4.4482216152605,
          offset: 0
        },
        poundforce: {
          name: "poundforce",
          base: BASE_UNITS.FORCE,
          prefixes: PREFIXES.NONE,
          value: 4.4482216152605,
          offset: 0
        },
        kip: {
          name: "kip",
          base: BASE_UNITS.FORCE,
          prefixes: PREFIXES.LONG,
          value: 4448.2216,
          offset: 0
        },
        kilogramforce: {
          name: "kilogramforce",
          base: BASE_UNITS.FORCE,
          prefixes: PREFIXES.NONE,
          value: 9.80665,
          offset: 0
        },
        J: {
          name: "J",
          base: BASE_UNITS.ENERGY,
          prefixes: PREFIXES.SHORT,
          value: 1,
          offset: 0
        },
        joule: {
          name: "joule",
          base: BASE_UNITS.ENERGY,
          prefixes: PREFIXES.SHORT,
          value: 1,
          offset: 0
        },
        erg: {
          name: "erg",
          base: BASE_UNITS.ENERGY,
          prefixes: PREFIXES.NONE,
          value: 1e-7,
          offset: 0
        },
        Wh: {
          name: "Wh",
          base: BASE_UNITS.ENERGY,
          prefixes: PREFIXES.SHORT,
          value: 3600,
          offset: 0
        },
        BTU: {
          name: "BTU",
          base: BASE_UNITS.ENERGY,
          prefixes: PREFIXES.BTU,
          value: 1055.05585262,
          offset: 0
        },
        eV: {
          name: "eV",
          base: BASE_UNITS.ENERGY,
          prefixes: PREFIXES.SHORT,
          value: 1602176565e-28,
          offset: 0
        },
        electronvolt: {
          name: "electronvolt",
          base: BASE_UNITS.ENERGY,
          prefixes: PREFIXES.LONG,
          value: 1602176565e-28,
          offset: 0
        },
        W: {
          name: "W",
          base: BASE_UNITS.POWER,
          prefixes: PREFIXES.SHORT,
          value: 1,
          offset: 0
        },
        watt: {
          name: "watt",
          base: BASE_UNITS.POWER,
          prefixes: PREFIXES.LONG,
          value: 1,
          offset: 0
        },
        hp: {
          name: "hp",
          base: BASE_UNITS.POWER,
          prefixes: PREFIXES.NONE,
          value: 745.6998715386,
          offset: 0
        },
        VAR: {
          name: "VAR",
          base: BASE_UNITS.POWER,
          prefixes: PREFIXES.SHORT,
          value: Complex3.I,
          offset: 0
        },
        VA: {
          name: "VA",
          base: BASE_UNITS.POWER,
          prefixes: PREFIXES.SHORT,
          value: 1,
          offset: 0
        },
        Pa: {
          name: "Pa",
          base: BASE_UNITS.PRESSURE,
          prefixes: PREFIXES.SHORT,
          value: 1,
          offset: 0
        },
        psi: {
          name: "psi",
          base: BASE_UNITS.PRESSURE,
          prefixes: PREFIXES.NONE,
          value: 6894.75729276459,
          offset: 0
        },
        atm: {
          name: "atm",
          base: BASE_UNITS.PRESSURE,
          prefixes: PREFIXES.NONE,
          value: 101325,
          offset: 0
        },
        bar: {
          name: "bar",
          base: BASE_UNITS.PRESSURE,
          prefixes: PREFIXES.SHORTLONG,
          value: 1e5,
          offset: 0
        },
        torr: {
          name: "torr",
          base: BASE_UNITS.PRESSURE,
          prefixes: PREFIXES.NONE,
          value: 133.322,
          offset: 0
        },
        mmHg: {
          name: "mmHg",
          base: BASE_UNITS.PRESSURE,
          prefixes: PREFIXES.NONE,
          value: 133.322,
          offset: 0
        },
        mmH2O: {
          name: "mmH2O",
          base: BASE_UNITS.PRESSURE,
          prefixes: PREFIXES.NONE,
          value: 9.80665,
          offset: 0
        },
        cmH2O: {
          name: "cmH2O",
          base: BASE_UNITS.PRESSURE,
          prefixes: PREFIXES.NONE,
          value: 98.0665,
          offset: 0
        },
        coulomb: {
          name: "coulomb",
          base: BASE_UNITS.ELECTRIC_CHARGE,
          prefixes: PREFIXES.LONG,
          value: 1,
          offset: 0
        },
        C: {
          name: "C",
          base: BASE_UNITS.ELECTRIC_CHARGE,
          prefixes: PREFIXES.SHORT,
          value: 1,
          offset: 0
        },
        farad: {
          name: "farad",
          base: BASE_UNITS.ELECTRIC_CAPACITANCE,
          prefixes: PREFIXES.LONG,
          value: 1,
          offset: 0
        },
        F: {
          name: "F",
          base: BASE_UNITS.ELECTRIC_CAPACITANCE,
          prefixes: PREFIXES.SHORT,
          value: 1,
          offset: 0
        },
        volt: {
          name: "volt",
          base: BASE_UNITS.ELECTRIC_POTENTIAL,
          prefixes: PREFIXES.LONG,
          value: 1,
          offset: 0
        },
        V: {
          name: "V",
          base: BASE_UNITS.ELECTRIC_POTENTIAL,
          prefixes: PREFIXES.SHORT,
          value: 1,
          offset: 0
        },
        ohm: {
          name: "ohm",
          base: BASE_UNITS.ELECTRIC_RESISTANCE,
          prefixes: PREFIXES.SHORTLONG,
          value: 1,
          offset: 0
        },
        henry: {
          name: "henry",
          base: BASE_UNITS.ELECTRIC_INDUCTANCE,
          prefixes: PREFIXES.LONG,
          value: 1,
          offset: 0
        },
        H: {
          name: "H",
          base: BASE_UNITS.ELECTRIC_INDUCTANCE,
          prefixes: PREFIXES.SHORT,
          value: 1,
          offset: 0
        },
        siemens: {
          name: "siemens",
          base: BASE_UNITS.ELECTRIC_CONDUCTANCE,
          prefixes: PREFIXES.LONG,
          value: 1,
          offset: 0
        },
        S: {
          name: "S",
          base: BASE_UNITS.ELECTRIC_CONDUCTANCE,
          prefixes: PREFIXES.SHORT,
          value: 1,
          offset: 0
        },
        weber: {
          name: "weber",
          base: BASE_UNITS.MAGNETIC_FLUX,
          prefixes: PREFIXES.LONG,
          value: 1,
          offset: 0
        },
        Wb: {
          name: "Wb",
          base: BASE_UNITS.MAGNETIC_FLUX,
          prefixes: PREFIXES.SHORT,
          value: 1,
          offset: 0
        },
        tesla: {
          name: "tesla",
          base: BASE_UNITS.MAGNETIC_FLUX_DENSITY,
          prefixes: PREFIXES.LONG,
          value: 1,
          offset: 0
        },
        T: {
          name: "T",
          base: BASE_UNITS.MAGNETIC_FLUX_DENSITY,
          prefixes: PREFIXES.SHORT,
          value: 1,
          offset: 0
        },
        b: {
          name: "b",
          base: BASE_UNITS.BIT,
          prefixes: PREFIXES.BINARY_SHORT,
          value: 1,
          offset: 0
        },
        bits: {
          name: "bits",
          base: BASE_UNITS.BIT,
          prefixes: PREFIXES.BINARY_LONG,
          value: 1,
          offset: 0
        },
        B: {
          name: "B",
          base: BASE_UNITS.BIT,
          prefixes: PREFIXES.BINARY_SHORT,
          value: 8,
          offset: 0
        },
        bytes: {
          name: "bytes",
          base: BASE_UNITS.BIT,
          prefixes: PREFIXES.BINARY_LONG,
          value: 8,
          offset: 0
        }
      };
      var ALIASES = {
        meters: "meter",
        inches: "inch",
        feet: "foot",
        yards: "yard",
        miles: "mile",
        links: "link",
        rods: "rod",
        chains: "chain",
        angstroms: "angstrom",
        lt: "l",
        litres: "litre",
        liter: "litre",
        liters: "litre",
        teaspoons: "teaspoon",
        tablespoons: "tablespoon",
        minims: "minim",
        fluiddrams: "fluiddram",
        fluidounces: "fluidounce",
        gills: "gill",
        cups: "cup",
        pints: "pint",
        quarts: "quart",
        gallons: "gallon",
        beerbarrels: "beerbarrel",
        oilbarrels: "oilbarrel",
        hogsheads: "hogshead",
        gtts: "gtt",
        grams: "gram",
        tons: "ton",
        tonnes: "tonne",
        grains: "grain",
        drams: "dram",
        ounces: "ounce",
        poundmasses: "poundmass",
        hundredweights: "hundredweight",
        sticks: "stick",
        lb: "lbm",
        lbs: "lbm",
        kips: "kip",
        kgf: "kilogramforce",
        acres: "acre",
        hectares: "hectare",
        sqfeet: "sqft",
        sqyard: "sqyd",
        sqmile: "sqmi",
        sqmiles: "sqmi",
        mmhg: "mmHg",
        mmh2o: "mmH2O",
        cmh2o: "cmH2O",
        seconds: "second",
        secs: "second",
        minutes: "minute",
        mins: "minute",
        hours: "hour",
        hr: "hour",
        hrs: "hour",
        days: "day",
        weeks: "week",
        months: "month",
        years: "year",
        decades: "decade",
        centuries: "century",
        millennia: "millennium",
        hertz: "hertz",
        radians: "radian",
        degrees: "degree",
        gradians: "gradian",
        cycles: "cycle",
        arcsecond: "arcsec",
        arcseconds: "arcsec",
        arcminute: "arcmin",
        arcminutes: "arcmin",
        BTUs: "BTU",
        watts: "watt",
        joules: "joule",
        amperes: "ampere",
        coulombs: "coulomb",
        volts: "volt",
        ohms: "ohm",
        farads: "farad",
        webers: "weber",
        teslas: "tesla",
        electronvolts: "electronvolt",
        moles: "mole",
        bit: "bits",
        byte: "bytes"
      };
      function calculateAngleValues(config4) {
        if (config4.number === "BigNumber") {
          var pi3 = createBigNumberPi(_BigNumber);
          UNITS.rad.value = new _BigNumber(1);
          UNITS.deg.value = pi3.div(180);
          UNITS.grad.value = pi3.div(200);
          UNITS.cycle.value = pi3.times(2);
          UNITS.arcsec.value = pi3.div(648e3);
          UNITS.arcmin.value = pi3.div(10800);
        } else {
          UNITS.rad.value = 1;
          UNITS.deg.value = Math.PI / 180;
          UNITS.grad.value = Math.PI / 200;
          UNITS.cycle.value = Math.PI * 2;
          UNITS.arcsec.value = Math.PI / 648e3;
          UNITS.arcmin.value = Math.PI / 10800;
        }
        UNITS.radian.value = UNITS.rad.value;
        UNITS.degree.value = UNITS.deg.value;
        UNITS.gradian.value = UNITS.grad.value;
      }
      calculateAngleValues(config3);
      if (on) {
        on("config", function(curr, prev) {
          if (curr.number !== prev.number) {
            calculateAngleValues(curr);
          }
        });
      }
      var UNIT_SYSTEMS = {
        si: {
          NONE: {
            unit: UNIT_NONE,
            prefix: PREFIXES.NONE[""]
          },
          LENGTH: {
            unit: UNITS.m,
            prefix: PREFIXES.SHORT[""]
          },
          MASS: {
            unit: UNITS.g,
            prefix: PREFIXES.SHORT.k
          },
          TIME: {
            unit: UNITS.s,
            prefix: PREFIXES.SHORT[""]
          },
          CURRENT: {
            unit: UNITS.A,
            prefix: PREFIXES.SHORT[""]
          },
          TEMPERATURE: {
            unit: UNITS.K,
            prefix: PREFIXES.SHORT[""]
          },
          LUMINOUS_INTENSITY: {
            unit: UNITS.cd,
            prefix: PREFIXES.SHORT[""]
          },
          AMOUNT_OF_SUBSTANCE: {
            unit: UNITS.mol,
            prefix: PREFIXES.SHORT[""]
          },
          ANGLE: {
            unit: UNITS.rad,
            prefix: PREFIXES.SHORT[""]
          },
          BIT: {
            unit: UNITS.bits,
            prefix: PREFIXES.SHORT[""]
          },
          FORCE: {
            unit: UNITS.N,
            prefix: PREFIXES.SHORT[""]
          },
          ENERGY: {
            unit: UNITS.J,
            prefix: PREFIXES.SHORT[""]
          },
          POWER: {
            unit: UNITS.W,
            prefix: PREFIXES.SHORT[""]
          },
          PRESSURE: {
            unit: UNITS.Pa,
            prefix: PREFIXES.SHORT[""]
          },
          ELECTRIC_CHARGE: {
            unit: UNITS.C,
            prefix: PREFIXES.SHORT[""]
          },
          ELECTRIC_CAPACITANCE: {
            unit: UNITS.F,
            prefix: PREFIXES.SHORT[""]
          },
          ELECTRIC_POTENTIAL: {
            unit: UNITS.V,
            prefix: PREFIXES.SHORT[""]
          },
          ELECTRIC_RESISTANCE: {
            unit: UNITS.ohm,
            prefix: PREFIXES.SHORT[""]
          },
          ELECTRIC_INDUCTANCE: {
            unit: UNITS.H,
            prefix: PREFIXES.SHORT[""]
          },
          ELECTRIC_CONDUCTANCE: {
            unit: UNITS.S,
            prefix: PREFIXES.SHORT[""]
          },
          MAGNETIC_FLUX: {
            unit: UNITS.Wb,
            prefix: PREFIXES.SHORT[""]
          },
          MAGNETIC_FLUX_DENSITY: {
            unit: UNITS.T,
            prefix: PREFIXES.SHORT[""]
          },
          FREQUENCY: {
            unit: UNITS.Hz,
            prefix: PREFIXES.SHORT[""]
          }
        }
      };
      UNIT_SYSTEMS.cgs = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
      UNIT_SYSTEMS.cgs.LENGTH = {
        unit: UNITS.m,
        prefix: PREFIXES.SHORT.c
      };
      UNIT_SYSTEMS.cgs.MASS = {
        unit: UNITS.g,
        prefix: PREFIXES.SHORT[""]
      };
      UNIT_SYSTEMS.cgs.FORCE = {
        unit: UNITS.dyn,
        prefix: PREFIXES.SHORT[""]
      };
      UNIT_SYSTEMS.cgs.ENERGY = {
        unit: UNITS.erg,
        prefix: PREFIXES.NONE[""]
      };
      UNIT_SYSTEMS.us = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
      UNIT_SYSTEMS.us.LENGTH = {
        unit: UNITS.ft,
        prefix: PREFIXES.NONE[""]
      };
      UNIT_SYSTEMS.us.MASS = {
        unit: UNITS.lbm,
        prefix: PREFIXES.NONE[""]
      };
      UNIT_SYSTEMS.us.TEMPERATURE = {
        unit: UNITS.degF,
        prefix: PREFIXES.NONE[""]
      };
      UNIT_SYSTEMS.us.FORCE = {
        unit: UNITS.lbf,
        prefix: PREFIXES.NONE[""]
      };
      UNIT_SYSTEMS.us.ENERGY = {
        unit: UNITS.BTU,
        prefix: PREFIXES.BTU[""]
      };
      UNIT_SYSTEMS.us.POWER = {
        unit: UNITS.hp,
        prefix: PREFIXES.NONE[""]
      };
      UNIT_SYSTEMS.us.PRESSURE = {
        unit: UNITS.psi,
        prefix: PREFIXES.NONE[""]
      };
      UNIT_SYSTEMS.auto = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
      var currentUnitSystem = UNIT_SYSTEMS.auto;
      Unit2.setUnitSystem = function(name296) {
        if (hasOwnProperty2(UNIT_SYSTEMS, name296)) {
          currentUnitSystem = UNIT_SYSTEMS[name296];
        } else {
          throw new Error("Unit system " + name296 + " does not exist. Choices are: " + Object.keys(UNIT_SYSTEMS).join(", "));
        }
      };
      Unit2.getUnitSystem = function() {
        for (var _key in UNIT_SYSTEMS) {
          if (hasOwnProperty2(UNIT_SYSTEMS, _key)) {
            if (UNIT_SYSTEMS[_key] === currentUnitSystem) {
              return _key;
            }
          }
        }
      };
      Unit2.typeConverters = {
        BigNumber: function BigNumber2(x) {
          return new _BigNumber(x + "");
        },
        Fraction: function Fraction3(x) {
          return new _Fraction(x);
        },
        Complex: function Complex4(x) {
          return x;
        },
        number: function number3(x) {
          return x;
        }
      };
      Unit2._getNumberConverter = function(type) {
        if (!Unit2.typeConverters[type]) {
          throw new TypeError('Unsupported type "' + type + '"');
        }
        return Unit2.typeConverters[type];
      };
      for (var _key2 in UNITS) {
        if (hasOwnProperty2(UNITS, _key2)) {
          var unit2 = UNITS[_key2];
          unit2.dimensions = unit2.base.dimensions;
        }
      }
      for (var _name2 in ALIASES) {
        if (hasOwnProperty2(ALIASES, _name2)) {
          var _unit2 = UNITS[ALIASES[_name2]];
          var alias = {};
          for (var _key3 in _unit2) {
            if (hasOwnProperty2(_unit2, _key3)) {
              alias[_key3] = _unit2[_key3];
            }
          }
          alias.name = _name2;
          UNITS[_name2] = alias;
        }
      }
      Unit2.isValidAlpha = function isValidAlpha(c2) {
        return /^[a-zA-Z]$/.test(c2);
      };
      function assertUnitNameIsValid(name296) {
        for (var i2 = 0; i2 < name296.length; i2++) {
          c = name296.charAt(i2);
          if (i2 === 0 && !Unit2.isValidAlpha(c)) {
            throw new Error('Invalid unit name (must begin with alpha character): "' + name296 + '"');
          }
          if (i2 > 0 && !(Unit2.isValidAlpha(c) || isDigit(c))) {
            throw new Error('Invalid unit name (only alphanumeric characters are allowed): "' + name296 + '"');
          }
        }
      }
      Unit2.createUnit = function(obj, options) {
        if (typeof obj !== "object") {
          throw new TypeError("createUnit expects first parameter to be of type 'Object'");
        }
        if (options && options.override) {
          for (var _key4 in obj) {
            if (hasOwnProperty2(obj, _key4)) {
              Unit2.deleteUnit(_key4);
            }
            if (obj[_key4].aliases) {
              for (var i2 = 0; i2 < obj[_key4].aliases.length; i2++) {
                Unit2.deleteUnit(obj[_key4].aliases[i2]);
              }
            }
          }
        }
        var lastUnit;
        for (var _key5 in obj) {
          if (hasOwnProperty2(obj, _key5)) {
            lastUnit = Unit2.createUnitSingle(_key5, obj[_key5]);
          }
        }
        return lastUnit;
      };
      Unit2.createUnitSingle = function(name296, obj, options) {
        if (typeof obj === "undefined" || obj === null) {
          obj = {};
        }
        if (typeof name296 !== "string") {
          throw new TypeError("createUnitSingle expects first parameter to be of type 'string'");
        }
        if (hasOwnProperty2(UNITS, name296)) {
          throw new Error('Cannot create unit "' + name296 + '": a unit with that name already exists');
        }
        assertUnitNameIsValid(name296);
        var defUnit = null;
        var aliases = [];
        var offset = 0;
        var definition;
        var prefixes;
        var baseName;
        if (obj && obj.type === "Unit") {
          defUnit = obj.clone();
        } else if (typeof obj === "string") {
          if (obj !== "") {
            definition = obj;
          }
        } else if (typeof obj === "object") {
          definition = obj.definition;
          prefixes = obj.prefixes;
          offset = obj.offset;
          baseName = obj.baseName;
          if (obj.aliases) {
            aliases = obj.aliases.valueOf();
          }
        } else {
          throw new TypeError('Cannot create unit "' + name296 + '" from "' + obj.toString() + '": expecting "string" or "Unit" or "Object"');
        }
        if (aliases) {
          for (var i2 = 0; i2 < aliases.length; i2++) {
            if (hasOwnProperty2(UNITS, aliases[i2])) {
              throw new Error('Cannot create alias "' + aliases[i2] + '": a unit with that name already exists');
            }
          }
        }
        if (definition && typeof definition === "string" && !defUnit) {
          try {
            defUnit = Unit2.parse(definition, {
              allowNoUnits: true
            });
          } catch (ex) {
            ex.message = 'Could not create unit "' + name296 + '" from "' + definition + '": ' + ex.message;
            throw ex;
          }
        } else if (definition && definition.type === "Unit") {
          defUnit = definition.clone();
        }
        aliases = aliases || [];
        offset = offset || 0;
        if (prefixes && prefixes.toUpperCase) {
          prefixes = PREFIXES[prefixes.toUpperCase()] || PREFIXES.NONE;
        } else {
          prefixes = PREFIXES.NONE;
        }
        var newUnit = {};
        if (!defUnit) {
          baseName = baseName || name296 + "_STUFF";
          if (BASE_DIMENSIONS.indexOf(baseName) >= 0) {
            throw new Error('Cannot create new base unit "' + name296 + '": a base unit with that name already exists (and cannot be overridden)');
          }
          BASE_DIMENSIONS.push(baseName);
          for (var b in BASE_UNITS) {
            if (hasOwnProperty2(BASE_UNITS, b)) {
              BASE_UNITS[b].dimensions[BASE_DIMENSIONS.length - 1] = 0;
            }
          }
          var newBaseUnit = {
            dimensions: []
          };
          for (var _i6 = 0; _i6 < BASE_DIMENSIONS.length; _i6++) {
            newBaseUnit.dimensions[_i6] = 0;
          }
          newBaseUnit.dimensions[BASE_DIMENSIONS.length - 1] = 1;
          newBaseUnit.key = baseName;
          BASE_UNITS[baseName] = newBaseUnit;
          newUnit = {
            name: name296,
            value: 1,
            dimensions: BASE_UNITS[baseName].dimensions.slice(0),
            prefixes,
            offset,
            base: BASE_UNITS[baseName]
          };
          currentUnitSystem[baseName] = {
            unit: newUnit,
            prefix: PREFIXES.NONE[""]
          };
        } else {
          newUnit = {
            name: name296,
            value: defUnit.value,
            dimensions: defUnit.dimensions.slice(0),
            prefixes,
            offset
          };
          var anyMatch = false;
          for (var _i7 in BASE_UNITS) {
            if (hasOwnProperty2(BASE_UNITS, _i7)) {
              var match = true;
              for (var j = 0; j < BASE_DIMENSIONS.length; j++) {
                if (Math.abs((newUnit.dimensions[j] || 0) - (BASE_UNITS[_i7].dimensions[j] || 0)) > 1e-12) {
                  match = false;
                  break;
                }
              }
              if (match) {
                anyMatch = true;
                newUnit.base = BASE_UNITS[_i7];
                break;
              }
            }
          }
          if (!anyMatch) {
            baseName = baseName || name296 + "_STUFF";
            var _newBaseUnit = {
              dimensions: defUnit.dimensions.slice(0)
            };
            _newBaseUnit.key = baseName;
            BASE_UNITS[baseName] = _newBaseUnit;
            currentUnitSystem[baseName] = {
              unit: newUnit,
              prefix: PREFIXES.NONE[""]
            };
            newUnit.base = BASE_UNITS[baseName];
          }
        }
        Unit2.UNITS[name296] = newUnit;
        for (var _i8 = 0; _i8 < aliases.length; _i8++) {
          var aliasName = aliases[_i8];
          var _alias = {};
          for (var _key6 in newUnit) {
            if (hasOwnProperty2(newUnit, _key6)) {
              _alias[_key6] = newUnit[_key6];
            }
          }
          _alias.name = aliasName;
          Unit2.UNITS[aliasName] = _alias;
        }
        delete _findUnit.cache;
        return new Unit2(null, name296);
      };
      Unit2.deleteUnit = function(name296) {
        delete Unit2.UNITS[name296];
      };
      Unit2.PREFIXES = PREFIXES;
      Unit2.BASE_DIMENSIONS = BASE_DIMENSIONS;
      Unit2.BASE_UNITS = BASE_UNITS;
      Unit2.UNIT_SYSTEMS = UNIT_SYSTEMS;
      Unit2.UNITS = UNITS;
      return Unit2;
    }, {
      isClass: true
    });
  }
});

// node_modules/mathjs/lib/esm/type/unit/function/unit.js
var name157, dependencies158, createUnitFunction;
var init_unit = __esm({
  "node_modules/mathjs/lib/esm/type/unit/function/unit.js"() {
    init_factory();
    init_collection();
    name157 = "unit";
    dependencies158 = ["typed", "Unit"];
    createUnitFunction = /* @__PURE__ */ factory(name157, dependencies158, (_ref) => {
      var {
        typed: typed2,
        Unit: Unit2
      } = _ref;
      return typed2(name157, {
        Unit: function Unit3(x) {
          return x.clone();
        },
        string: function string2(x) {
          if (Unit2.isValuelessUnit(x)) {
            return new Unit2(null, x);
          }
          return Unit2.parse(x, {
            allowNoUnits: true
          });
        },
        "number | BigNumber | Fraction | Complex, string": function numberBigNumberFractionComplexString(value, unit2) {
          return new Unit2(value, unit2);
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/type/matrix/function/sparse.js
var name158, dependencies159, createSparse;
var init_sparse = __esm({
  "node_modules/mathjs/lib/esm/type/matrix/function/sparse.js"() {
    init_factory();
    name158 = "sparse";
    dependencies159 = ["typed", "SparseMatrix"];
    createSparse = /* @__PURE__ */ factory(name158, dependencies159, (_ref) => {
      var {
        typed: typed2,
        SparseMatrix: SparseMatrix2
      } = _ref;
      return typed2(name158, {
        "": function _() {
          return new SparseMatrix2([]);
        },
        string: function string2(datatype) {
          return new SparseMatrix2([], datatype);
        },
        "Array | Matrix": function ArrayMatrix(data) {
          return new SparseMatrix2(data);
        },
        "Array | Matrix, string": function ArrayMatrixString(data, datatype) {
          return new SparseMatrix2(data, datatype);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/type/unit/function/createUnit.js
var name159, dependencies160, createCreateUnit;
var init_createUnit = __esm({
  "node_modules/mathjs/lib/esm/type/unit/function/createUnit.js"() {
    init_factory();
    name159 = "createUnit";
    dependencies160 = ["typed", "Unit"];
    createCreateUnit = /* @__PURE__ */ factory(name159, dependencies160, (_ref) => {
      var {
        typed: typed2,
        Unit: Unit2
      } = _ref;
      return typed2(name159, {
        "Object, Object": function ObjectObject(obj, options) {
          return Unit2.createUnit(obj, options);
        },
        Object: function Object2(obj) {
          return Unit2.createUnit(obj, {});
        },
        "string, Unit | string | Object, Object": function stringUnitStringObjectObject(name296, def, options) {
          var obj = {};
          obj[name296] = def;
          return Unit2.createUnit(obj, options);
        },
        "string, Unit | string | Object": function stringUnitStringObject(name296, def) {
          var obj = {};
          obj[name296] = def;
          return Unit2.createUnit(obj, {});
        },
        string: function string2(name296) {
          var obj = {};
          obj[name296] = {};
          return Unit2.createUnit(obj, {});
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/trigonometry/acos.js
var name160, dependencies161, createAcos;
var init_acos = __esm({
  "node_modules/mathjs/lib/esm/function/trigonometry/acos.js"() {
    init_factory();
    init_collection();
    name160 = "acos";
    dependencies161 = ["typed", "config", "Complex"];
    createAcos = /* @__PURE__ */ factory(name160, dependencies161, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        Complex: Complex3
      } = _ref;
      return typed2(name160, {
        number: function number2(x) {
          if (x >= -1 && x <= 1 || config3.predictable) {
            return Math.acos(x);
          } else {
            return new Complex3(x, 0).acos();
          }
        },
        Complex: function Complex4(x) {
          return x.acos();
        },
        BigNumber: function BigNumber2(x) {
          return x.acos();
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/trigonometry/acosh.js
var name161, dependencies162, createAcosh;
var init_acosh = __esm({
  "node_modules/mathjs/lib/esm/function/trigonometry/acosh.js"() {
    init_factory();
    init_collection();
    init_number2();
    name161 = "acosh";
    dependencies162 = ["typed", "config", "Complex"];
    createAcosh = /* @__PURE__ */ factory(name161, dependencies162, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        Complex: Complex3
      } = _ref;
      return typed2(name161, {
        number: function number2(x) {
          if (x >= 1 || config3.predictable) {
            return acoshNumber(x);
          }
          if (x <= -1) {
            return new Complex3(Math.log(Math.sqrt(x * x - 1) - x), Math.PI);
          }
          return new Complex3(x, 0).acosh();
        },
        Complex: function Complex4(x) {
          return x.acosh();
        },
        BigNumber: function BigNumber2(x) {
          return x.acosh();
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/trigonometry/acot.js
var name162, dependencies163, createAcot;
var init_acot = __esm({
  "node_modules/mathjs/lib/esm/function/trigonometry/acot.js"() {
    init_factory();
    init_collection();
    init_number2();
    name162 = "acot";
    dependencies163 = ["typed", "BigNumber"];
    createAcot = /* @__PURE__ */ factory(name162, dependencies163, (_ref) => {
      var {
        typed: typed2,
        BigNumber: _BigNumber
      } = _ref;
      return typed2(name162, {
        number: acotNumber,
        Complex: function Complex3(x) {
          return x.acot();
        },
        BigNumber: function BigNumber2(x) {
          return new _BigNumber(1).div(x).atan();
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/trigonometry/acoth.js
var name163, dependencies164, createAcoth;
var init_acoth = __esm({
  "node_modules/mathjs/lib/esm/function/trigonometry/acoth.js"() {
    init_factory();
    init_collection();
    init_number2();
    name163 = "acoth";
    dependencies164 = ["typed", "config", "Complex", "BigNumber"];
    createAcoth = /* @__PURE__ */ factory(name163, dependencies164, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        Complex: Complex3,
        BigNumber: _BigNumber
      } = _ref;
      return typed2(name163, {
        number: function number2(x) {
          if (x >= 1 || x <= -1 || config3.predictable) {
            return acothNumber(x);
          }
          return new Complex3(x, 0).acoth();
        },
        Complex: function Complex4(x) {
          return x.acoth();
        },
        BigNumber: function BigNumber2(x) {
          return new _BigNumber(1).div(x).atanh();
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/trigonometry/acsc.js
var name164, dependencies165, createAcsc;
var init_acsc = __esm({
  "node_modules/mathjs/lib/esm/function/trigonometry/acsc.js"() {
    init_factory();
    init_collection();
    init_number2();
    name164 = "acsc";
    dependencies165 = ["typed", "config", "Complex", "BigNumber"];
    createAcsc = /* @__PURE__ */ factory(name164, dependencies165, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        Complex: Complex3,
        BigNumber: _BigNumber
      } = _ref;
      return typed2(name164, {
        number: function number2(x) {
          if (x <= -1 || x >= 1 || config3.predictable) {
            return acscNumber(x);
          }
          return new Complex3(x, 0).acsc();
        },
        Complex: function Complex4(x) {
          return x.acsc();
        },
        BigNumber: function BigNumber2(x) {
          return new _BigNumber(1).div(x).asin();
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/trigonometry/acsch.js
var name165, dependencies166, createAcsch;
var init_acsch = __esm({
  "node_modules/mathjs/lib/esm/function/trigonometry/acsch.js"() {
    init_factory();
    init_collection();
    init_number2();
    name165 = "acsch";
    dependencies166 = ["typed", "BigNumber"];
    createAcsch = /* @__PURE__ */ factory(name165, dependencies166, (_ref) => {
      var {
        typed: typed2,
        BigNumber: _BigNumber
      } = _ref;
      return typed2(name165, {
        number: acschNumber,
        Complex: function Complex3(x) {
          return x.acsch();
        },
        BigNumber: function BigNumber2(x) {
          return new _BigNumber(1).div(x).asinh();
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/trigonometry/asec.js
var name166, dependencies167, createAsec;
var init_asec = __esm({
  "node_modules/mathjs/lib/esm/function/trigonometry/asec.js"() {
    init_factory();
    init_collection();
    init_number2();
    name166 = "asec";
    dependencies167 = ["typed", "config", "Complex", "BigNumber"];
    createAsec = /* @__PURE__ */ factory(name166, dependencies167, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        Complex: Complex3,
        BigNumber: _BigNumber
      } = _ref;
      return typed2(name166, {
        number: function number2(x) {
          if (x <= -1 || x >= 1 || config3.predictable) {
            return asecNumber(x);
          }
          return new Complex3(x, 0).asec();
        },
        Complex: function Complex4(x) {
          return x.asec();
        },
        BigNumber: function BigNumber2(x) {
          return new _BigNumber(1).div(x).acos();
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/trigonometry/asech.js
var name167, dependencies168, createAsech;
var init_asech = __esm({
  "node_modules/mathjs/lib/esm/function/trigonometry/asech.js"() {
    init_factory();
    init_collection();
    init_number2();
    name167 = "asech";
    dependencies168 = ["typed", "config", "Complex", "BigNumber"];
    createAsech = /* @__PURE__ */ factory(name167, dependencies168, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        Complex: Complex3,
        BigNumber: _BigNumber
      } = _ref;
      return typed2(name167, {
        number: function number2(x) {
          if (x <= 1 && x >= -1 || config3.predictable) {
            var xInv = 1 / x;
            if (xInv > 0 || config3.predictable) {
              return asechNumber(x);
            }
            var ret = Math.sqrt(xInv * xInv - 1);
            return new Complex3(Math.log(ret - xInv), Math.PI);
          }
          return new Complex3(x, 0).asech();
        },
        Complex: function Complex4(x) {
          return x.asech();
        },
        BigNumber: function BigNumber2(x) {
          return new _BigNumber(1).div(x).acosh();
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/trigonometry/asin.js
var name168, dependencies169, createAsin;
var init_asin = __esm({
  "node_modules/mathjs/lib/esm/function/trigonometry/asin.js"() {
    init_factory();
    init_collection();
    name168 = "asin";
    dependencies169 = ["typed", "config", "Complex"];
    createAsin = /* @__PURE__ */ factory(name168, dependencies169, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        Complex: Complex3
      } = _ref;
      return typed2(name168, {
        number: function number2(x) {
          if (x >= -1 && x <= 1 || config3.predictable) {
            return Math.asin(x);
          } else {
            return new Complex3(x, 0).asin();
          }
        },
        Complex: function Complex4(x) {
          return x.asin();
        },
        BigNumber: function BigNumber2(x) {
          return x.asin();
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this, true);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/trigonometry/asinh.js
var name169, dependencies170, createAsinh;
var init_asinh = __esm({
  "node_modules/mathjs/lib/esm/function/trigonometry/asinh.js"() {
    init_factory();
    init_collection();
    init_number2();
    name169 = "asinh";
    dependencies170 = ["typed"];
    createAsinh = /* @__PURE__ */ factory(name169, dependencies170, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2("asinh", {
        number: asinhNumber,
        Complex: function Complex3(x) {
          return x.asinh();
        },
        BigNumber: function BigNumber2(x) {
          return x.asinh();
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this, true);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/trigonometry/atan.js
var name170, dependencies171, createAtan;
var init_atan = __esm({
  "node_modules/mathjs/lib/esm/function/trigonometry/atan.js"() {
    init_factory();
    init_collection();
    name170 = "atan";
    dependencies171 = ["typed"];
    createAtan = /* @__PURE__ */ factory(name170, dependencies171, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2("atan", {
        number: function number2(x) {
          return Math.atan(x);
        },
        Complex: function Complex3(x) {
          return x.atan();
        },
        BigNumber: function BigNumber2(x) {
          return x.atan();
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this, true);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/trigonometry/atan2.js
var name171, dependencies172, createAtan2;
var init_atan2 = __esm({
  "node_modules/mathjs/lib/esm/function/trigonometry/atan2.js"() {
    init_factory();
    init_algorithm02();
    init_algorithm03();
    init_algorithm09();
    init_algorithm11();
    init_algorithm12();
    init_algorithm13();
    init_algorithm14();
    name171 = "atan2";
    dependencies172 = ["typed", "matrix", "equalScalar", "BigNumber", "DenseMatrix"];
    createAtan2 = /* @__PURE__ */ factory(name171, dependencies172, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        equalScalar: equalScalar2,
        BigNumber: BigNumber2,
        DenseMatrix: DenseMatrix2
      } = _ref;
      var algorithm02 = createAlgorithm02({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm03 = createAlgorithm03({
        typed: typed2
      });
      var algorithm09 = createAlgorithm09({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm11 = createAlgorithm11({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm12 = createAlgorithm12({
        typed: typed2,
        DenseMatrix: DenseMatrix2
      });
      var algorithm13 = createAlgorithm13({
        typed: typed2
      });
      var algorithm14 = createAlgorithm14({
        typed: typed2
      });
      return typed2(name171, {
        "number, number": Math.atan2,
        "BigNumber, BigNumber": function BigNumberBigNumber(y, x) {
          return BigNumber2.atan2(y, x);
        },
        "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
          return algorithm09(x, y, this, false);
        },
        "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
          return algorithm02(y, x, this, true);
        },
        "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
          return algorithm03(x, y, this, false);
        },
        "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
          return algorithm13(x, y, this);
        },
        "Array, Array": function ArrayArray(x, y) {
          return this(matrix2(x), matrix2(y)).valueOf();
        },
        "Array, Matrix": function ArrayMatrix(x, y) {
          return this(matrix2(x), y);
        },
        "Matrix, Array": function MatrixArray(x, y) {
          return this(x, matrix2(y));
        },
        "SparseMatrix, number | BigNumber": function SparseMatrixNumberBigNumber(x, y) {
          return algorithm11(x, y, this, false);
        },
        "DenseMatrix, number | BigNumber": function DenseMatrixNumberBigNumber(x, y) {
          return algorithm14(x, y, this, false);
        },
        "number | BigNumber, SparseMatrix": function numberBigNumberSparseMatrix(x, y) {
          return algorithm12(y, x, this, true);
        },
        "number | BigNumber, DenseMatrix": function numberBigNumberDenseMatrix(x, y) {
          return algorithm14(y, x, this, true);
        },
        "Array, number | BigNumber": function ArrayNumberBigNumber(x, y) {
          return algorithm14(matrix2(x), y, this, false).valueOf();
        },
        "number | BigNumber, Array": function numberBigNumberArray(x, y) {
          return algorithm14(matrix2(y), x, this, true).valueOf();
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/trigonometry/atanh.js
var name172, dependencies173, createAtanh;
var init_atanh = __esm({
  "node_modules/mathjs/lib/esm/function/trigonometry/atanh.js"() {
    init_factory();
    init_collection();
    init_number2();
    name172 = "atanh";
    dependencies173 = ["typed", "config", "Complex"];
    createAtanh = /* @__PURE__ */ factory(name172, dependencies173, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        Complex: Complex3
      } = _ref;
      return typed2(name172, {
        number: function number2(x) {
          if (x <= 1 && x >= -1 || config3.predictable) {
            return atanhNumber(x);
          }
          return new Complex3(x, 0).atanh();
        },
        Complex: function Complex4(x) {
          return x.atanh();
        },
        BigNumber: function BigNumber2(x) {
          return x.atanh();
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this, true);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/trigonometry/cos.js
var name173, dependencies174, createCos;
var init_cos = __esm({
  "node_modules/mathjs/lib/esm/function/trigonometry/cos.js"() {
    init_factory();
    init_collection();
    name173 = "cos";
    dependencies174 = ["typed"];
    createCos = /* @__PURE__ */ factory(name173, dependencies174, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2(name173, {
        number: Math.cos,
        Complex: function Complex3(x) {
          return x.cos();
        },
        BigNumber: function BigNumber2(x) {
          return x.cos();
        },
        Unit: function Unit2(x) {
          if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
            throw new TypeError("Unit in function cos is no angle");
          }
          return this(x.value);
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/trigonometry/cosh.js
var name174, dependencies175, createCosh;
var init_cosh = __esm({
  "node_modules/mathjs/lib/esm/function/trigonometry/cosh.js"() {
    init_factory();
    init_collection();
    init_number();
    name174 = "cosh";
    dependencies175 = ["typed"];
    createCosh = /* @__PURE__ */ factory(name174, dependencies175, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2(name174, {
        number: cosh,
        Complex: function Complex3(x) {
          return x.cosh();
        },
        BigNumber: function BigNumber2(x) {
          return x.cosh();
        },
        Unit: function Unit2(x) {
          if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
            throw new TypeError("Unit in function cosh is no angle");
          }
          return this(x.value);
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/trigonometry/cot.js
var name175, dependencies176, createCot;
var init_cot = __esm({
  "node_modules/mathjs/lib/esm/function/trigonometry/cot.js"() {
    init_factory();
    init_collection();
    init_number2();
    name175 = "cot";
    dependencies176 = ["typed", "BigNumber"];
    createCot = /* @__PURE__ */ factory(name175, dependencies176, (_ref) => {
      var {
        typed: typed2,
        BigNumber: _BigNumber
      } = _ref;
      return typed2(name175, {
        number: cotNumber,
        Complex: function Complex3(x) {
          return x.cot();
        },
        BigNumber: function BigNumber2(x) {
          return new _BigNumber(1).div(x.tan());
        },
        Unit: function Unit2(x) {
          if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
            throw new TypeError("Unit in function cot is no angle");
          }
          return this(x.value);
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/trigonometry/coth.js
var name176, dependencies177, createCoth;
var init_coth = __esm({
  "node_modules/mathjs/lib/esm/function/trigonometry/coth.js"() {
    init_factory();
    init_collection();
    init_number2();
    name176 = "coth";
    dependencies177 = ["typed", "BigNumber"];
    createCoth = /* @__PURE__ */ factory(name176, dependencies177, (_ref) => {
      var {
        typed: typed2,
        BigNumber: _BigNumber
      } = _ref;
      return typed2(name176, {
        number: cothNumber,
        Complex: function Complex3(x) {
          return x.coth();
        },
        BigNumber: function BigNumber2(x) {
          return new _BigNumber(1).div(x.tanh());
        },
        Unit: function Unit2(x) {
          if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
            throw new TypeError("Unit in function coth is no angle");
          }
          return this(x.value);
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/trigonometry/csc.js
var name177, dependencies178, createCsc;
var init_csc = __esm({
  "node_modules/mathjs/lib/esm/function/trigonometry/csc.js"() {
    init_factory();
    init_collection();
    init_number2();
    name177 = "csc";
    dependencies178 = ["typed", "BigNumber"];
    createCsc = /* @__PURE__ */ factory(name177, dependencies178, (_ref) => {
      var {
        typed: typed2,
        BigNumber: _BigNumber
      } = _ref;
      return typed2(name177, {
        number: cscNumber,
        Complex: function Complex3(x) {
          return x.csc();
        },
        BigNumber: function BigNumber2(x) {
          return new _BigNumber(1).div(x.sin());
        },
        Unit: function Unit2(x) {
          if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
            throw new TypeError("Unit in function csc is no angle");
          }
          return this(x.value);
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/trigonometry/csch.js
var name178, dependencies179, createCsch;
var init_csch = __esm({
  "node_modules/mathjs/lib/esm/function/trigonometry/csch.js"() {
    init_factory();
    init_collection();
    init_number2();
    name178 = "csch";
    dependencies179 = ["typed", "BigNumber"];
    createCsch = /* @__PURE__ */ factory(name178, dependencies179, (_ref) => {
      var {
        typed: typed2,
        BigNumber: _BigNumber
      } = _ref;
      return typed2(name178, {
        number: cschNumber,
        Complex: function Complex3(x) {
          return x.csch();
        },
        BigNumber: function BigNumber2(x) {
          return new _BigNumber(1).div(x.sinh());
        },
        Unit: function Unit2(x) {
          if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
            throw new TypeError("Unit in function csch is no angle");
          }
          return this(x.value);
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/trigonometry/sec.js
var name179, dependencies180, createSec;
var init_sec = __esm({
  "node_modules/mathjs/lib/esm/function/trigonometry/sec.js"() {
    init_factory();
    init_collection();
    init_number2();
    name179 = "sec";
    dependencies180 = ["typed", "BigNumber"];
    createSec = /* @__PURE__ */ factory(name179, dependencies180, (_ref) => {
      var {
        typed: typed2,
        BigNumber: _BigNumber
      } = _ref;
      return typed2(name179, {
        number: secNumber,
        Complex: function Complex3(x) {
          return x.sec();
        },
        BigNumber: function BigNumber2(x) {
          return new _BigNumber(1).div(x.cos());
        },
        Unit: function Unit2(x) {
          if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
            throw new TypeError("Unit in function sec is no angle");
          }
          return this(x.value);
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/trigonometry/sech.js
var name180, dependencies181, createSech;
var init_sech = __esm({
  "node_modules/mathjs/lib/esm/function/trigonometry/sech.js"() {
    init_factory();
    init_collection();
    init_number2();
    name180 = "sech";
    dependencies181 = ["typed", "BigNumber"];
    createSech = /* @__PURE__ */ factory(name180, dependencies181, (_ref) => {
      var {
        typed: typed2,
        BigNumber: _BigNumber
      } = _ref;
      return typed2(name180, {
        number: sechNumber,
        Complex: function Complex3(x) {
          return x.sech();
        },
        BigNumber: function BigNumber2(x) {
          return new _BigNumber(1).div(x.cosh());
        },
        Unit: function Unit2(x) {
          if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
            throw new TypeError("Unit in function sech is no angle");
          }
          return this(x.value);
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/trigonometry/sin.js
var name181, dependencies182, createSin;
var init_sin = __esm({
  "node_modules/mathjs/lib/esm/function/trigonometry/sin.js"() {
    init_factory();
    init_collection();
    name181 = "sin";
    dependencies182 = ["typed"];
    createSin = /* @__PURE__ */ factory(name181, dependencies182, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2(name181, {
        number: Math.sin,
        Complex: function Complex3(x) {
          return x.sin();
        },
        BigNumber: function BigNumber2(x) {
          return x.sin();
        },
        Unit: function Unit2(x) {
          if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
            throw new TypeError("Unit in function sin is no angle");
          }
          return this(x.value);
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this, true);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/trigonometry/sinh.js
var name182, dependencies183, createSinh;
var init_sinh = __esm({
  "node_modules/mathjs/lib/esm/function/trigonometry/sinh.js"() {
    init_factory();
    init_collection();
    init_number2();
    name182 = "sinh";
    dependencies183 = ["typed"];
    createSinh = /* @__PURE__ */ factory(name182, dependencies183, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2(name182, {
        number: sinhNumber,
        Complex: function Complex3(x) {
          return x.sinh();
        },
        BigNumber: function BigNumber2(x) {
          return x.sinh();
        },
        Unit: function Unit2(x) {
          if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
            throw new TypeError("Unit in function sinh is no angle");
          }
          return this(x.value);
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this, true);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/trigonometry/tan.js
var name183, dependencies184, createTan;
var init_tan = __esm({
  "node_modules/mathjs/lib/esm/function/trigonometry/tan.js"() {
    init_factory();
    init_collection();
    name183 = "tan";
    dependencies184 = ["typed"];
    createTan = /* @__PURE__ */ factory(name183, dependencies184, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2(name183, {
        number: Math.tan,
        Complex: function Complex3(x) {
          return x.tan();
        },
        BigNumber: function BigNumber2(x) {
          return x.tan();
        },
        Unit: function Unit2(x) {
          if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
            throw new TypeError("Unit in function tan is no angle");
          }
          return this(x.value);
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this, true);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/trigonometry/tanh.js
var name184, dependencies185, createTanh;
var init_tanh = __esm({
  "node_modules/mathjs/lib/esm/function/trigonometry/tanh.js"() {
    init_factory();
    init_collection();
    init_number();
    name184 = "tanh";
    dependencies185 = ["typed"];
    createTanh = /* @__PURE__ */ factory(name184, dependencies185, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2("tanh", {
        number: tanh,
        Complex: function Complex3(x) {
          return x.tanh();
        },
        BigNumber: function BigNumber2(x) {
          return x.tanh();
        },
        Unit: function Unit2(x) {
          if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
            throw new TypeError("Unit in function tanh is no angle");
          }
          return this(x.value);
        },
        "Array | Matrix": function ArrayMatrix(x) {
          return deepMap(x, this, true);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/set/setCartesian.js
var name185, dependencies186, createSetCartesian;
var init_setCartesian = __esm({
  "node_modules/mathjs/lib/esm/function/set/setCartesian.js"() {
    init_array();
    init_factory();
    name185 = "setCartesian";
    dependencies186 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
    createSetCartesian = /* @__PURE__ */ factory(name185, dependencies186, (_ref) => {
      var {
        typed: typed2,
        size: size2,
        subset: subset2,
        compareNatural: compareNatural2,
        Index: Index2,
        DenseMatrix: DenseMatrix2
      } = _ref;
      return typed2(name185, {
        "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
          var result = [];
          if (subset2(size2(a1), new Index2(0)) !== 0 && subset2(size2(a2), new Index2(0)) !== 0) {
            var b1 = flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural2);
            var b2 = flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural2);
            result = [];
            for (var i2 = 0; i2 < b1.length; i2++) {
              for (var j = 0; j < b2.length; j++) {
                result.push([b1[i2], b2[j]]);
              }
            }
          }
          if (Array.isArray(a1) && Array.isArray(a2)) {
            return result;
          }
          return new DenseMatrix2(result);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/set/setDifference.js
var name186, dependencies187, createSetDifference;
var init_setDifference = __esm({
  "node_modules/mathjs/lib/esm/function/set/setDifference.js"() {
    init_array();
    init_factory();
    name186 = "setDifference";
    dependencies187 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
    createSetDifference = /* @__PURE__ */ factory(name186, dependencies187, (_ref) => {
      var {
        typed: typed2,
        size: size2,
        subset: subset2,
        compareNatural: compareNatural2,
        Index: Index2,
        DenseMatrix: DenseMatrix2
      } = _ref;
      return typed2(name186, {
        "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
          var result;
          if (subset2(size2(a1), new Index2(0)) === 0) {
            result = [];
          } else if (subset2(size2(a2), new Index2(0)) === 0) {
            return flatten(a1.toArray());
          } else {
            var b1 = identify(flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural2));
            var b2 = identify(flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural2));
            result = [];
            var inb2;
            for (var i2 = 0; i2 < b1.length; i2++) {
              inb2 = false;
              for (var j = 0; j < b2.length; j++) {
                if (compareNatural2(b1[i2].value, b2[j].value) === 0 && b1[i2].identifier === b2[j].identifier) {
                  inb2 = true;
                  break;
                }
              }
              if (!inb2) {
                result.push(b1[i2]);
              }
            }
          }
          if (Array.isArray(a1) && Array.isArray(a2)) {
            return generalize(result);
          }
          return new DenseMatrix2(generalize(result));
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/set/setDistinct.js
var name187, dependencies188, createSetDistinct;
var init_setDistinct = __esm({
  "node_modules/mathjs/lib/esm/function/set/setDistinct.js"() {
    init_array();
    init_factory();
    name187 = "setDistinct";
    dependencies188 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
    createSetDistinct = /* @__PURE__ */ factory(name187, dependencies188, (_ref) => {
      var {
        typed: typed2,
        size: size2,
        subset: subset2,
        compareNatural: compareNatural2,
        Index: Index2,
        DenseMatrix: DenseMatrix2
      } = _ref;
      return typed2(name187, {
        "Array | Matrix": function ArrayMatrix(a) {
          var result;
          if (subset2(size2(a), new Index2(0)) === 0) {
            result = [];
          } else {
            var b = flatten(Array.isArray(a) ? a : a.toArray()).sort(compareNatural2);
            result = [];
            result.push(b[0]);
            for (var i2 = 1; i2 < b.length; i2++) {
              if (compareNatural2(b[i2], b[i2 - 1]) !== 0) {
                result.push(b[i2]);
              }
            }
          }
          if (Array.isArray(a)) {
            return result;
          }
          return new DenseMatrix2(result);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/set/setIntersect.js
var name188, dependencies189, createSetIntersect;
var init_setIntersect = __esm({
  "node_modules/mathjs/lib/esm/function/set/setIntersect.js"() {
    init_array();
    init_factory();
    name188 = "setIntersect";
    dependencies189 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
    createSetIntersect = /* @__PURE__ */ factory(name188, dependencies189, (_ref) => {
      var {
        typed: typed2,
        size: size2,
        subset: subset2,
        compareNatural: compareNatural2,
        Index: Index2,
        DenseMatrix: DenseMatrix2
      } = _ref;
      return typed2(name188, {
        "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
          var result;
          if (subset2(size2(a1), new Index2(0)) === 0 || subset2(size2(a2), new Index2(0)) === 0) {
            result = [];
          } else {
            var b1 = identify(flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural2));
            var b2 = identify(flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural2));
            result = [];
            for (var i2 = 0; i2 < b1.length; i2++) {
              for (var j = 0; j < b2.length; j++) {
                if (compareNatural2(b1[i2].value, b2[j].value) === 0 && b1[i2].identifier === b2[j].identifier) {
                  result.push(b1[i2]);
                  break;
                }
              }
            }
          }
          if (Array.isArray(a1) && Array.isArray(a2)) {
            return generalize(result);
          }
          return new DenseMatrix2(generalize(result));
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/set/setIsSubset.js
var name189, dependencies190, createSetIsSubset;
var init_setIsSubset = __esm({
  "node_modules/mathjs/lib/esm/function/set/setIsSubset.js"() {
    init_array();
    init_factory();
    name189 = "setIsSubset";
    dependencies190 = ["typed", "size", "subset", "compareNatural", "Index"];
    createSetIsSubset = /* @__PURE__ */ factory(name189, dependencies190, (_ref) => {
      var {
        typed: typed2,
        size: size2,
        subset: subset2,
        compareNatural: compareNatural2,
        Index: Index2
      } = _ref;
      return typed2(name189, {
        "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
          if (subset2(size2(a1), new Index2(0)) === 0) {
            return true;
          } else if (subset2(size2(a2), new Index2(0)) === 0) {
            return false;
          }
          var b1 = identify(flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural2));
          var b2 = identify(flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural2));
          var inb2;
          for (var i2 = 0; i2 < b1.length; i2++) {
            inb2 = false;
            for (var j = 0; j < b2.length; j++) {
              if (compareNatural2(b1[i2].value, b2[j].value) === 0 && b1[i2].identifier === b2[j].identifier) {
                inb2 = true;
                break;
              }
            }
            if (inb2 === false) {
              return false;
            }
          }
          return true;
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/set/setMultiplicity.js
var name190, dependencies191, createSetMultiplicity;
var init_setMultiplicity = __esm({
  "node_modules/mathjs/lib/esm/function/set/setMultiplicity.js"() {
    init_array();
    init_factory();
    name190 = "setMultiplicity";
    dependencies191 = ["typed", "size", "subset", "compareNatural", "Index"];
    createSetMultiplicity = /* @__PURE__ */ factory(name190, dependencies191, (_ref) => {
      var {
        typed: typed2,
        size: size2,
        subset: subset2,
        compareNatural: compareNatural2,
        Index: Index2
      } = _ref;
      return typed2(name190, {
        "number | BigNumber | Fraction | Complex, Array | Matrix": function numberBigNumberFractionComplexArrayMatrix(e3, a) {
          if (subset2(size2(a), new Index2(0)) === 0) {
            return 0;
          }
          var b = flatten(Array.isArray(a) ? a : a.toArray());
          var count2 = 0;
          for (var i2 = 0; i2 < b.length; i2++) {
            if (compareNatural2(b[i2], e3) === 0) {
              count2++;
            }
          }
          return count2;
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/set/setPowerset.js
var name191, dependencies192, createSetPowerset;
var init_setPowerset = __esm({
  "node_modules/mathjs/lib/esm/function/set/setPowerset.js"() {
    init_array();
    init_factory();
    name191 = "setPowerset";
    dependencies192 = ["typed", "size", "subset", "compareNatural", "Index"];
    createSetPowerset = /* @__PURE__ */ factory(name191, dependencies192, (_ref) => {
      var {
        typed: typed2,
        size: size2,
        subset: subset2,
        compareNatural: compareNatural2,
        Index: Index2
      } = _ref;
      return typed2(name191, {
        "Array | Matrix": function ArrayMatrix(a) {
          if (subset2(size2(a), new Index2(0)) === 0) {
            return [];
          }
          var b = flatten(Array.isArray(a) ? a : a.toArray()).sort(compareNatural2);
          var result = [];
          var number2 = 0;
          while (number2.toString(2).length <= b.length) {
            result.push(_subset(b, number2.toString(2).split("").reverse()));
            number2++;
          }
          return _sort(result);
        }
      });
      function _subset(array, bitarray) {
        var result = [];
        for (var i2 = 0; i2 < bitarray.length; i2++) {
          if (bitarray[i2] === "1") {
            result.push(array[i2]);
          }
        }
        return result;
      }
      function _sort(array) {
        var temp = [];
        for (var i2 = array.length - 1; i2 > 0; i2--) {
          for (var j = 0; j < i2; j++) {
            if (array[j].length > array[j + 1].length) {
              temp = array[j];
              array[j] = array[j + 1];
              array[j + 1] = temp;
            }
          }
        }
        return array;
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/set/setSize.js
var name192, dependencies193, createSetSize;
var init_setSize = __esm({
  "node_modules/mathjs/lib/esm/function/set/setSize.js"() {
    init_array();
    init_factory();
    name192 = "setSize";
    dependencies193 = ["typed", "compareNatural"];
    createSetSize = /* @__PURE__ */ factory(name192, dependencies193, (_ref) => {
      var {
        typed: typed2,
        compareNatural: compareNatural2
      } = _ref;
      return typed2(name192, {
        "Array | Matrix": function ArrayMatrix(a) {
          return Array.isArray(a) ? flatten(a).length : flatten(a.toArray()).length;
        },
        "Array | Matrix, boolean": function ArrayMatrixBoolean(a, unique) {
          if (unique === false || a.length === 0) {
            return Array.isArray(a) ? flatten(a).length : flatten(a.toArray()).length;
          } else {
            var b = flatten(Array.isArray(a) ? a : a.toArray()).sort(compareNatural2);
            var count2 = 1;
            for (var i2 = 1; i2 < b.length; i2++) {
              if (compareNatural2(b[i2], b[i2 - 1]) !== 0) {
                count2++;
              }
            }
            return count2;
          }
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/set/setSymDifference.js
var name193, dependencies194, createSetSymDifference;
var init_setSymDifference = __esm({
  "node_modules/mathjs/lib/esm/function/set/setSymDifference.js"() {
    init_array();
    init_factory();
    name193 = "setSymDifference";
    dependencies194 = ["typed", "size", "concat", "subset", "setDifference", "Index"];
    createSetSymDifference = /* @__PURE__ */ factory(name193, dependencies194, (_ref) => {
      var {
        typed: typed2,
        size: size2,
        concat: concat2,
        subset: subset2,
        setDifference: setDifference2,
        Index: Index2
      } = _ref;
      return typed2(name193, {
        "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
          if (subset2(size2(a1), new Index2(0)) === 0) {
            return flatten(a2);
          } else if (subset2(size2(a2), new Index2(0)) === 0) {
            return flatten(a1);
          }
          var b1 = flatten(a1);
          var b2 = flatten(a2);
          return concat2(setDifference2(b1, b2), setDifference2(b2, b1));
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/set/setUnion.js
var name194, dependencies195, createSetUnion;
var init_setUnion = __esm({
  "node_modules/mathjs/lib/esm/function/set/setUnion.js"() {
    init_array();
    init_factory();
    name194 = "setUnion";
    dependencies195 = ["typed", "size", "concat", "subset", "setIntersect", "setSymDifference", "Index"];
    createSetUnion = /* @__PURE__ */ factory(name194, dependencies195, (_ref) => {
      var {
        typed: typed2,
        size: size2,
        concat: concat2,
        subset: subset2,
        setIntersect: setIntersect2,
        setSymDifference: setSymDifference2,
        Index: Index2
      } = _ref;
      return typed2(name194, {
        "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
          if (subset2(size2(a1), new Index2(0)) === 0) {
            return flatten(a2);
          } else if (subset2(size2(a2), new Index2(0)) === 0) {
            return flatten(a1);
          }
          var b1 = flatten(a1);
          var b2 = flatten(a2);
          return concat2(setSymDifference2(b1, b2), setIntersect2(b1, b2));
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/add.js
var name195, dependencies196, createAdd;
var init_add = __esm({
  "node_modules/mathjs/lib/esm/function/arithmetic/add.js"() {
    init_factory();
    init_object();
    init_algorithm01();
    init_algorithm04();
    init_algorithm10();
    init_algorithm13();
    init_algorithm14();
    name195 = "add";
    dependencies196 = ["typed", "matrix", "addScalar", "equalScalar", "DenseMatrix", "SparseMatrix"];
    createAdd = /* @__PURE__ */ factory(name195, dependencies196, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        addScalar: addScalar2,
        equalScalar: equalScalar2,
        DenseMatrix: DenseMatrix2,
        SparseMatrix: SparseMatrix2
      } = _ref;
      var algorithm01 = createAlgorithm01({
        typed: typed2
      });
      var algorithm04 = createAlgorithm04({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm10 = createAlgorithm10({
        typed: typed2,
        DenseMatrix: DenseMatrix2
      });
      var algorithm13 = createAlgorithm13({
        typed: typed2
      });
      var algorithm14 = createAlgorithm14({
        typed: typed2
      });
      return typed2(name195, extend({
        "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
          return algorithm13(x, y, addScalar2);
        },
        "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
          return algorithm01(x, y, addScalar2, false);
        },
        "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
          return algorithm01(y, x, addScalar2, true);
        },
        "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
          return algorithm04(x, y, addScalar2);
        },
        "Array, Array": function ArrayArray(x, y) {
          return this(matrix2(x), matrix2(y)).valueOf();
        },
        "Array, Matrix": function ArrayMatrix(x, y) {
          return this(matrix2(x), y);
        },
        "Matrix, Array": function MatrixArray(x, y) {
          return this(x, matrix2(y));
        },
        "DenseMatrix, any": function DenseMatrixAny(x, y) {
          return algorithm14(x, y, addScalar2, false);
        },
        "SparseMatrix, any": function SparseMatrixAny(x, y) {
          return algorithm10(x, y, addScalar2, false);
        },
        "any, DenseMatrix": function anyDenseMatrix(x, y) {
          return algorithm14(y, x, addScalar2, true);
        },
        "any, SparseMatrix": function anySparseMatrix(x, y) {
          return algorithm10(y, x, addScalar2, true);
        },
        "Array, any": function ArrayAny(x, y) {
          return algorithm14(matrix2(x), y, addScalar2, false).valueOf();
        },
        "any, Array": function anyArray(x, y) {
          return algorithm14(matrix2(y), x, addScalar2, true).valueOf();
        },
        "any, any": addScalar2,
        "any, any, ...any": function anyAnyAny(x, y, rest) {
          var result = this(x, y);
          for (var i2 = 0; i2 < rest.length; i2++) {
            result = this(result, rest[i2]);
          }
          return result;
        }
      }, addScalar2.signatures));
    });
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/hypot.js
var name196, dependencies197, createHypot;
var init_hypot = __esm({
  "node_modules/mathjs/lib/esm/function/arithmetic/hypot.js"() {
    init_factory();
    init_array();
    name196 = "hypot";
    dependencies197 = ["typed", "abs", "addScalar", "divideScalar", "multiplyScalar", "sqrt", "smaller", "isPositive"];
    createHypot = /* @__PURE__ */ factory(name196, dependencies197, (_ref) => {
      var {
        typed: typed2,
        abs: abs2,
        addScalar: addScalar2,
        divideScalar: divideScalar2,
        multiplyScalar: multiplyScalar2,
        sqrt: sqrt2,
        smaller: smaller2,
        isPositive: isPositive2
      } = _ref;
      return typed2(name196, {
        "... number | BigNumber": _hypot,
        Array: function Array2(x) {
          return this.apply(this, flatten(x));
        },
        Matrix: function Matrix2(x) {
          return this.apply(this, flatten(x.toArray()));
        }
      });
      function _hypot(args) {
        var result = 0;
        var largest = 0;
        for (var i2 = 0; i2 < args.length; i2++) {
          var value = abs2(args[i2]);
          if (smaller2(largest, value)) {
            result = multiplyScalar2(result, multiplyScalar2(divideScalar2(largest, value), divideScalar2(largest, value)));
            result = addScalar2(result, 1);
            largest = value;
          } else {
            result = addScalar2(result, isPositive2(value) ? multiplyScalar2(divideScalar2(value, largest), divideScalar2(value, largest)) : value);
          }
        }
        return multiplyScalar2(largest, sqrt2(result));
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/norm.js
var name197, dependencies198, createNorm;
var init_norm = __esm({
  "node_modules/mathjs/lib/esm/function/arithmetic/norm.js"() {
    init_factory();
    name197 = "norm";
    dependencies198 = ["typed", "abs", "add", "pow", "conj", "sqrt", "multiply", "equalScalar", "larger", "smaller", "matrix", "ctranspose", "eigs"];
    createNorm = /* @__PURE__ */ factory(name197, dependencies198, (_ref) => {
      var {
        typed: typed2,
        abs: abs2,
        add: add2,
        pow: pow2,
        conj: conj2,
        sqrt: sqrt2,
        multiply: multiply2,
        equalScalar: equalScalar2,
        larger: larger2,
        smaller: smaller2,
        matrix: matrix2,
        ctranspose: ctranspose2,
        eigs: eigs2
      } = _ref;
      return typed2(name197, {
        number: Math.abs,
        Complex: function Complex3(x) {
          return x.abs();
        },
        BigNumber: function BigNumber2(x) {
          return x.abs();
        },
        boolean: function boolean2(x) {
          return Math.abs(x);
        },
        Array: function Array2(x) {
          return _norm(matrix2(x), 2);
        },
        Matrix: function Matrix2(x) {
          return _norm(x, 2);
        },
        "number | Complex | BigNumber | boolean, number | BigNumber | string": function numberComplexBigNumberBooleanNumberBigNumberString(x) {
          return this(x);
        },
        "Array, number | BigNumber | string": function ArrayNumberBigNumberString(x, p) {
          return _norm(matrix2(x), p);
        },
        "Matrix, number | BigNumber | string": function MatrixNumberBigNumberString(x, p) {
          return _norm(x, p);
        }
      });
      function _vectorNormPlusInfinity(x) {
        var pinf = 0;
        x.forEach(function(value) {
          var v = abs2(value);
          if (larger2(v, pinf)) {
            pinf = v;
          }
        }, true);
        return pinf;
      }
      function _vectorNormMinusInfinity(x) {
        var ninf;
        x.forEach(function(value) {
          var v = abs2(value);
          if (!ninf || smaller2(v, ninf)) {
            ninf = v;
          }
        }, true);
        return ninf || 0;
      }
      function _vectorNorm(x, p) {
        if (p === Number.POSITIVE_INFINITY || p === "inf") {
          return _vectorNormPlusInfinity(x);
        }
        if (p === Number.NEGATIVE_INFINITY || p === "-inf") {
          return _vectorNormMinusInfinity(x);
        }
        if (p === "fro") {
          return _norm(x, 2);
        }
        if (typeof p === "number" && !isNaN(p)) {
          if (!equalScalar2(p, 0)) {
            var n = 0;
            x.forEach(function(value) {
              n = add2(pow2(abs2(value), p), n);
            }, true);
            return pow2(n, 1 / p);
          }
          return Number.POSITIVE_INFINITY;
        }
        throw new Error("Unsupported parameter value");
      }
      function _matrixNormFrobenius(x) {
        var fro = 0;
        x.forEach(function(value, index2) {
          fro = add2(fro, multiply2(value, conj2(value)));
        });
        return abs2(sqrt2(fro));
      }
      function _matrixNormOne(x) {
        var c = [];
        var maxc = 0;
        x.forEach(function(value, index2) {
          var j = index2[1];
          var cj = add2(c[j] || 0, abs2(value));
          if (larger2(cj, maxc)) {
            maxc = cj;
          }
          c[j] = cj;
        }, true);
        return maxc;
      }
      function _matrixNormTwo(x) {
        var sizeX = x.size();
        if (sizeX[0] !== sizeX[1]) {
          throw new RangeError("Invalid matrix dimensions");
        }
        var tx = ctranspose2(x);
        var squaredX = multiply2(tx, x);
        var eigenVals = eigs2(squaredX).values.toArray();
        var rho = eigenVals[eigenVals.length - 1];
        return abs2(sqrt2(rho));
      }
      function _matrixNormInfinity(x) {
        var r = [];
        var maxr = 0;
        x.forEach(function(value, index2) {
          var i2 = index2[0];
          var ri = add2(r[i2] || 0, abs2(value));
          if (larger2(ri, maxr)) {
            maxr = ri;
          }
          r[i2] = ri;
        }, true);
        return maxr;
      }
      function _matrixNorm(x, p) {
        if (p === 1) {
          return _matrixNormOne(x);
        }
        if (p === Number.POSITIVE_INFINITY || p === "inf") {
          return _matrixNormInfinity(x);
        }
        if (p === "fro") {
          return _matrixNormFrobenius(x);
        }
        if (p === 2) {
          return _matrixNormTwo(x);
        }
        throw new Error("Unsupported parameter value " + p);
      }
      function _norm(x, p) {
        var sizeX = x.size();
        if (sizeX.length === 1) {
          return _vectorNorm(x, p);
        }
        if (sizeX.length === 2) {
          if (sizeX[0] && sizeX[1]) {
            return _matrixNorm(x, p);
          } else {
            throw new RangeError("Invalid matrix dimensions");
          }
        }
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/dot.js
var name198, dependencies199, createDot;
var init_dot = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/dot.js"() {
    init_factory();
    init_is();
    name198 = "dot";
    dependencies199 = ["typed", "addScalar", "multiplyScalar", "conj", "size"];
    createDot = /* @__PURE__ */ factory(name198, dependencies199, (_ref) => {
      var {
        typed: typed2,
        addScalar: addScalar2,
        multiplyScalar: multiplyScalar2,
        conj: conj2,
        size: size2
      } = _ref;
      return typed2(name198, {
        "Array | DenseMatrix, Array | DenseMatrix": _denseDot,
        "SparseMatrix, SparseMatrix": _sparseDot
      });
      function _validateDim(x, y) {
        var xSize = _size(x);
        var ySize = _size(y);
        var xLen, yLen;
        if (xSize.length === 1) {
          xLen = xSize[0];
        } else if (xSize.length === 2 && xSize[1] === 1) {
          xLen = xSize[0];
        } else {
          throw new RangeError("Expected a column vector, instead got a matrix of size (" + xSize.join(", ") + ")");
        }
        if (ySize.length === 1) {
          yLen = ySize[0];
        } else if (ySize.length === 2 && ySize[1] === 1) {
          yLen = ySize[0];
        } else {
          throw new RangeError("Expected a column vector, instead got a matrix of size (" + ySize.join(", ") + ")");
        }
        if (xLen !== yLen)
          throw new RangeError("Vectors must have equal length (" + xLen + " != " + yLen + ")");
        if (xLen === 0)
          throw new RangeError("Cannot calculate the dot product of empty vectors");
        return xLen;
      }
      function _denseDot(a, b) {
        var N = _validateDim(a, b);
        var adata = isMatrix(a) ? a._data : a;
        var adt = isMatrix(a) ? a._datatype : void 0;
        var bdata = isMatrix(b) ? b._data : b;
        var bdt = isMatrix(b) ? b._datatype : void 0;
        var aIsColumn = _size(a).length === 2;
        var bIsColumn = _size(b).length === 2;
        var add2 = addScalar2;
        var mul = multiplyScalar2;
        if (adt && bdt && adt === bdt && typeof adt === "string") {
          var dt = adt;
          add2 = typed2.find(addScalar2, [dt, dt]);
          mul = typed2.find(multiplyScalar2, [dt, dt]);
        }
        if (!aIsColumn && !bIsColumn) {
          var c = mul(conj2(adata[0]), bdata[0]);
          for (var i2 = 1; i2 < N; i2++) {
            c = add2(c, mul(conj2(adata[i2]), bdata[i2]));
          }
          return c;
        }
        if (!aIsColumn && bIsColumn) {
          var _c = mul(conj2(adata[0]), bdata[0][0]);
          for (var _i = 1; _i < N; _i++) {
            _c = add2(_c, mul(conj2(adata[_i]), bdata[_i][0]));
          }
          return _c;
        }
        if (aIsColumn && !bIsColumn) {
          var _c2 = mul(conj2(adata[0][0]), bdata[0]);
          for (var _i2 = 1; _i2 < N; _i2++) {
            _c2 = add2(_c2, mul(conj2(adata[_i2][0]), bdata[_i2]));
          }
          return _c2;
        }
        if (aIsColumn && bIsColumn) {
          var _c3 = mul(conj2(adata[0][0]), bdata[0][0]);
          for (var _i3 = 1; _i3 < N; _i3++) {
            _c3 = add2(_c3, mul(conj2(adata[_i3][0]), bdata[_i3][0]));
          }
          return _c3;
        }
      }
      function _sparseDot(x, y) {
        _validateDim(x, y);
        var xindex = x._index;
        var xvalues = x._values;
        var yindex = y._index;
        var yvalues = y._values;
        var c = 0;
        var add2 = addScalar2;
        var mul = multiplyScalar2;
        var i2 = 0;
        var j = 0;
        while (i2 < xindex.length && j < yindex.length) {
          var I = xindex[i2];
          var J = yindex[j];
          if (I < J) {
            i2++;
            continue;
          }
          if (I > J) {
            j++;
            continue;
          }
          if (I === J) {
            c = add2(c, mul(xvalues[i2], yvalues[j]));
            i2++;
            j++;
          }
        }
        return c;
      }
      function _size(x) {
        return isMatrix(x) ? x.size() : size2(x);
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/trace.js
var name199, dependencies200, createTrace;
var init_trace = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/trace.js"() {
    init_object();
    init_string();
    init_factory();
    name199 = "trace";
    dependencies200 = ["typed", "matrix", "add"];
    createTrace = /* @__PURE__ */ factory(name199, dependencies200, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        add: add2
      } = _ref;
      return typed2("trace", {
        Array: function _arrayTrace(x) {
          return _denseTrace(matrix2(x));
        },
        SparseMatrix: _sparseTrace,
        DenseMatrix: _denseTrace,
        any: clone
      });
      function _denseTrace(m) {
        var size2 = m._size;
        var data = m._data;
        switch (size2.length) {
          case 1:
            if (size2[0] === 1) {
              return clone(data[0]);
            }
            throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
          case 2: {
            var rows = size2[0];
            var cols = size2[1];
            if (rows === cols) {
              var sum2 = 0;
              for (var i2 = 0; i2 < rows; i2++) {
                sum2 = add2(sum2, data[i2][i2]);
              }
              return sum2;
            } else {
              throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
            }
          }
          default:
            throw new RangeError("Matrix must be two dimensional (size: " + format3(size2) + ")");
        }
      }
      function _sparseTrace(m) {
        var values = m._values;
        var index2 = m._index;
        var ptr = m._ptr;
        var size2 = m._size;
        var rows = size2[0];
        var columns = size2[1];
        if (rows === columns) {
          var sum2 = 0;
          if (values.length > 0) {
            for (var j = 0; j < columns; j++) {
              var k0 = ptr[j];
              var k1 = ptr[j + 1];
              for (var k = k0; k < k1; k++) {
                var i2 = index2[k];
                if (i2 === j) {
                  sum2 = add2(sum2, values[k]);
                  break;
                }
                if (i2 > j) {
                  break;
                }
              }
            }
          }
          return sum2;
        }
        throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
      }
    });
  }
});

// node_modules/mathjs/lib/esm/type/matrix/function/index.js
var name200, dependencies201, createIndex;
var init_function2 = __esm({
  "node_modules/mathjs/lib/esm/type/matrix/function/index.js"() {
    init_factory();
    init_is();
    name200 = "index";
    dependencies201 = ["typed", "Index"];
    createIndex = /* @__PURE__ */ factory(name200, dependencies201, (_ref) => {
      var {
        typed: typed2,
        Index: Index2
      } = _ref;
      return typed2(name200, {
        "...number | string | BigNumber | Range | Array | Matrix": function numberStringBigNumberRangeArrayMatrix(args) {
          var ranges = args.map(function(arg2) {
            if (isBigNumber(arg2)) {
              return arg2.toNumber();
            } else if (Array.isArray(arg2) || isMatrix(arg2)) {
              return arg2.map(function(elem) {
                return isBigNumber(elem) ? elem.toNumber() : elem;
              });
            } else {
              return arg2;
            }
          });
          var res = new Index2();
          Index2.apply(res, ranges);
          return res;
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/expression/keywords.js
var keywords;
var init_keywords = __esm({
  "node_modules/mathjs/lib/esm/expression/keywords.js"() {
    keywords = /* @__PURE__ */ new Set(["end"]);
  }
});

// node_modules/mathjs/lib/esm/expression/node/Node.js
var name201, dependencies202, createNode;
var init_Node = __esm({
  "node_modules/mathjs/lib/esm/expression/node/Node.js"() {
    init_is();
    init_keywords();
    init_object();
    init_factory();
    init_map();
    name201 = "Node";
    dependencies202 = ["mathWithTransform"];
    createNode = /* @__PURE__ */ factory(name201, dependencies202, (_ref) => {
      var {
        mathWithTransform: mathWithTransform2
      } = _ref;
      function Node2() {
        if (!(this instanceof Node2)) {
          throw new SyntaxError("Constructor must be called with the new operator");
        }
      }
      Node2.prototype.evaluate = function(scope) {
        return this.compile().evaluate(scope);
      };
      Node2.prototype.type = "Node";
      Node2.prototype.isNode = true;
      Node2.prototype.comment = "";
      Node2.prototype.compile = function() {
        var expr = this._compile(mathWithTransform2, {});
        var args = {};
        var context = null;
        function evaluate2(scope) {
          var s = createMap(scope);
          _validateScope(s);
          return expr(s, args, context);
        }
        return {
          evaluate: evaluate2
        };
      };
      Node2.prototype._compile = function(math2, argNames) {
        throw new Error("Method _compile should be implemented by type " + this.type);
      };
      Node2.prototype.forEach = function(callback) {
        throw new Error("Cannot run forEach on a Node interface");
      };
      Node2.prototype.map = function(callback) {
        throw new Error("Cannot run map on a Node interface");
      };
      Node2.prototype._ifNode = function(node) {
        if (!isNode(node)) {
          throw new TypeError("Callback function must return a Node");
        }
        return node;
      };
      Node2.prototype.traverse = function(callback) {
        callback(this, null, null);
        function _traverse(node, callback2) {
          node.forEach(function(child2, path, parent2) {
            callback2(child2, path, parent2);
            _traverse(child2, callback2);
          });
        }
        _traverse(this, callback);
      };
      Node2.prototype.transform = function(callback) {
        function _transform(child2, path, parent2) {
          var replacement = callback(child2, path, parent2);
          if (replacement !== child2) {
            return replacement;
          }
          return child2.map(_transform);
        }
        return _transform(this, null, null);
      };
      Node2.prototype.filter = function(callback) {
        var nodes = [];
        this.traverse(function(node, path, parent2) {
          if (callback(node, path, parent2)) {
            nodes.push(node);
          }
        });
        return nodes;
      };
      Node2.prototype.clone = function() {
        throw new Error("Cannot clone a Node interface");
      };
      Node2.prototype.cloneDeep = function() {
        return this.map(function(node) {
          return node.cloneDeep();
        });
      };
      Node2.prototype.equals = function(other) {
        return other ? deepStrictEqual(this, other) : false;
      };
      Node2.prototype.toString = function(options) {
        var customString = this._getCustomString(options);
        if (typeof customString !== "undefined") {
          return customString;
        }
        return this._toString(options);
      };
      Node2.prototype.toJSON = function() {
        throw new Error("Cannot serialize object: toJSON not implemented by " + this.type);
      };
      Node2.prototype.toHTML = function(options) {
        var customString = this._getCustomString(options);
        if (typeof customString !== "undefined") {
          return customString;
        }
        return this.toHTML(options);
      };
      Node2.prototype._toString = function() {
        throw new Error("_toString not implemented for " + this.type);
      };
      Node2.prototype.toTex = function(options) {
        var customString = this._getCustomString(options);
        if (typeof customString !== "undefined") {
          return customString;
        }
        return this._toTex(options);
      };
      Node2.prototype._toTex = function(options) {
        throw new Error("_toTex not implemented for " + this.type);
      };
      Node2.prototype._getCustomString = function(options) {
        if (options && typeof options === "object") {
          switch (typeof options.handler) {
            case "object":
            case "undefined":
              return;
            case "function":
              return options.handler(this, options);
            default:
              throw new TypeError("Object or function expected as callback");
          }
        }
      };
      Node2.prototype.getIdentifier = function() {
        return this.type;
      };
      Node2.prototype.getContent = function() {
        return this;
      };
      function _validateScope(scope) {
        for (var symbol of [...keywords]) {
          if (scope.has(symbol)) {
            throw new Error('Scope contains an illegal symbol, "' + symbol + '" is a reserved keyword');
          }
        }
      }
      return Node2;
    }, {
      isClass: true,
      isNode: true
    });
  }
});

// node_modules/mathjs/lib/esm/expression/transform/utils/errorTransform.js
function errorTransform(err) {
  if (err && err.isIndexError) {
    return new IndexError(err.index + 1, err.min + 1, err.max !== void 0 ? err.max + 1 : void 0);
  }
  return err;
}
var init_errorTransform = __esm({
  "node_modules/mathjs/lib/esm/expression/transform/utils/errorTransform.js"() {
    init_IndexError();
  }
});

// node_modules/mathjs/lib/esm/expression/node/utils/access.js
function accessFactory(_ref) {
  var {
    subset: subset2
  } = _ref;
  return function access(object, index2) {
    try {
      if (Array.isArray(object)) {
        return subset2(object, index2);
      } else if (object && typeof object.subset === "function") {
        return object.subset(index2);
      } else if (typeof object === "string") {
        return subset2(object, index2);
      } else if (typeof object === "object") {
        if (!index2.isObjectProperty()) {
          throw new TypeError("Cannot apply a numeric index as object property");
        }
        return getSafeProperty(object, index2.getObjectProperty());
      } else {
        throw new TypeError("Cannot apply index: unsupported type of object");
      }
    } catch (err) {
      throw errorTransform(err);
    }
  };
}
var init_access = __esm({
  "node_modules/mathjs/lib/esm/expression/node/utils/access.js"() {
    init_errorTransform();
    init_customs();
  }
});

// node_modules/mathjs/lib/esm/expression/node/AccessorNode.js
var name202, dependencies203, createAccessorNode;
var init_AccessorNode = __esm({
  "node_modules/mathjs/lib/esm/expression/node/AccessorNode.js"() {
    init_is();
    init_customs();
    init_factory();
    init_access();
    name202 = "AccessorNode";
    dependencies203 = ["subset", "Node"];
    createAccessorNode = /* @__PURE__ */ factory(name202, dependencies203, (_ref) => {
      var {
        subset: subset2,
        Node: Node2
      } = _ref;
      var access = accessFactory({
        subset: subset2
      });
      function AccessorNode2(object, index2) {
        if (!(this instanceof AccessorNode2)) {
          throw new SyntaxError("Constructor must be called with the new operator");
        }
        if (!isNode(object)) {
          throw new TypeError('Node expected for parameter "object"');
        }
        if (!isIndexNode(index2)) {
          throw new TypeError('IndexNode expected for parameter "index"');
        }
        this.object = object || null;
        this.index = index2;
        Object.defineProperty(this, "name", {
          get: function() {
            if (this.index) {
              return this.index.isObjectProperty() ? this.index.getObjectProperty() : "";
            } else {
              return this.object.name || "";
            }
          }.bind(this),
          set: function set() {
            throw new Error("Cannot assign a new name, name is read-only");
          }
        });
      }
      AccessorNode2.prototype = new Node2();
      AccessorNode2.prototype.type = "AccessorNode";
      AccessorNode2.prototype.isAccessorNode = true;
      AccessorNode2.prototype._compile = function(math2, argNames) {
        var evalObject = this.object._compile(math2, argNames);
        var evalIndex = this.index._compile(math2, argNames);
        if (this.index.isObjectProperty()) {
          var prop = this.index.getObjectProperty();
          return function evalAccessorNode(scope, args, context) {
            return getSafeProperty(evalObject(scope, args, context), prop);
          };
        } else {
          return function evalAccessorNode(scope, args, context) {
            var object = evalObject(scope, args, context);
            var index2 = evalIndex(scope, args, object);
            return access(object, index2);
          };
        }
      };
      AccessorNode2.prototype.forEach = function(callback) {
        callback(this.object, "object", this);
        callback(this.index, "index", this);
      };
      AccessorNode2.prototype.map = function(callback) {
        return new AccessorNode2(this._ifNode(callback(this.object, "object", this)), this._ifNode(callback(this.index, "index", this)));
      };
      AccessorNode2.prototype.clone = function() {
        return new AccessorNode2(this.object, this.index);
      };
      AccessorNode2.prototype._toString = function(options) {
        var object = this.object.toString(options);
        if (needParenthesis(this.object)) {
          object = "(" + object + ")";
        }
        return object + this.index.toString(options);
      };
      AccessorNode2.prototype.toHTML = function(options) {
        var object = this.object.toHTML(options);
        if (needParenthesis(this.object)) {
          object = '<span class="math-parenthesis math-round-parenthesis">(</span>' + object + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        return object + this.index.toHTML(options);
      };
      AccessorNode2.prototype._toTex = function(options) {
        var object = this.object.toTex(options);
        if (needParenthesis(this.object)) {
          object = "\\left(' + object + '\\right)";
        }
        return object + this.index.toTex(options);
      };
      AccessorNode2.prototype.toJSON = function() {
        return {
          mathjs: "AccessorNode",
          object: this.object,
          index: this.index
        };
      };
      AccessorNode2.fromJSON = function(json) {
        return new AccessorNode2(json.object, json.index);
      };
      function needParenthesis(node) {
        return !(isAccessorNode(node) || isArrayNode(node) || isConstantNode(node) || isFunctionNode(node) || isObjectNode(node) || isParenthesisNode(node) || isSymbolNode(node));
      }
      return AccessorNode2;
    }, {
      isClass: true,
      isNode: true
    });
  }
});

// node_modules/mathjs/lib/esm/expression/node/ArrayNode.js
var name203, dependencies204, createArrayNode;
var init_ArrayNode = __esm({
  "node_modules/mathjs/lib/esm/expression/node/ArrayNode.js"() {
    init_is();
    init_array();
    init_factory();
    name203 = "ArrayNode";
    dependencies204 = ["Node"];
    createArrayNode = /* @__PURE__ */ factory(name203, dependencies204, (_ref) => {
      var {
        Node: Node2
      } = _ref;
      function ArrayNode2(items) {
        if (!(this instanceof ArrayNode2)) {
          throw new SyntaxError("Constructor must be called with the new operator");
        }
        this.items = items || [];
        if (!Array.isArray(this.items) || !this.items.every(isNode)) {
          throw new TypeError("Array containing Nodes expected");
        }
      }
      ArrayNode2.prototype = new Node2();
      ArrayNode2.prototype.type = "ArrayNode";
      ArrayNode2.prototype.isArrayNode = true;
      ArrayNode2.prototype._compile = function(math2, argNames) {
        var evalItems = map(this.items, function(item) {
          return item._compile(math2, argNames);
        });
        var asMatrix = math2.config.matrix !== "Array";
        if (asMatrix) {
          var matrix2 = math2.matrix;
          return function evalArrayNode(scope, args, context) {
            return matrix2(map(evalItems, function(evalItem) {
              return evalItem(scope, args, context);
            }));
          };
        } else {
          return function evalArrayNode(scope, args, context) {
            return map(evalItems, function(evalItem) {
              return evalItem(scope, args, context);
            });
          };
        }
      };
      ArrayNode2.prototype.forEach = function(callback) {
        for (var i2 = 0; i2 < this.items.length; i2++) {
          var node = this.items[i2];
          callback(node, "items[" + i2 + "]", this);
        }
      };
      ArrayNode2.prototype.map = function(callback) {
        var items = [];
        for (var i2 = 0; i2 < this.items.length; i2++) {
          items[i2] = this._ifNode(callback(this.items[i2], "items[" + i2 + "]", this));
        }
        return new ArrayNode2(items);
      };
      ArrayNode2.prototype.clone = function() {
        return new ArrayNode2(this.items.slice(0));
      };
      ArrayNode2.prototype._toString = function(options) {
        var items = this.items.map(function(node) {
          return node.toString(options);
        });
        return "[" + items.join(", ") + "]";
      };
      ArrayNode2.prototype.toJSON = function() {
        return {
          mathjs: "ArrayNode",
          items: this.items
        };
      };
      ArrayNode2.fromJSON = function(json) {
        return new ArrayNode2(json.items);
      };
      ArrayNode2.prototype.toHTML = function(options) {
        var items = this.items.map(function(node) {
          return node.toHTML(options);
        });
        return '<span class="math-parenthesis math-square-parenthesis">[</span>' + items.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-square-parenthesis">]</span>';
      };
      ArrayNode2.prototype._toTex = function(options) {
        function itemsToTex(items, nested) {
          var mixedItems = items.some(isArrayNode) && !items.every(isArrayNode);
          var itemsFormRow = nested || mixedItems;
          var itemSep = itemsFormRow ? "&" : "\\\\";
          var itemsTex = items.map(function(node) {
            if (node.items) {
              return itemsToTex(node.items, !nested);
            } else {
              return node.toTex(options);
            }
          }).join(itemSep);
          return mixedItems || !itemsFormRow || itemsFormRow && !nested ? "\\begin{bmatrix}" + itemsTex + "\\end{bmatrix}" : itemsTex;
        }
        return itemsToTex(this.items, false);
      };
      return ArrayNode2;
    }, {
      isClass: true,
      isNode: true
    });
  }
});

// node_modules/mathjs/lib/esm/expression/node/utils/assign.js
function assignFactory(_ref) {
  var {
    subset: subset2,
    matrix: matrix2
  } = _ref;
  return function assign2(object, index2, value) {
    try {
      if (Array.isArray(object)) {
        return matrix2(object).subset(index2, value).valueOf();
      } else if (object && typeof object.subset === "function") {
        return object.subset(index2, value);
      } else if (typeof object === "string") {
        return subset2(object, index2, value);
      } else if (typeof object === "object") {
        if (!index2.isObjectProperty()) {
          throw TypeError("Cannot apply a numeric index as object property");
        }
        setSafeProperty(object, index2.getObjectProperty(), value);
        return object;
      } else {
        throw new TypeError("Cannot apply index: unsupported type of object");
      }
    } catch (err) {
      throw errorTransform(err);
    }
  };
}
var init_assign = __esm({
  "node_modules/mathjs/lib/esm/expression/node/utils/assign.js"() {
    init_errorTransform();
    init_customs();
  }
});

// node_modules/mathjs/lib/esm/expression/operators.js
function getPrecedence(_node, parenthesis) {
  var node = _node;
  if (parenthesis !== "keep") {
    node = _node.getContent();
  }
  var identifier = node.getIdentifier();
  for (var i2 = 0; i2 < properties.length; i2++) {
    if (identifier in properties[i2]) {
      return i2;
    }
  }
  return null;
}
function getAssociativity(_node, parenthesis) {
  var node = _node;
  if (parenthesis !== "keep") {
    node = _node.getContent();
  }
  var identifier = node.getIdentifier();
  var index2 = getPrecedence(node, parenthesis);
  if (index2 === null) {
    return null;
  }
  var property = properties[index2][identifier];
  if (hasOwnProperty2(property, "associativity")) {
    if (property.associativity === "left") {
      return "left";
    }
    if (property.associativity === "right") {
      return "right";
    }
    throw Error("'" + identifier + "' has the invalid associativity '" + property.associativity + "'.");
  }
  return null;
}
function isAssociativeWith(nodeA, nodeB, parenthesis) {
  var a = parenthesis !== "keep" ? nodeA.getContent() : nodeA;
  var b = parenthesis !== "keep" ? nodeA.getContent() : nodeB;
  var identifierA = a.getIdentifier();
  var identifierB = b.getIdentifier();
  var index2 = getPrecedence(a, parenthesis);
  if (index2 === null) {
    return null;
  }
  var property = properties[index2][identifierA];
  if (hasOwnProperty2(property, "associativeWith") && property.associativeWith instanceof Array) {
    for (var i2 = 0; i2 < property.associativeWith.length; i2++) {
      if (property.associativeWith[i2] === identifierB) {
        return true;
      }
    }
    return false;
  }
  return null;
}
var properties;
var init_operators = __esm({
  "node_modules/mathjs/lib/esm/expression/operators.js"() {
    init_object();
    properties = [{
      AssignmentNode: {},
      FunctionAssignmentNode: {}
    }, {
      ConditionalNode: {
        latexLeftParens: false,
        latexRightParens: false,
        latexParens: false
      }
    }, {
      "OperatorNode:or": {
        associativity: "left",
        associativeWith: []
      }
    }, {
      "OperatorNode:xor": {
        associativity: "left",
        associativeWith: []
      }
    }, {
      "OperatorNode:and": {
        associativity: "left",
        associativeWith: []
      }
    }, {
      "OperatorNode:bitOr": {
        associativity: "left",
        associativeWith: []
      }
    }, {
      "OperatorNode:bitXor": {
        associativity: "left",
        associativeWith: []
      }
    }, {
      "OperatorNode:bitAnd": {
        associativity: "left",
        associativeWith: []
      }
    }, {
      "OperatorNode:equal": {
        associativity: "left",
        associativeWith: []
      },
      "OperatorNode:unequal": {
        associativity: "left",
        associativeWith: []
      },
      "OperatorNode:smaller": {
        associativity: "left",
        associativeWith: []
      },
      "OperatorNode:larger": {
        associativity: "left",
        associativeWith: []
      },
      "OperatorNode:smallerEq": {
        associativity: "left",
        associativeWith: []
      },
      "OperatorNode:largerEq": {
        associativity: "left",
        associativeWith: []
      },
      RelationalNode: {
        associativity: "left",
        associativeWith: []
      }
    }, {
      "OperatorNode:leftShift": {
        associativity: "left",
        associativeWith: []
      },
      "OperatorNode:rightArithShift": {
        associativity: "left",
        associativeWith: []
      },
      "OperatorNode:rightLogShift": {
        associativity: "left",
        associativeWith: []
      }
    }, {
      "OperatorNode:to": {
        associativity: "left",
        associativeWith: []
      }
    }, {
      RangeNode: {}
    }, {
      "OperatorNode:add": {
        associativity: "left",
        associativeWith: ["OperatorNode:add", "OperatorNode:subtract"]
      },
      "OperatorNode:subtract": {
        associativity: "left",
        associativeWith: []
      }
    }, {
      "OperatorNode:multiply": {
        associativity: "left",
        associativeWith: ["OperatorNode:multiply", "OperatorNode:divide", "Operator:dotMultiply", "Operator:dotDivide"]
      },
      "OperatorNode:divide": {
        associativity: "left",
        associativeWith: [],
        latexLeftParens: false,
        latexRightParens: false,
        latexParens: false
      },
      "OperatorNode:dotMultiply": {
        associativity: "left",
        associativeWith: ["OperatorNode:multiply", "OperatorNode:divide", "OperatorNode:dotMultiply", "OperatorNode:doDivide"]
      },
      "OperatorNode:dotDivide": {
        associativity: "left",
        associativeWith: []
      },
      "OperatorNode:mod": {
        associativity: "left",
        associativeWith: []
      }
    }, {
      "OperatorNode:unaryPlus": {
        associativity: "right"
      },
      "OperatorNode:unaryMinus": {
        associativity: "right"
      },
      "OperatorNode:bitNot": {
        associativity: "right"
      },
      "OperatorNode:not": {
        associativity: "right"
      }
    }, {
      "OperatorNode:pow": {
        associativity: "right",
        associativeWith: [],
        latexRightParens: false
      },
      "OperatorNode:dotPow": {
        associativity: "right",
        associativeWith: []
      }
    }, {
      "OperatorNode:factorial": {
        associativity: "left"
      }
    }, {
      "OperatorNode:transpose": {
        associativity: "left"
      }
    }];
  }
});

// node_modules/mathjs/lib/esm/expression/node/AssignmentNode.js
var name204, dependencies205, createAssignmentNode;
var init_AssignmentNode = __esm({
  "node_modules/mathjs/lib/esm/expression/node/AssignmentNode.js"() {
    init_is();
    init_customs();
    init_factory();
    init_access();
    init_assign();
    init_operators();
    name204 = "AssignmentNode";
    dependencies205 = [
      "subset",
      "?matrix",
      "Node"
    ];
    createAssignmentNode = /* @__PURE__ */ factory(name204, dependencies205, (_ref) => {
      var {
        subset: subset2,
        matrix: matrix2,
        Node: Node2
      } = _ref;
      var access = accessFactory({
        subset: subset2
      });
      var assign2 = assignFactory({
        subset: subset2,
        matrix: matrix2
      });
      function AssignmentNode2(object, index2, value) {
        if (!(this instanceof AssignmentNode2)) {
          throw new SyntaxError("Constructor must be called with the new operator");
        }
        this.object = object;
        this.index = value ? index2 : null;
        this.value = value || index2;
        if (!isSymbolNode(object) && !isAccessorNode(object)) {
          throw new TypeError('SymbolNode or AccessorNode expected as "object"');
        }
        if (isSymbolNode(object) && object.name === "end") {
          throw new Error('Cannot assign to symbol "end"');
        }
        if (this.index && !isIndexNode(this.index)) {
          throw new TypeError('IndexNode expected as "index"');
        }
        if (!isNode(this.value)) {
          throw new TypeError('Node expected as "value"');
        }
        Object.defineProperty(this, "name", {
          get: function() {
            if (this.index) {
              return this.index.isObjectProperty() ? this.index.getObjectProperty() : "";
            } else {
              return this.object.name || "";
            }
          }.bind(this),
          set: function set() {
            throw new Error("Cannot assign a new name, name is read-only");
          }
        });
      }
      AssignmentNode2.prototype = new Node2();
      AssignmentNode2.prototype.type = "AssignmentNode";
      AssignmentNode2.prototype.isAssignmentNode = true;
      AssignmentNode2.prototype._compile = function(math2, argNames) {
        var evalObject = this.object._compile(math2, argNames);
        var evalIndex = this.index ? this.index._compile(math2, argNames) : null;
        var evalValue = this.value._compile(math2, argNames);
        var name296 = this.object.name;
        if (!this.index) {
          if (!isSymbolNode(this.object)) {
            throw new TypeError("SymbolNode expected as object");
          }
          return function evalAssignmentNode(scope, args, context) {
            var value = evalValue(scope, args, context);
            scope.set(name296, value);
            return value;
          };
        } else if (this.index.isObjectProperty()) {
          var prop = this.index.getObjectProperty();
          return function evalAssignmentNode(scope, args, context) {
            var object = evalObject(scope, args, context);
            var value = evalValue(scope, args, context);
            setSafeProperty(object, prop, value);
            return value;
          };
        } else if (isSymbolNode(this.object)) {
          return function evalAssignmentNode(scope, args, context) {
            var childObject = evalObject(scope, args, context);
            var value = evalValue(scope, args, context);
            var index2 = evalIndex(scope, args, childObject);
            scope.set(name296, assign2(childObject, index2, value));
            return value;
          };
        } else {
          var evalParentObject = this.object.object._compile(math2, argNames);
          if (this.object.index.isObjectProperty()) {
            var parentProp = this.object.index.getObjectProperty();
            return function evalAssignmentNode(scope, args, context) {
              var parent2 = evalParentObject(scope, args, context);
              var childObject = getSafeProperty(parent2, parentProp);
              var index2 = evalIndex(scope, args, childObject);
              var value = evalValue(scope, args, context);
              setSafeProperty(parent2, parentProp, assign2(childObject, index2, value));
              return value;
            };
          } else {
            var evalParentIndex = this.object.index._compile(math2, argNames);
            return function evalAssignmentNode(scope, args, context) {
              var parent2 = evalParentObject(scope, args, context);
              var parentIndex = evalParentIndex(scope, args, parent2);
              var childObject = access(parent2, parentIndex);
              var index2 = evalIndex(scope, args, childObject);
              var value = evalValue(scope, args, context);
              assign2(parent2, parentIndex, assign2(childObject, index2, value));
              return value;
            };
          }
        }
      };
      AssignmentNode2.prototype.forEach = function(callback) {
        callback(this.object, "object", this);
        if (this.index) {
          callback(this.index, "index", this);
        }
        callback(this.value, "value", this);
      };
      AssignmentNode2.prototype.map = function(callback) {
        var object = this._ifNode(callback(this.object, "object", this));
        var index2 = this.index ? this._ifNode(callback(this.index, "index", this)) : null;
        var value = this._ifNode(callback(this.value, "value", this));
        return new AssignmentNode2(object, index2, value);
      };
      AssignmentNode2.prototype.clone = function() {
        return new AssignmentNode2(this.object, this.index, this.value);
      };
      function needParenthesis(node, parenthesis) {
        if (!parenthesis) {
          parenthesis = "keep";
        }
        var precedence = getPrecedence(node, parenthesis);
        var exprPrecedence = getPrecedence(node.value, parenthesis);
        return parenthesis === "all" || exprPrecedence !== null && exprPrecedence <= precedence;
      }
      AssignmentNode2.prototype._toString = function(options) {
        var object = this.object.toString(options);
        var index2 = this.index ? this.index.toString(options) : "";
        var value = this.value.toString(options);
        if (needParenthesis(this, options && options.parenthesis)) {
          value = "(" + value + ")";
        }
        return object + index2 + " = " + value;
      };
      AssignmentNode2.prototype.toJSON = function() {
        return {
          mathjs: "AssignmentNode",
          object: this.object,
          index: this.index,
          value: this.value
        };
      };
      AssignmentNode2.fromJSON = function(json) {
        return new AssignmentNode2(json.object, json.index, json.value);
      };
      AssignmentNode2.prototype.toHTML = function(options) {
        var object = this.object.toHTML(options);
        var index2 = this.index ? this.index.toHTML(options) : "";
        var value = this.value.toHTML(options);
        if (needParenthesis(this, options && options.parenthesis)) {
          value = '<span class="math-paranthesis math-round-parenthesis">(</span>' + value + '<span class="math-paranthesis math-round-parenthesis">)</span>';
        }
        return object + index2 + '<span class="math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator">=</span>' + value;
      };
      AssignmentNode2.prototype._toTex = function(options) {
        var object = this.object.toTex(options);
        var index2 = this.index ? this.index.toTex(options) : "";
        var value = this.value.toTex(options);
        if (needParenthesis(this, options && options.parenthesis)) {
          value = "\\left(".concat(value, "\\right)");
        }
        return object + index2 + ":=" + value;
      };
      return AssignmentNode2;
    }, {
      isClass: true,
      isNode: true
    });
  }
});

// node_modules/mathjs/lib/esm/expression/node/BlockNode.js
var name205, dependencies206, createBlockNode;
var init_BlockNode = __esm({
  "node_modules/mathjs/lib/esm/expression/node/BlockNode.js"() {
    init_is();
    init_array();
    init_factory();
    name205 = "BlockNode";
    dependencies206 = ["ResultSet", "Node"];
    createBlockNode = /* @__PURE__ */ factory(name205, dependencies206, (_ref) => {
      var {
        ResultSet: ResultSet2,
        Node: Node2
      } = _ref;
      function BlockNode2(blocks) {
        if (!(this instanceof BlockNode2)) {
          throw new SyntaxError("Constructor must be called with the new operator");
        }
        if (!Array.isArray(blocks))
          throw new Error("Array expected");
        this.blocks = blocks.map(function(block) {
          var node = block && block.node;
          var visible = block && block.visible !== void 0 ? block.visible : true;
          if (!isNode(node))
            throw new TypeError('Property "node" must be a Node');
          if (typeof visible !== "boolean")
            throw new TypeError('Property "visible" must be a boolean');
          return {
            node,
            visible
          };
        });
      }
      BlockNode2.prototype = new Node2();
      BlockNode2.prototype.type = "BlockNode";
      BlockNode2.prototype.isBlockNode = true;
      BlockNode2.prototype._compile = function(math2, argNames) {
        var evalBlocks = map(this.blocks, function(block) {
          return {
            evaluate: block.node._compile(math2, argNames),
            visible: block.visible
          };
        });
        return function evalBlockNodes(scope, args, context) {
          var results = [];
          forEach(evalBlocks, function evalBlockNode(block) {
            var result = block.evaluate(scope, args, context);
            if (block.visible) {
              results.push(result);
            }
          });
          return new ResultSet2(results);
        };
      };
      BlockNode2.prototype.forEach = function(callback) {
        for (var i2 = 0; i2 < this.blocks.length; i2++) {
          callback(this.blocks[i2].node, "blocks[" + i2 + "].node", this);
        }
      };
      BlockNode2.prototype.map = function(callback) {
        var blocks = [];
        for (var i2 = 0; i2 < this.blocks.length; i2++) {
          var block = this.blocks[i2];
          var node = this._ifNode(callback(block.node, "blocks[" + i2 + "].node", this));
          blocks[i2] = {
            node,
            visible: block.visible
          };
        }
        return new BlockNode2(blocks);
      };
      BlockNode2.prototype.clone = function() {
        var blocks = this.blocks.map(function(block) {
          return {
            node: block.node,
            visible: block.visible
          };
        });
        return new BlockNode2(blocks);
      };
      BlockNode2.prototype._toString = function(options) {
        return this.blocks.map(function(param) {
          return param.node.toString(options) + (param.visible ? "" : ";");
        }).join("\n");
      };
      BlockNode2.prototype.toJSON = function() {
        return {
          mathjs: "BlockNode",
          blocks: this.blocks
        };
      };
      BlockNode2.fromJSON = function(json) {
        return new BlockNode2(json.blocks);
      };
      BlockNode2.prototype.toHTML = function(options) {
        return this.blocks.map(function(param) {
          return param.node.toHTML(options) + (param.visible ? "" : '<span class="math-separator">;</span>');
        }).join('<span class="math-separator"><br /></span>');
      };
      BlockNode2.prototype._toTex = function(options) {
        return this.blocks.map(function(param) {
          return param.node.toTex(options) + (param.visible ? "" : ";");
        }).join("\\;\\;\n");
      };
      return BlockNode2;
    }, {
      isClass: true,
      isNode: true
    });
  }
});

// node_modules/mathjs/lib/esm/expression/node/ConditionalNode.js
var name206, dependencies207, createConditionalNode;
var init_ConditionalNode = __esm({
  "node_modules/mathjs/lib/esm/expression/node/ConditionalNode.js"() {
    init_is();
    init_factory();
    init_operators();
    name206 = "ConditionalNode";
    dependencies207 = ["Node"];
    createConditionalNode = /* @__PURE__ */ factory(name206, dependencies207, (_ref) => {
      var {
        Node: Node2
      } = _ref;
      function ConditionalNode2(condition, trueExpr, falseExpr) {
        if (!(this instanceof ConditionalNode2)) {
          throw new SyntaxError("Constructor must be called with the new operator");
        }
        if (!isNode(condition))
          throw new TypeError("Parameter condition must be a Node");
        if (!isNode(trueExpr))
          throw new TypeError("Parameter trueExpr must be a Node");
        if (!isNode(falseExpr))
          throw new TypeError("Parameter falseExpr must be a Node");
        this.condition = condition;
        this.trueExpr = trueExpr;
        this.falseExpr = falseExpr;
      }
      ConditionalNode2.prototype = new Node2();
      ConditionalNode2.prototype.type = "ConditionalNode";
      ConditionalNode2.prototype.isConditionalNode = true;
      ConditionalNode2.prototype._compile = function(math2, argNames) {
        var evalCondition = this.condition._compile(math2, argNames);
        var evalTrueExpr = this.trueExpr._compile(math2, argNames);
        var evalFalseExpr = this.falseExpr._compile(math2, argNames);
        return function evalConditionalNode(scope, args, context) {
          return testCondition(evalCondition(scope, args, context)) ? evalTrueExpr(scope, args, context) : evalFalseExpr(scope, args, context);
        };
      };
      ConditionalNode2.prototype.forEach = function(callback) {
        callback(this.condition, "condition", this);
        callback(this.trueExpr, "trueExpr", this);
        callback(this.falseExpr, "falseExpr", this);
      };
      ConditionalNode2.prototype.map = function(callback) {
        return new ConditionalNode2(this._ifNode(callback(this.condition, "condition", this)), this._ifNode(callback(this.trueExpr, "trueExpr", this)), this._ifNode(callback(this.falseExpr, "falseExpr", this)));
      };
      ConditionalNode2.prototype.clone = function() {
        return new ConditionalNode2(this.condition, this.trueExpr, this.falseExpr);
      };
      ConditionalNode2.prototype._toString = function(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var precedence = getPrecedence(this, parenthesis);
        var condition = this.condition.toString(options);
        var conditionPrecedence = getPrecedence(this.condition, parenthesis);
        if (parenthesis === "all" || this.condition.type === "OperatorNode" || conditionPrecedence !== null && conditionPrecedence <= precedence) {
          condition = "(" + condition + ")";
        }
        var trueExpr = this.trueExpr.toString(options);
        var truePrecedence = getPrecedence(this.trueExpr, parenthesis);
        if (parenthesis === "all" || this.trueExpr.type === "OperatorNode" || truePrecedence !== null && truePrecedence <= precedence) {
          trueExpr = "(" + trueExpr + ")";
        }
        var falseExpr = this.falseExpr.toString(options);
        var falsePrecedence = getPrecedence(this.falseExpr, parenthesis);
        if (parenthesis === "all" || this.falseExpr.type === "OperatorNode" || falsePrecedence !== null && falsePrecedence <= precedence) {
          falseExpr = "(" + falseExpr + ")";
        }
        return condition + " ? " + trueExpr + " : " + falseExpr;
      };
      ConditionalNode2.prototype.toJSON = function() {
        return {
          mathjs: "ConditionalNode",
          condition: this.condition,
          trueExpr: this.trueExpr,
          falseExpr: this.falseExpr
        };
      };
      ConditionalNode2.fromJSON = function(json) {
        return new ConditionalNode2(json.condition, json.trueExpr, json.falseExpr);
      };
      ConditionalNode2.prototype.toHTML = function(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var precedence = getPrecedence(this, parenthesis);
        var condition = this.condition.toHTML(options);
        var conditionPrecedence = getPrecedence(this.condition, parenthesis);
        if (parenthesis === "all" || this.condition.type === "OperatorNode" || conditionPrecedence !== null && conditionPrecedence <= precedence) {
          condition = '<span class="math-parenthesis math-round-parenthesis">(</span>' + condition + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        var trueExpr = this.trueExpr.toHTML(options);
        var truePrecedence = getPrecedence(this.trueExpr, parenthesis);
        if (parenthesis === "all" || this.trueExpr.type === "OperatorNode" || truePrecedence !== null && truePrecedence <= precedence) {
          trueExpr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + trueExpr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        var falseExpr = this.falseExpr.toHTML(options);
        var falsePrecedence = getPrecedence(this.falseExpr, parenthesis);
        if (parenthesis === "all" || this.falseExpr.type === "OperatorNode" || falsePrecedence !== null && falsePrecedence <= precedence) {
          falseExpr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + falseExpr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        return condition + '<span class="math-operator math-conditional-operator">?</span>' + trueExpr + '<span class="math-operator math-conditional-operator">:</span>' + falseExpr;
      };
      ConditionalNode2.prototype._toTex = function(options) {
        return "\\begin{cases} {" + this.trueExpr.toTex(options) + "}, &\\quad{\\text{if }\\;" + this.condition.toTex(options) + "}\\\\{" + this.falseExpr.toTex(options) + "}, &\\quad{\\text{otherwise}}\\end{cases}";
      };
      function testCondition(condition) {
        if (typeof condition === "number" || typeof condition === "boolean" || typeof condition === "string") {
          return !!condition;
        }
        if (condition) {
          if (isBigNumber(condition)) {
            return !condition.isZero();
          }
          if (isComplex(condition)) {
            return !!(condition.re || condition.im);
          }
          if (isUnit(condition)) {
            return !!condition.value;
          }
        }
        if (condition === null || condition === void 0) {
          return false;
        }
        throw new TypeError('Unsupported type of condition "' + typeOf(condition) + '"');
      }
      return ConditionalNode2;
    }, {
      isClass: true,
      isNode: true
    });
  }
});

// node_modules/escape-latex/dist/index.js
var require_dist = __commonJS({
  "node_modules/escape-latex/dist/index.js"(exports, module) {
    "use strict";
    var _extends6 = Object.assign || function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var defaultEscapes = {
      "{": "\\{",
      "}": "\\}",
      "\\": "\\textbackslash{}",
      "#": "\\#",
      $: "\\$",
      "%": "\\%",
      "&": "\\&",
      "^": "\\textasciicircum{}",
      _: "\\_",
      "~": "\\textasciitilde{}"
    };
    var formatEscapes = {
      "\u2013": "\\--",
      "\u2014": "\\---",
      " ": "~",
      "	": "\\qquad{}",
      "\r\n": "\\newline{}",
      "\n": "\\newline{}"
    };
    var defaultEscapeMapFn = function defaultEscapeMapFn2(defaultEscapes2, formatEscapes2) {
      return _extends6({}, defaultEscapes2, formatEscapes2);
    };
    module.exports = function(str) {
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$preserveFormatti = _ref.preserveFormatting, preserveFormatting = _ref$preserveFormatti === void 0 ? false : _ref$preserveFormatti, _ref$escapeMapFn = _ref.escapeMapFn, escapeMapFn = _ref$escapeMapFn === void 0 ? defaultEscapeMapFn : _ref$escapeMapFn;
      var runningStr = String(str);
      var result = "";
      var escapes = escapeMapFn(_extends6({}, defaultEscapes), preserveFormatting ? _extends6({}, formatEscapes) : {});
      var escapeKeys = Object.keys(escapes);
      var _loop = function _loop2() {
        var specialCharFound = false;
        escapeKeys.forEach(function(key, index2) {
          if (specialCharFound) {
            return;
          }
          if (runningStr.length >= key.length && runningStr.slice(0, key.length) === key) {
            result += escapes[escapeKeys[index2]];
            runningStr = runningStr.slice(key.length, runningStr.length);
            specialCharFound = true;
          }
        });
        if (!specialCharFound) {
          result += runningStr.slice(0, 1);
          runningStr = runningStr.slice(1, runningStr.length);
        }
      };
      while (runningStr) {
        _loop();
      }
      return result;
    };
  }
});

// node_modules/mathjs/lib/esm/utils/latex.js
function escapeLatex(string2) {
  return (0, import_escape_latex.default)(string2, {
    preserveFormatting: true
  });
}
function toSymbol(name296, isUnit2) {
  isUnit2 = typeof isUnit2 === "undefined" ? false : isUnit2;
  if (isUnit2) {
    if (hasOwnProperty2(latexUnits, name296)) {
      return latexUnits[name296];
    }
    return "\\mathrm{" + escapeLatex(name296) + "}";
  }
  if (hasOwnProperty2(latexSymbols, name296)) {
    return latexSymbols[name296];
  }
  return escapeLatex(name296);
}
var import_escape_latex, latexSymbols, latexOperators, latexFunctions, defaultTemplate, latexUnits;
var init_latex = __esm({
  "node_modules/mathjs/lib/esm/utils/latex.js"() {
    import_escape_latex = __toESM(require_dist(), 1);
    init_object();
    latexSymbols = {
      Alpha: "A",
      alpha: "\\alpha",
      Beta: "B",
      beta: "\\beta",
      Gamma: "\\Gamma",
      gamma: "\\gamma",
      Delta: "\\Delta",
      delta: "\\delta",
      Epsilon: "E",
      epsilon: "\\epsilon",
      varepsilon: "\\varepsilon",
      Zeta: "Z",
      zeta: "\\zeta",
      Eta: "H",
      eta: "\\eta",
      Theta: "\\Theta",
      theta: "\\theta",
      vartheta: "\\vartheta",
      Iota: "I",
      iota: "\\iota",
      Kappa: "K",
      kappa: "\\kappa",
      varkappa: "\\varkappa",
      Lambda: "\\Lambda",
      lambda: "\\lambda",
      Mu: "M",
      mu: "\\mu",
      Nu: "N",
      nu: "\\nu",
      Xi: "\\Xi",
      xi: "\\xi",
      Omicron: "O",
      omicron: "o",
      Pi: "\\Pi",
      pi: "\\pi",
      varpi: "\\varpi",
      Rho: "P",
      rho: "\\rho",
      varrho: "\\varrho",
      Sigma: "\\Sigma",
      sigma: "\\sigma",
      varsigma: "\\varsigma",
      Tau: "T",
      tau: "\\tau",
      Upsilon: "\\Upsilon",
      upsilon: "\\upsilon",
      Phi: "\\Phi",
      phi: "\\phi",
      varphi: "\\varphi",
      Chi: "X",
      chi: "\\chi",
      Psi: "\\Psi",
      psi: "\\psi",
      Omega: "\\Omega",
      omega: "\\omega",
      true: "\\mathrm{True}",
      false: "\\mathrm{False}",
      i: "i",
      inf: "\\infty",
      Inf: "\\infty",
      infinity: "\\infty",
      Infinity: "\\infty",
      oo: "\\infty",
      lim: "\\lim",
      undefined: "\\mathbf{?}"
    };
    latexOperators = {
      transpose: "^\\top",
      ctranspose: "^H",
      factorial: "!",
      pow: "^",
      dotPow: ".^\\wedge",
      unaryPlus: "+",
      unaryMinus: "-",
      bitNot: "\\~",
      not: "\\neg",
      multiply: "\\cdot",
      divide: "\\frac",
      dotMultiply: ".\\cdot",
      dotDivide: ".:",
      mod: "\\mod",
      add: "+",
      subtract: "-",
      to: "\\rightarrow",
      leftShift: "<<",
      rightArithShift: ">>",
      rightLogShift: ">>>",
      equal: "=",
      unequal: "\\neq",
      smaller: "<",
      larger: ">",
      smallerEq: "\\leq",
      largerEq: "\\geq",
      bitAnd: "\\&",
      bitXor: "\\underline{|}",
      bitOr: "|",
      and: "\\wedge",
      xor: "\\veebar",
      or: "\\vee"
    };
    latexFunctions = {
      abs: {
        1: "\\left|${args[0]}\\right|"
      },
      add: {
        2: "\\left(${args[0]}".concat(latexOperators.add, "${args[1]}\\right)")
      },
      cbrt: {
        1: "\\sqrt[3]{${args[0]}}"
      },
      ceil: {
        1: "\\left\\lceil${args[0]}\\right\\rceil"
      },
      cube: {
        1: "\\left(${args[0]}\\right)^3"
      },
      divide: {
        2: "\\frac{${args[0]}}{${args[1]}}"
      },
      dotDivide: {
        2: "\\left(${args[0]}".concat(latexOperators.dotDivide, "${args[1]}\\right)")
      },
      dotMultiply: {
        2: "\\left(${args[0]}".concat(latexOperators.dotMultiply, "${args[1]}\\right)")
      },
      dotPow: {
        2: "\\left(${args[0]}".concat(latexOperators.dotPow, "${args[1]}\\right)")
      },
      exp: {
        1: "\\exp\\left(${args[0]}\\right)"
      },
      expm1: "\\left(e".concat(latexOperators.pow, "{${args[0]}}-1\\right)"),
      fix: {
        1: "\\mathrm{${name}}\\left(${args[0]}\\right)"
      },
      floor: {
        1: "\\left\\lfloor${args[0]}\\right\\rfloor"
      },
      gcd: "\\gcd\\left(${args}\\right)",
      hypot: "\\hypot\\left(${args}\\right)",
      log: {
        1: "\\ln\\left(${args[0]}\\right)",
        2: "\\log_{${args[1]}}\\left(${args[0]}\\right)"
      },
      log10: {
        1: "\\log_{10}\\left(${args[0]}\\right)"
      },
      log1p: {
        1: "\\ln\\left(${args[0]}+1\\right)",
        2: "\\log_{${args[1]}}\\left(${args[0]}+1\\right)"
      },
      log2: "\\log_{2}\\left(${args[0]}\\right)",
      mod: {
        2: "\\left(${args[0]}".concat(latexOperators.mod, "${args[1]}\\right)")
      },
      multiply: {
        2: "\\left(${args[0]}".concat(latexOperators.multiply, "${args[1]}\\right)")
      },
      norm: {
        1: "\\left\\|${args[0]}\\right\\|",
        2: void 0
      },
      nthRoot: {
        2: "\\sqrt[${args[1]}]{${args[0]}}"
      },
      nthRoots: {
        2: "\\{y : $y^{args[1]} = {${args[0]}}\\}"
      },
      pow: {
        2: "\\left(${args[0]}\\right)".concat(latexOperators.pow, "{${args[1]}}")
      },
      round: {
        1: "\\left\\lfloor${args[0]}\\right\\rceil",
        2: void 0
      },
      sign: {
        1: "\\mathrm{${name}}\\left(${args[0]}\\right)"
      },
      sqrt: {
        1: "\\sqrt{${args[0]}}"
      },
      square: {
        1: "\\left(${args[0]}\\right)^2"
      },
      subtract: {
        2: "\\left(${args[0]}".concat(latexOperators.subtract, "${args[1]}\\right)")
      },
      unaryMinus: {
        1: "".concat(latexOperators.unaryMinus, "\\left(${args[0]}\\right)")
      },
      unaryPlus: {
        1: "".concat(latexOperators.unaryPlus, "\\left(${args[0]}\\right)")
      },
      bitAnd: {
        2: "\\left(${args[0]}".concat(latexOperators.bitAnd, "${args[1]}\\right)")
      },
      bitNot: {
        1: latexOperators.bitNot + "\\left(${args[0]}\\right)"
      },
      bitOr: {
        2: "\\left(${args[0]}".concat(latexOperators.bitOr, "${args[1]}\\right)")
      },
      bitXor: {
        2: "\\left(${args[0]}".concat(latexOperators.bitXor, "${args[1]}\\right)")
      },
      leftShift: {
        2: "\\left(${args[0]}".concat(latexOperators.leftShift, "${args[1]}\\right)")
      },
      rightArithShift: {
        2: "\\left(${args[0]}".concat(latexOperators.rightArithShift, "${args[1]}\\right)")
      },
      rightLogShift: {
        2: "\\left(${args[0]}".concat(latexOperators.rightLogShift, "${args[1]}\\right)")
      },
      bellNumbers: {
        1: "\\mathrm{B}_{${args[0]}}"
      },
      catalan: {
        1: "\\mathrm{C}_{${args[0]}}"
      },
      stirlingS2: {
        2: "\\mathrm{S}\\left(${args}\\right)"
      },
      arg: {
        1: "\\arg\\left(${args[0]}\\right)"
      },
      conj: {
        1: "\\left(${args[0]}\\right)^*"
      },
      im: {
        1: "\\Im\\left\\lbrace${args[0]}\\right\\rbrace"
      },
      re: {
        1: "\\Re\\left\\lbrace${args[0]}\\right\\rbrace"
      },
      and: {
        2: "\\left(${args[0]}".concat(latexOperators.and, "${args[1]}\\right)")
      },
      not: {
        1: latexOperators.not + "\\left(${args[0]}\\right)"
      },
      or: {
        2: "\\left(${args[0]}".concat(latexOperators.or, "${args[1]}\\right)")
      },
      xor: {
        2: "\\left(${args[0]}".concat(latexOperators.xor, "${args[1]}\\right)")
      },
      cross: {
        2: "\\left(${args[0]}\\right)\\times\\left(${args[1]}\\right)"
      },
      ctranspose: {
        1: "\\left(${args[0]}\\right)".concat(latexOperators.ctranspose)
      },
      det: {
        1: "\\det\\left(${args[0]}\\right)"
      },
      dot: {
        2: "\\left(${args[0]}\\cdot${args[1]}\\right)"
      },
      expm: {
        1: "\\exp\\left(${args[0]}\\right)"
      },
      inv: {
        1: "\\left(${args[0]}\\right)^{-1}"
      },
      pinv: {
        1: "\\left(${args[0]}\\right)^{+}"
      },
      sqrtm: {
        1: "{${args[0]}}".concat(latexOperators.pow, "{\\frac{1}{2}}")
      },
      trace: {
        1: "\\mathrm{tr}\\left(${args[0]}\\right)"
      },
      transpose: {
        1: "\\left(${args[0]}\\right)".concat(latexOperators.transpose)
      },
      combinations: {
        2: "\\binom{${args[0]}}{${args[1]}}"
      },
      combinationsWithRep: {
        2: "\\left(\\!\\!{\\binom{${args[0]}}{${args[1]}}}\\!\\!\\right)"
      },
      factorial: {
        1: "\\left(${args[0]}\\right)".concat(latexOperators.factorial)
      },
      gamma: {
        1: "\\Gamma\\left(${args[0]}\\right)"
      },
      lgamma: {
        1: "\\ln\\Gamma\\left(${args[0]}\\right)"
      },
      equal: {
        2: "\\left(${args[0]}".concat(latexOperators.equal, "${args[1]}\\right)")
      },
      larger: {
        2: "\\left(${args[0]}".concat(latexOperators.larger, "${args[1]}\\right)")
      },
      largerEq: {
        2: "\\left(${args[0]}".concat(latexOperators.largerEq, "${args[1]}\\right)")
      },
      smaller: {
        2: "\\left(${args[0]}".concat(latexOperators.smaller, "${args[1]}\\right)")
      },
      smallerEq: {
        2: "\\left(${args[0]}".concat(latexOperators.smallerEq, "${args[1]}\\right)")
      },
      unequal: {
        2: "\\left(${args[0]}".concat(latexOperators.unequal, "${args[1]}\\right)")
      },
      erf: {
        1: "erf\\left(${args[0]}\\right)"
      },
      max: "\\max\\left(${args}\\right)",
      min: "\\min\\left(${args}\\right)",
      variance: "\\mathrm{Var}\\left(${args}\\right)",
      acos: {
        1: "\\cos^{-1}\\left(${args[0]}\\right)"
      },
      acosh: {
        1: "\\cosh^{-1}\\left(${args[0]}\\right)"
      },
      acot: {
        1: "\\cot^{-1}\\left(${args[0]}\\right)"
      },
      acoth: {
        1: "\\coth^{-1}\\left(${args[0]}\\right)"
      },
      acsc: {
        1: "\\csc^{-1}\\left(${args[0]}\\right)"
      },
      acsch: {
        1: "\\mathrm{csch}^{-1}\\left(${args[0]}\\right)"
      },
      asec: {
        1: "\\sec^{-1}\\left(${args[0]}\\right)"
      },
      asech: {
        1: "\\mathrm{sech}^{-1}\\left(${args[0]}\\right)"
      },
      asin: {
        1: "\\sin^{-1}\\left(${args[0]}\\right)"
      },
      asinh: {
        1: "\\sinh^{-1}\\left(${args[0]}\\right)"
      },
      atan: {
        1: "\\tan^{-1}\\left(${args[0]}\\right)"
      },
      atan2: {
        2: "\\mathrm{atan2}\\left(${args}\\right)"
      },
      atanh: {
        1: "\\tanh^{-1}\\left(${args[0]}\\right)"
      },
      cos: {
        1: "\\cos\\left(${args[0]}\\right)"
      },
      cosh: {
        1: "\\cosh\\left(${args[0]}\\right)"
      },
      cot: {
        1: "\\cot\\left(${args[0]}\\right)"
      },
      coth: {
        1: "\\coth\\left(${args[0]}\\right)"
      },
      csc: {
        1: "\\csc\\left(${args[0]}\\right)"
      },
      csch: {
        1: "\\mathrm{csch}\\left(${args[0]}\\right)"
      },
      sec: {
        1: "\\sec\\left(${args[0]}\\right)"
      },
      sech: {
        1: "\\mathrm{sech}\\left(${args[0]}\\right)"
      },
      sin: {
        1: "\\sin\\left(${args[0]}\\right)"
      },
      sinh: {
        1: "\\sinh\\left(${args[0]}\\right)"
      },
      tan: {
        1: "\\tan\\left(${args[0]}\\right)"
      },
      tanh: {
        1: "\\tanh\\left(${args[0]}\\right)"
      },
      to: {
        2: "\\left(${args[0]}".concat(latexOperators.to, "${args[1]}\\right)")
      },
      numeric: function numeric(node, options) {
        return node.args[0].toTex();
      },
      number: {
        0: "0",
        1: "\\left(${args[0]}\\right)",
        2: "\\left(\\left(${args[0]}\\right)${args[1]}\\right)"
      },
      string: {
        0: '\\mathtt{""}',
        1: "\\mathrm{string}\\left(${args[0]}\\right)"
      },
      bignumber: {
        0: "0",
        1: "\\left(${args[0]}\\right)"
      },
      complex: {
        0: "0",
        1: "\\left(${args[0]}\\right)",
        2: "\\left(\\left(${args[0]}\\right)+".concat(latexSymbols.i, "\\cdot\\left(${args[1]}\\right)\\right)")
      },
      matrix: {
        0: "\\begin{bmatrix}\\end{bmatrix}",
        1: "\\left(${args[0]}\\right)",
        2: "\\left(${args[0]}\\right)"
      },
      sparse: {
        0: "\\begin{bsparse}\\end{bsparse}",
        1: "\\left(${args[0]}\\right)"
      },
      unit: {
        1: "\\left(${args[0]}\\right)",
        2: "\\left(\\left(${args[0]}\\right)${args[1]}\\right)"
      }
    };
    defaultTemplate = "\\mathrm{${name}}\\left(${args}\\right)";
    latexUnits = {
      deg: "^\\circ"
    };
  }
});

// node_modules/mathjs/lib/esm/expression/node/ConstantNode.js
var name207, dependencies208, createConstantNode;
var init_ConstantNode = __esm({
  "node_modules/mathjs/lib/esm/expression/node/ConstantNode.js"() {
    init_string();
    init_is();
    init_latex();
    init_factory();
    name207 = "ConstantNode";
    dependencies208 = ["Node"];
    createConstantNode = /* @__PURE__ */ factory(name207, dependencies208, (_ref) => {
      var {
        Node: Node2
      } = _ref;
      function ConstantNode2(value) {
        if (!(this instanceof ConstantNode2)) {
          throw new SyntaxError("Constructor must be called with the new operator");
        }
        this.value = value;
      }
      ConstantNode2.prototype = new Node2();
      ConstantNode2.prototype.type = "ConstantNode";
      ConstantNode2.prototype.isConstantNode = true;
      ConstantNode2.prototype._compile = function(math2, argNames) {
        var value = this.value;
        return function evalConstantNode() {
          return value;
        };
      };
      ConstantNode2.prototype.forEach = function(callback) {
      };
      ConstantNode2.prototype.map = function(callback) {
        return this.clone();
      };
      ConstantNode2.prototype.clone = function() {
        return new ConstantNode2(this.value);
      };
      ConstantNode2.prototype._toString = function(options) {
        return format3(this.value, options);
      };
      ConstantNode2.prototype.toHTML = function(options) {
        var value = this._toString(options);
        switch (typeOf(this.value)) {
          case "number":
          case "BigNumber":
          case "Fraction":
            return '<span class="math-number">' + value + "</span>";
          case "string":
            return '<span class="math-string">' + value + "</span>";
          case "boolean":
            return '<span class="math-boolean">' + value + "</span>";
          case "null":
            return '<span class="math-null-symbol">' + value + "</span>";
          case "undefined":
            return '<span class="math-undefined">' + value + "</span>";
          default:
            return '<span class="math-symbol">' + value + "</span>";
        }
      };
      ConstantNode2.prototype.toJSON = function() {
        return {
          mathjs: "ConstantNode",
          value: this.value
        };
      };
      ConstantNode2.fromJSON = function(json) {
        return new ConstantNode2(json.value);
      };
      ConstantNode2.prototype._toTex = function(options) {
        var value = this._toString(options);
        switch (typeOf(this.value)) {
          case "string":
            return "\\mathtt{" + escapeLatex(value) + "}";
          case "number":
          case "BigNumber":
            {
              if (!isFinite(this.value)) {
                return this.value.valueOf() < 0 ? "-\\infty" : "\\infty";
              }
              var index2 = value.toLowerCase().indexOf("e");
              if (index2 !== -1) {
                return value.substring(0, index2) + "\\cdot10^{" + value.substring(index2 + 1) + "}";
              }
            }
            return value;
          case "Fraction":
            return this.value.toLatex();
          default:
            return value;
        }
      };
      return ConstantNode2;
    }, {
      isClass: true,
      isNode: true
    });
  }
});

// node_modules/mathjs/lib/esm/expression/node/FunctionAssignmentNode.js
var name208, dependencies209, createFunctionAssignmentNode;
var init_FunctionAssignmentNode = __esm({
  "node_modules/mathjs/lib/esm/expression/node/FunctionAssignmentNode.js"() {
    init_is();
    init_keywords();
    init_string();
    init_array();
    init_latex();
    init_operators();
    init_factory();
    name208 = "FunctionAssignmentNode";
    dependencies209 = ["typed", "Node"];
    createFunctionAssignmentNode = /* @__PURE__ */ factory(name208, dependencies209, (_ref) => {
      var {
        typed: typed2,
        Node: Node2
      } = _ref;
      function FunctionAssignmentNode2(name296, params, expr) {
        if (!(this instanceof FunctionAssignmentNode2)) {
          throw new SyntaxError("Constructor must be called with the new operator");
        }
        if (typeof name296 !== "string")
          throw new TypeError('String expected for parameter "name"');
        if (!Array.isArray(params))
          throw new TypeError('Array containing strings or objects expected for parameter "params"');
        if (!isNode(expr))
          throw new TypeError('Node expected for parameter "expr"');
        if (keywords.has(name296))
          throw new Error('Illegal function name, "' + name296 + '" is a reserved keyword');
        this.name = name296;
        this.params = params.map(function(param) {
          return param && param.name || param;
        });
        this.types = params.map(function(param) {
          return param && param.type || "any";
        });
        this.expr = expr;
      }
      FunctionAssignmentNode2.prototype = new Node2();
      FunctionAssignmentNode2.prototype.type = "FunctionAssignmentNode";
      FunctionAssignmentNode2.prototype.isFunctionAssignmentNode = true;
      FunctionAssignmentNode2.prototype._compile = function(math2, argNames) {
        var childArgNames = Object.create(argNames);
        forEach(this.params, function(param) {
          childArgNames[param] = true;
        });
        var evalExpr = this.expr._compile(math2, childArgNames);
        var name296 = this.name;
        var params = this.params;
        var signature = join(this.types, ",");
        var syntax = name296 + "(" + join(this.params, ", ") + ")";
        return function evalFunctionAssignmentNode(scope, args, context) {
          var signatures = {};
          signatures[signature] = function() {
            var childArgs = Object.create(args);
            for (var i2 = 0; i2 < params.length; i2++) {
              childArgs[params[i2]] = arguments[i2];
            }
            return evalExpr(scope, childArgs, context);
          };
          var fn = typed2(name296, signatures);
          fn.syntax = syntax;
          scope.set(name296, fn);
          return fn;
        };
      };
      FunctionAssignmentNode2.prototype.forEach = function(callback) {
        callback(this.expr, "expr", this);
      };
      FunctionAssignmentNode2.prototype.map = function(callback) {
        var expr = this._ifNode(callback(this.expr, "expr", this));
        return new FunctionAssignmentNode2(this.name, this.params.slice(0), expr);
      };
      FunctionAssignmentNode2.prototype.clone = function() {
        return new FunctionAssignmentNode2(this.name, this.params.slice(0), this.expr);
      };
      function needParenthesis(node, parenthesis) {
        var precedence = getPrecedence(node, parenthesis);
        var exprPrecedence = getPrecedence(node.expr, parenthesis);
        return parenthesis === "all" || exprPrecedence !== null && exprPrecedence <= precedence;
      }
      FunctionAssignmentNode2.prototype._toString = function(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var expr = this.expr.toString(options);
        if (needParenthesis(this, parenthesis)) {
          expr = "(" + expr + ")";
        }
        return this.name + "(" + this.params.join(", ") + ") = " + expr;
      };
      FunctionAssignmentNode2.prototype.toJSON = function() {
        var types = this.types;
        return {
          mathjs: "FunctionAssignmentNode",
          name: this.name,
          params: this.params.map(function(param, index2) {
            return {
              name: param,
              type: types[index2]
            };
          }),
          expr: this.expr
        };
      };
      FunctionAssignmentNode2.fromJSON = function(json) {
        return new FunctionAssignmentNode2(json.name, json.params, json.expr);
      };
      FunctionAssignmentNode2.prototype.toHTML = function(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var params = [];
        for (var i2 = 0; i2 < this.params.length; i2++) {
          params.push('<span class="math-symbol math-parameter">' + escape(this.params[i2]) + "</span>");
        }
        var expr = this.expr.toHTML(options);
        if (needParenthesis(this, parenthesis)) {
          expr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + expr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        return '<span class="math-function">' + escape(this.name) + '</span><span class="math-parenthesis math-round-parenthesis">(</span>' + params.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-round-parenthesis">)</span><span class="math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator">=</span>' + expr;
      };
      FunctionAssignmentNode2.prototype._toTex = function(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var expr = this.expr.toTex(options);
        if (needParenthesis(this, parenthesis)) {
          expr = "\\left(".concat(expr, "\\right)");
        }
        return "\\mathrm{" + this.name + "}\\left(" + this.params.map(toSymbol).join(",") + "\\right):=" + expr;
      };
      return FunctionAssignmentNode2;
    }, {
      isClass: true,
      isNode: true
    });
  }
});

// node_modules/mathjs/lib/esm/expression/node/IndexNode.js
var name209, dependencies210, createIndexNode;
var init_IndexNode = __esm({
  "node_modules/mathjs/lib/esm/expression/node/IndexNode.js"() {
    init_array();
    init_customs();
    init_factory();
    init_is();
    init_string();
    name209 = "IndexNode";
    dependencies210 = ["Node", "size"];
    createIndexNode = /* @__PURE__ */ factory(name209, dependencies210, (_ref) => {
      var {
        Node: Node2,
        size: size2
      } = _ref;
      function IndexNode2(dimensions, dotNotation) {
        if (!(this instanceof IndexNode2)) {
          throw new SyntaxError("Constructor must be called with the new operator");
        }
        this.dimensions = dimensions;
        this.dotNotation = dotNotation || false;
        if (!Array.isArray(dimensions) || !dimensions.every(isNode)) {
          throw new TypeError('Array containing Nodes expected for parameter "dimensions"');
        }
        if (this.dotNotation && !this.isObjectProperty()) {
          throw new Error("dotNotation only applicable for object properties");
        }
      }
      IndexNode2.prototype = new Node2();
      IndexNode2.prototype.type = "IndexNode";
      IndexNode2.prototype.isIndexNode = true;
      IndexNode2.prototype._compile = function(math2, argNames) {
        var evalDimensions = map(this.dimensions, function(dimension, i2) {
          var needsEnd = dimension.filter((node) => node.isSymbolNode && node.name === "end").length > 0;
          if (needsEnd) {
            var childArgNames = Object.create(argNames);
            childArgNames.end = true;
            var _evalDimension = dimension._compile(math2, childArgNames);
            return function evalDimension(scope, args, context) {
              if (!isMatrix(context) && !isArray(context) && !isString2(context)) {
                throw new TypeError('Cannot resolve "end": context must be a Matrix, Array, or string but is ' + typeOf(context));
              }
              var s = size2(context).valueOf();
              var childArgs = Object.create(args);
              childArgs.end = s[i2];
              return _evalDimension(scope, childArgs, context);
            };
          } else {
            return dimension._compile(math2, argNames);
          }
        });
        var index2 = getSafeProperty(math2, "index");
        return function evalIndexNode(scope, args, context) {
          var dimensions = map(evalDimensions, function(evalDimension) {
            return evalDimension(scope, args, context);
          });
          return index2(...dimensions);
        };
      };
      IndexNode2.prototype.forEach = function(callback) {
        for (var i2 = 0; i2 < this.dimensions.length; i2++) {
          callback(this.dimensions[i2], "dimensions[" + i2 + "]", this);
        }
      };
      IndexNode2.prototype.map = function(callback) {
        var dimensions = [];
        for (var i2 = 0; i2 < this.dimensions.length; i2++) {
          dimensions[i2] = this._ifNode(callback(this.dimensions[i2], "dimensions[" + i2 + "]", this));
        }
        return new IndexNode2(dimensions, this.dotNotation);
      };
      IndexNode2.prototype.clone = function() {
        return new IndexNode2(this.dimensions.slice(0), this.dotNotation);
      };
      IndexNode2.prototype.isObjectProperty = function() {
        return this.dimensions.length === 1 && isConstantNode(this.dimensions[0]) && typeof this.dimensions[0].value === "string";
      };
      IndexNode2.prototype.getObjectProperty = function() {
        return this.isObjectProperty() ? this.dimensions[0].value : null;
      };
      IndexNode2.prototype._toString = function(options) {
        return this.dotNotation ? "." + this.getObjectProperty() : "[" + this.dimensions.join(", ") + "]";
      };
      IndexNode2.prototype.toJSON = function() {
        return {
          mathjs: "IndexNode",
          dimensions: this.dimensions,
          dotNotation: this.dotNotation
        };
      };
      IndexNode2.fromJSON = function(json) {
        return new IndexNode2(json.dimensions, json.dotNotation);
      };
      IndexNode2.prototype.toHTML = function(options) {
        var dimensions = [];
        for (var i2 = 0; i2 < this.dimensions.length; i2++) {
          dimensions[i2] = this.dimensions[i2].toHTML();
        }
        if (this.dotNotation) {
          return '<span class="math-operator math-accessor-operator">.</span><span class="math-symbol math-property">' + escape(this.getObjectProperty()) + "</span>";
        } else {
          return '<span class="math-parenthesis math-square-parenthesis">[</span>' + dimensions.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-square-parenthesis">]</span>';
        }
      };
      IndexNode2.prototype._toTex = function(options) {
        var dimensions = this.dimensions.map(function(range2) {
          return range2.toTex(options);
        });
        return this.dotNotation ? "." + this.getObjectProperty() : "_{" + dimensions.join(",") + "}";
      };
      return IndexNode2;
    }, {
      isClass: true,
      isNode: true
    });
  }
});

// node_modules/mathjs/lib/esm/expression/node/ObjectNode.js
var name210, dependencies211, createObjectNode;
var init_ObjectNode = __esm({
  "node_modules/mathjs/lib/esm/expression/node/ObjectNode.js"() {
    init_is();
    init_string();
    init_customs();
    init_object();
    init_factory();
    name210 = "ObjectNode";
    dependencies211 = ["Node"];
    createObjectNode = /* @__PURE__ */ factory(name210, dependencies211, (_ref) => {
      var {
        Node: Node2
      } = _ref;
      function ObjectNode2(properties2) {
        if (!(this instanceof ObjectNode2)) {
          throw new SyntaxError("Constructor must be called with the new operator");
        }
        this.properties = properties2 || {};
        if (properties2) {
          if (!(typeof properties2 === "object") || !Object.keys(properties2).every(function(key) {
            return isNode(properties2[key]);
          })) {
            throw new TypeError("Object containing Nodes expected");
          }
        }
      }
      ObjectNode2.prototype = new Node2();
      ObjectNode2.prototype.type = "ObjectNode";
      ObjectNode2.prototype.isObjectNode = true;
      ObjectNode2.prototype._compile = function(math2, argNames) {
        var evalEntries = {};
        for (var key in this.properties) {
          if (hasOwnProperty2(this.properties, key)) {
            var stringifiedKey = stringify(key);
            var parsedKey = JSON.parse(stringifiedKey);
            if (!isSafeProperty(this.properties, parsedKey)) {
              throw new Error('No access to property "' + parsedKey + '"');
            }
            evalEntries[parsedKey] = this.properties[key]._compile(math2, argNames);
          }
        }
        return function evalObjectNode(scope, args, context) {
          var obj = {};
          for (var _key in evalEntries) {
            if (hasOwnProperty2(evalEntries, _key)) {
              obj[_key] = evalEntries[_key](scope, args, context);
            }
          }
          return obj;
        };
      };
      ObjectNode2.prototype.forEach = function(callback) {
        for (var key in this.properties) {
          if (hasOwnProperty2(this.properties, key)) {
            callback(this.properties[key], "properties[" + stringify(key) + "]", this);
          }
        }
      };
      ObjectNode2.prototype.map = function(callback) {
        var properties2 = {};
        for (var key in this.properties) {
          if (hasOwnProperty2(this.properties, key)) {
            properties2[key] = this._ifNode(callback(this.properties[key], "properties[" + stringify(key) + "]", this));
          }
        }
        return new ObjectNode2(properties2);
      };
      ObjectNode2.prototype.clone = function() {
        var properties2 = {};
        for (var key in this.properties) {
          if (hasOwnProperty2(this.properties, key)) {
            properties2[key] = this.properties[key];
          }
        }
        return new ObjectNode2(properties2);
      };
      ObjectNode2.prototype._toString = function(options) {
        var entries = [];
        for (var key in this.properties) {
          if (hasOwnProperty2(this.properties, key)) {
            entries.push(stringify(key) + ": " + this.properties[key].toString(options));
          }
        }
        return "{" + entries.join(", ") + "}";
      };
      ObjectNode2.prototype.toJSON = function() {
        return {
          mathjs: "ObjectNode",
          properties: this.properties
        };
      };
      ObjectNode2.fromJSON = function(json) {
        return new ObjectNode2(json.properties);
      };
      ObjectNode2.prototype.toHTML = function(options) {
        var entries = [];
        for (var key in this.properties) {
          if (hasOwnProperty2(this.properties, key)) {
            entries.push('<span class="math-symbol math-property">' + escape(key) + '</span><span class="math-operator math-assignment-operator math-property-assignment-operator math-binary-operator">:</span>' + this.properties[key].toHTML(options));
          }
        }
        return '<span class="math-parenthesis math-curly-parenthesis">{</span>' + entries.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-curly-parenthesis">}</span>';
      };
      ObjectNode2.prototype._toTex = function(options) {
        var entries = [];
        for (var key in this.properties) {
          if (hasOwnProperty2(this.properties, key)) {
            entries.push("\\mathbf{" + key + ":} & " + this.properties[key].toTex(options) + "\\\\");
          }
        }
        return "\\left\\{\\begin{array}{ll}".concat(entries.join("\n"), "\\end{array}\\right\\}");
      };
      return ObjectNode2;
    }, {
      isClass: true,
      isNode: true
    });
  }
});

// node_modules/mathjs/lib/esm/expression/node/OperatorNode.js
var name211, dependencies212, createOperatorNode;
var init_OperatorNode = __esm({
  "node_modules/mathjs/lib/esm/expression/node/OperatorNode.js"() {
    init_is();
    init_array();
    init_string();
    init_customs();
    init_operators();
    init_latex();
    init_factory();
    name211 = "OperatorNode";
    dependencies212 = ["Node"];
    createOperatorNode = /* @__PURE__ */ factory(name211, dependencies212, (_ref) => {
      var {
        Node: Node2
      } = _ref;
      function OperatorNode2(op, fn, args, implicit, isPercentage) {
        if (!(this instanceof OperatorNode2)) {
          throw new SyntaxError("Constructor must be called with the new operator");
        }
        if (typeof op !== "string") {
          throw new TypeError('string expected for parameter "op"');
        }
        if (typeof fn !== "string") {
          throw new TypeError('string expected for parameter "fn"');
        }
        if (!Array.isArray(args) || !args.every(isNode)) {
          throw new TypeError('Array containing Nodes expected for parameter "args"');
        }
        this.implicit = implicit === true;
        this.isPercentage = isPercentage === true;
        this.op = op;
        this.fn = fn;
        this.args = args || [];
      }
      OperatorNode2.prototype = new Node2();
      OperatorNode2.prototype.type = "OperatorNode";
      OperatorNode2.prototype.isOperatorNode = true;
      OperatorNode2.prototype._compile = function(math2, argNames) {
        if (typeof this.fn !== "string" || !isSafeMethod(math2, this.fn)) {
          if (!math2[this.fn]) {
            throw new Error("Function " + this.fn + ' missing in provided namespace "math"');
          } else {
            throw new Error('No access to function "' + this.fn + '"');
          }
        }
        var fn = getSafeProperty(math2, this.fn);
        var evalArgs = map(this.args, function(arg2) {
          return arg2._compile(math2, argNames);
        });
        if (evalArgs.length === 1) {
          var evalArg0 = evalArgs[0];
          return function evalOperatorNode(scope, args, context) {
            return fn(evalArg0(scope, args, context));
          };
        } else if (evalArgs.length === 2) {
          var _evalArg = evalArgs[0];
          var evalArg1 = evalArgs[1];
          return function evalOperatorNode(scope, args, context) {
            return fn(_evalArg(scope, args, context), evalArg1(scope, args, context));
          };
        } else {
          return function evalOperatorNode(scope, args, context) {
            return fn.apply(null, map(evalArgs, function(evalArg) {
              return evalArg(scope, args, context);
            }));
          };
        }
      };
      OperatorNode2.prototype.forEach = function(callback) {
        for (var i2 = 0; i2 < this.args.length; i2++) {
          callback(this.args[i2], "args[" + i2 + "]", this);
        }
      };
      OperatorNode2.prototype.map = function(callback) {
        var args = [];
        for (var i2 = 0; i2 < this.args.length; i2++) {
          args[i2] = this._ifNode(callback(this.args[i2], "args[" + i2 + "]", this));
        }
        return new OperatorNode2(this.op, this.fn, args, this.implicit, this.isPercentage);
      };
      OperatorNode2.prototype.clone = function() {
        return new OperatorNode2(this.op, this.fn, this.args.slice(0), this.implicit, this.isPercentage);
      };
      OperatorNode2.prototype.isUnary = function() {
        return this.args.length === 1;
      };
      OperatorNode2.prototype.isBinary = function() {
        return this.args.length === 2;
      };
      function calculateNecessaryParentheses(root, parenthesis, implicit, args, latex) {
        var precedence = getPrecedence(root, parenthesis);
        var associativity = getAssociativity(root, parenthesis);
        if (parenthesis === "all" || args.length > 2 && root.getIdentifier() !== "OperatorNode:add" && root.getIdentifier() !== "OperatorNode:multiply") {
          return args.map(function(arg2) {
            switch (arg2.getContent().type) {
              case "ArrayNode":
              case "ConstantNode":
              case "SymbolNode":
              case "ParenthesisNode":
                return false;
              default:
                return true;
            }
          });
        }
        var result;
        switch (args.length) {
          case 0:
            result = [];
            break;
          case 1:
            {
              var operandPrecedence = getPrecedence(args[0], parenthesis);
              if (latex && operandPrecedence !== null) {
                var operandIdentifier;
                var rootIdentifier;
                if (parenthesis === "keep") {
                  operandIdentifier = args[0].getIdentifier();
                  rootIdentifier = root.getIdentifier();
                } else {
                  operandIdentifier = args[0].getContent().getIdentifier();
                  rootIdentifier = root.getContent().getIdentifier();
                }
                if (properties[precedence][rootIdentifier].latexLeftParens === false) {
                  result = [false];
                  break;
                }
                if (properties[operandPrecedence][operandIdentifier].latexParens === false) {
                  result = [false];
                  break;
                }
              }
              if (operandPrecedence === null) {
                result = [false];
                break;
              }
              if (operandPrecedence <= precedence) {
                result = [true];
                break;
              }
              result = [false];
            }
            break;
          case 2:
            {
              var lhsParens;
              var lhsPrecedence = getPrecedence(args[0], parenthesis);
              var assocWithLhs = isAssociativeWith(root, args[0], parenthesis);
              if (lhsPrecedence === null) {
                lhsParens = false;
              } else if (lhsPrecedence === precedence && associativity === "right" && !assocWithLhs) {
                lhsParens = true;
              } else if (lhsPrecedence < precedence) {
                lhsParens = true;
              } else {
                lhsParens = false;
              }
              var rhsParens;
              var rhsPrecedence = getPrecedence(args[1], parenthesis);
              var assocWithRhs = isAssociativeWith(root, args[1], parenthesis);
              if (rhsPrecedence === null) {
                rhsParens = false;
              } else if (rhsPrecedence === precedence && associativity === "left" && !assocWithRhs) {
                rhsParens = true;
              } else if (rhsPrecedence < precedence) {
                rhsParens = true;
              } else {
                rhsParens = false;
              }
              if (latex) {
                var _rootIdentifier;
                var lhsIdentifier;
                var rhsIdentifier;
                if (parenthesis === "keep") {
                  _rootIdentifier = root.getIdentifier();
                  lhsIdentifier = root.args[0].getIdentifier();
                  rhsIdentifier = root.args[1].getIdentifier();
                } else {
                  _rootIdentifier = root.getContent().getIdentifier();
                  lhsIdentifier = root.args[0].getContent().getIdentifier();
                  rhsIdentifier = root.args[1].getContent().getIdentifier();
                }
                if (lhsPrecedence !== null) {
                  if (properties[precedence][_rootIdentifier].latexLeftParens === false) {
                    lhsParens = false;
                  }
                  if (properties[lhsPrecedence][lhsIdentifier].latexParens === false) {
                    lhsParens = false;
                  }
                }
                if (rhsPrecedence !== null) {
                  if (properties[precedence][_rootIdentifier].latexRightParens === false) {
                    rhsParens = false;
                  }
                  if (properties[rhsPrecedence][rhsIdentifier].latexParens === false) {
                    rhsParens = false;
                  }
                }
              }
              result = [lhsParens, rhsParens];
            }
            break;
          default:
            if (root.getIdentifier() === "OperatorNode:add" || root.getIdentifier() === "OperatorNode:multiply") {
              result = args.map(function(arg2) {
                var argPrecedence = getPrecedence(arg2, parenthesis);
                var assocWithArg = isAssociativeWith(root, arg2, parenthesis);
                var argAssociativity = getAssociativity(arg2, parenthesis);
                if (argPrecedence === null) {
                  return false;
                } else if (precedence === argPrecedence && associativity === argAssociativity && !assocWithArg) {
                  return true;
                } else if (argPrecedence < precedence) {
                  return true;
                }
                return false;
              });
            }
            break;
        }
        if (args.length >= 2 && root.getIdentifier() === "OperatorNode:multiply" && root.implicit && parenthesis === "auto" && implicit === "hide") {
          result = args.map(function(arg2, index2) {
            var isParenthesisNode2 = arg2.getIdentifier() === "ParenthesisNode";
            if (result[index2] || isParenthesisNode2) {
              return true;
            }
            return false;
          });
        }
        return result;
      }
      OperatorNode2.prototype._toString = function(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var implicit = options && options.implicit ? options.implicit : "hide";
        var args = this.args;
        var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);
        if (args.length === 1) {
          var assoc = getAssociativity(this, parenthesis);
          var operand = args[0].toString(options);
          if (parens[0]) {
            operand = "(" + operand + ")";
          }
          var opIsNamed = /[a-zA-Z]+/.test(this.op);
          if (assoc === "right") {
            return this.op + (opIsNamed ? " " : "") + operand;
          } else if (assoc === "left") {
            return operand + (opIsNamed ? " " : "") + this.op;
          }
          return operand + this.op;
        } else if (args.length === 2) {
          var lhs = args[0].toString(options);
          var rhs = args[1].toString(options);
          if (parens[0]) {
            lhs = "(" + lhs + ")";
          }
          if (parens[1]) {
            rhs = "(" + rhs + ")";
          }
          if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
            return lhs + " " + rhs;
          }
          return lhs + " " + this.op + " " + rhs;
        } else if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
          var stringifiedArgs = args.map(function(arg2, index2) {
            arg2 = arg2.toString(options);
            if (parens[index2]) {
              arg2 = "(" + arg2 + ")";
            }
            return arg2;
          });
          if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
            return stringifiedArgs.join(" ");
          }
          return stringifiedArgs.join(" " + this.op + " ");
        } else {
          return this.fn + "(" + this.args.join(", ") + ")";
        }
      };
      OperatorNode2.prototype.toJSON = function() {
        return {
          mathjs: "OperatorNode",
          op: this.op,
          fn: this.fn,
          args: this.args,
          implicit: this.implicit,
          isPercentage: this.isPercentage
        };
      };
      OperatorNode2.fromJSON = function(json) {
        return new OperatorNode2(json.op, json.fn, json.args, json.implicit, json.isPercentage);
      };
      OperatorNode2.prototype.toHTML = function(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var implicit = options && options.implicit ? options.implicit : "hide";
        var args = this.args;
        var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);
        if (args.length === 1) {
          var assoc = getAssociativity(this, parenthesis);
          var operand = args[0].toHTML(options);
          if (parens[0]) {
            operand = '<span class="math-parenthesis math-round-parenthesis">(</span>' + operand + '<span class="math-parenthesis math-round-parenthesis">)</span>';
          }
          if (assoc === "right") {
            return '<span class="math-operator math-unary-operator math-lefthand-unary-operator">' + escape(this.op) + "</span>" + operand;
          } else {
            return operand + '<span class="math-operator math-unary-operator math-righthand-unary-operator">' + escape(this.op) + "</span>";
          }
        } else if (args.length === 2) {
          var lhs = args[0].toHTML(options);
          var rhs = args[1].toHTML(options);
          if (parens[0]) {
            lhs = '<span class="math-parenthesis math-round-parenthesis">(</span>' + lhs + '<span class="math-parenthesis math-round-parenthesis">)</span>';
          }
          if (parens[1]) {
            rhs = '<span class="math-parenthesis math-round-parenthesis">(</span>' + rhs + '<span class="math-parenthesis math-round-parenthesis">)</span>';
          }
          if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
            return lhs + '<span class="math-operator math-binary-operator math-implicit-binary-operator"></span>' + rhs;
          }
          return lhs + '<span class="math-operator math-binary-operator math-explicit-binary-operator">' + escape(this.op) + "</span>" + rhs;
        } else {
          var stringifiedArgs = args.map(function(arg2, index2) {
            arg2 = arg2.toHTML(options);
            if (parens[index2]) {
              arg2 = '<span class="math-parenthesis math-round-parenthesis">(</span>' + arg2 + '<span class="math-parenthesis math-round-parenthesis">)</span>';
            }
            return arg2;
          });
          if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
            if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
              return stringifiedArgs.join('<span class="math-operator math-binary-operator math-implicit-binary-operator"></span>');
            }
            return stringifiedArgs.join('<span class="math-operator math-binary-operator math-explicit-binary-operator">' + escape(this.op) + "</span>");
          } else {
            return '<span class="math-function">' + escape(this.fn) + '</span><span class="math-paranthesis math-round-parenthesis">(</span>' + stringifiedArgs.join('<span class="math-separator">,</span>') + '<span class="math-paranthesis math-round-parenthesis">)</span>';
          }
        }
      };
      OperatorNode2.prototype._toTex = function(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var implicit = options && options.implicit ? options.implicit : "hide";
        var args = this.args;
        var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, true);
        var op = latexOperators[this.fn];
        op = typeof op === "undefined" ? this.op : op;
        if (args.length === 1) {
          var assoc = getAssociativity(this, parenthesis);
          var operand = args[0].toTex(options);
          if (parens[0]) {
            operand = "\\left(".concat(operand, "\\right)");
          }
          if (assoc === "right") {
            return op + operand;
          } else if (assoc === "left") {
            return operand + op;
          }
          return operand + op;
        } else if (args.length === 2) {
          var lhs = args[0];
          var lhsTex = lhs.toTex(options);
          if (parens[0]) {
            lhsTex = "\\left(".concat(lhsTex, "\\right)");
          }
          var rhs = args[1];
          var rhsTex = rhs.toTex(options);
          if (parens[1]) {
            rhsTex = "\\left(".concat(rhsTex, "\\right)");
          }
          var lhsIdentifier;
          if (parenthesis === "keep") {
            lhsIdentifier = lhs.getIdentifier();
          } else {
            lhsIdentifier = lhs.getContent().getIdentifier();
          }
          switch (this.getIdentifier()) {
            case "OperatorNode:divide":
              return op + "{" + lhsTex + "}{" + rhsTex + "}";
            case "OperatorNode:pow":
              lhsTex = "{" + lhsTex + "}";
              rhsTex = "{" + rhsTex + "}";
              switch (lhsIdentifier) {
                case "ConditionalNode":
                case "OperatorNode:divide":
                  lhsTex = "\\left(".concat(lhsTex, "\\right)");
              }
              break;
            case "OperatorNode:multiply":
              if (this.implicit && implicit === "hide") {
                return lhsTex + "~" + rhsTex;
              }
          }
          return lhsTex + op + rhsTex;
        } else if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
          var texifiedArgs = args.map(function(arg2, index2) {
            arg2 = arg2.toTex(options);
            if (parens[index2]) {
              arg2 = "\\left(".concat(arg2, "\\right)");
            }
            return arg2;
          });
          if (this.getIdentifier() === "OperatorNode:multiply" && this.implicit) {
            return texifiedArgs.join("~");
          }
          return texifiedArgs.join(op);
        } else {
          return "\\mathrm{" + this.fn + "}\\left(" + args.map(function(arg2) {
            return arg2.toTex(options);
          }).join(",") + "\\right)";
        }
      };
      OperatorNode2.prototype.getIdentifier = function() {
        return this.type + ":" + this.fn;
      };
      return OperatorNode2;
    }, {
      isClass: true,
      isNode: true
    });
  }
});

// node_modules/mathjs/lib/esm/expression/node/ParenthesisNode.js
var name212, dependencies213, createParenthesisNode;
var init_ParenthesisNode = __esm({
  "node_modules/mathjs/lib/esm/expression/node/ParenthesisNode.js"() {
    init_is();
    init_factory();
    name212 = "ParenthesisNode";
    dependencies213 = ["Node"];
    createParenthesisNode = /* @__PURE__ */ factory(name212, dependencies213, (_ref) => {
      var {
        Node: Node2
      } = _ref;
      function ParenthesisNode2(content) {
        if (!(this instanceof ParenthesisNode2)) {
          throw new SyntaxError("Constructor must be called with the new operator");
        }
        if (!isNode(content)) {
          throw new TypeError('Node expected for parameter "content"');
        }
        this.content = content;
      }
      ParenthesisNode2.prototype = new Node2();
      ParenthesisNode2.prototype.type = "ParenthesisNode";
      ParenthesisNode2.prototype.isParenthesisNode = true;
      ParenthesisNode2.prototype._compile = function(math2, argNames) {
        return this.content._compile(math2, argNames);
      };
      ParenthesisNode2.prototype.getContent = function() {
        return this.content.getContent();
      };
      ParenthesisNode2.prototype.forEach = function(callback) {
        callback(this.content, "content", this);
      };
      ParenthesisNode2.prototype.map = function(callback) {
        var content = callback(this.content, "content", this);
        return new ParenthesisNode2(content);
      };
      ParenthesisNode2.prototype.clone = function() {
        return new ParenthesisNode2(this.content);
      };
      ParenthesisNode2.prototype._toString = function(options) {
        if (!options || options && !options.parenthesis || options && options.parenthesis === "keep") {
          return "(" + this.content.toString(options) + ")";
        }
        return this.content.toString(options);
      };
      ParenthesisNode2.prototype.toJSON = function() {
        return {
          mathjs: "ParenthesisNode",
          content: this.content
        };
      };
      ParenthesisNode2.fromJSON = function(json) {
        return new ParenthesisNode2(json.content);
      };
      ParenthesisNode2.prototype.toHTML = function(options) {
        if (!options || options && !options.parenthesis || options && options.parenthesis === "keep") {
          return '<span class="math-parenthesis math-round-parenthesis">(</span>' + this.content.toHTML(options) + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        return this.content.toHTML(options);
      };
      ParenthesisNode2.prototype._toTex = function(options) {
        if (!options || options && !options.parenthesis || options && options.parenthesis === "keep") {
          return "\\left(".concat(this.content.toTex(options), "\\right)");
        }
        return this.content.toTex(options);
      };
      return ParenthesisNode2;
    }, {
      isClass: true,
      isNode: true
    });
  }
});

// node_modules/mathjs/lib/esm/expression/node/RangeNode.js
var name213, dependencies214, createRangeNode;
var init_RangeNode = __esm({
  "node_modules/mathjs/lib/esm/expression/node/RangeNode.js"() {
    init_is();
    init_factory();
    init_operators();
    name213 = "RangeNode";
    dependencies214 = ["Node"];
    createRangeNode = /* @__PURE__ */ factory(name213, dependencies214, (_ref) => {
      var {
        Node: Node2
      } = _ref;
      function RangeNode2(start, end, step) {
        if (!(this instanceof RangeNode2)) {
          throw new SyntaxError("Constructor must be called with the new operator");
        }
        if (!isNode(start))
          throw new TypeError("Node expected");
        if (!isNode(end))
          throw new TypeError("Node expected");
        if (step && !isNode(step))
          throw new TypeError("Node expected");
        if (arguments.length > 3)
          throw new Error("Too many arguments");
        this.start = start;
        this.end = end;
        this.step = step || null;
      }
      RangeNode2.prototype = new Node2();
      RangeNode2.prototype.type = "RangeNode";
      RangeNode2.prototype.isRangeNode = true;
      RangeNode2.prototype.needsEnd = function() {
        var endSymbols = this.filter(function(node) {
          return isSymbolNode(node) && node.name === "end";
        });
        return endSymbols.length > 0;
      };
      RangeNode2.prototype._compile = function(math2, argNames) {
        var range2 = math2.range;
        var evalStart = this.start._compile(math2, argNames);
        var evalEnd = this.end._compile(math2, argNames);
        if (this.step) {
          var evalStep = this.step._compile(math2, argNames);
          return function evalRangeNode(scope, args, context) {
            return range2(evalStart(scope, args, context), evalEnd(scope, args, context), evalStep(scope, args, context));
          };
        } else {
          return function evalRangeNode(scope, args, context) {
            return range2(evalStart(scope, args, context), evalEnd(scope, args, context));
          };
        }
      };
      RangeNode2.prototype.forEach = function(callback) {
        callback(this.start, "start", this);
        callback(this.end, "end", this);
        if (this.step) {
          callback(this.step, "step", this);
        }
      };
      RangeNode2.prototype.map = function(callback) {
        return new RangeNode2(this._ifNode(callback(this.start, "start", this)), this._ifNode(callback(this.end, "end", this)), this.step && this._ifNode(callback(this.step, "step", this)));
      };
      RangeNode2.prototype.clone = function() {
        return new RangeNode2(this.start, this.end, this.step && this.step);
      };
      function calculateNecessaryParentheses(node, parenthesis) {
        var precedence = getPrecedence(node, parenthesis);
        var parens = {};
        var startPrecedence = getPrecedence(node.start, parenthesis);
        parens.start = startPrecedence !== null && startPrecedence <= precedence || parenthesis === "all";
        if (node.step) {
          var stepPrecedence = getPrecedence(node.step, parenthesis);
          parens.step = stepPrecedence !== null && stepPrecedence <= precedence || parenthesis === "all";
        }
        var endPrecedence = getPrecedence(node.end, parenthesis);
        parens.end = endPrecedence !== null && endPrecedence <= precedence || parenthesis === "all";
        return parens;
      }
      RangeNode2.prototype._toString = function(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var parens = calculateNecessaryParentheses(this, parenthesis);
        var str;
        var start = this.start.toString(options);
        if (parens.start) {
          start = "(" + start + ")";
        }
        str = start;
        if (this.step) {
          var step = this.step.toString(options);
          if (parens.step) {
            step = "(" + step + ")";
          }
          str += ":" + step;
        }
        var end = this.end.toString(options);
        if (parens.end) {
          end = "(" + end + ")";
        }
        str += ":" + end;
        return str;
      };
      RangeNode2.prototype.toJSON = function() {
        return {
          mathjs: "RangeNode",
          start: this.start,
          end: this.end,
          step: this.step
        };
      };
      RangeNode2.fromJSON = function(json) {
        return new RangeNode2(json.start, json.end, json.step);
      };
      RangeNode2.prototype.toHTML = function(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var parens = calculateNecessaryParentheses(this, parenthesis);
        var str;
        var start = this.start.toHTML(options);
        if (parens.start) {
          start = '<span class="math-parenthesis math-round-parenthesis">(</span>' + start + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        str = start;
        if (this.step) {
          var step = this.step.toHTML(options);
          if (parens.step) {
            step = '<span class="math-parenthesis math-round-parenthesis">(</span>' + step + '<span class="math-parenthesis math-round-parenthesis">)</span>';
          }
          str += '<span class="math-operator math-range-operator">:</span>' + step;
        }
        var end = this.end.toHTML(options);
        if (parens.end) {
          end = '<span class="math-parenthesis math-round-parenthesis">(</span>' + end + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        str += '<span class="math-operator math-range-operator">:</span>' + end;
        return str;
      };
      RangeNode2.prototype._toTex = function(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var parens = calculateNecessaryParentheses(this, parenthesis);
        var str = this.start.toTex(options);
        if (parens.start) {
          str = "\\left(".concat(str, "\\right)");
        }
        if (this.step) {
          var step = this.step.toTex(options);
          if (parens.step) {
            step = "\\left(".concat(step, "\\right)");
          }
          str += ":" + step;
        }
        var end = this.end.toTex(options);
        if (parens.end) {
          end = "\\left(".concat(end, "\\right)");
        }
        str += ":" + end;
        return str;
      };
      return RangeNode2;
    }, {
      isClass: true,
      isNode: true
    });
  }
});

// node_modules/mathjs/lib/esm/expression/node/RelationalNode.js
var name214, dependencies215, createRelationalNode;
var init_RelationalNode = __esm({
  "node_modules/mathjs/lib/esm/expression/node/RelationalNode.js"() {
    init_operators();
    init_string();
    init_customs();
    init_latex();
    init_factory();
    name214 = "RelationalNode";
    dependencies215 = ["Node"];
    createRelationalNode = /* @__PURE__ */ factory(name214, dependencies215, (_ref) => {
      var {
        Node: Node2
      } = _ref;
      function RelationalNode2(conditionals, params) {
        if (!(this instanceof RelationalNode2)) {
          throw new SyntaxError("Constructor must be called with the new operator");
        }
        if (!Array.isArray(conditionals))
          throw new TypeError("Parameter conditionals must be an array");
        if (!Array.isArray(params))
          throw new TypeError("Parameter params must be an array");
        if (conditionals.length !== params.length - 1)
          throw new TypeError("Parameter params must contain exactly one more element than parameter conditionals");
        this.conditionals = conditionals;
        this.params = params;
      }
      RelationalNode2.prototype = new Node2();
      RelationalNode2.prototype.type = "RelationalNode";
      RelationalNode2.prototype.isRelationalNode = true;
      RelationalNode2.prototype._compile = function(math2, argNames) {
        var self2 = this;
        var compiled = this.params.map((p) => p._compile(math2, argNames));
        return function evalRelationalNode(scope, args, context) {
          var evalLhs;
          var evalRhs = compiled[0](scope, args, context);
          for (var i2 = 0; i2 < self2.conditionals.length; i2++) {
            evalLhs = evalRhs;
            evalRhs = compiled[i2 + 1](scope, args, context);
            var condFn = getSafeProperty(math2, self2.conditionals[i2]);
            if (!condFn(evalLhs, evalRhs)) {
              return false;
            }
          }
          return true;
        };
      };
      RelationalNode2.prototype.forEach = function(callback) {
        this.params.forEach((n, i2) => callback(n, "params[" + i2 + "]", this), this);
      };
      RelationalNode2.prototype.map = function(callback) {
        return new RelationalNode2(this.conditionals.slice(), this.params.map((n, i2) => this._ifNode(callback(n, "params[" + i2 + "]", this)), this));
      };
      RelationalNode2.prototype.clone = function() {
        return new RelationalNode2(this.conditionals, this.params);
      };
      RelationalNode2.prototype._toString = function(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var precedence = getPrecedence(this, parenthesis);
        var paramStrings = this.params.map(function(p, index2) {
          var paramPrecedence = getPrecedence(p, parenthesis);
          return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? "(" + p.toString(options) + ")" : p.toString(options);
        });
        var operatorMap = {
          equal: "==",
          unequal: "!=",
          smaller: "<",
          larger: ">",
          smallerEq: "<=",
          largerEq: ">="
        };
        var ret = paramStrings[0];
        for (var i2 = 0; i2 < this.conditionals.length; i2++) {
          ret += " " + operatorMap[this.conditionals[i2]] + " " + paramStrings[i2 + 1];
        }
        return ret;
      };
      RelationalNode2.prototype.toJSON = function() {
        return {
          mathjs: "RelationalNode",
          conditionals: this.conditionals,
          params: this.params
        };
      };
      RelationalNode2.fromJSON = function(json) {
        return new RelationalNode2(json.conditionals, json.params);
      };
      RelationalNode2.prototype.toHTML = function(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var precedence = getPrecedence(this, parenthesis);
        var paramStrings = this.params.map(function(p, index2) {
          var paramPrecedence = getPrecedence(p, parenthesis);
          return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? '<span class="math-parenthesis math-round-parenthesis">(</span>' + p.toHTML(options) + '<span class="math-parenthesis math-round-parenthesis">)</span>' : p.toHTML(options);
        });
        var operatorMap = {
          equal: "==",
          unequal: "!=",
          smaller: "<",
          larger: ">",
          smallerEq: "<=",
          largerEq: ">="
        };
        var ret = paramStrings[0];
        for (var i2 = 0; i2 < this.conditionals.length; i2++) {
          ret += '<span class="math-operator math-binary-operator math-explicit-binary-operator">' + escape(operatorMap[this.conditionals[i2]]) + "</span>" + paramStrings[i2 + 1];
        }
        return ret;
      };
      RelationalNode2.prototype._toTex = function(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var precedence = getPrecedence(this, parenthesis);
        var paramStrings = this.params.map(function(p, index2) {
          var paramPrecedence = getPrecedence(p, parenthesis);
          return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? "\\left(" + p.toTex(options) + "\right)" : p.toTex(options);
        });
        var ret = paramStrings[0];
        for (var i2 = 0; i2 < this.conditionals.length; i2++) {
          ret += latexOperators[this.conditionals[i2]] + paramStrings[i2 + 1];
        }
        return ret;
      };
      return RelationalNode2;
    }, {
      isClass: true,
      isNode: true
    });
  }
});

// node_modules/mathjs/lib/esm/expression/node/SymbolNode.js
var name215, dependencies216, createSymbolNode;
var init_SymbolNode = __esm({
  "node_modules/mathjs/lib/esm/expression/node/SymbolNode.js"() {
    init_string();
    init_customs();
    init_factory();
    init_latex();
    name215 = "SymbolNode";
    dependencies216 = ["math", "?Unit", "Node"];
    createSymbolNode = /* @__PURE__ */ factory(name215, dependencies216, (_ref) => {
      var {
        math: math2,
        Unit: Unit2,
        Node: Node2
      } = _ref;
      function isValuelessUnit(name296) {
        return Unit2 ? Unit2.isValuelessUnit(name296) : false;
      }
      function SymbolNode2(name296) {
        if (!(this instanceof SymbolNode2)) {
          throw new SyntaxError("Constructor must be called with the new operator");
        }
        if (typeof name296 !== "string")
          throw new TypeError('String expected for parameter "name"');
        this.name = name296;
      }
      SymbolNode2.prototype = new Node2();
      SymbolNode2.prototype.type = "SymbolNode";
      SymbolNode2.prototype.isSymbolNode = true;
      SymbolNode2.prototype._compile = function(math3, argNames) {
        var name296 = this.name;
        if (argNames[name296] === true) {
          return function(scope, args, context) {
            return args[name296];
          };
        } else if (name296 in math3) {
          return function(scope, args, context) {
            return scope.has(name296) ? scope.get(name296) : getSafeProperty(math3, name296);
          };
        } else {
          var isUnit2 = isValuelessUnit(name296);
          return function(scope, args, context) {
            return scope.has(name296) ? scope.get(name296) : isUnit2 ? new Unit2(null, name296) : SymbolNode2.onUndefinedSymbol(name296);
          };
        }
      };
      SymbolNode2.prototype.forEach = function(callback) {
      };
      SymbolNode2.prototype.map = function(callback) {
        return this.clone();
      };
      SymbolNode2.onUndefinedSymbol = function(name296) {
        throw new Error("Undefined symbol " + name296);
      };
      SymbolNode2.prototype.clone = function() {
        return new SymbolNode2(this.name);
      };
      SymbolNode2.prototype._toString = function(options) {
        return this.name;
      };
      SymbolNode2.prototype.toHTML = function(options) {
        var name296 = escape(this.name);
        if (name296 === "true" || name296 === "false") {
          return '<span class="math-symbol math-boolean">' + name296 + "</span>";
        } else if (name296 === "i") {
          return '<span class="math-symbol math-imaginary-symbol">' + name296 + "</span>";
        } else if (name296 === "Infinity") {
          return '<span class="math-symbol math-infinity-symbol">' + name296 + "</span>";
        } else if (name296 === "NaN") {
          return '<span class="math-symbol math-nan-symbol">' + name296 + "</span>";
        } else if (name296 === "null") {
          return '<span class="math-symbol math-null-symbol">' + name296 + "</span>";
        } else if (name296 === "undefined") {
          return '<span class="math-symbol math-undefined-symbol">' + name296 + "</span>";
        }
        return '<span class="math-symbol">' + name296 + "</span>";
      };
      SymbolNode2.prototype.toJSON = function() {
        return {
          mathjs: "SymbolNode",
          name: this.name
        };
      };
      SymbolNode2.fromJSON = function(json) {
        return new SymbolNode2(json.name);
      };
      SymbolNode2.prototype._toTex = function(options) {
        var isUnit2 = false;
        if (typeof math2[this.name] === "undefined" && isValuelessUnit(this.name)) {
          isUnit2 = true;
        }
        var symbol = toSymbol(this.name, isUnit2);
        if (symbol[0] === "\\") {
          return symbol;
        }
        return " " + symbol;
      };
      return SymbolNode2;
    }, {
      isClass: true,
      isNode: true
    });
  }
});

// node_modules/mathjs/lib/esm/utils/scope.js
function createSubScope(parentScope) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  if (typeof parentScope.createSubScope === "function") {
    return assign(parentScope.createSubScope(), ...args);
  }
  return assign(createEmptyMap(), parentScope, ...args);
}
var init_scope = __esm({
  "node_modules/mathjs/lib/esm/utils/scope.js"() {
    init_map();
  }
});

// node_modules/mathjs/lib/esm/expression/node/FunctionNode.js
var name216, dependencies217, createFunctionNode;
var init_FunctionNode = __esm({
  "node_modules/mathjs/lib/esm/expression/node/FunctionNode.js"() {
    init_is();
    init_string();
    init_object();
    init_customs();
    init_scope();
    init_factory();
    init_latex();
    name216 = "FunctionNode";
    dependencies217 = ["math", "Node", "SymbolNode"];
    createFunctionNode = /* @__PURE__ */ factory(name216, dependencies217, (_ref) => {
      var {
        math: math2,
        Node: Node2,
        SymbolNode: SymbolNode2
      } = _ref;
      function FunctionNode2(fn, args) {
        if (!(this instanceof FunctionNode2)) {
          throw new SyntaxError("Constructor must be called with the new operator");
        }
        if (typeof fn === "string") {
          fn = new SymbolNode2(fn);
        }
        if (!isNode(fn))
          throw new TypeError('Node expected as parameter "fn"');
        if (!Array.isArray(args) || !args.every(isNode)) {
          throw new TypeError('Array containing Nodes expected for parameter "args"');
        }
        this.fn = fn;
        this.args = args || [];
        Object.defineProperty(this, "name", {
          get: function() {
            return this.fn.name || "";
          }.bind(this),
          set: function set() {
            throw new Error("Cannot assign a new name, name is read-only");
          }
        });
      }
      FunctionNode2.prototype = new Node2();
      FunctionNode2.prototype.type = "FunctionNode";
      FunctionNode2.prototype.isFunctionNode = true;
      var strin = (entity) => format3(entity, {
        truncate: 78
      });
      FunctionNode2.prototype._compile = function(math3, argNames) {
        if (!(this instanceof FunctionNode2)) {
          throw new TypeError("No valid FunctionNode");
        }
        var evalArgs = this.args.map((arg2) => arg2._compile(math3, argNames));
        if (isSymbolNode(this.fn)) {
          var _name = this.fn.name;
          if (!argNames[_name]) {
            var fn = _name in math3 ? getSafeProperty(math3, _name) : void 0;
            var isRaw = typeof fn === "function" && fn.rawArgs === true;
            var resolveFn = (scope) => {
              var value;
              if (scope.has(_name)) {
                value = scope.get(_name);
              } else if (_name in math3) {
                value = getSafeProperty(math3, _name);
              } else {
                return FunctionNode2.onUndefinedFunction(_name);
              }
              if (typeof value === "function") {
                return value;
              }
              throw new TypeError("'".concat(_name, "' is not a function; its value is:\n  ").concat(strin(value)));
            };
            if (isRaw) {
              var rawArgs = this.args;
              return function evalFunctionNode(scope, args, context) {
                var fn2 = resolveFn(scope);
                return fn2(rawArgs, math3, createSubScope(scope, args), scope);
              };
            } else {
              switch (evalArgs.length) {
                case 0:
                  return function evalFunctionNode(scope, args, context) {
                    var fn2 = resolveFn(scope);
                    return fn2();
                  };
                case 1:
                  return function evalFunctionNode(scope, args, context) {
                    var fn2 = resolveFn(scope);
                    var evalArg0 = evalArgs[0];
                    return fn2(evalArg0(scope, args, context));
                  };
                case 2:
                  return function evalFunctionNode(scope, args, context) {
                    var fn2 = resolveFn(scope);
                    var evalArg0 = evalArgs[0];
                    var evalArg1 = evalArgs[1];
                    return fn2(evalArg0(scope, args, context), evalArg1(scope, args, context));
                  };
                default:
                  return function evalFunctionNode(scope, args, context) {
                    var fn2 = resolveFn(scope);
                    var values = evalArgs.map((evalArg) => evalArg(scope, args, context));
                    return fn2(...values);
                  };
              }
            }
          } else {
            var _rawArgs = this.args;
            return function evalFunctionNode(scope, args, context) {
              var fn2 = args[_name];
              if (typeof fn2 !== "function") {
                throw new TypeError("Argument '".concat(_name, "' was not a function; received: ").concat(strin(fn2)));
              }
              if (fn2.rawArgs) {
                return fn2(_rawArgs, math3, createSubScope(scope, args), scope);
              } else {
                var values = evalArgs.map((evalArg) => evalArg(scope, args, context));
                return fn2.apply(fn2, values);
              }
            };
          }
        } else if (isAccessorNode(this.fn) && isIndexNode(this.fn.index) && this.fn.index.isObjectProperty()) {
          var evalObject = this.fn.object._compile(math3, argNames);
          var prop = this.fn.index.getObjectProperty();
          var _rawArgs2 = this.args;
          return function evalFunctionNode(scope, args, context) {
            var object = evalObject(scope, args, context);
            validateSafeMethod(object, prop);
            var isRaw2 = object[prop] && object[prop].rawArgs;
            if (isRaw2) {
              return object[prop](_rawArgs2, math3, createSubScope(scope, args), scope);
            } else {
              var values = evalArgs.map((evalArg) => evalArg(scope, args, context));
              return object[prop].apply(object, values);
            }
          };
        } else {
          var fnExpr = this.fn.toString();
          var evalFn = this.fn._compile(math3, argNames);
          var _rawArgs3 = this.args;
          return function evalFunctionNode(scope, args, context) {
            var fn2 = evalFn(scope, args, context);
            if (typeof fn2 !== "function") {
              throw new TypeError("Expression '".concat(fnExpr, "' did not evaluate to a function; value is:") + "\n  ".concat(strin(fn2)));
            }
            if (fn2.rawArgs) {
              return fn2(_rawArgs3, math3, createSubScope(scope, args), scope);
            } else {
              var values = evalArgs.map((evalArg) => evalArg(scope, args, context));
              return fn2.apply(fn2, values);
            }
          };
        }
      };
      FunctionNode2.prototype.forEach = function(callback) {
        callback(this.fn, "fn", this);
        for (var i2 = 0; i2 < this.args.length; i2++) {
          callback(this.args[i2], "args[" + i2 + "]", this);
        }
      };
      FunctionNode2.prototype.map = function(callback) {
        var fn = this._ifNode(callback(this.fn, "fn", this));
        var args = [];
        for (var i2 = 0; i2 < this.args.length; i2++) {
          args[i2] = this._ifNode(callback(this.args[i2], "args[" + i2 + "]", this));
        }
        return new FunctionNode2(fn, args);
      };
      FunctionNode2.prototype.clone = function() {
        return new FunctionNode2(this.fn, this.args.slice(0));
      };
      FunctionNode2.onUndefinedFunction = function(name296) {
        throw new Error("Undefined function " + name296);
      };
      var nodeToString = FunctionNode2.prototype.toString;
      FunctionNode2.prototype.toString = function(options) {
        var customString;
        var name296 = this.fn.toString(options);
        if (options && typeof options.handler === "object" && hasOwnProperty2(options.handler, name296)) {
          customString = options.handler[name296](this, options);
        }
        if (typeof customString !== "undefined") {
          return customString;
        }
        return nodeToString.call(this, options);
      };
      FunctionNode2.prototype._toString = function(options) {
        var args = this.args.map(function(arg2) {
          return arg2.toString(options);
        });
        var fn = isFunctionAssignmentNode(this.fn) ? "(" + this.fn.toString(options) + ")" : this.fn.toString(options);
        return fn + "(" + args.join(", ") + ")";
      };
      FunctionNode2.prototype.toJSON = function() {
        return {
          mathjs: "FunctionNode",
          fn: this.fn,
          args: this.args
        };
      };
      FunctionNode2.fromJSON = function(json) {
        return new FunctionNode2(json.fn, json.args);
      };
      FunctionNode2.prototype.toHTML = function(options) {
        var args = this.args.map(function(arg2) {
          return arg2.toHTML(options);
        });
        return '<span class="math-function">' + escape(this.fn) + '</span><span class="math-paranthesis math-round-parenthesis">(</span>' + args.join('<span class="math-separator">,</span>') + '<span class="math-paranthesis math-round-parenthesis">)</span>';
      };
      function expandTemplate(template, node, options) {
        var latex = "";
        var regex = /\$(?:\{([a-z_][a-z_0-9]*)(?:\[([0-9]+)\])?\}|\$)/gi;
        var inputPos = 0;
        var match;
        while ((match = regex.exec(template)) !== null) {
          latex += template.substring(inputPos, match.index);
          inputPos = match.index;
          if (match[0] === "$$") {
            latex += "$";
            inputPos++;
          } else {
            inputPos += match[0].length;
            var property = node[match[1]];
            if (!property) {
              throw new ReferenceError("Template: Property " + match[1] + " does not exist.");
            }
            if (match[2] === void 0) {
              switch (typeof property) {
                case "string":
                  latex += property;
                  break;
                case "object":
                  if (isNode(property)) {
                    latex += property.toTex(options);
                  } else if (Array.isArray(property)) {
                    latex += property.map(function(arg2, index2) {
                      if (isNode(arg2)) {
                        return arg2.toTex(options);
                      }
                      throw new TypeError("Template: " + match[1] + "[" + index2 + "] is not a Node.");
                    }).join(",");
                  } else {
                    throw new TypeError("Template: " + match[1] + " has to be a Node, String or array of Nodes");
                  }
                  break;
                default:
                  throw new TypeError("Template: " + match[1] + " has to be a Node, String or array of Nodes");
              }
            } else {
              if (isNode(property[match[2]] && property[match[2]])) {
                latex += property[match[2]].toTex(options);
              } else {
                throw new TypeError("Template: " + match[1] + "[" + match[2] + "] is not a Node.");
              }
            }
          }
        }
        latex += template.slice(inputPos);
        return latex;
      }
      var nodeToTex = FunctionNode2.prototype.toTex;
      FunctionNode2.prototype.toTex = function(options) {
        var customTex;
        if (options && typeof options.handler === "object" && hasOwnProperty2(options.handler, this.name)) {
          customTex = options.handler[this.name](this, options);
        }
        if (typeof customTex !== "undefined") {
          return customTex;
        }
        return nodeToTex.call(this, options);
      };
      FunctionNode2.prototype._toTex = function(options) {
        var args = this.args.map(function(arg2) {
          return arg2.toTex(options);
        });
        var latexConverter;
        if (latexFunctions[this.name]) {
          latexConverter = latexFunctions[this.name];
        }
        if (math2[this.name] && (typeof math2[this.name].toTex === "function" || typeof math2[this.name].toTex === "object" || typeof math2[this.name].toTex === "string")) {
          latexConverter = math2[this.name].toTex;
        }
        var customToTex;
        switch (typeof latexConverter) {
          case "function":
            customToTex = latexConverter(this, options);
            break;
          case "string":
            customToTex = expandTemplate(latexConverter, this, options);
            break;
          case "object":
            switch (typeof latexConverter[args.length]) {
              case "function":
                customToTex = latexConverter[args.length](this, options);
                break;
              case "string":
                customToTex = expandTemplate(latexConverter[args.length], this, options);
                break;
            }
        }
        if (typeof customToTex !== "undefined") {
          return customToTex;
        }
        return expandTemplate(defaultTemplate, this, options);
      };
      FunctionNode2.prototype.getIdentifier = function() {
        return this.type + ":" + this.name;
      };
      return FunctionNode2;
    }, {
      isClass: true,
      isNode: true
    });
  }
});

// node_modules/mathjs/lib/esm/expression/parse.js
var import_extends3, name217, dependencies218, createParse;
var init_parse = __esm({
  "node_modules/mathjs/lib/esm/expression/parse.js"() {
    import_extends3 = __toESM(require_extends(), 1);
    init_factory();
    init_is();
    init_collection();
    init_object();
    name217 = "parse";
    dependencies218 = ["typed", "numeric", "config", "AccessorNode", "ArrayNode", "AssignmentNode", "BlockNode", "ConditionalNode", "ConstantNode", "FunctionAssignmentNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "ParenthesisNode", "RangeNode", "RelationalNode", "SymbolNode"];
    createParse = /* @__PURE__ */ factory(name217, dependencies218, (_ref) => {
      var {
        typed: typed2,
        numeric: numeric3,
        config: config3,
        AccessorNode: AccessorNode2,
        ArrayNode: ArrayNode2,
        AssignmentNode: AssignmentNode2,
        BlockNode: BlockNode2,
        ConditionalNode: ConditionalNode2,
        ConstantNode: ConstantNode2,
        FunctionAssignmentNode: FunctionAssignmentNode2,
        FunctionNode: FunctionNode2,
        IndexNode: IndexNode2,
        ObjectNode: ObjectNode2,
        OperatorNode: OperatorNode2,
        ParenthesisNode: ParenthesisNode2,
        RangeNode: RangeNode2,
        RelationalNode: RelationalNode2,
        SymbolNode: SymbolNode2
      } = _ref;
      var parse2 = typed2(name217, {
        string: function string2(expression) {
          return parseStart(expression, {});
        },
        "Array | Matrix": function ArrayMatrix(expressions) {
          return parseMultiple(expressions, {});
        },
        "string, Object": function stringObject(expression, options) {
          var extraNodes = options.nodes !== void 0 ? options.nodes : {};
          return parseStart(expression, extraNodes);
        },
        "Array | Matrix, Object": parseMultiple
      });
      function parseMultiple(expressions) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var extraNodes = options.nodes !== void 0 ? options.nodes : {};
        return deepMap(expressions, function(elem) {
          if (typeof elem !== "string")
            throw new TypeError("String expected");
          return parseStart(elem, extraNodes);
        });
      }
      var TOKENTYPE = {
        NULL: 0,
        DELIMITER: 1,
        NUMBER: 2,
        SYMBOL: 3,
        UNKNOWN: 4
      };
      var DELIMITERS = {
        ",": true,
        "(": true,
        ")": true,
        "[": true,
        "]": true,
        "{": true,
        "}": true,
        '"': true,
        "'": true,
        ";": true,
        "+": true,
        "-": true,
        "*": true,
        ".*": true,
        "/": true,
        "./": true,
        "%": true,
        "^": true,
        ".^": true,
        "~": true,
        "!": true,
        "&": true,
        "|": true,
        "^|": true,
        "=": true,
        ":": true,
        "?": true,
        "==": true,
        "!=": true,
        "<": true,
        ">": true,
        "<=": true,
        ">=": true,
        "<<": true,
        ">>": true,
        ">>>": true
      };
      var NAMED_DELIMITERS = {
        mod: true,
        to: true,
        in: true,
        and: true,
        xor: true,
        or: true,
        not: true
      };
      var CONSTANTS = {
        true: true,
        false: false,
        null: null,
        undefined: void 0
      };
      var NUMERIC_CONSTANTS = ["NaN", "Infinity"];
      function initialState() {
        return {
          extraNodes: {},
          expression: "",
          comment: "",
          index: 0,
          token: "",
          tokenType: TOKENTYPE.NULL,
          nestingLevel: 0,
          conditionalLevel: null
        };
      }
      function currentString(state, length) {
        return state.expression.substr(state.index, length);
      }
      function currentCharacter(state) {
        return currentString(state, 1);
      }
      function next(state) {
        state.index++;
      }
      function prevCharacter(state) {
        return state.expression.charAt(state.index - 1);
      }
      function nextCharacter(state) {
        return state.expression.charAt(state.index + 1);
      }
      function getToken(state) {
        state.tokenType = TOKENTYPE.NULL;
        state.token = "";
        state.comment = "";
        while (true) {
          if (currentCharacter(state) === "#") {
            while (currentCharacter(state) !== "\n" && currentCharacter(state) !== "") {
              state.comment += currentCharacter(state);
              next(state);
            }
          }
          if (parse2.isWhitespace(currentCharacter(state), state.nestingLevel)) {
            next(state);
          } else {
            break;
          }
        }
        if (currentCharacter(state) === "") {
          state.tokenType = TOKENTYPE.DELIMITER;
          return;
        }
        if (currentCharacter(state) === "\n" && !state.nestingLevel) {
          state.tokenType = TOKENTYPE.DELIMITER;
          state.token = currentCharacter(state);
          next(state);
          return;
        }
        var c1 = currentCharacter(state);
        var c2 = currentString(state, 2);
        var c3 = currentString(state, 3);
        if (c3.length === 3 && DELIMITERS[c3]) {
          state.tokenType = TOKENTYPE.DELIMITER;
          state.token = c3;
          next(state);
          next(state);
          next(state);
          return;
        }
        if (c2.length === 2 && DELIMITERS[c2]) {
          state.tokenType = TOKENTYPE.DELIMITER;
          state.token = c2;
          next(state);
          next(state);
          return;
        }
        if (DELIMITERS[c1]) {
          state.tokenType = TOKENTYPE.DELIMITER;
          state.token = c1;
          next(state);
          return;
        }
        if (parse2.isDigitDot(c1)) {
          state.tokenType = TOKENTYPE.NUMBER;
          var _c = currentString(state, 2);
          if (_c === "0b" || _c === "0o" || _c === "0x") {
            state.token += currentCharacter(state);
            next(state);
            state.token += currentCharacter(state);
            next(state);
            while (parse2.isHexDigit(currentCharacter(state))) {
              state.token += currentCharacter(state);
              next(state);
            }
            if (currentCharacter(state) === ".") {
              state.token += ".";
              next(state);
              while (parse2.isHexDigit(currentCharacter(state))) {
                state.token += currentCharacter(state);
                next(state);
              }
            } else if (currentCharacter(state) === "i") {
              state.token += "i";
              next(state);
              while (parse2.isDigit(currentCharacter(state))) {
                state.token += currentCharacter(state);
                next(state);
              }
            }
            return;
          }
          if (currentCharacter(state) === ".") {
            state.token += currentCharacter(state);
            next(state);
            if (!parse2.isDigit(currentCharacter(state))) {
              state.tokenType = TOKENTYPE.DELIMITER;
              return;
            }
          } else {
            while (parse2.isDigit(currentCharacter(state))) {
              state.token += currentCharacter(state);
              next(state);
            }
            if (parse2.isDecimalMark(currentCharacter(state), nextCharacter(state))) {
              state.token += currentCharacter(state);
              next(state);
            }
          }
          while (parse2.isDigit(currentCharacter(state))) {
            state.token += currentCharacter(state);
            next(state);
          }
          if (currentCharacter(state) === "E" || currentCharacter(state) === "e") {
            if (parse2.isDigit(nextCharacter(state)) || nextCharacter(state) === "-" || nextCharacter(state) === "+") {
              state.token += currentCharacter(state);
              next(state);
              if (currentCharacter(state) === "+" || currentCharacter(state) === "-") {
                state.token += currentCharacter(state);
                next(state);
              }
              if (!parse2.isDigit(currentCharacter(state))) {
                throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
              }
              while (parse2.isDigit(currentCharacter(state))) {
                state.token += currentCharacter(state);
                next(state);
              }
              if (parse2.isDecimalMark(currentCharacter(state), nextCharacter(state))) {
                throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
              }
            } else if (nextCharacter(state) === ".") {
              next(state);
              throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
            }
          }
          return;
        }
        if (parse2.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state))) {
          while (parse2.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state)) || parse2.isDigit(currentCharacter(state))) {
            state.token += currentCharacter(state);
            next(state);
          }
          if (hasOwnProperty2(NAMED_DELIMITERS, state.token)) {
            state.tokenType = TOKENTYPE.DELIMITER;
          } else {
            state.tokenType = TOKENTYPE.SYMBOL;
          }
          return;
        }
        state.tokenType = TOKENTYPE.UNKNOWN;
        while (currentCharacter(state) !== "") {
          state.token += currentCharacter(state);
          next(state);
        }
        throw createSyntaxError(state, 'Syntax error in part "' + state.token + '"');
      }
      function getTokenSkipNewline(state) {
        do {
          getToken(state);
        } while (state.token === "\n");
      }
      function openParams(state) {
        state.nestingLevel++;
      }
      function closeParams(state) {
        state.nestingLevel--;
      }
      parse2.isAlpha = function isAlpha(c, cPrev, cNext) {
        return parse2.isValidLatinOrGreek(c) || parse2.isValidMathSymbol(c, cNext) || parse2.isValidMathSymbol(cPrev, c);
      };
      parse2.isValidLatinOrGreek = function isValidLatinOrGreek(c) {
        return /^[a-zA-Z_$\u00C0-\u02AF\u0370-\u03FF\u2100-\u214F]$/.test(c);
      };
      parse2.isValidMathSymbol = function isValidMathSymbol(high, low) {
        return /^[\uD835]$/.test(high) && /^[\uDC00-\uDFFF]$/.test(low) && /^[^\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]$/.test(low);
      };
      parse2.isWhitespace = function isWhitespace(c, nestingLevel) {
        return c === " " || c === "	" || c === "\n" && nestingLevel > 0;
      };
      parse2.isDecimalMark = function isDecimalMark(c, cNext) {
        return c === "." && cNext !== "/" && cNext !== "*" && cNext !== "^";
      };
      parse2.isDigitDot = function isDigitDot(c) {
        return c >= "0" && c <= "9" || c === ".";
      };
      parse2.isDigit = function isDigit(c) {
        return c >= "0" && c <= "9";
      };
      parse2.isHexDigit = function isHexDigit(c) {
        return c >= "0" && c <= "9" || c >= "a" && c <= "f" || c >= "A" && c <= "F";
      };
      function parseStart(expression, extraNodes) {
        var state = initialState();
        (0, import_extends3.default)(state, {
          expression,
          extraNodes
        });
        getToken(state);
        var node = parseBlock(state);
        if (state.token !== "") {
          if (state.tokenType === TOKENTYPE.DELIMITER) {
            throw createError(state, "Unexpected operator " + state.token);
          } else {
            throw createSyntaxError(state, 'Unexpected part "' + state.token + '"');
          }
        }
        return node;
      }
      function parseBlock(state) {
        var node;
        var blocks = [];
        var visible;
        if (state.token !== "" && state.token !== "\n" && state.token !== ";") {
          node = parseAssignment(state);
          node.comment = state.comment;
        }
        while (state.token === "\n" || state.token === ";") {
          if (blocks.length === 0 && node) {
            visible = state.token !== ";";
            blocks.push({
              node,
              visible
            });
          }
          getToken(state);
          if (state.token !== "\n" && state.token !== ";" && state.token !== "") {
            node = parseAssignment(state);
            node.comment = state.comment;
            visible = state.token !== ";";
            blocks.push({
              node,
              visible
            });
          }
        }
        if (blocks.length > 0) {
          return new BlockNode2(blocks);
        } else {
          if (!node) {
            node = new ConstantNode2(void 0);
            node.comment = state.comment;
          }
          return node;
        }
      }
      function parseAssignment(state) {
        var name296, args, value, valid;
        var node = parseConditional(state);
        if (state.token === "=") {
          if (isSymbolNode(node)) {
            name296 = node.name;
            getTokenSkipNewline(state);
            value = parseAssignment(state);
            return new AssignmentNode2(new SymbolNode2(name296), value);
          } else if (isAccessorNode(node)) {
            getTokenSkipNewline(state);
            value = parseAssignment(state);
            return new AssignmentNode2(node.object, node.index, value);
          } else if (isFunctionNode(node) && isSymbolNode(node.fn)) {
            valid = true;
            args = [];
            name296 = node.name;
            node.args.forEach(function(arg2, index2) {
              if (isSymbolNode(arg2)) {
                args[index2] = arg2.name;
              } else {
                valid = false;
              }
            });
            if (valid) {
              getTokenSkipNewline(state);
              value = parseAssignment(state);
              return new FunctionAssignmentNode2(name296, args, value);
            }
          }
          throw createSyntaxError(state, "Invalid left hand side of assignment operator =");
        }
        return node;
      }
      function parseConditional(state) {
        var node = parseLogicalOr(state);
        while (state.token === "?") {
          var prev = state.conditionalLevel;
          state.conditionalLevel = state.nestingLevel;
          getTokenSkipNewline(state);
          var condition = node;
          var trueExpr = parseAssignment(state);
          if (state.token !== ":")
            throw createSyntaxError(state, "False part of conditional expression expected");
          state.conditionalLevel = null;
          getTokenSkipNewline(state);
          var falseExpr = parseAssignment(state);
          node = new ConditionalNode2(condition, trueExpr, falseExpr);
          state.conditionalLevel = prev;
        }
        return node;
      }
      function parseLogicalOr(state) {
        var node = parseLogicalXor(state);
        while (state.token === "or") {
          getTokenSkipNewline(state);
          node = new OperatorNode2("or", "or", [node, parseLogicalXor(state)]);
        }
        return node;
      }
      function parseLogicalXor(state) {
        var node = parseLogicalAnd(state);
        while (state.token === "xor") {
          getTokenSkipNewline(state);
          node = new OperatorNode2("xor", "xor", [node, parseLogicalAnd(state)]);
        }
        return node;
      }
      function parseLogicalAnd(state) {
        var node = parseBitwiseOr(state);
        while (state.token === "and") {
          getTokenSkipNewline(state);
          node = new OperatorNode2("and", "and", [node, parseBitwiseOr(state)]);
        }
        return node;
      }
      function parseBitwiseOr(state) {
        var node = parseBitwiseXor(state);
        while (state.token === "|") {
          getTokenSkipNewline(state);
          node = new OperatorNode2("|", "bitOr", [node, parseBitwiseXor(state)]);
        }
        return node;
      }
      function parseBitwiseXor(state) {
        var node = parseBitwiseAnd(state);
        while (state.token === "^|") {
          getTokenSkipNewline(state);
          node = new OperatorNode2("^|", "bitXor", [node, parseBitwiseAnd(state)]);
        }
        return node;
      }
      function parseBitwiseAnd(state) {
        var node = parseRelational(state);
        while (state.token === "&") {
          getTokenSkipNewline(state);
          node = new OperatorNode2("&", "bitAnd", [node, parseRelational(state)]);
        }
        return node;
      }
      function parseRelational(state) {
        var params = [parseShift(state)];
        var conditionals = [];
        var operators = {
          "==": "equal",
          "!=": "unequal",
          "<": "smaller",
          ">": "larger",
          "<=": "smallerEq",
          ">=": "largerEq"
        };
        while (hasOwnProperty2(operators, state.token)) {
          var cond = {
            name: state.token,
            fn: operators[state.token]
          };
          conditionals.push(cond);
          getTokenSkipNewline(state);
          params.push(parseShift(state));
        }
        if (params.length === 1) {
          return params[0];
        } else if (params.length === 2) {
          return new OperatorNode2(conditionals[0].name, conditionals[0].fn, params);
        } else {
          return new RelationalNode2(conditionals.map((c) => c.fn), params);
        }
      }
      function parseShift(state) {
        var node, name296, fn, params;
        node = parseConversion(state);
        var operators = {
          "<<": "leftShift",
          ">>": "rightArithShift",
          ">>>": "rightLogShift"
        };
        while (hasOwnProperty2(operators, state.token)) {
          name296 = state.token;
          fn = operators[name296];
          getTokenSkipNewline(state);
          params = [node, parseConversion(state)];
          node = new OperatorNode2(name296, fn, params);
        }
        return node;
      }
      function parseConversion(state) {
        var node, name296, fn, params;
        node = parseRange(state);
        var operators = {
          to: "to",
          in: "to"
        };
        while (hasOwnProperty2(operators, state.token)) {
          name296 = state.token;
          fn = operators[name296];
          getTokenSkipNewline(state);
          if (name296 === "in" && state.token === "") {
            node = new OperatorNode2("*", "multiply", [node, new SymbolNode2("in")], true);
          } else {
            params = [node, parseRange(state)];
            node = new OperatorNode2(name296, fn, params);
          }
        }
        return node;
      }
      function parseRange(state) {
        var node;
        var params = [];
        if (state.token === ":") {
          node = new ConstantNode2(1);
        } else {
          node = parseAddSubtract(state);
        }
        if (state.token === ":" && state.conditionalLevel !== state.nestingLevel) {
          params.push(node);
          while (state.token === ":" && params.length < 3) {
            getTokenSkipNewline(state);
            if (state.token === ")" || state.token === "]" || state.token === "," || state.token === "") {
              params.push(new SymbolNode2("end"));
            } else {
              params.push(parseAddSubtract(state));
            }
          }
          if (params.length === 3) {
            node = new RangeNode2(params[0], params[2], params[1]);
          } else {
            node = new RangeNode2(params[0], params[1]);
          }
        }
        return node;
      }
      function parseAddSubtract(state) {
        var node, name296, fn, params;
        node = parseMultiplyDivide(state);
        var operators = {
          "+": "add",
          "-": "subtract"
        };
        while (hasOwnProperty2(operators, state.token)) {
          name296 = state.token;
          fn = operators[name296];
          getTokenSkipNewline(state);
          var rightNode = parseMultiplyDivide(state);
          if (rightNode.isPercentage) {
            params = [node, new OperatorNode2("*", "multiply", [node, rightNode])];
          } else {
            params = [node, rightNode];
          }
          node = new OperatorNode2(name296, fn, params);
        }
        return node;
      }
      function parseMultiplyDivide(state) {
        var node, last, name296, fn;
        node = parseImplicitMultiplication(state);
        last = node;
        var operators = {
          "*": "multiply",
          ".*": "dotMultiply",
          "/": "divide",
          "./": "dotDivide"
        };
        while (true) {
          if (hasOwnProperty2(operators, state.token)) {
            name296 = state.token;
            fn = operators[name296];
            getTokenSkipNewline(state);
            last = parseImplicitMultiplication(state);
            node = new OperatorNode2(name296, fn, [node, last]);
          } else {
            break;
          }
        }
        return node;
      }
      function parseImplicitMultiplication(state) {
        var node, last;
        node = parseRule2(state);
        last = node;
        while (true) {
          if (state.tokenType === TOKENTYPE.SYMBOL || state.token === "in" && isConstantNode(node) || state.tokenType === TOKENTYPE.NUMBER && !isConstantNode(last) && (!isOperatorNode(last) || last.op === "!") || state.token === "(") {
            last = parseRule2(state);
            node = new OperatorNode2(
              "*",
              "multiply",
              [node, last],
              true
            );
          } else {
            break;
          }
        }
        return node;
      }
      function parseRule2(state) {
        var node = parsePercentage(state);
        var last = node;
        var tokenStates = [];
        while (true) {
          if (state.token === "/" && isConstantNode(last)) {
            tokenStates.push((0, import_extends3.default)({}, state));
            getTokenSkipNewline(state);
            if (state.tokenType === TOKENTYPE.NUMBER) {
              tokenStates.push((0, import_extends3.default)({}, state));
              getTokenSkipNewline(state);
              if (state.tokenType === TOKENTYPE.SYMBOL || state.token === "(") {
                (0, import_extends3.default)(state, tokenStates.pop());
                tokenStates.pop();
                last = parsePercentage(state);
                node = new OperatorNode2("/", "divide", [node, last]);
              } else {
                tokenStates.pop();
                (0, import_extends3.default)(state, tokenStates.pop());
                break;
              }
            } else {
              (0, import_extends3.default)(state, tokenStates.pop());
              break;
            }
          } else {
            break;
          }
        }
        return node;
      }
      function parsePercentage(state) {
        var node, name296, fn, params;
        node = parseUnary(state);
        var operators = {
          "%": "mod",
          mod: "mod"
        };
        while (hasOwnProperty2(operators, state.token)) {
          name296 = state.token;
          fn = operators[name296];
          getTokenSkipNewline(state);
          if (name296 === "%" && state.tokenType === TOKENTYPE.DELIMITER && state.token !== "(") {
            node = new OperatorNode2("/", "divide", [node, new ConstantNode2(100)], false, true);
          } else {
            params = [node, parseUnary(state)];
            node = new OperatorNode2(name296, fn, params);
          }
        }
        return node;
      }
      function parseUnary(state) {
        var name296, params, fn;
        var operators = {
          "-": "unaryMinus",
          "+": "unaryPlus",
          "~": "bitNot",
          not: "not"
        };
        if (hasOwnProperty2(operators, state.token)) {
          fn = operators[state.token];
          name296 = state.token;
          getTokenSkipNewline(state);
          params = [parseUnary(state)];
          return new OperatorNode2(name296, fn, params);
        }
        return parsePow(state);
      }
      function parsePow(state) {
        var node, name296, fn, params;
        node = parseLeftHandOperators(state);
        if (state.token === "^" || state.token === ".^") {
          name296 = state.token;
          fn = name296 === "^" ? "pow" : "dotPow";
          getTokenSkipNewline(state);
          params = [node, parseUnary(state)];
          node = new OperatorNode2(name296, fn, params);
        }
        return node;
      }
      function parseLeftHandOperators(state) {
        var node, name296, fn, params;
        node = parseCustomNodes(state);
        var operators = {
          "!": "factorial",
          "'": "ctranspose"
        };
        while (hasOwnProperty2(operators, state.token)) {
          name296 = state.token;
          fn = operators[name296];
          getToken(state);
          params = [node];
          node = new OperatorNode2(name296, fn, params);
          node = parseAccessors(state, node);
        }
        return node;
      }
      function parseCustomNodes(state) {
        var params = [];
        if (state.tokenType === TOKENTYPE.SYMBOL && hasOwnProperty2(state.extraNodes, state.token)) {
          var CustomNode = state.extraNodes[state.token];
          getToken(state);
          if (state.token === "(") {
            params = [];
            openParams(state);
            getToken(state);
            if (state.token !== ")") {
              params.push(parseAssignment(state));
              while (state.token === ",") {
                getToken(state);
                params.push(parseAssignment(state));
              }
            }
            if (state.token !== ")") {
              throw createSyntaxError(state, "Parenthesis ) expected");
            }
            closeParams(state);
            getToken(state);
          }
          return new CustomNode(params);
        }
        return parseSymbol(state);
      }
      function parseSymbol(state) {
        var node, name296;
        if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {
          name296 = state.token;
          getToken(state);
          if (hasOwnProperty2(CONSTANTS, name296)) {
            node = new ConstantNode2(CONSTANTS[name296]);
          } else if (NUMERIC_CONSTANTS.indexOf(name296) !== -1) {
            node = new ConstantNode2(numeric3(name296, "number"));
          } else {
            node = new SymbolNode2(name296);
          }
          node = parseAccessors(state, node);
          return node;
        }
        return parseDoubleQuotesString(state);
      }
      function parseAccessors(state, node, types) {
        var params;
        while ((state.token === "(" || state.token === "[" || state.token === ".") && (!types || types.indexOf(state.token) !== -1)) {
          params = [];
          if (state.token === "(") {
            if (isSymbolNode(node) || isAccessorNode(node)) {
              openParams(state);
              getToken(state);
              if (state.token !== ")") {
                params.push(parseAssignment(state));
                while (state.token === ",") {
                  getToken(state);
                  params.push(parseAssignment(state));
                }
              }
              if (state.token !== ")") {
                throw createSyntaxError(state, "Parenthesis ) expected");
              }
              closeParams(state);
              getToken(state);
              node = new FunctionNode2(node, params);
            } else {
              return node;
            }
          } else if (state.token === "[") {
            openParams(state);
            getToken(state);
            if (state.token !== "]") {
              params.push(parseAssignment(state));
              while (state.token === ",") {
                getToken(state);
                params.push(parseAssignment(state));
              }
            }
            if (state.token !== "]") {
              throw createSyntaxError(state, "Parenthesis ] expected");
            }
            closeParams(state);
            getToken(state);
            node = new AccessorNode2(node, new IndexNode2(params));
          } else {
            getToken(state);
            if (state.tokenType !== TOKENTYPE.SYMBOL) {
              throw createSyntaxError(state, "Property name expected after dot");
            }
            params.push(new ConstantNode2(state.token));
            getToken(state);
            var dotNotation = true;
            node = new AccessorNode2(node, new IndexNode2(params, dotNotation));
          }
        }
        return node;
      }
      function parseDoubleQuotesString(state) {
        var node, str;
        if (state.token === '"') {
          str = parseDoubleQuotesStringToken(state);
          node = new ConstantNode2(str);
          node = parseAccessors(state, node);
          return node;
        }
        return parseSingleQuotesString(state);
      }
      function parseDoubleQuotesStringToken(state) {
        var str = "";
        while (currentCharacter(state) !== "" && currentCharacter(state) !== '"') {
          if (currentCharacter(state) === "\\") {
            str += currentCharacter(state);
            next(state);
          }
          str += currentCharacter(state);
          next(state);
        }
        getToken(state);
        if (state.token !== '"') {
          throw createSyntaxError(state, 'End of string " expected');
        }
        getToken(state);
        return JSON.parse('"' + str + '"');
      }
      function parseSingleQuotesString(state) {
        var node, str;
        if (state.token === "'") {
          str = parseSingleQuotesStringToken(state);
          node = new ConstantNode2(str);
          node = parseAccessors(state, node);
          return node;
        }
        return parseMatrix(state);
      }
      function parseSingleQuotesStringToken(state) {
        var str = "";
        while (currentCharacter(state) !== "" && currentCharacter(state) !== "'") {
          if (currentCharacter(state) === "\\") {
            str += currentCharacter(state);
            next(state);
          }
          str += currentCharacter(state);
          next(state);
        }
        getToken(state);
        if (state.token !== "'") {
          throw createSyntaxError(state, "End of string ' expected");
        }
        getToken(state);
        return JSON.parse('"' + str + '"');
      }
      function parseMatrix(state) {
        var array, params, rows, cols;
        if (state.token === "[") {
          openParams(state);
          getToken(state);
          if (state.token !== "]") {
            var row2 = parseRow(state);
            if (state.token === ";") {
              rows = 1;
              params = [row2];
              while (state.token === ";") {
                getToken(state);
                params[rows] = parseRow(state);
                rows++;
              }
              if (state.token !== "]") {
                throw createSyntaxError(state, "End of matrix ] expected");
              }
              closeParams(state);
              getToken(state);
              cols = params[0].items.length;
              for (var r = 1; r < rows; r++) {
                if (params[r].items.length !== cols) {
                  throw createError(state, "Column dimensions mismatch (" + params[r].items.length + " !== " + cols + ")");
                }
              }
              array = new ArrayNode2(params);
            } else {
              if (state.token !== "]") {
                throw createSyntaxError(state, "End of matrix ] expected");
              }
              closeParams(state);
              getToken(state);
              array = row2;
            }
          } else {
            closeParams(state);
            getToken(state);
            array = new ArrayNode2([]);
          }
          return parseAccessors(state, array);
        }
        return parseObject(state);
      }
      function parseRow(state) {
        var params = [parseAssignment(state)];
        var len = 1;
        while (state.token === ",") {
          getToken(state);
          params[len] = parseAssignment(state);
          len++;
        }
        return new ArrayNode2(params);
      }
      function parseObject(state) {
        if (state.token === "{") {
          openParams(state);
          var key;
          var properties2 = {};
          do {
            getToken(state);
            if (state.token !== "}") {
              if (state.token === '"') {
                key = parseDoubleQuotesStringToken(state);
              } else if (state.token === "'") {
                key = parseSingleQuotesStringToken(state);
              } else if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {
                key = state.token;
                getToken(state);
              } else {
                throw createSyntaxError(state, "Symbol or string expected as object key");
              }
              if (state.token !== ":") {
                throw createSyntaxError(state, "Colon : expected after object key");
              }
              getToken(state);
              properties2[key] = parseAssignment(state);
            }
          } while (state.token === ",");
          if (state.token !== "}") {
            throw createSyntaxError(state, "Comma , or bracket } expected after object value");
          }
          closeParams(state);
          getToken(state);
          var node = new ObjectNode2(properties2);
          node = parseAccessors(state, node);
          return node;
        }
        return parseNumber(state);
      }
      function parseNumber(state) {
        var numberStr;
        if (state.tokenType === TOKENTYPE.NUMBER) {
          numberStr = state.token;
          getToken(state);
          return new ConstantNode2(numeric3(numberStr, config3.number));
        }
        return parseParentheses(state);
      }
      function parseParentheses(state) {
        var node;
        if (state.token === "(") {
          openParams(state);
          getToken(state);
          node = parseAssignment(state);
          if (state.token !== ")") {
            throw createSyntaxError(state, "Parenthesis ) expected");
          }
          closeParams(state);
          getToken(state);
          node = new ParenthesisNode2(node);
          node = parseAccessors(state, node);
          return node;
        }
        return parseEnd(state);
      }
      function parseEnd(state) {
        if (state.token === "") {
          throw createSyntaxError(state, "Unexpected end of expression");
        } else {
          throw createSyntaxError(state, "Value expected");
        }
      }
      function col(state) {
        return state.index - state.token.length + 1;
      }
      function createSyntaxError(state, message) {
        var c = col(state);
        var error = new SyntaxError(message + " (char " + c + ")");
        error.char = c;
        return error;
      }
      function createError(state, message) {
        var c = col(state);
        var error = new SyntaxError(message + " (char " + c + ")");
        error.char = c;
        return error;
      }
      return parse2;
    });
  }
});

// node_modules/mathjs/lib/esm/expression/function/compile.js
var name218, dependencies219, createCompile;
var init_compile = __esm({
  "node_modules/mathjs/lib/esm/expression/function/compile.js"() {
    init_collection();
    init_factory();
    name218 = "compile";
    dependencies219 = ["typed", "parse"];
    createCompile = /* @__PURE__ */ factory(name218, dependencies219, (_ref) => {
      var {
        typed: typed2,
        parse: parse2
      } = _ref;
      return typed2(name218, {
        string: function string2(expr) {
          return parse2(expr).compile();
        },
        "Array | Matrix": function ArrayMatrix(expr) {
          return deepMap(expr, function(entry) {
            return parse2(entry).compile();
          });
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/expression/function/evaluate.js
var name219, dependencies220, createEvaluate;
var init_evaluate = __esm({
  "node_modules/mathjs/lib/esm/expression/function/evaluate.js"() {
    init_collection();
    init_factory();
    init_map();
    name219 = "evaluate";
    dependencies220 = ["typed", "parse"];
    createEvaluate = /* @__PURE__ */ factory(name219, dependencies220, (_ref) => {
      var {
        typed: typed2,
        parse: parse2
      } = _ref;
      return typed2(name219, {
        string: function string2(expr) {
          var scope = createEmptyMap();
          return parse2(expr).compile().evaluate(scope);
        },
        "string, Map | Object": function stringMapObject(expr, scope) {
          return parse2(expr).compile().evaluate(scope);
        },
        "Array | Matrix": function ArrayMatrix(expr) {
          var scope = createEmptyMap();
          return deepMap(expr, function(entry) {
            return parse2(entry).compile().evaluate(scope);
          });
        },
        "Array | Matrix, Map | Object": function ArrayMatrixMapObject(expr, scope) {
          return deepMap(expr, function(entry) {
            return parse2(entry).compile().evaluate(scope);
          });
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/expression/Parser.js
var name220, dependencies221, createParserClass;
var init_Parser = __esm({
  "node_modules/mathjs/lib/esm/expression/Parser.js"() {
    init_factory();
    init_map();
    name220 = "Parser";
    dependencies221 = ["evaluate"];
    createParserClass = /* @__PURE__ */ factory(name220, dependencies221, (_ref) => {
      var {
        evaluate: evaluate2
      } = _ref;
      function Parser2() {
        if (!(this instanceof Parser2)) {
          throw new SyntaxError("Constructor must be called with the new operator");
        }
        Object.defineProperty(this, "scope", {
          value: createEmptyMap(),
          writable: false
        });
      }
      Parser2.prototype.type = "Parser";
      Parser2.prototype.isParser = true;
      Parser2.prototype.evaluate = function(expr) {
        return evaluate2(expr, this.scope);
      };
      Parser2.prototype.get = function(name296) {
        if (this.scope.has(name296)) {
          return this.scope.get(name296);
        }
      };
      Parser2.prototype.getAll = function() {
        return toObject(this.scope);
      };
      Parser2.prototype.getAllAsMap = function() {
        return this.scope;
      };
      Parser2.prototype.set = function(name296, value) {
        this.scope.set(name296, value);
        return value;
      };
      Parser2.prototype.remove = function(name296) {
        this.scope.delete(name296);
      };
      Parser2.prototype.clear = function() {
        this.scope.clear();
      };
      return Parser2;
    }, {
      isClass: true
    });
  }
});

// node_modules/mathjs/lib/esm/expression/function/parser.js
var name221, dependencies222, createParser;
var init_parser = __esm({
  "node_modules/mathjs/lib/esm/expression/function/parser.js"() {
    init_factory();
    name221 = "parser";
    dependencies222 = ["typed", "Parser"];
    createParser = /* @__PURE__ */ factory(name221, dependencies222, (_ref) => {
      var {
        typed: typed2,
        Parser: Parser2
      } = _ref;
      return typed2(name221, {
        "": function _() {
          return new Parser2();
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/algebra/decomposition/lup.js
var name222, dependencies223, createLup;
var init_lup = __esm({
  "node_modules/mathjs/lib/esm/function/algebra/decomposition/lup.js"() {
    init_object();
    init_factory();
    name222 = "lup";
    dependencies223 = ["typed", "matrix", "abs", "addScalar", "divideScalar", "multiplyScalar", "subtract", "larger", "equalScalar", "unaryMinus", "DenseMatrix", "SparseMatrix", "Spa"];
    createLup = /* @__PURE__ */ factory(name222, dependencies223, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        abs: abs2,
        addScalar: addScalar2,
        divideScalar: divideScalar2,
        multiplyScalar: multiplyScalar2,
        subtract: subtract2,
        larger: larger2,
        equalScalar: equalScalar2,
        unaryMinus: unaryMinus2,
        DenseMatrix: DenseMatrix2,
        SparseMatrix: SparseMatrix2,
        Spa: Spa2
      } = _ref;
      return typed2(name222, {
        DenseMatrix: function DenseMatrix3(m) {
          return _denseLUP(m);
        },
        SparseMatrix: function SparseMatrix3(m) {
          return _sparseLUP(m);
        },
        Array: function Array2(a) {
          var m = matrix2(a);
          var r = _denseLUP(m);
          return {
            L: r.L.valueOf(),
            U: r.U.valueOf(),
            p: r.p
          };
        }
      });
      function _denseLUP(m) {
        var rows = m._size[0];
        var columns = m._size[1];
        var n = Math.min(rows, columns);
        var data = clone(m._data);
        var ldata = [];
        var lsize = [rows, n];
        var udata = [];
        var usize = [n, columns];
        var i2, j, k;
        var p = [];
        for (i2 = 0; i2 < rows; i2++) {
          p[i2] = i2;
        }
        for (j = 0; j < columns; j++) {
          if (j > 0) {
            for (i2 = 0; i2 < rows; i2++) {
              var min2 = Math.min(i2, j);
              var s = 0;
              for (k = 0; k < min2; k++) {
                s = addScalar2(s, multiplyScalar2(data[i2][k], data[k][j]));
              }
              data[i2][j] = subtract2(data[i2][j], s);
            }
          }
          var pi3 = j;
          var pabsv = 0;
          var vjj = 0;
          for (i2 = j; i2 < rows; i2++) {
            var v = data[i2][j];
            var absv = abs2(v);
            if (larger2(absv, pabsv)) {
              pi3 = i2;
              pabsv = absv;
              vjj = v;
            }
          }
          if (j !== pi3) {
            p[j] = [p[pi3], p[pi3] = p[j]][0];
            DenseMatrix2._swapRows(j, pi3, data);
          }
          if (j < rows) {
            for (i2 = j + 1; i2 < rows; i2++) {
              var vij = data[i2][j];
              if (!equalScalar2(vij, 0)) {
                data[i2][j] = divideScalar2(data[i2][j], vjj);
              }
            }
          }
        }
        for (j = 0; j < columns; j++) {
          for (i2 = 0; i2 < rows; i2++) {
            if (j === 0) {
              if (i2 < columns) {
                udata[i2] = [];
              }
              ldata[i2] = [];
            }
            if (i2 < j) {
              if (i2 < columns) {
                udata[i2][j] = data[i2][j];
              }
              if (j < rows) {
                ldata[i2][j] = 0;
              }
              continue;
            }
            if (i2 === j) {
              if (i2 < columns) {
                udata[i2][j] = data[i2][j];
              }
              if (j < rows) {
                ldata[i2][j] = 1;
              }
              continue;
            }
            if (i2 < columns) {
              udata[i2][j] = 0;
            }
            if (j < rows) {
              ldata[i2][j] = data[i2][j];
            }
          }
        }
        var l = new DenseMatrix2({
          data: ldata,
          size: lsize
        });
        var u = new DenseMatrix2({
          data: udata,
          size: usize
        });
        var pv = [];
        for (i2 = 0, n = p.length; i2 < n; i2++) {
          pv[p[i2]] = i2;
        }
        return {
          L: l,
          U: u,
          p: pv,
          toString: function toString() {
            return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\nP: " + this.p;
          }
        };
      }
      function _sparseLUP(m) {
        var rows = m._size[0];
        var columns = m._size[1];
        var n = Math.min(rows, columns);
        var values = m._values;
        var index2 = m._index;
        var ptr = m._ptr;
        var lvalues = [];
        var lindex = [];
        var lptr = [];
        var lsize = [rows, n];
        var uvalues = [];
        var uindex = [];
        var uptr = [];
        var usize = [n, columns];
        var i2, j, k;
        var pvCo = [];
        var pvOc = [];
        for (i2 = 0; i2 < rows; i2++) {
          pvCo[i2] = i2;
          pvOc[i2] = i2;
        }
        var swapIndeces = function swapIndeces2(x, y) {
          var kx = pvOc[x];
          var ky = pvOc[y];
          pvCo[kx] = y;
          pvCo[ky] = x;
          pvOc[x] = ky;
          pvOc[y] = kx;
        };
        var _loop = function _loop2() {
          var spa = new Spa2();
          if (j < rows) {
            lptr.push(lvalues.length);
            lvalues.push(1);
            lindex.push(j);
          }
          uptr.push(uvalues.length);
          var k0 = ptr[j];
          var k1 = ptr[j + 1];
          for (k = k0; k < k1; k++) {
            i2 = index2[k];
            spa.set(pvCo[i2], values[k]);
          }
          if (j > 0) {
            spa.forEach(0, j - 1, function(k2, vkj) {
              SparseMatrix2._forEachRow(k2, lvalues, lindex, lptr, function(i3, vik) {
                if (i3 > k2) {
                  spa.accumulate(i3, unaryMinus2(multiplyScalar2(vik, vkj)));
                }
              });
            });
          }
          var pi3 = j;
          var vjj = spa.get(j);
          var pabsv = abs2(vjj);
          spa.forEach(j + 1, rows - 1, function(x, v) {
            var absv = abs2(v);
            if (larger2(absv, pabsv)) {
              pi3 = x;
              pabsv = absv;
              vjj = v;
            }
          });
          if (j !== pi3) {
            SparseMatrix2._swapRows(j, pi3, lsize[1], lvalues, lindex, lptr);
            SparseMatrix2._swapRows(j, pi3, usize[1], uvalues, uindex, uptr);
            spa.swap(j, pi3);
            swapIndeces(j, pi3);
          }
          spa.forEach(0, rows - 1, function(x, v) {
            if (x <= j) {
              uvalues.push(v);
              uindex.push(x);
            } else {
              v = divideScalar2(v, vjj);
              if (!equalScalar2(v, 0)) {
                lvalues.push(v);
                lindex.push(x);
              }
            }
          });
        };
        for (j = 0; j < columns; j++) {
          _loop();
        }
        uptr.push(uvalues.length);
        lptr.push(lvalues.length);
        return {
          L: new SparseMatrix2({
            values: lvalues,
            index: lindex,
            ptr: lptr,
            size: lsize
          }),
          U: new SparseMatrix2({
            values: uvalues,
            index: uindex,
            ptr: uptr,
            size: usize
          }),
          p: pvCo,
          toString: function toString() {
            return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\nP: " + this.p;
          }
        };
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/algebra/decomposition/qr.js
var import_extends4, name223, dependencies224, createQr;
var init_qr = __esm({
  "node_modules/mathjs/lib/esm/function/algebra/decomposition/qr.js"() {
    import_extends4 = __toESM(require_extends(), 1);
    init_factory();
    name223 = "qr";
    dependencies224 = ["typed", "matrix", "zeros", "identity", "isZero", "equal", "sign", "sqrt", "conj", "unaryMinus", "addScalar", "divideScalar", "multiplyScalar", "subtract", "complex"];
    createQr = /* @__PURE__ */ factory(name223, dependencies224, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        zeros: zeros3,
        identity: identity2,
        isZero: isZero2,
        equal: equal2,
        sign: sign3,
        sqrt: sqrt2,
        conj: conj2,
        unaryMinus: unaryMinus2,
        addScalar: addScalar2,
        divideScalar: divideScalar2,
        multiplyScalar: multiplyScalar2,
        subtract: subtract2,
        complex: complex2
      } = _ref;
      return (0, import_extends4.default)(typed2(name223, {
        DenseMatrix: function DenseMatrix2(m) {
          return _denseQR(m);
        },
        SparseMatrix: function SparseMatrix2(m) {
          return _sparseQR(m);
        },
        Array: function Array2(a) {
          var m = matrix2(a);
          var r = _denseQR(m);
          return {
            Q: r.Q.valueOf(),
            R: r.R.valueOf()
          };
        }
      }), {
        _denseQRimpl
      });
      function _denseQRimpl(m) {
        var rows = m._size[0];
        var cols = m._size[1];
        var Q2 = identity2([rows], "dense");
        var Qdata = Q2._data;
        var R = m.clone();
        var Rdata = R._data;
        var i2, j, k;
        var w = zeros3([rows], "");
        for (k = 0; k < Math.min(cols, rows); ++k) {
          var pivot = Rdata[k][k];
          var sgn = unaryMinus2(equal2(pivot, 0) ? 1 : sign3(pivot));
          var conjSgn = conj2(sgn);
          var alphaSquared = 0;
          for (i2 = k; i2 < rows; i2++) {
            alphaSquared = addScalar2(alphaSquared, multiplyScalar2(Rdata[i2][k], conj2(Rdata[i2][k])));
          }
          var alpha = multiplyScalar2(sgn, sqrt2(alphaSquared));
          if (!isZero2(alpha)) {
            var u1 = subtract2(pivot, alpha);
            w[k] = 1;
            for (i2 = k + 1; i2 < rows; i2++) {
              w[i2] = divideScalar2(Rdata[i2][k], u1);
            }
            var tau3 = unaryMinus2(conj2(divideScalar2(u1, alpha)));
            var s = void 0;
            for (j = k; j < cols; j++) {
              s = 0;
              for (i2 = k; i2 < rows; i2++) {
                s = addScalar2(s, multiplyScalar2(conj2(w[i2]), Rdata[i2][j]));
              }
              s = multiplyScalar2(s, tau3);
              for (i2 = k; i2 < rows; i2++) {
                Rdata[i2][j] = multiplyScalar2(subtract2(Rdata[i2][j], multiplyScalar2(w[i2], s)), conjSgn);
              }
            }
            for (i2 = 0; i2 < rows; i2++) {
              s = 0;
              for (j = k; j < rows; j++) {
                s = addScalar2(s, multiplyScalar2(Qdata[i2][j], w[j]));
              }
              s = multiplyScalar2(s, tau3);
              for (j = k; j < rows; ++j) {
                Qdata[i2][j] = divideScalar2(subtract2(Qdata[i2][j], multiplyScalar2(s, conj2(w[j]))), conjSgn);
              }
            }
          }
        }
        return {
          Q: Q2,
          R,
          toString: function toString() {
            return "Q: " + this.Q.toString() + "\nR: " + this.R.toString();
          }
        };
      }
      function _denseQR(m) {
        var ret = _denseQRimpl(m);
        var Rdata = ret.R._data;
        if (m._data.length > 0) {
          var zero = Rdata[0][0].type === "Complex" ? complex2(0) : 0;
          for (var i2 = 0; i2 < Rdata.length; ++i2) {
            for (var j = 0; j < i2 && j < (Rdata[0] || []).length; ++j) {
              Rdata[i2][j] = zero;
            }
          }
        }
        return ret;
      }
      function _sparseQR(m) {
        throw new Error("qr not implemented for sparse matrices yet");
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csPermute.js
function csPermute(a, pinv2, q, values) {
  var avalues = a._values;
  var aindex = a._index;
  var aptr = a._ptr;
  var asize = a._size;
  var adt = a._datatype;
  var m = asize[0];
  var n = asize[1];
  var cvalues = values && a._values ? [] : null;
  var cindex = [];
  var cptr = [];
  var nz = 0;
  for (var k = 0; k < n; k++) {
    cptr[k] = nz;
    var j = q ? q[k] : k;
    for (var t0 = aptr[j], t1 = aptr[j + 1], t = t0; t < t1; t++) {
      var r = pinv2 ? pinv2[aindex[t]] : aindex[t];
      cindex[nz] = r;
      if (cvalues) {
        cvalues[nz] = avalues[t];
      }
      nz++;
    }
  }
  cptr[n] = nz;
  return a.createSparseMatrix({
    values: cvalues,
    index: cindex,
    ptr: cptr,
    size: [m, n],
    datatype: adt
  });
}
var init_csPermute = __esm({
  "node_modules/mathjs/lib/esm/function/algebra/sparse/csPermute.js"() {
  }
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csTdfs.js
function csTdfs(j, k, w, head, next, post, stack) {
  var top = 0;
  w[stack] = j;
  while (top >= 0) {
    var p = w[stack + top];
    var i2 = w[head + p];
    if (i2 === -1) {
      top--;
      post[k++] = p;
    } else {
      w[head + p] = w[next + i2];
      ++top;
      w[stack + top] = i2;
    }
  }
  return k;
}
var init_csTdfs = __esm({
  "node_modules/mathjs/lib/esm/function/algebra/sparse/csTdfs.js"() {
  }
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csPost.js
function csPost(parent2, n) {
  if (!parent2) {
    return null;
  }
  var k = 0;
  var j;
  var post = [];
  var w = [];
  var head = 0;
  var next = n;
  var stack = 2 * n;
  for (j = 0; j < n; j++) {
    w[head + j] = -1;
  }
  for (j = n - 1; j >= 0; j--) {
    if (parent2[j] === -1) {
      continue;
    }
    w[next + j] = w[head + parent2[j]];
    w[head + parent2[j]] = j;
  }
  for (j = 0; j < n; j++) {
    if (parent2[j] !== -1) {
      continue;
    }
    k = csTdfs(j, k, w, head, next, post, stack);
  }
  return post;
}
var init_csPost = __esm({
  "node_modules/mathjs/lib/esm/function/algebra/sparse/csPost.js"() {
    init_csTdfs();
  }
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csEtree.js
function csEtree(a, ata) {
  if (!a) {
    return null;
  }
  var aindex = a._index;
  var aptr = a._ptr;
  var asize = a._size;
  var m = asize[0];
  var n = asize[1];
  var parent2 = [];
  var w = [];
  var ancestor = 0;
  var prev = n;
  var i2, inext;
  if (ata) {
    for (i2 = 0; i2 < m; i2++) {
      w[prev + i2] = -1;
    }
  }
  for (var k = 0; k < n; k++) {
    parent2[k] = -1;
    w[ancestor + k] = -1;
    for (var p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {
      var r = aindex[p];
      i2 = ata ? w[prev + r] : r;
      for (; i2 !== -1 && i2 < k; i2 = inext) {
        inext = w[ancestor + i2];
        w[ancestor + i2] = k;
        if (inext === -1) {
          parent2[i2] = k;
        }
      }
      if (ata) {
        w[prev + r] = k;
      }
    }
  }
  return parent2;
}
var init_csEtree = __esm({
  "node_modules/mathjs/lib/esm/function/algebra/sparse/csEtree.js"() {
  }
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csFkeep.js
function csFkeep(a, callback, other) {
  var avalues = a._values;
  var aindex = a._index;
  var aptr = a._ptr;
  var asize = a._size;
  var n = asize[1];
  var nz = 0;
  for (var j = 0; j < n; j++) {
    var p = aptr[j];
    aptr[j] = nz;
    for (; p < aptr[j + 1]; p++) {
      if (callback(aindex[p], j, avalues ? avalues[p] : 1, other)) {
        aindex[nz] = aindex[p];
        if (avalues) {
          avalues[nz] = avalues[p];
        }
        nz++;
      }
    }
  }
  aptr[n] = nz;
  aindex.splice(nz, aindex.length - nz);
  if (avalues) {
    avalues.splice(nz, avalues.length - nz);
  }
  return nz;
}
var init_csFkeep = __esm({
  "node_modules/mathjs/lib/esm/function/algebra/sparse/csFkeep.js"() {
  }
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csFlip.js
function csFlip(i2) {
  return -i2 - 2;
}
var init_csFlip = __esm({
  "node_modules/mathjs/lib/esm/function/algebra/sparse/csFlip.js"() {
  }
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csAmd.js
var name224, dependencies225, createCsAmd;
var init_csAmd = __esm({
  "node_modules/mathjs/lib/esm/function/algebra/sparse/csAmd.js"() {
    init_factory();
    init_csFkeep();
    init_csFlip();
    init_csTdfs();
    name224 = "csAmd";
    dependencies225 = ["add", "multiply", "transpose"];
    createCsAmd = /* @__PURE__ */ factory(name224, dependencies225, (_ref) => {
      var {
        add: add2,
        multiply: multiply2,
        transpose: transpose2
      } = _ref;
      return function csAmd(order, a) {
        if (!a || order <= 0 || order > 3) {
          return null;
        }
        var asize = a._size;
        var m = asize[0];
        var n = asize[1];
        var lemax = 0;
        var dense = Math.max(16, 10 * Math.sqrt(n));
        dense = Math.min(n - 2, dense);
        var cm = _createTargetMatrix(order, a, m, n, dense);
        csFkeep(cm, _diag, null);
        var cindex = cm._index;
        var cptr = cm._ptr;
        var cnz = cptr[n];
        var P2 = [];
        var W = [];
        var len = 0;
        var nv = n + 1;
        var next = 2 * (n + 1);
        var head = 3 * (n + 1);
        var elen = 4 * (n + 1);
        var degree = 5 * (n + 1);
        var w = 6 * (n + 1);
        var hhead = 7 * (n + 1);
        var last = P2;
        var mark = _initializeQuotientGraph(n, cptr, W, len, head, last, next, hhead, nv, w, elen, degree);
        var nel = _initializeDegreeLists(n, cptr, W, degree, elen, w, dense, nv, head, last, next);
        var mindeg = 0;
        var i2, j, k, k1, k2, e3, pj, ln, nvi, pk, eln, p1, p2, pn, h, d;
        while (nel < n) {
          for (k = -1; mindeg < n && (k = W[head + mindeg]) === -1; mindeg++) {
            ;
          }
          if (W[next + k] !== -1) {
            last[W[next + k]] = -1;
          }
          W[head + mindeg] = W[next + k];
          var elenk = W[elen + k];
          var nvk = W[nv + k];
          nel += nvk;
          var dk = 0;
          W[nv + k] = -nvk;
          var p = cptr[k];
          var pk1 = elenk === 0 ? p : cnz;
          var pk2 = pk1;
          for (k1 = 1; k1 <= elenk + 1; k1++) {
            if (k1 > elenk) {
              e3 = k;
              pj = p;
              ln = W[len + k] - elenk;
            } else {
              e3 = cindex[p++];
              pj = cptr[e3];
              ln = W[len + e3];
            }
            for (k2 = 1; k2 <= ln; k2++) {
              i2 = cindex[pj++];
              if ((nvi = W[nv + i2]) <= 0) {
                continue;
              }
              dk += nvi;
              W[nv + i2] = -nvi;
              cindex[pk2++] = i2;
              if (W[next + i2] !== -1) {
                last[W[next + i2]] = last[i2];
              }
              if (last[i2] !== -1) {
                W[next + last[i2]] = W[next + i2];
              } else {
                W[head + W[degree + i2]] = W[next + i2];
              }
            }
            if (e3 !== k) {
              cptr[e3] = csFlip(k);
              W[w + e3] = 0;
            }
          }
          if (elenk !== 0) {
            cnz = pk2;
          }
          W[degree + k] = dk;
          cptr[k] = pk1;
          W[len + k] = pk2 - pk1;
          W[elen + k] = -2;
          mark = _wclear(mark, lemax, W, w, n);
          for (pk = pk1; pk < pk2; pk++) {
            i2 = cindex[pk];
            if ((eln = W[elen + i2]) <= 0) {
              continue;
            }
            nvi = -W[nv + i2];
            var wnvi = mark - nvi;
            for (p = cptr[i2], p1 = cptr[i2] + eln - 1; p <= p1; p++) {
              e3 = cindex[p];
              if (W[w + e3] >= mark) {
                W[w + e3] -= nvi;
              } else if (W[w + e3] !== 0) {
                W[w + e3] = W[degree + e3] + wnvi;
              }
            }
          }
          for (pk = pk1; pk < pk2; pk++) {
            i2 = cindex[pk];
            p1 = cptr[i2];
            p2 = p1 + W[elen + i2] - 1;
            pn = p1;
            for (h = 0, d = 0, p = p1; p <= p2; p++) {
              e3 = cindex[p];
              if (W[w + e3] !== 0) {
                var dext = W[w + e3] - mark;
                if (dext > 0) {
                  d += dext;
                  cindex[pn++] = e3;
                  h += e3;
                } else {
                  cptr[e3] = csFlip(k);
                  W[w + e3] = 0;
                }
              }
            }
            W[elen + i2] = pn - p1 + 1;
            var p3 = pn;
            var p4 = p1 + W[len + i2];
            for (p = p2 + 1; p < p4; p++) {
              j = cindex[p];
              var nvj = W[nv + j];
              if (nvj <= 0) {
                continue;
              }
              d += nvj;
              cindex[pn++] = j;
              h += j;
            }
            if (d === 0) {
              cptr[i2] = csFlip(k);
              nvi = -W[nv + i2];
              dk -= nvi;
              nvk += nvi;
              nel += nvi;
              W[nv + i2] = 0;
              W[elen + i2] = -1;
            } else {
              W[degree + i2] = Math.min(W[degree + i2], d);
              cindex[pn] = cindex[p3];
              cindex[p3] = cindex[p1];
              cindex[p1] = k;
              W[len + i2] = pn - p1 + 1;
              h = (h < 0 ? -h : h) % n;
              W[next + i2] = W[hhead + h];
              W[hhead + h] = i2;
              last[i2] = h;
            }
          }
          W[degree + k] = dk;
          lemax = Math.max(lemax, dk);
          mark = _wclear(mark + lemax, lemax, W, w, n);
          for (pk = pk1; pk < pk2; pk++) {
            i2 = cindex[pk];
            if (W[nv + i2] >= 0) {
              continue;
            }
            h = last[i2];
            i2 = W[hhead + h];
            W[hhead + h] = -1;
            for (; i2 !== -1 && W[next + i2] !== -1; i2 = W[next + i2], mark++) {
              ln = W[len + i2];
              eln = W[elen + i2];
              for (p = cptr[i2] + 1; p <= cptr[i2] + ln - 1; p++) {
                W[w + cindex[p]] = mark;
              }
              var jlast = i2;
              for (j = W[next + i2]; j !== -1; ) {
                var ok = W[len + j] === ln && W[elen + j] === eln;
                for (p = cptr[j] + 1; ok && p <= cptr[j] + ln - 1; p++) {
                  if (W[w + cindex[p]] !== mark) {
                    ok = 0;
                  }
                }
                if (ok) {
                  cptr[j] = csFlip(i2);
                  W[nv + i2] += W[nv + j];
                  W[nv + j] = 0;
                  W[elen + j] = -1;
                  j = W[next + j];
                  W[next + jlast] = j;
                } else {
                  jlast = j;
                  j = W[next + j];
                }
              }
            }
          }
          for (p = pk1, pk = pk1; pk < pk2; pk++) {
            i2 = cindex[pk];
            if ((nvi = -W[nv + i2]) <= 0) {
              continue;
            }
            W[nv + i2] = nvi;
            d = W[degree + i2] + dk - nvi;
            d = Math.min(d, n - nel - nvi);
            if (W[head + d] !== -1) {
              last[W[head + d]] = i2;
            }
            W[next + i2] = W[head + d];
            last[i2] = -1;
            W[head + d] = i2;
            mindeg = Math.min(mindeg, d);
            W[degree + i2] = d;
            cindex[p++] = i2;
          }
          W[nv + k] = nvk;
          if ((W[len + k] = p - pk1) === 0) {
            cptr[k] = -1;
            W[w + k] = 0;
          }
          if (elenk !== 0) {
            cnz = p;
          }
        }
        for (i2 = 0; i2 < n; i2++) {
          cptr[i2] = csFlip(cptr[i2]);
        }
        for (j = 0; j <= n; j++) {
          W[head + j] = -1;
        }
        for (j = n; j >= 0; j--) {
          if (W[nv + j] > 0) {
            continue;
          }
          W[next + j] = W[head + cptr[j]];
          W[head + cptr[j]] = j;
        }
        for (e3 = n; e3 >= 0; e3--) {
          if (W[nv + e3] <= 0) {
            continue;
          }
          if (cptr[e3] !== -1) {
            W[next + e3] = W[head + cptr[e3]];
            W[head + cptr[e3]] = e3;
          }
        }
        for (k = 0, i2 = 0; i2 <= n; i2++) {
          if (cptr[i2] === -1) {
            k = csTdfs(i2, k, W, head, next, P2, w);
          }
        }
        P2.splice(P2.length - 1, 1);
        return P2;
      };
      function _createTargetMatrix(order, a, m, n, dense) {
        var at = transpose2(a);
        if (order === 1 && n === m) {
          return add2(a, at);
        }
        if (order === 2) {
          var tindex = at._index;
          var tptr = at._ptr;
          var p2 = 0;
          for (var j = 0; j < m; j++) {
            var p = tptr[j];
            tptr[j] = p2;
            if (tptr[j + 1] - p > dense) {
              continue;
            }
            for (var p1 = tptr[j + 1]; p < p1; p++) {
              tindex[p2++] = tindex[p];
            }
          }
          tptr[m] = p2;
          a = transpose2(at);
          return multiply2(at, a);
        }
        return multiply2(at, a);
      }
      function _initializeQuotientGraph(n, cptr, W, len, head, last, next, hhead, nv, w, elen, degree) {
        for (var k = 0; k < n; k++) {
          W[len + k] = cptr[k + 1] - cptr[k];
        }
        W[len + n] = 0;
        for (var i2 = 0; i2 <= n; i2++) {
          W[head + i2] = -1;
          last[i2] = -1;
          W[next + i2] = -1;
          W[hhead + i2] = -1;
          W[nv + i2] = 1;
          W[w + i2] = 1;
          W[elen + i2] = 0;
          W[degree + i2] = W[len + i2];
        }
        var mark = _wclear(0, 0, W, w, n);
        W[elen + n] = -2;
        cptr[n] = -1;
        W[w + n] = 0;
        return mark;
      }
      function _initializeDegreeLists(n, cptr, W, degree, elen, w, dense, nv, head, last, next) {
        var nel = 0;
        for (var i2 = 0; i2 < n; i2++) {
          var d = W[degree + i2];
          if (d === 0) {
            W[elen + i2] = -2;
            nel++;
            cptr[i2] = -1;
            W[w + i2] = 0;
          } else if (d > dense) {
            W[nv + i2] = 0;
            W[elen + i2] = -1;
            nel++;
            cptr[i2] = csFlip(n);
            W[nv + n]++;
          } else {
            var h = W[head + d];
            if (h !== -1) {
              last[h] = i2;
            }
            W[next + i2] = W[head + d];
            W[head + d] = i2;
          }
        }
        return nel;
      }
      function _wclear(mark, lemax, W, w, n) {
        if (mark < 2 || mark + lemax < 0) {
          for (var k = 0; k < n; k++) {
            if (W[w + k] !== 0) {
              W[w + k] = 1;
            }
          }
          mark = 2;
        }
        return mark;
      }
      function _diag(i2, j) {
        return i2 !== j;
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csLeaf.js
function csLeaf(i2, j, w, first, maxfirst, prevleaf, ancestor) {
  var s, sparent;
  var jleaf = 0;
  var q;
  if (i2 <= j || w[first + j] <= w[maxfirst + i2]) {
    return -1;
  }
  w[maxfirst + i2] = w[first + j];
  var jprev = w[prevleaf + i2];
  w[prevleaf + i2] = j;
  if (jprev === -1) {
    jleaf = 1;
    q = i2;
  } else {
    jleaf = 2;
    for (q = jprev; q !== w[ancestor + q]; q = w[ancestor + q]) {
      ;
    }
    for (s = jprev; s !== q; s = sparent) {
      sparent = w[ancestor + s];
      w[ancestor + s] = q;
    }
  }
  return {
    jleaf,
    q
  };
}
var init_csLeaf = __esm({
  "node_modules/mathjs/lib/esm/function/algebra/sparse/csLeaf.js"() {
  }
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csCounts.js
var name225, dependencies226, createCsCounts;
var init_csCounts = __esm({
  "node_modules/mathjs/lib/esm/function/algebra/sparse/csCounts.js"() {
    init_factory();
    init_csLeaf();
    name225 = "csCounts";
    dependencies226 = ["transpose"];
    createCsCounts = /* @__PURE__ */ factory(name225, dependencies226, (_ref) => {
      var {
        transpose: transpose2
      } = _ref;
      return function(a, parent2, post, ata) {
        if (!a || !parent2 || !post) {
          return null;
        }
        var asize = a._size;
        var m = asize[0];
        var n = asize[1];
        var i2, j, k, J, p, p0, p1;
        var s = 4 * n + (ata ? n + m + 1 : 0);
        var w = [];
        var ancestor = 0;
        var maxfirst = n;
        var prevleaf = 2 * n;
        var first = 3 * n;
        var head = 4 * n;
        var next = 5 * n + 1;
        for (k = 0; k < s; k++) {
          w[k] = -1;
        }
        var colcount = [];
        var at = transpose2(a);
        var tindex = at._index;
        var tptr = at._ptr;
        for (k = 0; k < n; k++) {
          j = post[k];
          colcount[j] = w[first + j] === -1 ? 1 : 0;
          for (; j !== -1 && w[first + j] === -1; j = parent2[j]) {
            w[first + j] = k;
          }
        }
        if (ata) {
          for (k = 0; k < n; k++) {
            w[post[k]] = k;
          }
          for (i2 = 0; i2 < m; i2++) {
            for (k = n, p0 = tptr[i2], p1 = tptr[i2 + 1], p = p0; p < p1; p++) {
              k = Math.min(k, w[tindex[p]]);
            }
            w[next + i2] = w[head + k];
            w[head + k] = i2;
          }
        }
        for (i2 = 0; i2 < n; i2++) {
          w[ancestor + i2] = i2;
        }
        for (k = 0; k < n; k++) {
          j = post[k];
          if (parent2[j] !== -1) {
            colcount[parent2[j]]--;
          }
          for (J = ata ? w[head + k] : j; J !== -1; J = ata ? w[next + J] : -1) {
            for (p = tptr[J]; p < tptr[J + 1]; p++) {
              i2 = tindex[p];
              var r = csLeaf(i2, j, w, first, maxfirst, prevleaf, ancestor);
              if (r.jleaf >= 1) {
                colcount[j]++;
              }
              if (r.jleaf === 2) {
                colcount[r.q]--;
              }
            }
          }
          if (parent2[j] !== -1) {
            w[ancestor + j] = parent2[j];
          }
        }
        for (j = 0; j < n; j++) {
          if (parent2[j] !== -1) {
            colcount[parent2[j]] += colcount[j];
          }
        }
        return colcount;
      };
    });
  }
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csSqr.js
var name226, dependencies227, createCsSqr;
var init_csSqr = __esm({
  "node_modules/mathjs/lib/esm/function/algebra/sparse/csSqr.js"() {
    init_csPermute();
    init_csPost();
    init_csEtree();
    init_csAmd();
    init_csCounts();
    init_factory();
    name226 = "csSqr";
    dependencies227 = ["add", "multiply", "transpose"];
    createCsSqr = /* @__PURE__ */ factory(name226, dependencies227, (_ref) => {
      var {
        add: add2,
        multiply: multiply2,
        transpose: transpose2
      } = _ref;
      var csAmd = createCsAmd({
        add: add2,
        multiply: multiply2,
        transpose: transpose2
      });
      var csCounts = createCsCounts({
        transpose: transpose2
      });
      return function csSqr(order, a, qr2) {
        var aptr = a._ptr;
        var asize = a._size;
        var n = asize[1];
        var k;
        var s = {};
        s.q = csAmd(order, a);
        if (order && !s.q) {
          return null;
        }
        if (qr2) {
          var c = order ? csPermute(a, null, s.q, 0) : a;
          s.parent = csEtree(c, 1);
          var post = csPost(s.parent, n);
          s.cp = csCounts(c, s.parent, post, 1);
          if (c && s.parent && s.cp && _vcount(c, s)) {
            for (s.unz = 0, k = 0; k < n; k++) {
              s.unz += s.cp[k];
            }
          }
        } else {
          s.unz = 4 * aptr[n] + n;
          s.lnz = s.unz;
        }
        return s;
      };
      function _vcount(a, s) {
        var aptr = a._ptr;
        var aindex = a._index;
        var asize = a._size;
        var m = asize[0];
        var n = asize[1];
        s.pinv = [];
        s.leftmost = [];
        var parent2 = s.parent;
        var pinv2 = s.pinv;
        var leftmost = s.leftmost;
        var w = [];
        var next = 0;
        var head = m;
        var tail = m + n;
        var nque = m + 2 * n;
        var i2, k, p, p0, p1;
        for (k = 0; k < n; k++) {
          w[head + k] = -1;
          w[tail + k] = -1;
          w[nque + k] = 0;
        }
        for (i2 = 0; i2 < m; i2++) {
          leftmost[i2] = -1;
        }
        for (k = n - 1; k >= 0; k--) {
          for (p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {
            leftmost[aindex[p]] = k;
          }
        }
        for (i2 = m - 1; i2 >= 0; i2--) {
          pinv2[i2] = -1;
          k = leftmost[i2];
          if (k === -1) {
            continue;
          }
          if (w[nque + k]++ === 0) {
            w[tail + k] = i2;
          }
          w[next + i2] = w[head + k];
          w[head + k] = i2;
        }
        s.lnz = 0;
        s.m2 = m;
        for (k = 0; k < n; k++) {
          i2 = w[head + k];
          s.lnz++;
          if (i2 < 0) {
            i2 = s.m2++;
          }
          pinv2[i2] = k;
          if (--nque[k] <= 0) {
            continue;
          }
          s.lnz += w[nque + k];
          var pa = parent2[k];
          if (pa !== -1) {
            if (w[nque + pa] === 0) {
              w[tail + pa] = w[tail + k];
            }
            w[next + w[tail + k]] = w[head + pa];
            w[head + pa] = w[next + i2];
            w[nque + pa] += w[nque + k];
          }
        }
        for (i2 = 0; i2 < m; i2++) {
          if (pinv2[i2] < 0) {
            pinv2[i2] = k++;
          }
        }
        return true;
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csMarked.js
function csMarked(w, j) {
  return w[j] < 0;
}
var init_csMarked = __esm({
  "node_modules/mathjs/lib/esm/function/algebra/sparse/csMarked.js"() {
  }
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csMark.js
function csMark(w, j) {
  w[j] = csFlip(w[j]);
}
var init_csMark = __esm({
  "node_modules/mathjs/lib/esm/function/algebra/sparse/csMark.js"() {
    init_csFlip();
  }
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csUnflip.js
function csUnflip(i2) {
  return i2 < 0 ? csFlip(i2) : i2;
}
var init_csUnflip = __esm({
  "node_modules/mathjs/lib/esm/function/algebra/sparse/csUnflip.js"() {
    init_csFlip();
  }
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csDfs.js
function csDfs(j, g2, top, xi, pinv2) {
  var index2 = g2._index;
  var ptr = g2._ptr;
  var size2 = g2._size;
  var n = size2[1];
  var i2, p, p2;
  var head = 0;
  xi[0] = j;
  while (head >= 0) {
    j = xi[head];
    var jnew = pinv2 ? pinv2[j] : j;
    if (!csMarked(ptr, j)) {
      csMark(ptr, j);
      xi[n + head] = jnew < 0 ? 0 : csUnflip(ptr[jnew]);
    }
    var done = 1;
    for (p = xi[n + head], p2 = jnew < 0 ? 0 : csUnflip(ptr[jnew + 1]); p < p2; p++) {
      i2 = index2[p];
      if (csMarked(ptr, i2)) {
        continue;
      }
      xi[n + head] = p;
      xi[++head] = i2;
      done = 0;
      break;
    }
    if (done) {
      head--;
      xi[--top] = j;
    }
  }
  return top;
}
var init_csDfs = __esm({
  "node_modules/mathjs/lib/esm/function/algebra/sparse/csDfs.js"() {
    init_csMarked();
    init_csMark();
    init_csUnflip();
  }
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csReach.js
function csReach(g2, b, k, xi, pinv2) {
  var gptr = g2._ptr;
  var gsize = g2._size;
  var bindex = b._index;
  var bptr = b._ptr;
  var n = gsize[1];
  var p, p0, p1;
  var top = n;
  for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {
    var i2 = bindex[p];
    if (!csMarked(gptr, i2)) {
      top = csDfs(i2, g2, top, xi, pinv2);
    }
  }
  for (p = top; p < n; p++) {
    csMark(gptr, xi[p]);
  }
  return top;
}
var init_csReach = __esm({
  "node_modules/mathjs/lib/esm/function/algebra/sparse/csReach.js"() {
    init_csMarked();
    init_csMark();
    init_csDfs();
  }
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csSpsolve.js
var name227, dependencies228, createCsSpsolve;
var init_csSpsolve = __esm({
  "node_modules/mathjs/lib/esm/function/algebra/sparse/csSpsolve.js"() {
    init_csReach();
    init_factory();
    name227 = "csSpsolve";
    dependencies228 = ["divideScalar", "multiply", "subtract"];
    createCsSpsolve = /* @__PURE__ */ factory(name227, dependencies228, (_ref) => {
      var {
        divideScalar: divideScalar2,
        multiply: multiply2,
        subtract: subtract2
      } = _ref;
      return function csSpsolve(g2, b, k, xi, x, pinv2, lo) {
        var gvalues = g2._values;
        var gindex = g2._index;
        var gptr = g2._ptr;
        var gsize = g2._size;
        var n = gsize[1];
        var bvalues = b._values;
        var bindex = b._index;
        var bptr = b._ptr;
        var p, p0, p1, q;
        var top = csReach(g2, b, k, xi, pinv2);
        for (p = top; p < n; p++) {
          x[xi[p]] = 0;
        }
        for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {
          x[bindex[p]] = bvalues[p];
        }
        for (var px = top; px < n; px++) {
          var j = xi[px];
          var J = pinv2 ? pinv2[j] : j;
          if (J < 0) {
            continue;
          }
          p0 = gptr[J];
          p1 = gptr[J + 1];
          x[j] = divideScalar2(x[j], gvalues[lo ? p0 : p1 - 1]);
          p = lo ? p0 + 1 : p0;
          q = lo ? p1 : p1 - 1;
          for (; p < q; p++) {
            var i2 = gindex[p];
            x[i2] = subtract2(x[i2], multiply2(gvalues[p], x[j]));
          }
        }
        return top;
      };
    });
  }
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csLu.js
var name228, dependencies229, createCsLu;
var init_csLu = __esm({
  "node_modules/mathjs/lib/esm/function/algebra/sparse/csLu.js"() {
    init_factory();
    init_csSpsolve();
    name228 = "csLu";
    dependencies229 = ["abs", "divideScalar", "multiply", "subtract", "larger", "largerEq", "SparseMatrix"];
    createCsLu = /* @__PURE__ */ factory(name228, dependencies229, (_ref) => {
      var {
        abs: abs2,
        divideScalar: divideScalar2,
        multiply: multiply2,
        subtract: subtract2,
        larger: larger2,
        largerEq: largerEq2,
        SparseMatrix: SparseMatrix2
      } = _ref;
      var csSpsolve = createCsSpsolve({
        divideScalar: divideScalar2,
        multiply: multiply2,
        subtract: subtract2
      });
      return function csLu(m, s, tol) {
        if (!m) {
          return null;
        }
        var size2 = m._size;
        var n = size2[1];
        var q;
        var lnz = 100;
        var unz = 100;
        if (s) {
          q = s.q;
          lnz = s.lnz || lnz;
          unz = s.unz || unz;
        }
        var lvalues = [];
        var lindex = [];
        var lptr = [];
        var L = new SparseMatrix2({
          values: lvalues,
          index: lindex,
          ptr: lptr,
          size: [n, n]
        });
        var uvalues = [];
        var uindex = [];
        var uptr = [];
        var U = new SparseMatrix2({
          values: uvalues,
          index: uindex,
          ptr: uptr,
          size: [n, n]
        });
        var pinv2 = [];
        var i2, p;
        var x = [];
        var xi = [];
        for (i2 = 0; i2 < n; i2++) {
          x[i2] = 0;
          pinv2[i2] = -1;
          lptr[i2 + 1] = 0;
        }
        lnz = 0;
        unz = 0;
        for (var k = 0; k < n; k++) {
          lptr[k] = lnz;
          uptr[k] = unz;
          var col = q ? q[k] : k;
          var top = csSpsolve(L, m, col, xi, x, pinv2, 1);
          var ipiv = -1;
          var a = -1;
          for (p = top; p < n; p++) {
            i2 = xi[p];
            if (pinv2[i2] < 0) {
              var xabs = abs2(x[i2]);
              if (larger2(xabs, a)) {
                a = xabs;
                ipiv = i2;
              }
            } else {
              uindex[unz] = pinv2[i2];
              uvalues[unz++] = x[i2];
            }
          }
          if (ipiv === -1 || a <= 0) {
            return null;
          }
          if (pinv2[col] < 0 && largerEq2(abs2(x[col]), multiply2(a, tol))) {
            ipiv = col;
          }
          var pivot = x[ipiv];
          uindex[unz] = k;
          uvalues[unz++] = pivot;
          pinv2[ipiv] = k;
          lindex[lnz] = ipiv;
          lvalues[lnz++] = 1;
          for (p = top; p < n; p++) {
            i2 = xi[p];
            if (pinv2[i2] < 0) {
              lindex[lnz] = i2;
              lvalues[lnz++] = divideScalar2(x[i2], pivot);
            }
            x[i2] = 0;
          }
        }
        lptr[n] = lnz;
        uptr[n] = unz;
        for (p = 0; p < lnz; p++) {
          lindex[p] = pinv2[lindex[p]];
        }
        lvalues.splice(lnz, lvalues.length - lnz);
        lindex.splice(lnz, lindex.length - lnz);
        uvalues.splice(unz, uvalues.length - unz);
        uindex.splice(unz, uindex.length - unz);
        return {
          L,
          U,
          pinv: pinv2
        };
      };
    });
  }
});

// node_modules/mathjs/lib/esm/function/algebra/decomposition/slu.js
var name229, dependencies230, createSlu;
var init_slu = __esm({
  "node_modules/mathjs/lib/esm/function/algebra/decomposition/slu.js"() {
    init_number();
    init_factory();
    init_csSqr();
    init_csLu();
    name229 = "slu";
    dependencies230 = ["typed", "abs", "add", "multiply", "transpose", "divideScalar", "subtract", "larger", "largerEq", "SparseMatrix"];
    createSlu = /* @__PURE__ */ factory(name229, dependencies230, (_ref) => {
      var {
        typed: typed2,
        abs: abs2,
        add: add2,
        multiply: multiply2,
        transpose: transpose2,
        divideScalar: divideScalar2,
        subtract: subtract2,
        larger: larger2,
        largerEq: largerEq2,
        SparseMatrix: SparseMatrix2
      } = _ref;
      var csSqr = createCsSqr({
        add: add2,
        multiply: multiply2,
        transpose: transpose2
      });
      var csLu = createCsLu({
        abs: abs2,
        divideScalar: divideScalar2,
        multiply: multiply2,
        subtract: subtract2,
        larger: larger2,
        largerEq: largerEq2,
        SparseMatrix: SparseMatrix2
      });
      return typed2(name229, {
        "SparseMatrix, number, number": function SparseMatrixNumberNumber(a, order, threshold) {
          if (!isInteger(order) || order < 0 || order > 3) {
            throw new Error("Symbolic Ordering and Analysis order must be an integer number in the interval [0, 3]");
          }
          if (threshold < 0 || threshold > 1) {
            throw new Error("Partial pivoting threshold must be a number from 0 to 1");
          }
          var s = csSqr(order, a, false);
          var f = csLu(a, s, threshold);
          return {
            L: f.L,
            U: f.U,
            p: f.pinv,
            q: s.q,
            toString: function toString() {
              return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\np: " + this.p.toString() + (this.q ? "\nq: " + this.q.toString() : "") + "\n";
            }
          };
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/algebra/sparse/csIpvec.js
function csIpvec(p, b) {
  var k;
  var n = b.length;
  var x = [];
  if (p) {
    for (k = 0; k < n; k++) {
      x[p[k]] = b[k];
    }
  } else {
    for (k = 0; k < n; k++) {
      x[k] = b[k];
    }
  }
  return x;
}
var init_csIpvec = __esm({
  "node_modules/mathjs/lib/esm/function/algebra/sparse/csIpvec.js"() {
  }
});

// node_modules/mathjs/lib/esm/function/algebra/solver/lusolve.js
var name230, dependencies231, createLusolve;
var init_lusolve = __esm({
  "node_modules/mathjs/lib/esm/function/algebra/solver/lusolve.js"() {
    init_is();
    init_factory();
    init_solveValidation();
    init_csIpvec();
    name230 = "lusolve";
    dependencies231 = ["typed", "matrix", "lup", "slu", "usolve", "lsolve", "DenseMatrix"];
    createLusolve = /* @__PURE__ */ factory(name230, dependencies231, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        lup: lup2,
        slu: slu2,
        usolve: usolve2,
        lsolve: lsolve2,
        DenseMatrix: DenseMatrix2
      } = _ref;
      var solveValidation = createSolveValidation({
        DenseMatrix: DenseMatrix2
      });
      return typed2(name230, {
        "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
          a = matrix2(a);
          var d = lup2(a);
          var x = _lusolve(d.L, d.U, d.p, null, b);
          return x.valueOf();
        },
        "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(a, b) {
          var d = lup2(a);
          return _lusolve(d.L, d.U, d.p, null, b);
        },
        "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(a, b) {
          var d = lup2(a);
          return _lusolve(d.L, d.U, d.p, null, b);
        },
        "SparseMatrix, Array | Matrix, number, number": function SparseMatrixArrayMatrixNumberNumber(a, b, order, threshold) {
          var d = slu2(a, order, threshold);
          return _lusolve(d.L, d.U, d.p, d.q, b);
        },
        "Object, Array | Matrix": function ObjectArrayMatrix(d, b) {
          return _lusolve(d.L, d.U, d.p, d.q, b);
        }
      });
      function _toMatrix(a) {
        if (isMatrix(a)) {
          return a;
        }
        if (isArray(a)) {
          return matrix2(a);
        }
        throw new TypeError("Invalid Matrix LU decomposition");
      }
      function _lusolve(l, u, p, q, b) {
        l = _toMatrix(l);
        u = _toMatrix(u);
        if (p) {
          b = solveValidation(l, b, true);
          b._data = csIpvec(p, b._data);
        }
        var y = lsolve2(l, b);
        var x = usolve2(u, y);
        if (q) {
          x._data = csIpvec(q, x._data);
        }
        return x;
      }
    });
  }
});

// node_modules/mathjs/lib/esm/expression/Help.js
var name231, dependencies232, createHelpClass;
var init_Help = __esm({
  "node_modules/mathjs/lib/esm/expression/Help.js"() {
    init_is();
    init_object();
    init_string();
    init_factory();
    name231 = "Help";
    dependencies232 = ["parse"];
    createHelpClass = /* @__PURE__ */ factory(name231, dependencies232, (_ref) => {
      var {
        parse: parse2
      } = _ref;
      function Help2(doc) {
        if (!(this instanceof Help2)) {
          throw new SyntaxError("Constructor must be called with the new operator");
        }
        if (!doc)
          throw new Error('Argument "doc" missing');
        this.doc = doc;
      }
      Help2.prototype.type = "Help";
      Help2.prototype.isHelp = true;
      Help2.prototype.toString = function() {
        var doc = this.doc || {};
        var desc = "\n";
        if (doc.name) {
          desc += "Name: " + doc.name + "\n\n";
        }
        if (doc.category) {
          desc += "Category: " + doc.category + "\n\n";
        }
        if (doc.description) {
          desc += "Description:\n    " + doc.description + "\n\n";
        }
        if (doc.syntax) {
          desc += "Syntax:\n    " + doc.syntax.join("\n    ") + "\n\n";
        }
        if (doc.examples) {
          desc += "Examples:\n";
          var scope = {};
          for (var i2 = 0; i2 < doc.examples.length; i2++) {
            var expr = doc.examples[i2];
            desc += "    " + expr + "\n";
            var res = void 0;
            try {
              res = parse2(expr).compile().evaluate(scope);
            } catch (e3) {
              res = e3;
            }
            if (res !== void 0 && !isHelp(res)) {
              desc += "        " + format3(res, {
                precision: 14
              }) + "\n";
            }
          }
          desc += "\n";
        }
        if (doc.mayThrow && doc.mayThrow.length) {
          desc += "Throws: " + doc.mayThrow.join(", ") + "\n\n";
        }
        if (doc.seealso && doc.seealso.length) {
          desc += "See also: " + doc.seealso.join(", ") + "\n";
        }
        return desc;
      };
      Help2.prototype.toJSON = function() {
        var obj = clone(this.doc);
        obj.mathjs = "Help";
        return obj;
      };
      Help2.fromJSON = function(json) {
        var doc = {};
        Object.keys(json).filter((prop) => prop !== "mathjs").forEach((prop) => {
          doc[prop] = json[prop];
        });
        return new Help2(doc);
      };
      Help2.prototype.valueOf = Help2.prototype.toString;
      return Help2;
    }, {
      isClass: true
    });
  }
});

// node_modules/mathjs/lib/esm/type/chain/Chain.js
var name232, dependencies233, createChainClass;
var init_Chain = __esm({
  "node_modules/mathjs/lib/esm/type/chain/Chain.js"() {
    init_is();
    init_string();
    init_object();
    init_factory();
    name232 = "Chain";
    dependencies233 = ["?on", "math"];
    createChainClass = /* @__PURE__ */ factory(name232, dependencies233, (_ref) => {
      var {
        on,
        math: math2
      } = _ref;
      function Chain2(value) {
        if (!(this instanceof Chain2)) {
          throw new SyntaxError("Constructor must be called with the new operator");
        }
        if (isChain(value)) {
          this.value = value.value;
        } else {
          this.value = value;
        }
      }
      Chain2.prototype.type = "Chain";
      Chain2.prototype.isChain = true;
      Chain2.prototype.done = function() {
        return this.value;
      };
      Chain2.prototype.valueOf = function() {
        return this.value;
      };
      Chain2.prototype.toString = function() {
        return format3(this.value);
      };
      Chain2.prototype.toJSON = function() {
        return {
          mathjs: "Chain",
          value: this.value
        };
      };
      Chain2.fromJSON = function(json) {
        return new Chain2(json.value);
      };
      function createProxy(name296, fn) {
        if (typeof fn === "function") {
          Chain2.prototype[name296] = chainify(fn);
        }
      }
      function createLazyProxy(name296, resolver) {
        lazy(Chain2.prototype, name296, function outerResolver() {
          var fn = resolver();
          if (typeof fn === "function") {
            return chainify(fn);
          }
          return void 0;
        });
      }
      function chainify(fn) {
        return function() {
          var args = [this.value];
          for (var i2 = 0; i2 < arguments.length; i2++) {
            args[i2 + 1] = arguments[i2];
          }
          return new Chain2(fn.apply(fn, args));
        };
      }
      Chain2.createProxy = function(arg0, arg1) {
        if (typeof arg0 === "string") {
          createProxy(arg0, arg1);
        } else {
          var _loop = function _loop2(_name2) {
            if (hasOwnProperty2(arg0, _name2) && excludedNames[_name2] === void 0) {
              createLazyProxy(_name2, () => arg0[_name2]);
            }
          };
          for (var _name in arg0) {
            _loop(_name);
          }
        }
      };
      var excludedNames = {
        expression: true,
        docs: true,
        type: true,
        classes: true,
        json: true,
        error: true,
        isChain: true
      };
      Chain2.createProxy(math2);
      if (on) {
        on("import", function(name296, resolver, path) {
          if (!path) {
            createLazyProxy(name296, resolver);
          }
        });
      }
      return Chain2;
    }, {
      isClass: true
    });
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/e.js
var eDocs;
var init_e = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/e.js"() {
    eDocs = {
      name: "e",
      category: "Constants",
      syntax: ["e"],
      description: "Euler's number, the base of the natural logarithm. Approximately equal to 2.71828",
      examples: ["e", "e ^ 2", "exp(2)", "log(e)"],
      seealso: ["exp"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/false.js
var falseDocs;
var init_false = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/false.js"() {
    falseDocs = {
      name: "false",
      category: "Constants",
      syntax: ["false"],
      description: "Boolean value false",
      examples: ["false"],
      seealso: ["true"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/i.js
var iDocs;
var init_i = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/i.js"() {
    iDocs = {
      name: "i",
      category: "Constants",
      syntax: ["i"],
      description: "Imaginary unit, defined as i*i=-1. A complex number is described as a + b*i, where a is the real part, and b is the imaginary part.",
      examples: ["i", "i * i", "sqrt(-1)"],
      seealso: []
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/Infinity.js
var InfinityDocs;
var init_Infinity = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/Infinity.js"() {
    InfinityDocs = {
      name: "Infinity",
      category: "Constants",
      syntax: ["Infinity"],
      description: "Infinity, a number which is larger than the maximum number that can be handled by a floating point number.",
      examples: ["Infinity", "1 / 0"],
      seealso: []
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LN10.js
var LN10Docs;
var init_LN10 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LN10.js"() {
    LN10Docs = {
      name: "LN10",
      category: "Constants",
      syntax: ["LN10"],
      description: "Returns the natural logarithm of 10, approximately equal to 2.302",
      examples: ["LN10", "log(10)"],
      seealso: []
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LN2.js
var LN2Docs;
var init_LN2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LN2.js"() {
    LN2Docs = {
      name: "LN2",
      category: "Constants",
      syntax: ["LN2"],
      description: "Returns the natural logarithm of 2, approximately equal to 0.693",
      examples: ["LN2", "log(2)"],
      seealso: []
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LOG10E.js
var LOG10EDocs;
var init_LOG10E = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LOG10E.js"() {
    LOG10EDocs = {
      name: "LOG10E",
      category: "Constants",
      syntax: ["LOG10E"],
      description: "Returns the base-10 logarithm of E, approximately equal to 0.434",
      examples: ["LOG10E", "log(e, 10)"],
      seealso: []
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LOG2E.js
var LOG2EDocs;
var init_LOG2E = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LOG2E.js"() {
    LOG2EDocs = {
      name: "LOG2E",
      category: "Constants",
      syntax: ["LOG2E"],
      description: "Returns the base-2 logarithm of E, approximately equal to 1.442",
      examples: ["LOG2E", "log(e, 2)"],
      seealso: []
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/NaN.js
var NaNDocs;
var init_NaN = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/NaN.js"() {
    NaNDocs = {
      name: "NaN",
      category: "Constants",
      syntax: ["NaN"],
      description: "Not a number",
      examples: ["NaN", "0 / 0"],
      seealso: []
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/null.js
var nullDocs;
var init_null = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/null.js"() {
    nullDocs = {
      name: "null",
      category: "Constants",
      syntax: ["null"],
      description: "Value null",
      examples: ["null"],
      seealso: ["true", "false"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/phi.js
var phiDocs;
var init_phi = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/phi.js"() {
    phiDocs = {
      name: "phi",
      category: "Constants",
      syntax: ["phi"],
      description: "Phi is the golden ratio. Two quantities are in the golden ratio if their ratio is the same as the ratio of their sum to the larger of the two quantities. Phi is defined as `(1 + sqrt(5)) / 2` and is approximately 1.618034...",
      examples: ["phi"],
      seealso: []
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/pi.js
var piDocs;
var init_pi = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/pi.js"() {
    piDocs = {
      name: "pi",
      category: "Constants",
      syntax: ["pi"],
      description: "The number pi is a mathematical constant that is the ratio of a circle's circumference to its diameter, and is approximately equal to 3.14159",
      examples: ["pi", "sin(pi/2)"],
      seealso: ["tau"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/SQRT1_2.js
var SQRT12Docs;
var init_SQRT1_2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/SQRT1_2.js"() {
    SQRT12Docs = {
      name: "SQRT1_2",
      category: "Constants",
      syntax: ["SQRT1_2"],
      description: "Returns the square root of 1/2, approximately equal to 0.707",
      examples: ["SQRT1_2", "sqrt(1/2)"],
      seealso: []
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/SQRT2.js
var SQRT2Docs;
var init_SQRT2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/SQRT2.js"() {
    SQRT2Docs = {
      name: "SQRT2",
      category: "Constants",
      syntax: ["SQRT2"],
      description: "Returns the square root of 2, approximately equal to 1.414",
      examples: ["SQRT2", "sqrt(2)"],
      seealso: []
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/tau.js
var tauDocs;
var init_tau = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/tau.js"() {
    tauDocs = {
      name: "tau",
      category: "Constants",
      syntax: ["tau"],
      description: "Tau is the ratio constant of a circle's circumference to radius, equal to 2 * pi, approximately 6.2832.",
      examples: ["tau", "2 * pi"],
      seealso: ["pi"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/true.js
var trueDocs;
var init_true = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/true.js"() {
    trueDocs = {
      name: "true",
      category: "Constants",
      syntax: ["true"],
      description: "Boolean value true",
      examples: ["true"],
      seealso: ["false"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/version.js
var versionDocs;
var init_version = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/version.js"() {
    versionDocs = {
      name: "version",
      category: "Constants",
      syntax: ["version"],
      description: "A string with the version number of math.js",
      examples: ["version"],
      seealso: []
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/bignumber.js
var bignumberDocs;
var init_bignumber2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/bignumber.js"() {
    bignumberDocs = {
      name: "bignumber",
      category: "Construction",
      syntax: ["bignumber(x)"],
      description: "Create a big number from a number or string.",
      examples: ["0.1 + 0.2", "bignumber(0.1) + bignumber(0.2)", 'bignumber("7.2")', 'bignumber("7.2e500")', "bignumber([0.1, 0.2, 0.3])"],
      seealso: ["boolean", "complex", "fraction", "index", "matrix", "string", "unit"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/boolean.js
var booleanDocs;
var init_boolean2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/boolean.js"() {
    booleanDocs = {
      name: "boolean",
      category: "Construction",
      syntax: ["x", "boolean(x)"],
      description: "Convert a string or number into a boolean.",
      examples: ["boolean(0)", "boolean(1)", "boolean(3)", 'boolean("true")', 'boolean("false")', "boolean([1, 0, 1, 1])"],
      seealso: ["bignumber", "complex", "index", "matrix", "number", "string", "unit"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/complex.js
var complexDocs;
var init_complex3 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/complex.js"() {
    complexDocs = {
      name: "complex",
      category: "Construction",
      syntax: ["complex()", "complex(re, im)", "complex(string)"],
      description: "Create a complex number.",
      examples: ["complex()", "complex(2, 3)", 'complex("7 - 2i")'],
      seealso: ["bignumber", "boolean", "index", "matrix", "number", "string", "unit"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/createUnit.js
var createUnitDocs;
var init_createUnit2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/createUnit.js"() {
    createUnitDocs = {
      name: "createUnit",
      category: "Construction",
      syntax: ["createUnit(definitions)", "createUnit(name, definition)"],
      description: "Create a user-defined unit and register it with the Unit type.",
      examples: ['createUnit("foo")', 'createUnit("knot", {definition: "0.514444444 m/s", aliases: ["knots", "kt", "kts"]})', 'createUnit("mph", "1 mile/hour")'],
      seealso: ["unit", "splitUnit"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/fraction.js
var fractionDocs;
var init_fraction2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/fraction.js"() {
    fractionDocs = {
      name: "fraction",
      category: "Construction",
      syntax: ["fraction(num)", "fraction(matrix)", "fraction(num,den)", "fraction({n: num, d: den})"],
      description: "Create a fraction from a number or from integer numerator and denominator.",
      examples: ["fraction(0.125)", "fraction(1, 3) + fraction(2, 5)", "fraction({n: 333, d: 53})", "fraction([sqrt(9), sqrt(10), sqrt(11)])"],
      seealso: ["bignumber", "boolean", "complex", "index", "matrix", "string", "unit"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/index.js
var indexDocs;
var init_construction = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/index.js"() {
    indexDocs = {
      name: "index",
      category: "Construction",
      syntax: ["[start]", "[start:end]", "[start:step:end]", "[start1, start 2, ...]", "[start1:end1, start2:end2, ...]", "[start1:step1:end1, start2:step2:end2, ...]"],
      description: "Create an index to get or replace a subset of a matrix",
      examples: ["[]", "[1, 2, 3]", "A = [1, 2, 3; 4, 5, 6]", "A[1, :]", "A[1, 2] = 50", "A[0:2, 0:2] = ones(2, 2)"],
      seealso: ["bignumber", "boolean", "complex", "matrix,", "number", "range", "string", "unit"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/matrix.js
var matrixDocs;
var init_matrix2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/matrix.js"() {
    matrixDocs = {
      name: "matrix",
      category: "Construction",
      syntax: ["[]", "[a1, b1, ...; a2, b2, ...]", "matrix()", 'matrix("dense")', "matrix([...])"],
      description: "Create a matrix.",
      examples: ["[]", "[1, 2, 3]", "[1, 2, 3; 4, 5, 6]", "matrix()", "matrix([3, 4])", 'matrix([3, 4; 5, 6], "sparse")', 'matrix([3, 4; 5, 6], "sparse", "number")'],
      seealso: ["bignumber", "boolean", "complex", "index", "number", "string", "unit", "sparse"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/number.js
var numberDocs;
var init_number4 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/number.js"() {
    numberDocs = {
      name: "number",
      category: "Construction",
      syntax: ["x", "number(x)", "number(unit, valuelessUnit)"],
      description: "Create a number or convert a string or boolean into a number.",
      examples: ["2", "2e3", "4.05", "number(2)", 'number("7.2")', "number(true)", "number([true, false, true, true])", 'number(unit("52cm"), "m")'],
      seealso: ["bignumber", "boolean", "complex", "fraction", "index", "matrix", "string", "unit"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/sparse.js
var sparseDocs;
var init_sparse2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/sparse.js"() {
    sparseDocs = {
      name: "sparse",
      category: "Construction",
      syntax: ["sparse()", "sparse([a1, b1, ...; a1, b2, ...])", 'sparse([a1, b1, ...; a1, b2, ...], "number")'],
      description: "Create a sparse matrix.",
      examples: ["sparse()", "sparse([3, 4; 5, 6])", 'sparse([3, 0; 5, 0], "number")'],
      seealso: ["bignumber", "boolean", "complex", "index", "number", "string", "unit", "matrix"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/splitUnit.js
var splitUnitDocs;
var init_splitUnit2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/splitUnit.js"() {
    splitUnitDocs = {
      name: "splitUnit",
      category: "Construction",
      syntax: ["splitUnit(unit: Unit, parts: Unit[])"],
      description: "Split a unit in an array of units whose sum is equal to the original unit.",
      examples: ['splitUnit(1 m, ["feet", "inch"])'],
      seealso: ["unit", "createUnit"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/string.js
var stringDocs;
var init_string3 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/string.js"() {
    stringDocs = {
      name: "string",
      category: "Construction",
      syntax: ['"text"', "string(x)"],
      description: "Create a string or convert a value to a string",
      examples: ['"Hello World!"', "string(4.2)", "string(3 + 2i)"],
      seealso: ["bignumber", "boolean", "complex", "index", "matrix", "number", "unit"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/unit.js
var unitDocs;
var init_unit2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/unit.js"() {
    unitDocs = {
      name: "unit",
      category: "Construction",
      syntax: ["value unit", "unit(value, unit)", "unit(string)"],
      description: "Create a unit.",
      examples: ["5.5 mm", "3 inch", 'unit(7.1, "kilogram")', 'unit("23 deg")'],
      seealso: ["bignumber", "boolean", "complex", "index", "matrix", "number", "string"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/core/config.js
var configDocs;
var init_config3 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/core/config.js"() {
    configDocs = {
      name: "config",
      category: "Core",
      syntax: ["config()", "config(options)"],
      description: "Get configuration or change configuration.",
      examples: ["config()", "1/3 + 1/4", 'config({number: "Fraction"})', "1/3 + 1/4"],
      seealso: []
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/core/import.js
var importDocs;
var init_import = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/core/import.js"() {
    importDocs = {
      name: "import",
      category: "Core",
      syntax: ["import(functions)", "import(functions, options)"],
      description: "Import functions or constants from an object.",
      examples: ["import({myFn: f(x)=x^2, myConstant: 32 })", "myFn(2)", "myConstant"],
      seealso: []
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/core/typed.js
var typedDocs;
var init_typed2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/core/typed.js"() {
    typedDocs = {
      name: "typed",
      category: "Core",
      syntax: ["typed(signatures)", "typed(name, signatures)"],
      description: "Create a typed function.",
      examples: ['double = typed({ "number": f(x)=x+x })', "double(2)", 'double("hello")'],
      seealso: []
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/derivative.js
var derivativeDocs;
var init_derivative = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/derivative.js"() {
    derivativeDocs = {
      name: "derivative",
      category: "Algebra",
      syntax: ["derivative(expr, variable)", "derivative(expr, variable, {simplify: boolean})"],
      description: "Takes the derivative of an expression expressed in parser Nodes. The derivative will be taken over the supplied variable in the second parameter. If there are multiple variables in the expression, it will return a partial derivative.",
      examples: ['derivative("2x^3", "x")', 'derivative("2x^3", "x", {simplify: false})', 'derivative("2x^2 + 3x + 4", "x")', 'derivative("sin(2x)", "x")', 'f = parse("x^2 + x")', 'x = parse("x")', "df = derivative(f, x)", "df.evaluate({x: 3})"],
      seealso: ["simplify", "parse", "evaluate"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/leafCount.js
var leafCountDocs;
var init_leafCount = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/leafCount.js"() {
    leafCountDocs = {
      name: "leafCount",
      category: "Algebra",
      syntax: ["leafCount(expr)"],
      description: "Computes the number of leaves in the parse tree of the given expression",
      examples: ['leafCount("e^(i*pi)-1")', 'leafCount(parse("{a: 22/7, b: 10^(1/2)}"))'],
      seealso: ["simplify"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lsolve.js
var lsolveDocs;
var init_lsolve2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lsolve.js"() {
    lsolveDocs = {
      name: "lsolve",
      category: "Algebra",
      syntax: ["x=lsolve(L, b)"],
      description: "Finds one solution of the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.",
      examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lsolve(a, b)"],
      seealso: ["lsolveAll", "lup", "lusolve", "usolve", "matrix", "sparse"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lsolveAll.js
var lsolveAllDocs;
var init_lsolveAll2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lsolveAll.js"() {
    lsolveAllDocs = {
      name: "lsolveAll",
      category: "Algebra",
      syntax: ["x=lsolveAll(L, b)"],
      description: "Finds all solutions of the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.",
      examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lsolve(a, b)"],
      seealso: ["lsolve", "lup", "lusolve", "usolve", "matrix", "sparse"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lup.js
var lupDocs;
var init_lup2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lup.js"() {
    lupDocs = {
      name: "lup",
      category: "Algebra",
      syntax: ["lup(m)"],
      description: "Calculate the Matrix LU decomposition with partial pivoting. Matrix A is decomposed in three matrices (L, U, P) where P * A = L * U",
      examples: ["lup([[2, 1], [1, 4]])", "lup(matrix([[2, 1], [1, 4]]))", "lup(sparse([[2, 1], [1, 4]]))"],
      seealso: ["lusolve", "lsolve", "usolve", "matrix", "sparse", "slu", "qr"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lusolve.js
var lusolveDocs;
var init_lusolve2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lusolve.js"() {
    lusolveDocs = {
      name: "lusolve",
      category: "Algebra",
      syntax: ["x=lusolve(A, b)", "x=lusolve(lu, b)"],
      description: "Solves the linear system A * x = b where A is an [n x n] matrix and b is a [n] column vector.",
      examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lusolve(a, b)"],
      seealso: ["lup", "slu", "lsolve", "usolve", "matrix", "sparse"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/qr.js
var qrDocs;
var init_qr2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/qr.js"() {
    qrDocs = {
      name: "qr",
      category: "Algebra",
      syntax: ["qr(A)"],
      description: "Calculates the Matrix QR decomposition. Matrix `A` is decomposed in two matrices (`Q`, `R`) where `Q` is an orthogonal matrix and `R` is an upper triangular matrix.",
      examples: ["qr([[1, -1,  4], [1,  4, -2], [1,  4,  2], [1,  -1, 0]])"],
      seealso: ["lup", "slu", "matrix"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/rationalize.js
var rationalizeDocs;
var init_rationalize = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/rationalize.js"() {
    rationalizeDocs = {
      name: "rationalize",
      category: "Algebra",
      syntax: ["rationalize(expr)", "rationalize(expr, scope)", "rationalize(expr, scope, detailed)"],
      description: "Transform a rationalizable expression in a rational fraction. If rational fraction is one variable polynomial then converts the numerator and denominator in canonical form, with decreasing exponents, returning the coefficients of numerator.",
      examples: ['rationalize("2x/y - y/(x+1)")', 'rationalize("2x/y - y/(x+1)", true)'],
      seealso: ["simplify"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/resolve.js
var resolveDocs;
var init_resolve = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/resolve.js"() {
    resolveDocs = {
      name: "resolve",
      category: "Algebra",
      syntax: ["resolve(node, scope)"],
      description: "Recursively substitute variables in an expression tree.",
      examples: ['resolve(parse("1 + x"), { x: 7 })', 'resolve(parse("size(text)"), { text: "Hello World" })', 'resolve(parse("x + y"), { x: parse("3z") })', 'resolve(parse("3x"), { x: parse("y+z"), z: parse("w^y") })'],
      seealso: ["simplify", "evaluate"],
      mayThrow: ["ReferenceError"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/simplify.js
var simplifyDocs;
var init_simplify = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/simplify.js"() {
    simplifyDocs = {
      name: "simplify",
      category: "Algebra",
      syntax: ["simplify(expr)", "simplify(expr, rules)"],
      description: "Simplify an expression tree.",
      examples: ['simplify("3 + 2 / 4")', 'simplify("2x + x")', 'f = parse("x * (x + 2 + x)")', "simplified = simplify(f)", "simplified.evaluate({x: 2})"],
      seealso: ["simplifyCore", "derivative", "evaluate", "parse", "rationalize", "resolve"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/simplifyCore.js
var simplifyCoreDocs;
var init_simplifyCore = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/simplifyCore.js"() {
    simplifyCoreDocs = {
      name: "simplifyCore",
      category: "Algebra",
      syntax: ["simplifyCore(node)"],
      description: "Perform simple one-pass simplifications on an expression tree.",
      examples: ['simplifyCore(parse("0*x"))', 'simplifyCore(parse("(x+0)*2"))'],
      seealso: ["simplify", "evaluate"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/slu.js
var sluDocs;
var init_slu2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/slu.js"() {
    sluDocs = {
      name: "slu",
      category: "Algebra",
      syntax: ["slu(A, order, threshold)"],
      description: "Calculate the Matrix LU decomposition with full pivoting. Matrix A is decomposed in two matrices (L, U) and two permutation vectors (pinv, q) where P * A * Q = L * U",
      examples: ["slu(sparse([4.5, 0, 3.2, 0; 3.1, 2.9, 0, 0.9; 0, 1.7, 3, 0; 3.5, 0.4, 0, 1]), 1, 0.001)"],
      seealso: ["lusolve", "lsolve", "usolve", "matrix", "sparse", "lup", "qr"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/symbolicEqual.js
var symbolicEqualDocs;
var init_symbolicEqual = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/symbolicEqual.js"() {
    symbolicEqualDocs = {
      name: "symbolicEqual",
      category: "Algebra",
      syntax: ["symbolicEqual(expr1, expr2)", "symbolicEqual(expr1, expr2, options)"],
      description: "Returns true if the difference of the expressions simplifies to 0",
      examples: ['symbolicEqual("x*y","y*x")', 'symbolicEqual("abs(x^2)", "x^2")', 'symbolicEqual("abs(x)", "x", {context: {abs: {trivial: true}}})'],
      seealso: ["simplify", "evaluate"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/usolve.js
var usolveDocs;
var init_usolve2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/usolve.js"() {
    usolveDocs = {
      name: "usolve",
      category: "Algebra",
      syntax: ["x=usolve(U, b)"],
      description: "Finds one solution of the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.",
      examples: ["x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])"],
      seealso: ["usolveAll", "lup", "lusolve", "lsolve", "matrix", "sparse"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/usolveAll.js
var usolveAllDocs;
var init_usolveAll2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/usolveAll.js"() {
    usolveAllDocs = {
      name: "usolveAll",
      category: "Algebra",
      syntax: ["x=usolve(U, b)"],
      description: "Finds all solutions of the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.",
      examples: ["x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])"],
      seealso: ["usolve", "lup", "lusolve", "lsolve", "matrix", "sparse"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/abs.js
var absDocs;
var init_abs2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/abs.js"() {
    absDocs = {
      name: "abs",
      category: "Arithmetic",
      syntax: ["abs(x)"],
      description: "Compute the absolute value.",
      examples: ["abs(3.5)", "abs(-4.2)"],
      seealso: ["sign"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/add.js
var addDocs;
var init_add2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/add.js"() {
    addDocs = {
      name: "add",
      category: "Operators",
      syntax: ["x + y", "add(x, y)"],
      description: "Add two values.",
      examples: ["a = 2.1 + 3.6", "a - 3.6", "3 + 2i", "3 cm + 2 inch", '"2.3" + "4"'],
      seealso: ["subtract"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/cbrt.js
var cbrtDocs;
var init_cbrt2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/cbrt.js"() {
    cbrtDocs = {
      name: "cbrt",
      category: "Arithmetic",
      syntax: ["cbrt(x)", "cbrt(x, allRoots)"],
      description: "Compute the cubic root value. If x = y * y * y, then y is the cubic root of x. When `x` is a number or complex number, an optional second argument `allRoots` can be provided to return all three cubic roots. If not provided, the principal root is returned",
      examples: ["cbrt(64)", "cube(4)", "cbrt(-8)", "cbrt(2 + 3i)", "cbrt(8i)", "cbrt(8i, true)", "cbrt(27 m^3)"],
      seealso: ["square", "sqrt", "cube", "multiply"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/ceil.js
var ceilDocs;
var init_ceil2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/ceil.js"() {
    ceilDocs = {
      name: "ceil",
      category: "Arithmetic",
      syntax: ["ceil(x)"],
      description: "Round a value towards plus infinity. If x is complex, both real and imaginary part are rounded towards plus infinity.",
      examples: ["ceil(3.2)", "ceil(3.8)", "ceil(-4.2)"],
      seealso: ["floor", "fix", "round"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/cube.js
var cubeDocs;
var init_cube2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/cube.js"() {
    cubeDocs = {
      name: "cube",
      category: "Arithmetic",
      syntax: ["cube(x)"],
      description: "Compute the cube of a value. The cube of x is x * x * x.",
      examples: ["cube(2)", "2^3", "2 * 2 * 2"],
      seealso: ["multiply", "square", "pow"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/divide.js
var divideDocs;
var init_divide = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/divide.js"() {
    divideDocs = {
      name: "divide",
      category: "Operators",
      syntax: ["x / y", "divide(x, y)"],
      description: "Divide two values.",
      examples: ["a = 2 / 3", "a * 3", "4.5 / 2", "3 + 4 / 2", "(3 + 4) / 2", "18 km / 4.5"],
      seealso: ["multiply"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/dotDivide.js
var dotDivideDocs;
var init_dotDivide2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/dotDivide.js"() {
    dotDivideDocs = {
      name: "dotDivide",
      category: "Operators",
      syntax: ["x ./ y", "dotDivide(x, y)"],
      description: "Divide two values element wise.",
      examples: ["a = [1, 2, 3; 4, 5, 6]", "b = [2, 1, 1; 3, 2, 5]", "a ./ b"],
      seealso: ["multiply", "dotMultiply", "divide"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/dotMultiply.js
var dotMultiplyDocs;
var init_dotMultiply2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/dotMultiply.js"() {
    dotMultiplyDocs = {
      name: "dotMultiply",
      category: "Operators",
      syntax: ["x .* y", "dotMultiply(x, y)"],
      description: "Multiply two values element wise.",
      examples: ["a = [1, 2, 3; 4, 5, 6]", "b = [2, 1, 1; 3, 2, 5]", "a .* b"],
      seealso: ["multiply", "divide", "dotDivide"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/dotPow.js
var dotPowDocs;
var init_dotPow2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/dotPow.js"() {
    dotPowDocs = {
      name: "dotPow",
      category: "Operators",
      syntax: ["x .^ y", "dotPow(x, y)"],
      description: "Calculates the power of x to y element wise.",
      examples: ["a = [1, 2, 3; 4, 5, 6]", "a .^ 2"],
      seealso: ["pow"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/exp.js
var expDocs;
var init_exp2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/exp.js"() {
    expDocs = {
      name: "exp",
      category: "Arithmetic",
      syntax: ["exp(x)"],
      description: "Calculate the exponent of a value.",
      examples: ["exp(1.3)", "e ^ 1.3", "log(exp(1.3))", "x = 2.4", "(exp(i*x) == cos(x) + i*sin(x))   # Euler's formula"],
      seealso: ["expm", "expm1", "pow", "log"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/expm.js
var expmDocs;
var init_expm = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/expm.js"() {
    expmDocs = {
      name: "expm",
      category: "Arithmetic",
      syntax: ["exp(x)"],
      description: "Compute the matrix exponential, expm(A) = e^A. The matrix must be square. Not to be confused with exp(a), which performs element-wise exponentiation.",
      examples: ["expm([[0,2],[0,0]])"],
      seealso: ["exp"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/expm1.js
var expm1Docs;
var init_expm12 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/expm1.js"() {
    expm1Docs = {
      name: "expm1",
      category: "Arithmetic",
      syntax: ["expm1(x)"],
      description: "Calculate the value of subtracting 1 from the exponential value.",
      examples: ["expm1(2)", "pow(e, 2) - 1", "log(expm1(2) + 1)"],
      seealso: ["exp", "pow", "log"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/fix.js
var fixDocs;
var init_fix2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/fix.js"() {
    fixDocs = {
      name: "fix",
      category: "Arithmetic",
      syntax: ["fix(x)"],
      description: "Round a value towards zero. If x is complex, both real and imaginary part are rounded towards zero.",
      examples: ["fix(3.2)", "fix(3.8)", "fix(-4.2)", "fix(-4.8)"],
      seealso: ["ceil", "floor", "round"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/floor.js
var floorDocs;
var init_floor2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/floor.js"() {
    floorDocs = {
      name: "floor",
      category: "Arithmetic",
      syntax: ["floor(x)"],
      description: "Round a value towards minus infinity.If x is complex, both real and imaginary part are rounded towards minus infinity.",
      examples: ["floor(3.2)", "floor(3.8)", "floor(-4.2)"],
      seealso: ["ceil", "fix", "round"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/gcd.js
var gcdDocs;
var init_gcd2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/gcd.js"() {
    gcdDocs = {
      name: "gcd",
      category: "Arithmetic",
      syntax: ["gcd(a, b)", "gcd(a, b, c, ...)"],
      description: "Compute the greatest common divisor.",
      examples: ["gcd(8, 12)", "gcd(-4, 6)", "gcd(25, 15, -10)"],
      seealso: ["lcm", "xgcd"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/hypot.js
var hypotDocs;
var init_hypot2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/hypot.js"() {
    hypotDocs = {
      name: "hypot",
      category: "Arithmetic",
      syntax: ["hypot(a, b, c, ...)", "hypot([a, b, c, ...])"],
      description: "Calculate the hypotenusa of a list with values. ",
      examples: ["hypot(3, 4)", "sqrt(3^2 + 4^2)", "hypot(-2)", "hypot([3, 4, 5])"],
      seealso: ["abs", "norm"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/invmod.js
var invmodDocs;
var init_invmod2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/invmod.js"() {
    invmodDocs = {
      name: "invmod",
      category: "Arithmetic",
      syntax: ["invmod(a, b)"],
      description: "Calculate the (modular) multiplicative inverse of a modulo b. Solution to the equation ax \u2263 1 (mod b)",
      examples: ["invmod(8, 12)=NaN", "invmod(7, 13)=2", "math.invmod(15151, 15122)=10429"],
      seealso: ["gcd", "xgcd"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/lcm.js
var lcmDocs;
var init_lcm2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/lcm.js"() {
    lcmDocs = {
      name: "lcm",
      category: "Arithmetic",
      syntax: ["lcm(x, y)"],
      description: "Compute the least common multiple.",
      examples: ["lcm(4, 6)", "lcm(6, 21)", "lcm(6, 21, 5)"],
      seealso: ["gcd"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log.js
var logDocs;
var init_log3 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log.js"() {
    logDocs = {
      name: "log",
      category: "Arithmetic",
      syntax: ["log(x)", "log(x, base)"],
      description: "Compute the logarithm of a value. If no base is provided, the natural logarithm of x is calculated. If base if provided, the logarithm is calculated for the specified base. log(x, base) is defined as log(x) / log(base).",
      examples: ["log(3.5)", "a = log(2.4)", "exp(a)", "10 ^ 4", "log(10000, 10)", "log(10000) / log(10)", "b = log(1024, 2)", "2 ^ b"],
      seealso: ["exp", "log1p", "log2", "log10"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log10.js
var log10Docs;
var init_log102 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log10.js"() {
    log10Docs = {
      name: "log10",
      category: "Arithmetic",
      syntax: ["log10(x)"],
      description: "Compute the 10-base logarithm of a value.",
      examples: ["log10(0.00001)", "log10(10000)", "10 ^ 4", "log(10000) / log(10)", "log(10000, 10)"],
      seealso: ["exp", "log"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log1p.js
var log1pDocs;
var init_log1p2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log1p.js"() {
    log1pDocs = {
      name: "log1p",
      category: "Arithmetic",
      syntax: ["log1p(x)", "log1p(x, base)"],
      description: "Calculate the logarithm of a `value+1`",
      examples: ["log1p(2.5)", "exp(log1p(1.4))", "pow(10, 4)", "log1p(9999, 10)", "log1p(9999) / log(10)"],
      seealso: ["exp", "log", "log2", "log10"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log2.js
var log2Docs;
var init_log22 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log2.js"() {
    log2Docs = {
      name: "log2",
      category: "Arithmetic",
      syntax: ["log2(x)"],
      description: "Calculate the 2-base of a value. This is the same as calculating `log(x, 2)`.",
      examples: ["log2(0.03125)", "log2(16)", "log2(16) / log2(2)", "pow(2, 4)"],
      seealso: ["exp", "log1p", "log", "log10"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/mod.js
var modDocs;
var init_mod2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/mod.js"() {
    modDocs = {
      name: "mod",
      category: "Operators",
      syntax: ["x % y", "x mod y", "mod(x, y)"],
      description: "Calculates the modulus, the remainder of an integer division.",
      examples: ["7 % 3", "11 % 2", "10 mod 4", "isOdd(x) = x % 2", "isOdd(2)", "isOdd(3)"],
      seealso: ["divide"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/multiply.js
var multiplyDocs;
var init_multiply2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/multiply.js"() {
    multiplyDocs = {
      name: "multiply",
      category: "Operators",
      syntax: ["x * y", "multiply(x, y)"],
      description: "multiply two values.",
      examples: ["a = 2.1 * 3.4", "a / 3.4", "2 * 3 + 4", "2 * (3 + 4)", "3 * 2.1 km"],
      seealso: ["divide"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/norm.js
var normDocs;
var init_norm2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/norm.js"() {
    normDocs = {
      name: "norm",
      category: "Arithmetic",
      syntax: ["norm(x)", "norm(x, p)"],
      description: "Calculate the norm of a number, vector or matrix.",
      examples: ["abs(-3.5)", "norm(-3.5)", "norm(3 - 4i)", "norm([1, 2, -3], Infinity)", "norm([1, 2, -3], -Infinity)", "norm([3, 4], 2)", "norm([[1, 2], [3, 4]], 1)", 'norm([[1, 2], [3, 4]], "inf")', 'norm([[1, 2], [3, 4]], "fro")']
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/nthRoot.js
var nthRootDocs;
var init_nthRoot2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/nthRoot.js"() {
    nthRootDocs = {
      name: "nthRoot",
      category: "Arithmetic",
      syntax: ["nthRoot(a)", "nthRoot(a, root)"],
      description: 'Calculate the nth root of a value. The principal nth root of a positive real number A, is the positive real solution of the equation "x^root = A".',
      examples: ["4 ^ 3", "nthRoot(64, 3)", "nthRoot(9, 2)", "sqrt(9)"],
      seealso: ["nthRoots", "pow", "sqrt"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/nthRoots.js
var nthRootsDocs;
var init_nthRoots2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/nthRoots.js"() {
    nthRootsDocs = {
      name: "nthRoots",
      category: "Arithmetic",
      syntax: ["nthRoots(A)", "nthRoots(A, root)"],
      description: 'Calculate the nth roots of a value. An nth root of a positive real number A, is a positive real solution of the equation "x^root = A". This function returns an array of complex values.',
      examples: ["nthRoots(1)", "nthRoots(1, 3)"],
      seealso: ["sqrt", "pow", "nthRoot"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/pow.js
var powDocs;
var init_pow2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/pow.js"() {
    powDocs = {
      name: "pow",
      category: "Operators",
      syntax: ["x ^ y", "pow(x, y)"],
      description: "Calculates the power of x to y, x^y.",
      examples: ["2^3", "2*2*2", "1 + e ^ (pi * i)", "math.pow([[1, 2], [4, 3]], 2)", "math.pow([[1, 2], [4, 3]], -1)"],
      seealso: ["multiply", "nthRoot", "nthRoots", "sqrt"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/round.js
var roundDocs;
var init_round2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/round.js"() {
    roundDocs = {
      name: "round",
      category: "Arithmetic",
      syntax: ["round(x)", "round(x, n)"],
      description: "round a value towards the nearest integer.If x is complex, both real and imaginary part are rounded towards the nearest integer. When n is specified, the value is rounded to n decimals.",
      examples: ["round(3.2)", "round(3.8)", "round(-4.2)", "round(-4.8)", "round(pi, 3)", "round(123.45678, 2)"],
      seealso: ["ceil", "floor", "fix"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/sign.js
var signDocs;
var init_sign2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/sign.js"() {
    signDocs = {
      name: "sign",
      category: "Arithmetic",
      syntax: ["sign(x)"],
      description: "Compute the sign of a value. The sign of a value x is 1 when x>1, -1 when x<0, and 0 when x=0.",
      examples: ["sign(3.5)", "sign(-4.2)", "sign(0)"],
      seealso: ["abs"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/sqrt.js
var sqrtDocs;
var init_sqrt2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/sqrt.js"() {
    sqrtDocs = {
      name: "sqrt",
      category: "Arithmetic",
      syntax: ["sqrt(x)"],
      description: "Compute the square root value. If x = y * y, then y is the square root of x.",
      examples: ["sqrt(25)", "5 * 5", "sqrt(-1)"],
      seealso: ["square", "sqrtm", "multiply", "nthRoot", "nthRoots", "pow"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/sqrtm.js
var sqrtmDocs;
var init_sqrtm = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/sqrtm.js"() {
    sqrtmDocs = {
      name: "sqrtm",
      category: "Arithmetic",
      syntax: ["sqrtm(x)"],
      description: "Calculate the principal square root of a square matrix. The principal square root matrix `X` of another matrix `A` is such that `X * X = A`.",
      examples: ["sqrtm([[1, 2], [3, 4]])"],
      seealso: ["sqrt", "abs", "square", "multiply"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/square.js
var squareDocs;
var init_square2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/square.js"() {
    squareDocs = {
      name: "square",
      category: "Arithmetic",
      syntax: ["square(x)"],
      description: "Compute the square of a value. The square of x is x * x.",
      examples: ["square(3)", "sqrt(9)", "3^2", "3 * 3"],
      seealso: ["multiply", "pow", "sqrt", "cube"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/subtract.js
var subtractDocs;
var init_subtract2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/subtract.js"() {
    subtractDocs = {
      name: "subtract",
      category: "Operators",
      syntax: ["x - y", "subtract(x, y)"],
      description: "subtract two values.",
      examples: ["a = 5.3 - 2", "a + 2", "2/3 - 1/6", "2 * 3 - 3", "2.1 km - 500m"],
      seealso: ["add"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/unaryMinus.js
var unaryMinusDocs;
var init_unaryMinus2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/unaryMinus.js"() {
    unaryMinusDocs = {
      name: "unaryMinus",
      category: "Operators",
      syntax: ["-x", "unaryMinus(x)"],
      description: "Inverse the sign of a value. Converts booleans and strings to numbers.",
      examples: ["-4.5", "-(-5.6)", '-"22"'],
      seealso: ["add", "subtract", "unaryPlus"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/unaryPlus.js
var unaryPlusDocs;
var init_unaryPlus2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/unaryPlus.js"() {
    unaryPlusDocs = {
      name: "unaryPlus",
      category: "Operators",
      syntax: ["+x", "unaryPlus(x)"],
      description: "Converts booleans and strings to numbers.",
      examples: ["+true", '+"2"'],
      seealso: ["add", "subtract", "unaryMinus"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/xgcd.js
var xgcdDocs;
var init_xgcd2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/xgcd.js"() {
    xgcdDocs = {
      name: "xgcd",
      category: "Arithmetic",
      syntax: ["xgcd(a, b)"],
      description: "Calculate the extended greatest common divisor for two values. The result is an array [d, x, y] with 3 entries, where d is the greatest common divisor, and d = x * a + y * b.",
      examples: ["xgcd(8, 12)", "gcd(8, 12)", "xgcd(36163, 21199)"],
      seealso: ["gcd", "lcm"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitAnd.js
var bitAndDocs;
var init_bitAnd2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitAnd.js"() {
    bitAndDocs = {
      name: "bitAnd",
      category: "Bitwise",
      syntax: ["x & y", "bitAnd(x, y)"],
      description: "Bitwise AND operation. Performs the logical AND operation on each pair of the corresponding bits of the two given values by multiplying them. If both bits in the compared position are 1, the bit in the resulting binary representation is 1, otherwise, the result is 0",
      examples: ["5 & 3", "bitAnd(53, 131)", "[1, 12, 31] & 42"],
      seealso: ["bitNot", "bitOr", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitNot.js
var bitNotDocs;
var init_bitNot2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitNot.js"() {
    bitNotDocs = {
      name: "bitNot",
      category: "Bitwise",
      syntax: ["~x", "bitNot(x)"],
      description: "Bitwise NOT operation. Performs a logical negation on each bit of the given value. Bits that are 0 become 1, and those that are 1 become 0.",
      examples: ["~1", "~2", "bitNot([2, -3, 4])"],
      seealso: ["bitAnd", "bitOr", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitOr.js
var bitOrDocs;
var init_bitOr2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitOr.js"() {
    bitOrDocs = {
      name: "bitOr",
      category: "Bitwise",
      syntax: ["x | y", "bitOr(x, y)"],
      description: "Bitwise OR operation. Performs the logical inclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if the first bit is 1 or the second bit is 1 or both bits are 1, otherwise, the result is 0.",
      examples: ["5 | 3", "bitOr([1, 2, 3], 4)"],
      seealso: ["bitAnd", "bitNot", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitXor.js
var bitXorDocs;
var init_bitXor2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitXor.js"() {
    bitXorDocs = {
      name: "bitXor",
      category: "Bitwise",
      syntax: ["bitXor(x, y)"],
      description: "Bitwise XOR operation, exclusive OR. Performs the logical exclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if only the first bit is 1 or only the second bit is 1, but will be 0 if both are 0 or both are 1.",
      examples: ["bitOr(1, 2)", "bitXor([2, 3, 4], 4)"],
      seealso: ["bitAnd", "bitNot", "bitOr", "leftShift", "rightArithShift", "rightLogShift"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/leftShift.js
var leftShiftDocs;
var init_leftShift2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/leftShift.js"() {
    leftShiftDocs = {
      name: "leftShift",
      category: "Bitwise",
      syntax: ["x << y", "leftShift(x, y)"],
      description: "Bitwise left logical shift of a value x by y number of bits.",
      examples: ["4 << 1", "8 >> 1"],
      seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "rightArithShift", "rightLogShift"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/rightArithShift.js
var rightArithShiftDocs;
var init_rightArithShift2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/rightArithShift.js"() {
    rightArithShiftDocs = {
      name: "rightArithShift",
      category: "Bitwise",
      syntax: ["x >> y", "rightArithShift(x, y)"],
      description: "Bitwise right arithmetic shift of a value x by y number of bits.",
      examples: ["8 >> 1", "4 << 1", "-12 >> 2"],
      seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "leftShift", "rightLogShift"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/rightLogShift.js
var rightLogShiftDocs;
var init_rightLogShift2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/rightLogShift.js"() {
    rightLogShiftDocs = {
      name: "rightLogShift",
      category: "Bitwise",
      syntax: ["x >>> y", "rightLogShift(x, y)"],
      description: "Bitwise right logical shift of a value x by y number of bits.",
      examples: ["8 >>> 1", "4 << 1", "-12 >>> 2"],
      seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "leftShift", "rightArithShift"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/bellNumbers.js
var bellNumbersDocs;
var init_bellNumbers = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/bellNumbers.js"() {
    bellNumbersDocs = {
      name: "bellNumbers",
      category: "Combinatorics",
      syntax: ["bellNumbers(n)"],
      description: "The Bell Numbers count the number of partitions of a set. A partition is a pairwise disjoint subset of S whose union is S. `bellNumbers` only takes integer arguments. The following condition must be enforced: n >= 0.",
      examples: ["bellNumbers(3)", "bellNumbers(8)"],
      seealso: ["stirlingS2"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/catalan.js
var catalanDocs;
var init_catalan = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/catalan.js"() {
    catalanDocs = {
      name: "catalan",
      category: "Combinatorics",
      syntax: ["catalan(n)"],
      description: "The Catalan Numbers enumerate combinatorial structures of many different types. catalan only takes integer arguments. The following condition must be enforced: n >= 0.",
      examples: ["catalan(3)", "catalan(8)"],
      seealso: ["bellNumbers"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/composition.js
var compositionDocs;
var init_composition = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/composition.js"() {
    compositionDocs = {
      name: "composition",
      category: "Combinatorics",
      syntax: ["composition(n, k)"],
      description: "The composition counts of n into k parts. composition only takes integer arguments. The following condition must be enforced: k <= n.",
      examples: ["composition(5, 3)"],
      seealso: ["combinations"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/stirlingS2.js
var stirlingS2Docs;
var init_stirlingS2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/stirlingS2.js"() {
    stirlingS2Docs = {
      name: "stirlingS2",
      category: "Combinatorics",
      syntax: ["stirlingS2(n, k)"],
      description: "he Stirling numbers of the second kind, counts the number of ways to partition a set of n labelled objects into k nonempty unlabelled subsets. `stirlingS2` only takes integer arguments. The following condition must be enforced: k <= n. If n = k or k = 1, then s(n,k) = 1.",
      examples: ["stirlingS2(5, 3)"],
      seealso: ["bellNumbers"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/arg.js
var argDocs;
var init_arg2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/arg.js"() {
    argDocs = {
      name: "arg",
      category: "Complex",
      syntax: ["arg(x)"],
      description: "Compute the argument of a complex value. If x = a+bi, the argument is computed as atan2(b, a).",
      examples: ["arg(2 + 2i)", "atan2(3, 2)", "arg(2 + 3i)"],
      seealso: ["re", "im", "conj", "abs"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/conj.js
var conjDocs;
var init_conj2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/conj.js"() {
    conjDocs = {
      name: "conj",
      category: "Complex",
      syntax: ["conj(x)"],
      description: "Compute the complex conjugate of a complex value. If x = a+bi, the complex conjugate is a-bi.",
      examples: ["conj(2 + 3i)", "conj(2 - 3i)", "conj(-5.2i)"],
      seealso: ["re", "im", "abs", "arg"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/im.js
var imDocs;
var init_im2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/im.js"() {
    imDocs = {
      name: "im",
      category: "Complex",
      syntax: ["im(x)"],
      description: "Get the imaginary part of a complex number.",
      examples: ["im(2 + 3i)", "re(2 + 3i)", "im(-5.2i)", "im(2.4)"],
      seealso: ["re", "conj", "abs", "arg"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/re.js
var reDocs;
var init_re2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/re.js"() {
    reDocs = {
      name: "re",
      category: "Complex",
      syntax: ["re(x)"],
      description: "Get the real part of a complex number.",
      examples: ["re(2 + 3i)", "im(2 + 3i)", "re(-5.2i)", "re(2.4)"],
      seealso: ["im", "conj", "abs", "arg"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/expression/evaluate.js
var evaluateDocs;
var init_evaluate2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/expression/evaluate.js"() {
    evaluateDocs = {
      name: "evaluate",
      category: "Expression",
      syntax: ["evaluate(expression)", "evaluate([expr1, expr2, expr3, ...])"],
      description: "Evaluate an expression or an array with expressions.",
      examples: ['evaluate("2 + 3")', 'evaluate("sqrt(" + 4 + ")")'],
      seealso: []
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/expression/help.js
var helpDocs;
var init_help = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/expression/help.js"() {
    helpDocs = {
      name: "help",
      category: "Expression",
      syntax: ["help(object)", "help(string)"],
      description: "Display documentation on a function or data type.",
      examples: ["help(sqrt)", 'help("complex")'],
      seealso: []
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/geometry/distance.js
var distanceDocs;
var init_distance = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/geometry/distance.js"() {
    distanceDocs = {
      name: "distance",
      category: "Geometry",
      syntax: ["distance([x1, y1], [x2, y2])", "distance([[x1, y1], [x2, y2]])"],
      description: "Calculates the Euclidean distance between two points.",
      examples: ["distance([0,0], [4,4])", "distance([[0,0], [4,4]])"],
      seealso: []
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/geometry/intersect.js
var intersectDocs;
var init_intersect = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/geometry/intersect.js"() {
    intersectDocs = {
      name: "intersect",
      category: "Geometry",
      syntax: ["intersect(expr1, expr2, expr3, expr4)", "intersect(expr1, expr2, expr3)"],
      description: "Computes the intersection point of lines and/or planes.",
      examples: ["intersect([0, 0], [10, 10], [10, 0], [0, 10])", "intersect([1, 0, 1],  [4, -2, 2], [1, 1, 1, 6])"],
      seealso: []
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/and.js
var andDocs;
var init_and2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/and.js"() {
    andDocs = {
      name: "and",
      category: "Logical",
      syntax: ["x and y", "and(x, y)"],
      description: "Logical and. Test whether two values are both defined with a nonzero/nonempty value.",
      examples: ["true and false", "true and true", "2 and 4"],
      seealso: ["not", "or", "xor"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/not.js
var notDocs;
var init_not2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/not.js"() {
    notDocs = {
      name: "not",
      category: "Logical",
      syntax: ["not x", "not(x)"],
      description: "Logical not. Flips the boolean value of given argument.",
      examples: ["not true", "not false", "not 2", "not 0"],
      seealso: ["and", "or", "xor"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/or.js
var orDocs;
var init_or2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/or.js"() {
    orDocs = {
      name: "or",
      category: "Logical",
      syntax: ["x or y", "or(x, y)"],
      description: "Logical or. Test if at least one value is defined with a nonzero/nonempty value.",
      examples: ["true or false", "false or false", "0 or 4"],
      seealso: ["not", "and", "xor"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/xor.js
var xorDocs;
var init_xor2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/xor.js"() {
    xorDocs = {
      name: "xor",
      category: "Logical",
      syntax: ["x xor y", "xor(x, y)"],
      description: "Logical exclusive or, xor. Test whether one and only one value is defined with a nonzero/nonempty value.",
      examples: ["true xor false", "false xor false", "true xor true", "0 xor 4"],
      seealso: ["not", "and", "or"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/column.js
var columnDocs;
var init_column2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/column.js"() {
    columnDocs = {
      name: "column",
      category: "Matrix",
      syntax: ["column(x, index)"],
      description: "Return a column from a matrix or array.",
      examples: ["A = [[1, 2], [3, 4]]", "column(A, 1)", "column(A, 2)"],
      seealso: ["row", "matrixFromColumns"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/concat.js
var concatDocs;
var init_concat2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/concat.js"() {
    concatDocs = {
      name: "concat",
      category: "Matrix",
      syntax: ["concat(A, B, C, ...)", "concat(A, B, C, ..., dim)"],
      description: "Concatenate matrices. By default, the matrices are concatenated by the last dimension. The dimension on which to concatenate can be provided as last argument.",
      examples: ["A = [1, 2; 5, 6]", "B = [3, 4; 7, 8]", "concat(A, B)", "concat(A, B, 1)", "concat(A, B, 2)"],
      seealso: ["det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/count.js
var countDocs;
var init_count2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/count.js"() {
    countDocs = {
      name: "count",
      category: "Matrix",
      syntax: ["count(x)"],
      description: "Count the number of elements of a matrix, array or string.",
      examples: ["a = [1, 2; 3, 4; 5, 6]", "count(a)", "size(a)", 'count("hello world")'],
      seealso: ["size"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/cross.js
var crossDocs;
var init_cross2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/cross.js"() {
    crossDocs = {
      name: "cross",
      category: "Matrix",
      syntax: ["cross(A, B)"],
      description: "Calculate the cross product for two vectors in three dimensional space.",
      examples: ["cross([1, 1, 0],  [0, 1, 1])", "cross([3, -3, 1], [4, 9, 2])", "cross([2, 3, 4],  [5, 6, 7])"],
      seealso: ["multiply", "dot"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/ctranspose.js
var ctransposeDocs;
var init_ctranspose2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/ctranspose.js"() {
    ctransposeDocs = {
      name: "ctranspose",
      category: "Matrix",
      syntax: ["x'", "ctranspose(x)"],
      description: "Complex Conjugate and Transpose a matrix",
      examples: ["a = [1, 2, 3; 4, 5, 6]", "a'", "ctranspose(a)"],
      seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "zeros"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/det.js
var detDocs;
var init_det = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/det.js"() {
    detDocs = {
      name: "det",
      category: "Matrix",
      syntax: ["det(x)"],
      description: "Calculate the determinant of a matrix",
      examples: ["det([1, 2; 3, 4])", "det([-2, 2, 3; -1, 1, 3; 2, 0, -1])"],
      seealso: ["concat", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/diag.js
var diagDocs;
var init_diag2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/diag.js"() {
    diagDocs = {
      name: "diag",
      category: "Matrix",
      syntax: ["diag(x)", "diag(x, k)"],
      description: "Create a diagonal matrix or retrieve the diagonal of a matrix. When x is a vector, a matrix with the vector values on the diagonal will be returned. When x is a matrix, a vector with the diagonal values of the matrix is returned. When k is provided, the k-th diagonal will be filled in or retrieved, if k is positive, the values are placed on the super diagonal. When k is negative, the values are placed on the sub diagonal.",
      examples: ["diag(1:3)", "diag(1:3, 1)", "a = [1, 2, 3; 4, 5, 6; 7, 8, 9]", "diag(a)"],
      seealso: ["concat", "det", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/diff.js
var diffDocs;
var init_diff2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/diff.js"() {
    diffDocs = {
      name: "diff",
      category: "Matrix",
      syntax: ["diff(arr)", "diff(arr, dim)"],
      description: ["Create a new matrix or array with the difference of the passed matrix or array.", "Dim parameter is optional and used to indicant the dimension of the array/matrix to apply the difference", "If no dimension parameter is passed it is assumed as dimension 0", "Dimension is zero-based in javascript and one-based in the parser", "Arrays must be 'rectangular' meaning arrays like [1, 2]", "If something is passed as a matrix it will be returned as a matrix but other than that all matrices are converted to arrays"],
      examples: ["diff([1, 2, 4, 7, 0])", "diff([1, 2, 4, 7, 0], 0)", "diff(matrix([1, 2, 4, 7, 0]))", "diff([[1, 2], [3, 4]])", "diff([[1, 2], [3, 4]], 0)", "diff([[1, 2], [3, 4]], 1)", "diff([[1, 2], [3, 4]], bignumber(1))", "diff(matrix([[1, 2], [3, 4]]), 1)", "diff([[1, 2], matrix([3, 4])], 1)"],
      seealso: ["subtract", "partitionSelect"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/dot.js
var dotDocs;
var init_dot2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/dot.js"() {
    dotDocs = {
      name: "dot",
      category: "Matrix",
      syntax: ["dot(A, B)", "A * B"],
      description: "Calculate the dot product of two vectors. The dot product of A = [a1, a2, a3, ..., an] and B = [b1, b2, b3, ..., bn] is defined as dot(A, B) = a1 * b1 + a2 * b2 + a3 * b3 + ... + an * bn",
      examples: ["dot([2, 4, 1], [2, 2, 3])", "[2, 4, 1] * [2, 2, 3]"],
      seealso: ["multiply", "cross"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/eigs.js
var eigsDocs;
var init_eigs = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/eigs.js"() {
    eigsDocs = {
      name: "eigs",
      category: "Matrix",
      syntax: ["eigs(x)"],
      description: "Calculate the eigenvalues and eigenvectors of a real symmetric matrix",
      examples: ["eigs([[5, 2.3], [2.3, 1]])"],
      seealso: ["inv"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/filter.js
var filterDocs;
var init_filter2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/filter.js"() {
    filterDocs = {
      name: "filter",
      category: "Matrix",
      syntax: ["filter(x, test)"],
      description: "Filter items in a matrix.",
      examples: ["isPositive(x) = x > 0", "filter([6, -2, -1, 4, 3], isPositive)", "filter([6, -2, 0, 1, 0], x != 0)"],
      seealso: ["sort", "map", "forEach"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/flatten.js
var flattenDocs;
var init_flatten2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/flatten.js"() {
    flattenDocs = {
      name: "flatten",
      category: "Matrix",
      syntax: ["flatten(x)"],
      description: "Flatten a multi dimensional matrix into a single dimensional matrix.",
      examples: ["a = [1, 2, 3; 4, 5, 6]", "size(a)", "b = flatten(a)", "size(b)"],
      seealso: ["concat", "resize", "size", "squeeze"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/forEach.js
var forEachDocs;
var init_forEach2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/forEach.js"() {
    forEachDocs = {
      name: "forEach",
      category: "Matrix",
      syntax: ["forEach(x, callback)"],
      description: "Iterates over all elements of a matrix/array, and executes the given callback function.",
      examples: ["numberOfPets = {}", "addPet(n) = numberOfPets[n] = (numberOfPets[n] ? numberOfPets[n]:0 ) + 1;", 'forEach(["Dog","Cat","Cat"], addPet)', "numberOfPets"],
      seealso: ["map", "sort", "filter"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/getMatrixDataType.js
var getMatrixDataTypeDocs;
var init_getMatrixDataType2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/getMatrixDataType.js"() {
    getMatrixDataTypeDocs = {
      name: "getMatrixDataType",
      category: "Matrix",
      syntax: ["getMatrixDataType(x)"],
      description: 'Find the data type of all elements in a matrix or array, for example "number" if all items are a number and "Complex" if all values are complex numbers. If a matrix contains more than one data type, it will return "mixed".',
      examples: ["getMatrixDataType([1, 2, 3])", "getMatrixDataType([[5 cm], [2 inch]])", 'getMatrixDataType([1, "text"])', "getMatrixDataType([1, bignumber(4)])"],
      seealso: ["matrix", "sparse", "typeOf"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/identity.js
var identityDocs;
var init_identity2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/identity.js"() {
    identityDocs = {
      name: "identity",
      category: "Matrix",
      syntax: ["identity(n)", "identity(m, n)", "identity([m, n])"],
      description: "Returns the identity matrix with size m-by-n. The matrix has ones on the diagonal and zeros elsewhere.",
      examples: ["identity(3)", "identity(3, 5)", "a = [1, 2, 3; 4, 5, 6]", "identity(size(a))"],
      seealso: ["concat", "det", "diag", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/inv.js
var invDocs;
var init_inv = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/inv.js"() {
    invDocs = {
      name: "inv",
      category: "Matrix",
      syntax: ["inv(x)"],
      description: "Calculate the inverse of a matrix",
      examples: ["inv([1, 2; 3, 4])", "inv(4)", "1 / 4"],
      seealso: ["concat", "det", "diag", "identity", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/pinv.js
var pinvDocs;
var init_pinv = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/pinv.js"() {
    pinvDocs = {
      name: "pinv",
      category: "Matrix",
      syntax: ["pinv(x)"],
      description: "Calculate the Moore\u2013Penrose inverse of a matrix",
      examples: ["pinv([1, 2; 3, 4])", "pinv([[1, 0], [0, 1], [0, 1]])", "pinv(4)"],
      seealso: ["inv"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/kron.js
var kronDocs;
var init_kron2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/kron.js"() {
    kronDocs = {
      name: "kron",
      category: "Matrix",
      syntax: ["kron(x, y)"],
      description: "Calculates the kronecker product of 2 matrices or vectors.",
      examples: ["kron([[1, 0], [0, 1]], [[1, 2], [3, 4]])", "kron([1,1], [2,3,4])"],
      seealso: ["multiply", "dot", "cross"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/map.js
var mapDocs;
var init_map3 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/map.js"() {
    mapDocs = {
      name: "map",
      category: "Matrix",
      syntax: ["map(x, callback)"],
      description: "Create a new matrix or array with the results of the callback function executed on each entry of the matrix/array.",
      examples: ["map([1, 2, 3], square)"],
      seealso: ["filter", "forEach"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/matrixFromColumns.js
var matrixFromColumnsDocs;
var init_matrixFromColumns2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/matrixFromColumns.js"() {
    matrixFromColumnsDocs = {
      name: "matrixFromColumns",
      category: "Matrix",
      syntax: ["math.matrixFromColumns(...arr)", "math.matrixFromColumns(row1, row2)", "math.matrixFromColumns(row1, row2, row3)"],
      description: "Create a dense matrix from vectors as individual columns.",
      examples: ["matrixFromColumns([1, 2, 3], [[4],[5],[6]])"],
      seealso: ["matrix", "matrixFromRows", "matrixFromFunction", "zeros"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/matrixFromFunction.js
var matrixFromFunctionDocs;
var init_matrixFromFunction2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/matrixFromFunction.js"() {
    matrixFromFunctionDocs = {
      name: "matrixFromFunction",
      category: "Matrix",
      syntax: ["math.matrixFromFunction(size, fn)", "math.matrixFromFunction(size, fn, format)", "math.matrixFromFunction(size, fn, format, datatype)", "math.matrixFromFunction(size, format, fn)", "math.matrixFromFunction(size, format, datatype, fn)"],
      description: "Create a matrix by evaluating a generating function at each index.",
      examples: ["f(I) = I[1] - I[2]", "matrixFromFunction([3,3], f)", "g(I) = I[1] - I[2] == 1 ? 4 : 0", 'matrixFromFunction([100, 100], "sparse", g)', "matrixFromFunction([5], random)"],
      seealso: ["matrix", "matrixFromRows", "matrixFromColumns", "zeros"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/matrixFromRows.js
var matrixFromRowsDocs;
var init_matrixFromRows2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/matrixFromRows.js"() {
    matrixFromRowsDocs = {
      name: "matrixFromRows",
      category: "Matrix",
      syntax: ["math.matrixFromRows(...arr)", "math.matrixFromRows(row1, row2)", "math.matrixFromRows(row1, row2, row3)"],
      description: "Create a dense matrix from vectors as individual rows.",
      examples: ["matrixFromRows([1, 2, 3], [[4],[5],[6]])"],
      seealso: ["matrix", "matrixFromColumns", "matrixFromFunction", "zeros"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/ones.js
var onesDocs;
var init_ones2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/ones.js"() {
    onesDocs = {
      name: "ones",
      category: "Matrix",
      syntax: ["ones(m)", "ones(m, n)", "ones(m, n, p, ...)", "ones([m])", "ones([m, n])", "ones([m, n, p, ...])"],
      description: "Create a matrix containing ones.",
      examples: ["ones(3)", "ones(3, 5)", "ones([2,3]) * 4.5", "a = [1, 2, 3; 4, 5, 6]", "ones(size(a))"],
      seealso: ["concat", "det", "diag", "identity", "inv", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/partitionSelect.js
var partitionSelectDocs;
var init_partitionSelect2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/partitionSelect.js"() {
    partitionSelectDocs = {
      name: "partitionSelect",
      category: "Matrix",
      syntax: ["partitionSelect(x, k)", "partitionSelect(x, k, compare)"],
      description: "Partition-based selection of an array or 1D matrix. Will find the kth smallest value, and mutates the input array. Uses Quickselect.",
      examples: ["partitionSelect([5, 10, 1], 2)", 'partitionSelect(["C", "B", "A", "D"], 1)'],
      seealso: ["sort"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/range.js
var rangeDocs;
var init_range2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/range.js"() {
    rangeDocs = {
      name: "range",
      category: "Type",
      syntax: ["start:end", "start:step:end", "range(start, end)", "range(start, end, step)", "range(string)"],
      description: "Create a range. Lower bound of the range is included, upper bound is excluded.",
      examples: ["1:5", "3:-1:-3", "range(3, 7)", "range(0, 12, 2)", 'range("4:10")', "a = [1, 2, 3, 4; 5, 6, 7, 8]", "a[1:2, 1:2]"],
      seealso: ["concat", "det", "diag", "identity", "inv", "ones", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/reshape.js
var reshapeDocs;
var init_reshape2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/reshape.js"() {
    reshapeDocs = {
      name: "reshape",
      category: "Matrix",
      syntax: ["reshape(x, sizes)"],
      description: "Reshape a multi dimensional array to fit the specified dimensions.",
      examples: ["reshape([1, 2, 3, 4, 5, 6], [2, 3])", "reshape([[1, 2], [3, 4]], [1, 4])", "reshape([[1, 2], [3, 4]], [4])"],
      seealso: ["size", "squeeze", "resize"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/resize.js
var resizeDocs;
var init_resize2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/resize.js"() {
    resizeDocs = {
      name: "resize",
      category: "Matrix",
      syntax: ["resize(x, size)", "resize(x, size, defaultValue)"],
      description: "Resize a matrix.",
      examples: ["resize([1,2,3,4,5], [3])", "resize([1,2,3], [5])", "resize([1,2,3], [5], -1)", "resize(2, [2, 3])", 'resize("hello", [8], "!")'],
      seealso: ["size", "subset", "squeeze", "reshape"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/rotate.js
var rotateDocs;
var init_rotate2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/rotate.js"() {
    rotateDocs = {
      name: "rotate",
      category: "Matrix",
      syntax: ["rotate(w, theta)", "rotate(w, theta, v)"],
      description: "Returns a 2-D rotation matrix (2x2) for a given angle (in radians). Returns a 2-D rotation matrix (3x3) of a given angle (in radians) around given axis.",
      examples: ["rotate([1, 0], math.pi / 2)", 'rotate(matrix([1, 0]), unit("35deg"))', 'rotate([1, 0, 0], unit("90deg"), [0, 0, 1])', 'rotate(matrix([1, 0, 0]), unit("90deg"), matrix([0, 0, 1]))'],
      seealso: ["matrix", "rotationMatrix"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/rotationMatrix.js
var rotationMatrixDocs;
var init_rotationMatrix2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/rotationMatrix.js"() {
    rotationMatrixDocs = {
      name: "rotationMatrix",
      category: "Matrix",
      syntax: ["rotationMatrix(theta)", "rotationMatrix(theta, v)", "rotationMatrix(theta, v, format)"],
      description: "Returns a 2-D rotation matrix (2x2) for a given angle (in radians). Returns a 2-D rotation matrix (3x3) of a given angle (in radians) around given axis.",
      examples: ["rotationMatrix(pi / 2)", 'rotationMatrix(unit("45deg"), [0, 0, 1])', 'rotationMatrix(1, matrix([0, 0, 1]), "sparse")'],
      seealso: ["cos", "sin"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/row.js
var rowDocs;
var init_row2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/row.js"() {
    rowDocs = {
      name: "row",
      category: "Matrix",
      syntax: ["row(x, index)"],
      description: "Return a row from a matrix or array.",
      examples: ["A = [[1, 2], [3, 4]]", "row(A, 1)", "row(A, 2)"],
      seealso: ["column", "matrixFromRows"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/size.js
var sizeDocs;
var init_size2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/size.js"() {
    sizeDocs = {
      name: "size",
      category: "Matrix",
      syntax: ["size(x)"],
      description: "Calculate the size of a matrix.",
      examples: ["size(2.3)", 'size("hello world")', "a = [1, 2; 3, 4; 5, 6]", "size(a)", "size(1:6)"],
      seealso: ["concat", "count", "det", "diag", "identity", "inv", "ones", "range", "squeeze", "subset", "trace", "transpose", "zeros"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/sort.js
var sortDocs;
var init_sort2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/sort.js"() {
    sortDocs = {
      name: "sort",
      category: "Matrix",
      syntax: ["sort(x)", "sort(x, compare)"],
      description: 'Sort the items in a matrix. Compare can be a string "asc", "desc", "natural", or a custom sort function.',
      examples: ["sort([5, 10, 1])", 'sort(["C", "B", "A", "D"])', "sortByLength(a, b) = size(a)[1] - size(b)[1]", 'sort(["Langdon", "Tom", "Sara"], sortByLength)', 'sort(["10", "1", "2"], "natural")'],
      seealso: ["map", "filter", "forEach"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/squeeze.js
var squeezeDocs;
var init_squeeze2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/squeeze.js"() {
    squeezeDocs = {
      name: "squeeze",
      category: "Matrix",
      syntax: ["squeeze(x)"],
      description: "Remove inner and outer singleton dimensions from a matrix.",
      examples: ["a = zeros(3,2,1)", "size(squeeze(a))", "b = zeros(1,1,3)", "size(squeeze(b))"],
      seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "subset", "trace", "transpose", "zeros"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/subset.js
var subsetDocs;
var init_subset2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/subset.js"() {
    subsetDocs = {
      name: "subset",
      category: "Matrix",
      syntax: ["value(index)", "value(index) = replacement", "subset(value, [index])", "subset(value, [index], replacement)"],
      description: "Get or set a subset of the entries of a matrix or characters of a string. Indexes are one-based. There should be one index specification for each dimension of the target. Each specification can be a single index, a list of indices, or a range in colon notation `l:u`. In a range, both the lower bound l and upper bound u are included; and if a bound is omitted it defaults to the most extreme valid value. The cartesian product of the indices specified in each dimension determines the target of the operation.",
      examples: ["d = [1, 2; 3, 4]", "e = []", "e[1, 1:2] = [5, 6]", "e[2, :] = [7, 8]", "f = d * e", "f[2, 1]", "f[:, 1]", "f[[1,2], [1,3]] = [9, 10; 11, 12]", "f"],
      seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "trace", "transpose", "zeros"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/trace.js
var traceDocs;
var init_trace2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/trace.js"() {
    traceDocs = {
      name: "trace",
      category: "Matrix",
      syntax: ["trace(A)"],
      description: "Calculate the trace of a matrix: the sum of the elements on the main diagonal of a square matrix.",
      examples: ["A = [1, 2, 3; -1, 2, 3; 2, 0, 3]", "trace(A)"],
      seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "transpose", "zeros"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/transpose.js
var transposeDocs;
var init_transpose2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/transpose.js"() {
    transposeDocs = {
      name: "transpose",
      category: "Matrix",
      syntax: ["x'", "transpose(x)"],
      description: "Transpose a matrix",
      examples: ["a = [1, 2, 3; 4, 5, 6]", "a'", "transpose(a)"],
      seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "zeros"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/zeros.js
var zerosDocs;
var init_zeros2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/zeros.js"() {
    zerosDocs = {
      name: "zeros",
      category: "Matrix",
      syntax: ["zeros(m)", "zeros(m, n)", "zeros(m, n, p, ...)", "zeros([m])", "zeros([m, n])", "zeros([m, n, p, ...])"],
      description: "Create a matrix containing zeros.",
      examples: ["zeros(3)", "zeros(3, 5)", "a = [1, 2, 3; 4, 5, 6]", "zeros(size(a))"],
      seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/fft.js
var fftDocs;
var init_fft2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/fft.js"() {
    fftDocs = {
      name: "fft",
      category: "Matrix",
      syntax: ["fft(x)"],
      description: "Calculate N-dimensional fourier transform",
      examples: ["fft([[1, 0], [1, 0]])"],
      seealso: ["ifft"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/ifft.js
var ifftDocs;
var init_ifft2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/ifft.js"() {
    ifftDocs = {
      name: "ifft",
      category: "Matrix",
      syntax: ["ifft(x)"],
      description: "Calculate N-dimensional inverse fourier transform",
      examples: ["ifft([[2, 2], [0, 0]])"],
      seealso: ["fft"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/combinations.js
var combinationsDocs;
var init_combinations2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/combinations.js"() {
    combinationsDocs = {
      name: "combinations",
      category: "Probability",
      syntax: ["combinations(n, k)"],
      description: "Compute the number of combinations of n items taken k at a time",
      examples: ["combinations(7, 5)"],
      seealso: ["combinationsWithRep", "permutations", "factorial"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/combinationsWithRep.js
var combinationsWithRepDocs;
var init_combinationsWithRep = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/combinationsWithRep.js"() {
    combinationsWithRepDocs = {
      name: "combinationsWithRep",
      category: "Probability",
      syntax: ["combinationsWithRep(n, k)"],
      description: "Compute the number of combinations of n items taken k at a time with replacements.",
      examples: ["combinationsWithRep(7, 5)"],
      seealso: ["combinations", "permutations", "factorial"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/factorial.js
var factorialDocs;
var init_factorial = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/factorial.js"() {
    factorialDocs = {
      name: "factorial",
      category: "Probability",
      syntax: ["n!", "factorial(n)"],
      description: "Compute the factorial of a value",
      examples: ["5!", "5 * 4 * 3 * 2 * 1", "3!"],
      seealso: ["combinations", "combinationsWithRep", "permutations", "gamma"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/gamma.js
var gammaDocs;
var init_gamma = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/gamma.js"() {
    gammaDocs = {
      name: "gamma",
      category: "Probability",
      syntax: ["gamma(n)"],
      description: "Compute the gamma function. For small values, the Lanczos approximation is used, and for large values the extended Stirling approximation.",
      examples: ["gamma(4)", "3!", "gamma(1/2)", "sqrt(pi)"],
      seealso: ["factorial"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/lgamma.js
var lgammaDocs;
var init_lgamma = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/lgamma.js"() {
    lgammaDocs = {
      name: "lgamma",
      category: "Probability",
      syntax: ["lgamma(n)"],
      description: "Logarithm of the gamma function for real, positive numbers and complex numbers, using Lanczos approximation for numbers and Stirling series for complex numbers.",
      examples: ["lgamma(4)", "lgamma(1/2)", "lgamma(math.i)", "lgamma(complex(1.1, 2))"],
      seealso: ["gamma"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/kldivergence.js
var kldivergenceDocs;
var init_kldivergence = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/kldivergence.js"() {
    kldivergenceDocs = {
      name: "kldivergence",
      category: "Probability",
      syntax: ["kldivergence(x, y)"],
      description: "Calculate the Kullback-Leibler (KL) divergence  between two distributions.",
      examples: ["kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5])"],
      seealso: []
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/multinomial.js
var multinomialDocs;
var init_multinomial = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/multinomial.js"() {
    multinomialDocs = {
      name: "multinomial",
      category: "Probability",
      syntax: ["multinomial(A)"],
      description: "Multinomial Coefficients compute the number of ways of picking a1, a2, ..., ai unordered outcomes from `n` possibilities. multinomial takes one array of integers as an argument. The following condition must be enforced: every ai > 0.",
      examples: ["multinomial([1, 2, 1])"],
      seealso: ["combinations", "factorial"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/permutations.js
var permutationsDocs;
var init_permutations = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/permutations.js"() {
    permutationsDocs = {
      name: "permutations",
      category: "Probability",
      syntax: ["permutations(n)", "permutations(n, k)"],
      description: "Compute the number of permutations of n items taken k at a time",
      examples: ["permutations(5)", "permutations(5, 3)"],
      seealso: ["combinations", "combinationsWithRep", "factorial"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/pickRandom.js
var pickRandomDocs;
var init_pickRandom = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/pickRandom.js"() {
    pickRandomDocs = {
      name: "pickRandom",
      category: "Probability",
      syntax: ["pickRandom(array)", "pickRandom(array, number)", "pickRandom(array, weights)", "pickRandom(array, number, weights)", "pickRandom(array, weights, number)"],
      description: "Pick a random entry from a given array.",
      examples: ["pickRandom(0:10)", "pickRandom([1, 3, 1, 6])", "pickRandom([1, 3, 1, 6], 2)", "pickRandom([1, 3, 1, 6], [2, 3, 2, 1])", "pickRandom([1, 3, 1, 6], 2, [2, 3, 2, 1])", "pickRandom([1, 3, 1, 6], [2, 3, 2, 1], 2)"],
      seealso: ["random", "randomInt"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/random.js
var randomDocs;
var init_random = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/random.js"() {
    randomDocs = {
      name: "random",
      category: "Probability",
      syntax: ["random()", "random(max)", "random(min, max)", "random(size)", "random(size, max)", "random(size, min, max)"],
      description: "Return a random number.",
      examples: ["random()", "random(10, 20)", "random([2, 3])"],
      seealso: ["pickRandom", "randomInt"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/randomInt.js
var randomIntDocs;
var init_randomInt = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/randomInt.js"() {
    randomIntDocs = {
      name: "randomInt",
      category: "Probability",
      syntax: ["randomInt(max)", "randomInt(min, max)", "randomInt(size)", "randomInt(size, max)", "randomInt(size, min, max)"],
      description: "Return a random integer number",
      examples: ["randomInt(10, 20)", "randomInt([2, 3], 10)"],
      seealso: ["pickRandom", "random"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/compare.js
var compareDocs;
var init_compare2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/compare.js"() {
    compareDocs = {
      name: "compare",
      category: "Relational",
      syntax: ["compare(x, y)"],
      description: "Compare two values. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
      examples: ["compare(2, 3)", "compare(3, 2)", "compare(2, 2)", "compare(5cm, 40mm)", "compare(2, [1, 2, 3])"],
      seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compareNatural", "compareText"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/compareNatural.js
var compareNaturalDocs;
var init_compareNatural2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/compareNatural.js"() {
    compareNaturalDocs = {
      name: "compareNatural",
      category: "Relational",
      syntax: ["compareNatural(x, y)"],
      description: "Compare two values of any type in a deterministic, natural way. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
      examples: ["compareNatural(2, 3)", "compareNatural(3, 2)", "compareNatural(2, 2)", "compareNatural(5cm, 40mm)", 'compareNatural("2", "10")', "compareNatural(2 + 3i, 2 + 4i)", "compareNatural([1, 2, 4], [1, 2, 3])", "compareNatural([1, 5], [1, 2, 3])", "compareNatural([1, 2], [1, 2])", "compareNatural({a: 2}, {a: 4})"],
      seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compare", "compareText"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/compareText.js
var compareTextDocs;
var init_compareText2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/compareText.js"() {
    compareTextDocs = {
      name: "compareText",
      category: "Relational",
      syntax: ["compareText(x, y)"],
      description: "Compare two strings lexically. Comparison is case sensitive. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
      examples: ['compareText("B", "A")', 'compareText("A", "B")', 'compareText("A", "A")', 'compareText("2", "10")', 'compare("2", "10")', "compare(2, 10)", 'compareNatural("2", "10")', 'compareText("B", ["A", "B", "C"])'],
      seealso: ["compare", "compareNatural"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/deepEqual.js
var deepEqualDocs;
var init_deepEqual2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/deepEqual.js"() {
    deepEqualDocs = {
      name: "deepEqual",
      category: "Relational",
      syntax: ["deepEqual(x, y)"],
      description: "Check equality of two matrices element wise. Returns true if the size of both matrices is equal and when and each of the elements are equal.",
      examples: ["deepEqual([1,3,4], [1,3,4])", "deepEqual([1,3,4], [1,3])"],
      seealso: ["equal", "unequal", "smaller", "larger", "smallerEq", "largerEq", "compare"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/equal.js
var equalDocs;
var init_equal2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/equal.js"() {
    equalDocs = {
      name: "equal",
      category: "Relational",
      syntax: ["x == y", "equal(x, y)"],
      description: "Check equality of two values. Returns true if the values are equal, and false if not.",
      examples: ["2+2 == 3", "2+2 == 4", "a = 3.2", "b = 6-2.8", "a == b", "50cm == 0.5m"],
      seealso: ["unequal", "smaller", "larger", "smallerEq", "largerEq", "compare", "deepEqual", "equalText"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/equalText.js
var equalTextDocs;
var init_equalText2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/equalText.js"() {
    equalTextDocs = {
      name: "equalText",
      category: "Relational",
      syntax: ["equalText(x, y)"],
      description: "Check equality of two strings. Comparison is case sensitive. Returns true if the values are equal, and false if not.",
      examples: ['equalText("Hello", "Hello")', 'equalText("a", "A")', 'equal("2e3", "2000")', 'equalText("2e3", "2000")', 'equalText("B", ["A", "B", "C"])'],
      seealso: ["compare", "compareNatural", "compareText", "equal"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/larger.js
var largerDocs;
var init_larger2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/larger.js"() {
    largerDocs = {
      name: "larger",
      category: "Relational",
      syntax: ["x > y", "larger(x, y)"],
      description: "Check if value x is larger than y. Returns true if x is larger than y, and false if not.",
      examples: ["2 > 3", "5 > 2*2", "a = 3.3", "b = 6-2.8", "(a > b)", "(b < a)", "5 cm > 2 inch"],
      seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compare"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/largerEq.js
var largerEqDocs;
var init_largerEq2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/largerEq.js"() {
    largerEqDocs = {
      name: "largerEq",
      category: "Relational",
      syntax: ["x >= y", "largerEq(x, y)"],
      description: "Check if value x is larger or equal to y. Returns true if x is larger or equal to y, and false if not.",
      examples: ["2 >= 1+1", "2 > 1+1", "a = 3.2", "b = 6-2.8", "(a >= b)"],
      seealso: ["equal", "unequal", "smallerEq", "smaller", "compare"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/smaller.js
var smallerDocs;
var init_smaller2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/smaller.js"() {
    smallerDocs = {
      name: "smaller",
      category: "Relational",
      syntax: ["x < y", "smaller(x, y)"],
      description: "Check if value x is smaller than value y. Returns true if x is smaller than y, and false if not.",
      examples: ["2 < 3", "5 < 2*2", "a = 3.3", "b = 6-2.8", "(a < b)", "5 cm < 2 inch"],
      seealso: ["equal", "unequal", "larger", "smallerEq", "largerEq", "compare"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/smallerEq.js
var smallerEqDocs;
var init_smallerEq2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/smallerEq.js"() {
    smallerEqDocs = {
      name: "smallerEq",
      category: "Relational",
      syntax: ["x <= y", "smallerEq(x, y)"],
      description: "Check if value x is smaller or equal to value y. Returns true if x is smaller than y, and false if not.",
      examples: ["2 <= 1+1", "2 < 1+1", "a = 3.2", "b = 6-2.8", "(a <= b)"],
      seealso: ["equal", "unequal", "larger", "smaller", "largerEq", "compare"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/unequal.js
var unequalDocs;
var init_unequal2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/unequal.js"() {
    unequalDocs = {
      name: "unequal",
      category: "Relational",
      syntax: ["x != y", "unequal(x, y)"],
      description: "Check unequality of two values. Returns true if the values are unequal, and false if they are equal.",
      examples: ["2+2 != 3", "2+2 != 4", "a = 3.2", "b = 6-2.8", "a != b", "50cm != 0.5m", "5 cm != 2 inch"],
      seealso: ["equal", "smaller", "larger", "smallerEq", "largerEq", "compare", "deepEqual"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setCartesian.js
var setCartesianDocs;
var init_setCartesian2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setCartesian.js"() {
    setCartesianDocs = {
      name: "setCartesian",
      category: "Set",
      syntax: ["setCartesian(set1, set2)"],
      description: "Create the cartesian product of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays and the values will be sorted in ascending order before the operation.",
      examples: ["setCartesian([1, 2], [3, 4])"],
      seealso: ["setUnion", "setIntersect", "setDifference", "setPowerset"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setDifference.js
var setDifferenceDocs;
var init_setDifference2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setDifference.js"() {
    setDifferenceDocs = {
      name: "setDifference",
      category: "Set",
      syntax: ["setDifference(set1, set2)"],
      description: "Create the difference of two (multi)sets: every element of set1, that is not the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
      examples: ["setDifference([1, 2, 3, 4], [3, 4, 5, 6])", "setDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
      seealso: ["setUnion", "setIntersect", "setSymDifference"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setDistinct.js
var setDistinctDocs;
var init_setDistinct2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setDistinct.js"() {
    setDistinctDocs = {
      name: "setDistinct",
      category: "Set",
      syntax: ["setDistinct(set)"],
      description: "Collect the distinct elements of a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.",
      examples: ["setDistinct([1, 1, 1, 2, 2, 3])"],
      seealso: ["setMultiplicity"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setIntersect.js
var setIntersectDocs;
var init_setIntersect2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setIntersect.js"() {
    setIntersectDocs = {
      name: "setIntersect",
      category: "Set",
      syntax: ["setIntersect(set1, set2)"],
      description: "Create the intersection of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
      examples: ["setIntersect([1, 2, 3, 4], [3, 4, 5, 6])", "setIntersect([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
      seealso: ["setUnion", "setDifference"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setIsSubset.js
var setIsSubsetDocs;
var init_setIsSubset2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setIsSubset.js"() {
    setIsSubsetDocs = {
      name: "setIsSubset",
      category: "Set",
      syntax: ["setIsSubset(set1, set2)"],
      description: "Check whether a (multi)set is a subset of another (multi)set: every element of set1 is the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
      examples: ["setIsSubset([1, 2], [3, 4, 5, 6])", "setIsSubset([3, 4], [3, 4, 5, 6])"],
      seealso: ["setUnion", "setIntersect", "setDifference"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setMultiplicity.js
var setMultiplicityDocs;
var init_setMultiplicity2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setMultiplicity.js"() {
    setMultiplicityDocs = {
      name: "setMultiplicity",
      category: "Set",
      syntax: ["setMultiplicity(element, set)"],
      description: "Count the multiplicity of an element in a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.",
      examples: ["setMultiplicity(1, [1, 2, 2, 4])", "setMultiplicity(2, [1, 2, 2, 4])"],
      seealso: ["setDistinct", "setSize"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setPowerset.js
var setPowersetDocs;
var init_setPowerset2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setPowerset.js"() {
    setPowersetDocs = {
      name: "setPowerset",
      category: "Set",
      syntax: ["setPowerset(set)"],
      description: "Create the powerset of a (multi)set: the powerset contains very possible subsets of a (multi)set. A multi-dimension array will be converted to a single-dimension array before the operation.",
      examples: ["setPowerset([1, 2, 3])"],
      seealso: ["setCartesian"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setSize.js
var setSizeDocs;
var init_setSize2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setSize.js"() {
    setSizeDocs = {
      name: "setSize",
      category: "Set",
      syntax: ["setSize(set)", "setSize(set, unique)"],
      description: 'Count the number of elements of a (multi)set. When the second parameter "unique" is true, count only the unique values. A multi-dimension array will be converted to a single-dimension array before the operation.',
      examples: ["setSize([1, 2, 2, 4])", "setSize([1, 2, 2, 4], true)"],
      seealso: ["setUnion", "setIntersect", "setDifference"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setSymDifference.js
var setSymDifferenceDocs;
var init_setSymDifference2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setSymDifference.js"() {
    setSymDifferenceDocs = {
      name: "setSymDifference",
      category: "Set",
      syntax: ["setSymDifference(set1, set2)"],
      description: "Create the symmetric difference of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
      examples: ["setSymDifference([1, 2, 3, 4], [3, 4, 5, 6])", "setSymDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
      seealso: ["setUnion", "setIntersect", "setDifference"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setUnion.js
var setUnionDocs;
var init_setUnion2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setUnion.js"() {
    setUnionDocs = {
      name: "setUnion",
      category: "Set",
      syntax: ["setUnion(set1, set2)"],
      description: "Create the union of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
      examples: ["setUnion([1, 2, 3, 4], [3, 4, 5, 6])", "setUnion([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
      seealso: ["setIntersect", "setDifference"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/special/erf.js
var erfDocs;
var init_erf2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/special/erf.js"() {
    erfDocs = {
      name: "erf",
      category: "Special",
      syntax: ["erf(x)"],
      description: "Compute the erf function of a value using a rational Chebyshev approximations for different intervals of x",
      examples: ["erf(0.2)", "erf(-0.5)", "erf(4)"],
      seealso: []
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/mad.js
var madDocs;
var init_mad = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/mad.js"() {
    madDocs = {
      name: "mad",
      category: "Statistics",
      syntax: ["mad(a, b, c, ...)", "mad(A)"],
      description: "Compute the median absolute deviation of a matrix or a list with values. The median absolute deviation is defined as the median of the absolute deviations from the median.",
      examples: ["mad(10, 20, 30)", "mad([1, 2, 3])"],
      seealso: ["mean", "median", "std", "abs"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/max.js
var maxDocs;
var init_max2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/max.js"() {
    maxDocs = {
      name: "max",
      category: "Statistics",
      syntax: ["max(a, b, c, ...)", "max(A)", "max(A, dim)"],
      description: "Compute the maximum value of a list of values.",
      examples: ["max(2, 3, 4, 1)", "max([2, 3, 4, 1])", "max([2, 5; 4, 3])", "max([2, 5; 4, 3], 1)", "max([2, 5; 4, 3], 2)", "max(2.7, 7.1, -4.5, 2.0, 4.1)", "min(2.7, 7.1, -4.5, 2.0, 4.1)"],
      seealso: ["mean", "median", "min", "prod", "std", "sum", "variance"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/mean.js
var meanDocs;
var init_mean = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/mean.js"() {
    meanDocs = {
      name: "mean",
      category: "Statistics",
      syntax: ["mean(a, b, c, ...)", "mean(A)", "mean(A, dim)"],
      description: "Compute the arithmetic mean of a list of values.",
      examples: ["mean(2, 3, 4, 1)", "mean([2, 3, 4, 1])", "mean([2, 5; 4, 3])", "mean([2, 5; 4, 3], 1)", "mean([2, 5; 4, 3], 2)", "mean([1.0, 2.7, 3.2, 4.0])"],
      seealso: ["max", "median", "min", "prod", "std", "sum", "variance"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/median.js
var medianDocs;
var init_median = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/median.js"() {
    medianDocs = {
      name: "median",
      category: "Statistics",
      syntax: ["median(a, b, c, ...)", "median(A)"],
      description: "Compute the median of all values. The values are sorted and the middle value is returned. In case of an even number of values, the average of the two middle values is returned.",
      examples: ["median(5, 2, 7)", "median([3, -1, 5, 7])"],
      seealso: ["max", "mean", "min", "prod", "std", "sum", "variance", "quantileSeq"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/min.js
var minDocs;
var init_min2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/min.js"() {
    minDocs = {
      name: "min",
      category: "Statistics",
      syntax: ["min(a, b, c, ...)", "min(A)", "min(A, dim)"],
      description: "Compute the minimum value of a list of values.",
      examples: ["min(2, 3, 4, 1)", "min([2, 3, 4, 1])", "min([2, 5; 4, 3])", "min([2, 5; 4, 3], 1)", "min([2, 5; 4, 3], 2)", "min(2.7, 7.1, -4.5, 2.0, 4.1)", "max(2.7, 7.1, -4.5, 2.0, 4.1)"],
      seealso: ["max", "mean", "median", "prod", "std", "sum", "variance"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/mode.js
var modeDocs;
var init_mode2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/mode.js"() {
    modeDocs = {
      name: "mode",
      category: "Statistics",
      syntax: ["mode(a, b, c, ...)", "mode(A)", "mode(A, a, b, B, c, ...)"],
      description: "Computes the mode of all values as an array. In case mode being more than one, multiple values are returned in an array.",
      examples: ["mode(2, 1, 4, 3, 1)", "mode([1, 2.7, 3.2, 4, 2.7])", "mode(1, 4, 6, 1, 6)"],
      seealso: ["max", "mean", "min", "median", "prod", "std", "sum", "variance"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/prod.js
var prodDocs;
var init_prod2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/prod.js"() {
    prodDocs = {
      name: "prod",
      category: "Statistics",
      syntax: ["prod(a, b, c, ...)", "prod(A)"],
      description: "Compute the product of all values.",
      examples: ["prod(2, 3, 4)", "prod([2, 3, 4])", "prod([2, 5; 4, 3])"],
      seealso: ["max", "mean", "min", "median", "min", "std", "sum", "variance"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/quantileSeq.js
var quantileSeqDocs;
var init_quantileSeq = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/quantileSeq.js"() {
    quantileSeqDocs = {
      name: "quantileSeq",
      category: "Statistics",
      syntax: ["quantileSeq(A, prob[, sorted])", "quantileSeq(A, [prob1, prob2, ...][, sorted])", "quantileSeq(A, N[, sorted])"],
      description: "Compute the prob order quantile of a matrix or a list with values. The sequence is sorted and the middle value is returned. Supported types of sequence values are: Number, BigNumber, Unit Supported types of probablity are: Number, BigNumber. \n\nIn case of a (multi dimensional) array or matrix, the prob order quantile of all elements will be calculated.",
      examples: ["quantileSeq([3, -1, 5, 7], 0.5)", "quantileSeq([3, -1, 5, 7], [1/3, 2/3])", "quantileSeq([3, -1, 5, 7], 2)", "quantileSeq([-1, 3, 5, 7], 0.5, true)"],
      seealso: ["mean", "median", "min", "max", "prod", "std", "sum", "variance"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/std.js
var stdDocs;
var init_std = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/std.js"() {
    stdDocs = {
      name: "std",
      category: "Statistics",
      syntax: ["std(a, b, c, ...)", "std(A)", "std(A, normalization)"],
      description: 'Compute the standard deviation of all values, defined as std(A) = sqrt(variance(A)). Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
      examples: ["std(2, 4, 6)", "std([2, 4, 6, 8])", 'std([2, 4, 6, 8], "uncorrected")', 'std([2, 4, 6, 8], "biased")', "std([1, 2, 3; 4, 5, 6])"],
      seealso: ["max", "mean", "min", "median", "prod", "sum", "variance"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/cumsum.js
var cumSumDocs;
var init_cumsum = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/cumsum.js"() {
    cumSumDocs = {
      name: "cumsum",
      category: "Statistics",
      syntax: ["cumsum(a, b, c, ...)", "cumsum(A)"],
      description: "Compute the cumulative sum of all values.",
      examples: ["cumsum(2, 3, 4, 1)", "cumsum([2, 3, 4, 1])", "cumsum([1, 2; 3, 4])", "cumsum([1, 2; 3, 4], 1)", "cumsum([1, 2; 3, 4], 2)"],
      seealso: ["max", "mean", "median", "min", "prod", "std", "sum", "variance"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/sum.js
var sumDocs;
var init_sum = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/sum.js"() {
    sumDocs = {
      name: "sum",
      category: "Statistics",
      syntax: ["sum(a, b, c, ...)", "sum(A)"],
      description: "Compute the sum of all values.",
      examples: ["sum(2, 3, 4, 1)", "sum([2, 3, 4, 1])", "sum([2, 5; 4, 3])"],
      seealso: ["max", "mean", "median", "min", "prod", "std", "sum", "variance"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/variance.js
var varianceDocs;
var init_variance = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/variance.js"() {
    varianceDocs = {
      name: "variance",
      category: "Statistics",
      syntax: ["variance(a, b, c, ...)", "variance(A)", "variance(A, normalization)"],
      description: 'Compute the variance of all values. Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
      examples: ["variance(2, 4, 6)", "variance([2, 4, 6, 8])", 'variance([2, 4, 6, 8], "uncorrected")', 'variance([2, 4, 6, 8], "biased")', "variance([1, 2, 3; 4, 5, 6])"],
      seealso: ["max", "mean", "min", "median", "min", "prod", "std", "sum"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acos.js
var acosDocs;
var init_acos2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acos.js"() {
    acosDocs = {
      name: "acos",
      category: "Trigonometry",
      syntax: ["acos(x)"],
      description: "Compute the inverse cosine of a value in radians.",
      examples: ["acos(0.5)", "acos(cos(2.3))"],
      seealso: ["cos", "atan", "asin"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acosh.js
var acoshDocs;
var init_acosh2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acosh.js"() {
    acoshDocs = {
      name: "acosh",
      category: "Trigonometry",
      syntax: ["acosh(x)"],
      description: "Calculate the hyperbolic arccos of a value, defined as `acosh(x) = ln(sqrt(x^2 - 1) + x)`.",
      examples: ["acosh(1.5)"],
      seealso: ["cosh", "asinh", "atanh"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acot.js
var acotDocs;
var init_acot2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acot.js"() {
    acotDocs = {
      name: "acot",
      category: "Trigonometry",
      syntax: ["acot(x)"],
      description: "Calculate the inverse cotangent of a value.",
      examples: ["acot(0.5)", "acot(cot(0.5))", "acot(2)"],
      seealso: ["cot", "atan"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acoth.js
var acothDocs;
var init_acoth2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acoth.js"() {
    acothDocs = {
      name: "acoth",
      category: "Trigonometry",
      syntax: ["acoth(x)"],
      description: "Calculate the hyperbolic arccotangent of a value, defined as `acoth(x) = (ln((x+1)/x) + ln(x/(x-1))) / 2`.",
      examples: ["acoth(2)", "acoth(0.5)"],
      seealso: ["acsch", "asech"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acsc.js
var acscDocs;
var init_acsc2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acsc.js"() {
    acscDocs = {
      name: "acsc",
      category: "Trigonometry",
      syntax: ["acsc(x)"],
      description: "Calculate the inverse cotangent of a value.",
      examples: ["acsc(2)", "acsc(csc(0.5))", "acsc(0.5)"],
      seealso: ["csc", "asin", "asec"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acsch.js
var acschDocs;
var init_acsch2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acsch.js"() {
    acschDocs = {
      name: "acsch",
      category: "Trigonometry",
      syntax: ["acsch(x)"],
      description: "Calculate the hyperbolic arccosecant of a value, defined as `acsch(x) = ln(1/x + sqrt(1/x^2 + 1))`.",
      examples: ["acsch(0.5)"],
      seealso: ["asech", "acoth"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asec.js
var asecDocs;
var init_asec2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asec.js"() {
    asecDocs = {
      name: "asec",
      category: "Trigonometry",
      syntax: ["asec(x)"],
      description: "Calculate the inverse secant of a value.",
      examples: ["asec(0.5)", "asec(sec(0.5))", "asec(2)"],
      seealso: ["acos", "acot", "acsc"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asech.js
var asechDocs;
var init_asech2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asech.js"() {
    asechDocs = {
      name: "asech",
      category: "Trigonometry",
      syntax: ["asech(x)"],
      description: "Calculate the inverse secant of a value.",
      examples: ["asech(0.5)"],
      seealso: ["acsch", "acoth"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asin.js
var asinDocs;
var init_asin2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asin.js"() {
    asinDocs = {
      name: "asin",
      category: "Trigonometry",
      syntax: ["asin(x)"],
      description: "Compute the inverse sine of a value in radians.",
      examples: ["asin(0.5)", "asin(sin(0.5))"],
      seealso: ["sin", "acos", "atan"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asinh.js
var asinhDocs;
var init_asinh2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asinh.js"() {
    asinhDocs = {
      name: "asinh",
      category: "Trigonometry",
      syntax: ["asinh(x)"],
      description: "Calculate the hyperbolic arcsine of a value, defined as `asinh(x) = ln(x + sqrt(x^2 + 1))`.",
      examples: ["asinh(0.5)"],
      seealso: ["acosh", "atanh"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/atan.js
var atanDocs;
var init_atan3 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/atan.js"() {
    atanDocs = {
      name: "atan",
      category: "Trigonometry",
      syntax: ["atan(x)"],
      description: "Compute the inverse tangent of a value in radians.",
      examples: ["atan(0.5)", "atan(tan(0.5))"],
      seealso: ["tan", "acos", "asin"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/atan2.js
var atan2Docs;
var init_atan22 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/atan2.js"() {
    atan2Docs = {
      name: "atan2",
      category: "Trigonometry",
      syntax: ["atan2(y, x)"],
      description: "Computes the principal value of the arc tangent of y/x in radians.",
      examples: ["atan2(2, 2) / pi", "angle = 60 deg in rad", "x = cos(angle)", "y = sin(angle)", "atan2(y, x)"],
      seealso: ["sin", "cos", "tan"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/atanh.js
var atanhDocs;
var init_atanh2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/atanh.js"() {
    atanhDocs = {
      name: "atanh",
      category: "Trigonometry",
      syntax: ["atanh(x)"],
      description: "Calculate the hyperbolic arctangent of a value, defined as `atanh(x) = ln((1 + x)/(1 - x)) / 2`.",
      examples: ["atanh(0.5)"],
      seealso: ["acosh", "asinh"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/cos.js
var cosDocs;
var init_cos2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/cos.js"() {
    cosDocs = {
      name: "cos",
      category: "Trigonometry",
      syntax: ["cos(x)"],
      description: "Compute the cosine of x in radians.",
      examples: ["cos(2)", "cos(pi / 4) ^ 2", "cos(180 deg)", "cos(60 deg)", "sin(0.2)^2 + cos(0.2)^2"],
      seealso: ["acos", "sin", "tan"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/cosh.js
var coshDocs;
var init_cosh2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/cosh.js"() {
    coshDocs = {
      name: "cosh",
      category: "Trigonometry",
      syntax: ["cosh(x)"],
      description: "Compute the hyperbolic cosine of x in radians.",
      examples: ["cosh(0.5)"],
      seealso: ["sinh", "tanh", "coth"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/cot.js
var cotDocs;
var init_cot2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/cot.js"() {
    cotDocs = {
      name: "cot",
      category: "Trigonometry",
      syntax: ["cot(x)"],
      description: "Compute the cotangent of x in radians. Defined as 1/tan(x)",
      examples: ["cot(2)", "1 / tan(2)"],
      seealso: ["sec", "csc", "tan"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/coth.js
var cothDocs;
var init_coth2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/coth.js"() {
    cothDocs = {
      name: "coth",
      category: "Trigonometry",
      syntax: ["coth(x)"],
      description: "Compute the hyperbolic cotangent of x in radians.",
      examples: ["coth(2)", "1 / tanh(2)"],
      seealso: ["sech", "csch", "tanh"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/csc.js
var cscDocs;
var init_csc2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/csc.js"() {
    cscDocs = {
      name: "csc",
      category: "Trigonometry",
      syntax: ["csc(x)"],
      description: "Compute the cosecant of x in radians. Defined as 1/sin(x)",
      examples: ["csc(2)", "1 / sin(2)"],
      seealso: ["sec", "cot", "sin"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/csch.js
var cschDocs;
var init_csch2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/csch.js"() {
    cschDocs = {
      name: "csch",
      category: "Trigonometry",
      syntax: ["csch(x)"],
      description: "Compute the hyperbolic cosecant of x in radians. Defined as 1/sinh(x)",
      examples: ["csch(2)", "1 / sinh(2)"],
      seealso: ["sech", "coth", "sinh"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sec.js
var secDocs;
var init_sec2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sec.js"() {
    secDocs = {
      name: "sec",
      category: "Trigonometry",
      syntax: ["sec(x)"],
      description: "Compute the secant of x in radians. Defined as 1/cos(x)",
      examples: ["sec(2)", "1 / cos(2)"],
      seealso: ["cot", "csc", "cos"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sech.js
var sechDocs;
var init_sech2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sech.js"() {
    sechDocs = {
      name: "sech",
      category: "Trigonometry",
      syntax: ["sech(x)"],
      description: "Compute the hyperbolic secant of x in radians. Defined as 1/cosh(x)",
      examples: ["sech(2)", "1 / cosh(2)"],
      seealso: ["coth", "csch", "cosh"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sin.js
var sinDocs;
var init_sin2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sin.js"() {
    sinDocs = {
      name: "sin",
      category: "Trigonometry",
      syntax: ["sin(x)"],
      description: "Compute the sine of x in radians.",
      examples: ["sin(2)", "sin(pi / 4) ^ 2", "sin(90 deg)", "sin(30 deg)", "sin(0.2)^2 + cos(0.2)^2"],
      seealso: ["asin", "cos", "tan"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sinh.js
var sinhDocs;
var init_sinh2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sinh.js"() {
    sinhDocs = {
      name: "sinh",
      category: "Trigonometry",
      syntax: ["sinh(x)"],
      description: "Compute the hyperbolic sine of x in radians.",
      examples: ["sinh(0.5)"],
      seealso: ["cosh", "tanh"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/tan.js
var tanDocs;
var init_tan2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/tan.js"() {
    tanDocs = {
      name: "tan",
      category: "Trigonometry",
      syntax: ["tan(x)"],
      description: "Compute the tangent of x in radians.",
      examples: ["tan(0.5)", "sin(0.5) / cos(0.5)", "tan(pi / 4)", "tan(45 deg)"],
      seealso: ["atan", "sin", "cos"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/tanh.js
var tanhDocs;
var init_tanh2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/tanh.js"() {
    tanhDocs = {
      name: "tanh",
      category: "Trigonometry",
      syntax: ["tanh(x)"],
      description: "Compute the hyperbolic tangent of x in radians.",
      examples: ["tanh(0.5)", "sinh(0.5) / cosh(0.5)"],
      seealso: ["sinh", "cosh"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/units/to.js
var toDocs;
var init_to2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/units/to.js"() {
    toDocs = {
      name: "to",
      category: "Units",
      syntax: ["x to unit", "to(x, unit)"],
      description: "Change the unit of a value.",
      examples: ["5 inch to cm", "3.2kg to g", "16 bytes in bits"],
      seealso: []
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/bin.js
var binDocs;
var init_bin2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/bin.js"() {
    binDocs = {
      name: "bin",
      category: "Utils",
      syntax: ["bin(value)"],
      description: "Format a number as binary",
      examples: ["bin(2)"],
      seealso: ["oct", "hex"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/clone.js
var cloneDocs;
var init_clone2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/clone.js"() {
    cloneDocs = {
      name: "clone",
      category: "Utils",
      syntax: ["clone(x)"],
      description: "Clone a variable. Creates a copy of primitive variables,and a deep copy of matrices",
      examples: ["clone(3.5)", "clone(2 - 4i)", "clone(45 deg)", "clone([1, 2; 3, 4])", 'clone("hello world")'],
      seealso: []
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/format.js
var formatDocs;
var init_format2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/format.js"() {
    formatDocs = {
      name: "format",
      category: "Utils",
      syntax: ["format(value)", "format(value, precision)"],
      description: "Format a value of any type as string.",
      examples: ["format(2.3)", "format(3 - 4i)", "format([])", "format(pi, 3)"],
      seealso: ["print"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/hasNumericValue.js
var hasNumericValueDocs;
var init_hasNumericValue2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/hasNumericValue.js"() {
    hasNumericValueDocs = {
      name: "hasNumericValue",
      category: "Utils",
      syntax: ["hasNumericValue(x)"],
      description: "Test whether a value is an numeric value. In case of a string, true is returned if the string contains a numeric value.",
      examples: ["hasNumericValue(2)", 'hasNumericValue("2")', 'isNumeric("2")', "hasNumericValue(0)", "hasNumericValue(bignumber(500))", "hasNumericValue(fraction(0.125))", "hasNumericValue(2 + 3i)", 'hasNumericValue([2.3, "foo", false])'],
      seealso: ["isInteger", "isZero", "isNegative", "isPositive", "isNaN", "isNumeric"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/hex.js
var hexDocs;
var init_hex2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/hex.js"() {
    hexDocs = {
      name: "hex",
      category: "Utils",
      syntax: ["hex(value)"],
      description: "Format a number as hexadecimal",
      examples: ["hex(240)"],
      seealso: ["bin", "oct"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isInteger.js
var isIntegerDocs;
var init_isInteger2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isInteger.js"() {
    isIntegerDocs = {
      name: "isInteger",
      category: "Utils",
      syntax: ["isInteger(x)"],
      description: "Test whether a value is an integer number.",
      examples: ["isInteger(2)", "isInteger(3.5)", "isInteger([3, 0.5, -2])"],
      seealso: ["isNegative", "isNumeric", "isPositive", "isZero"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isNaN.js
var isNaNDocs;
var init_isNaN2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isNaN.js"() {
    isNaNDocs = {
      name: "isNaN",
      category: "Utils",
      syntax: ["isNaN(x)"],
      description: "Test whether a value is NaN (not a number)",
      examples: ["isNaN(2)", "isNaN(0 / 0)", "isNaN(NaN)", "isNaN(Infinity)"],
      seealso: ["isNegative", "isNumeric", "isPositive", "isZero"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isNegative.js
var isNegativeDocs;
var init_isNegative2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isNegative.js"() {
    isNegativeDocs = {
      name: "isNegative",
      category: "Utils",
      syntax: ["isNegative(x)"],
      description: "Test whether a value is negative: smaller than zero.",
      examples: ["isNegative(2)", "isNegative(0)", "isNegative(-4)", "isNegative([3, 0.5, -2])"],
      seealso: ["isInteger", "isNumeric", "isPositive", "isZero"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isNumeric.js
var isNumericDocs;
var init_isNumeric2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isNumeric.js"() {
    isNumericDocs = {
      name: "isNumeric",
      category: "Utils",
      syntax: ["isNumeric(x)"],
      description: "Test whether a value is a numeric value. Returns true when the input is a number, BigNumber, Fraction, or boolean.",
      examples: ["isNumeric(2)", 'isNumeric("2")', 'hasNumericValue("2")', "isNumeric(0)", "isNumeric(bignumber(500))", "isNumeric(fraction(0.125))", "isNumeric(2 + 3i)", 'isNumeric([2.3, "foo", false])'],
      seealso: ["isInteger", "isZero", "isNegative", "isPositive", "isNaN", "hasNumericValue"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isPositive.js
var isPositiveDocs;
var init_isPositive2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isPositive.js"() {
    isPositiveDocs = {
      name: "isPositive",
      category: "Utils",
      syntax: ["isPositive(x)"],
      description: "Test whether a value is positive: larger than zero.",
      examples: ["isPositive(2)", "isPositive(0)", "isPositive(-4)", "isPositive([3, 0.5, -2])"],
      seealso: ["isInteger", "isNumeric", "isNegative", "isZero"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isPrime.js
var isPrimeDocs;
var init_isPrime2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isPrime.js"() {
    isPrimeDocs = {
      name: "isPrime",
      category: "Utils",
      syntax: ["isPrime(x)"],
      description: "Test whether a value is prime: has no divisors other than itself and one.",
      examples: ["isPrime(3)", "isPrime(-2)", "isPrime([2, 17, 100])"],
      seealso: ["isInteger", "isNumeric", "isNegative", "isZero"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isZero.js
var isZeroDocs;
var init_isZero2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isZero.js"() {
    isZeroDocs = {
      name: "isZero",
      category: "Utils",
      syntax: ["isZero(x)"],
      description: "Test whether a value is zero.",
      examples: ["isZero(2)", "isZero(0)", "isZero(-4)", "isZero([3, 0, -2, 0])"],
      seealso: ["isInteger", "isNumeric", "isNegative", "isPositive"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/numeric.js
var numericDocs;
var init_numeric2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/numeric.js"() {
    numericDocs = {
      name: "numeric",
      category: "Utils",
      syntax: ["numeric(x)"],
      description: "Convert a numeric input to a specific numeric type: number, BigNumber, or Fraction.",
      examples: ['numeric("4")', 'numeric("4", "number")', 'numeric("4", "BigNumber")', 'numeric("4", "Fraction)', 'numeric(4, "Fraction")', 'numeric(fraction(2, 5), "number)'],
      seealso: ["number", "fraction", "bignumber", "string", "format"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/oct.js
var octDocs;
var init_oct2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/oct.js"() {
    octDocs = {
      name: "oct",
      category: "Utils",
      syntax: ["oct(value)"],
      description: "Format a number as octal",
      examples: ["oct(56)"],
      seealso: ["bin", "hex"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/print.js
var printDocs;
var init_print2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/print.js"() {
    printDocs = {
      name: "print",
      category: "Utils",
      syntax: ["print(template, values)", "print(template, values, precision)"],
      description: "Interpolate values into a string template.",
      examples: ['print("Lucy is $age years old", {age: 5})', 'print("The value of pi is $pi", {pi: pi}, 3)', 'print("Hello, $user.name!", {user: {name: "John"}})', 'print("Values: $0, $1, $2", [6, 9, 4])'],
      seealso: ["format"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/typeOf.js
var typeOfDocs;
var init_typeOf2 = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/typeOf.js"() {
    typeOfDocs = {
      name: "typeOf",
      category: "Utils",
      syntax: ["typeOf(x)"],
      description: "Get the type of a variable.",
      examples: ["typeOf(3.5)", "typeOf(2 - 4i)", "typeOf(45 deg)", 'typeOf("hello world")'],
      seealso: ["getMatrixDataType"]
    };
  }
});

// node_modules/mathjs/lib/esm/expression/embeddedDocs/embeddedDocs.js
var embeddedDocs;
var init_embeddedDocs = __esm({
  "node_modules/mathjs/lib/esm/expression/embeddedDocs/embeddedDocs.js"() {
    init_e();
    init_false();
    init_i();
    init_Infinity();
    init_LN10();
    init_LN2();
    init_LOG10E();
    init_LOG2E();
    init_NaN();
    init_null();
    init_phi();
    init_pi();
    init_SQRT1_2();
    init_SQRT2();
    init_tau();
    init_true();
    init_version();
    init_bignumber2();
    init_boolean2();
    init_complex3();
    init_createUnit2();
    init_fraction2();
    init_construction();
    init_matrix2();
    init_number4();
    init_sparse2();
    init_splitUnit2();
    init_string3();
    init_unit2();
    init_config3();
    init_import();
    init_typed2();
    init_derivative();
    init_leafCount();
    init_lsolve2();
    init_lsolveAll2();
    init_lup2();
    init_lusolve2();
    init_qr2();
    init_rationalize();
    init_resolve();
    init_simplify();
    init_simplifyCore();
    init_slu2();
    init_symbolicEqual();
    init_usolve2();
    init_usolveAll2();
    init_abs2();
    init_add2();
    init_cbrt2();
    init_ceil2();
    init_cube2();
    init_divide();
    init_dotDivide2();
    init_dotMultiply2();
    init_dotPow2();
    init_exp2();
    init_expm();
    init_expm12();
    init_fix2();
    init_floor2();
    init_gcd2();
    init_hypot2();
    init_invmod2();
    init_lcm2();
    init_log3();
    init_log102();
    init_log1p2();
    init_log22();
    init_mod2();
    init_multiply2();
    init_norm2();
    init_nthRoot2();
    init_nthRoots2();
    init_pow2();
    init_round2();
    init_sign2();
    init_sqrt2();
    init_sqrtm();
    init_square2();
    init_subtract2();
    init_unaryMinus2();
    init_unaryPlus2();
    init_xgcd2();
    init_bitAnd2();
    init_bitNot2();
    init_bitOr2();
    init_bitXor2();
    init_leftShift2();
    init_rightArithShift2();
    init_rightLogShift2();
    init_bellNumbers();
    init_catalan();
    init_composition();
    init_stirlingS2();
    init_arg2();
    init_conj2();
    init_im2();
    init_re2();
    init_evaluate2();
    init_help();
    init_distance();
    init_intersect();
    init_and2();
    init_not2();
    init_or2();
    init_xor2();
    init_column2();
    init_concat2();
    init_count2();
    init_cross2();
    init_ctranspose2();
    init_det();
    init_diag2();
    init_diff2();
    init_dot2();
    init_eigs();
    init_filter2();
    init_flatten2();
    init_forEach2();
    init_getMatrixDataType2();
    init_identity2();
    init_inv();
    init_pinv();
    init_kron2();
    init_map3();
    init_matrixFromColumns2();
    init_matrixFromFunction2();
    init_matrixFromRows2();
    init_ones2();
    init_partitionSelect2();
    init_range2();
    init_reshape2();
    init_resize2();
    init_rotate2();
    init_rotationMatrix2();
    init_row2();
    init_size2();
    init_sort2();
    init_squeeze2();
    init_subset2();
    init_trace2();
    init_transpose2();
    init_zeros2();
    init_fft2();
    init_ifft2();
    init_combinations2();
    init_combinationsWithRep();
    init_factorial();
    init_gamma();
    init_lgamma();
    init_kldivergence();
    init_multinomial();
    init_permutations();
    init_pickRandom();
    init_random();
    init_randomInt();
    init_compare2();
    init_compareNatural2();
    init_compareText2();
    init_deepEqual2();
    init_equal2();
    init_equalText2();
    init_larger2();
    init_largerEq2();
    init_smaller2();
    init_smallerEq2();
    init_unequal2();
    init_setCartesian2();
    init_setDifference2();
    init_setDistinct2();
    init_setIntersect2();
    init_setIsSubset2();
    init_setMultiplicity2();
    init_setPowerset2();
    init_setSize2();
    init_setSymDifference2();
    init_setUnion2();
    init_erf2();
    init_mad();
    init_max2();
    init_mean();
    init_median();
    init_min2();
    init_mode2();
    init_prod2();
    init_quantileSeq();
    init_std();
    init_cumsum();
    init_sum();
    init_variance();
    init_acos2();
    init_acosh2();
    init_acot2();
    init_acoth2();
    init_acsc2();
    init_acsch2();
    init_asec2();
    init_asech2();
    init_asin2();
    init_asinh2();
    init_atan3();
    init_atan22();
    init_atanh2();
    init_cos2();
    init_cosh2();
    init_cot2();
    init_coth2();
    init_csc2();
    init_csch2();
    init_sec2();
    init_sech2();
    init_sin2();
    init_sinh2();
    init_tan2();
    init_tanh2();
    init_to2();
    init_bin2();
    init_clone2();
    init_format2();
    init_hasNumericValue2();
    init_hex2();
    init_isInteger2();
    init_isNaN2();
    init_isNegative2();
    init_isNumeric2();
    init_isPositive2();
    init_isPrime2();
    init_isZero2();
    init_numeric2();
    init_oct2();
    init_print2();
    init_typeOf2();
    embeddedDocs = {
      bignumber: bignumberDocs,
      boolean: booleanDocs,
      complex: complexDocs,
      createUnit: createUnitDocs,
      fraction: fractionDocs,
      index: indexDocs,
      matrix: matrixDocs,
      number: numberDocs,
      sparse: sparseDocs,
      splitUnit: splitUnitDocs,
      string: stringDocs,
      unit: unitDocs,
      e: eDocs,
      E: eDocs,
      false: falseDocs,
      i: iDocs,
      Infinity: InfinityDocs,
      LN2: LN2Docs,
      LN10: LN10Docs,
      LOG2E: LOG2EDocs,
      LOG10E: LOG10EDocs,
      NaN: NaNDocs,
      null: nullDocs,
      pi: piDocs,
      PI: piDocs,
      phi: phiDocs,
      SQRT1_2: SQRT12Docs,
      SQRT2: SQRT2Docs,
      tau: tauDocs,
      true: trueDocs,
      version: versionDocs,
      speedOfLight: {
        description: "Speed of light in vacuum",
        examples: ["speedOfLight"]
      },
      gravitationConstant: {
        description: "Newtonian constant of gravitation",
        examples: ["gravitationConstant"]
      },
      planckConstant: {
        description: "Planck constant",
        examples: ["planckConstant"]
      },
      reducedPlanckConstant: {
        description: "Reduced Planck constant",
        examples: ["reducedPlanckConstant"]
      },
      magneticConstant: {
        description: "Magnetic constant (vacuum permeability)",
        examples: ["magneticConstant"]
      },
      electricConstant: {
        description: "Electric constant (vacuum permeability)",
        examples: ["electricConstant"]
      },
      vacuumImpedance: {
        description: "Characteristic impedance of vacuum",
        examples: ["vacuumImpedance"]
      },
      coulomb: {
        description: "Coulomb's constant",
        examples: ["coulomb"]
      },
      elementaryCharge: {
        description: "Elementary charge",
        examples: ["elementaryCharge"]
      },
      bohrMagneton: {
        description: "Borh magneton",
        examples: ["bohrMagneton"]
      },
      conductanceQuantum: {
        description: "Conductance quantum",
        examples: ["conductanceQuantum"]
      },
      inverseConductanceQuantum: {
        description: "Inverse conductance quantum",
        examples: ["inverseConductanceQuantum"]
      },
      magneticFluxQuantum: {
        description: "Magnetic flux quantum",
        examples: ["magneticFluxQuantum"]
      },
      nuclearMagneton: {
        description: "Nuclear magneton",
        examples: ["nuclearMagneton"]
      },
      klitzing: {
        description: "Von Klitzing constant",
        examples: ["klitzing"]
      },
      bohrRadius: {
        description: "Borh radius",
        examples: ["bohrRadius"]
      },
      classicalElectronRadius: {
        description: "Classical electron radius",
        examples: ["classicalElectronRadius"]
      },
      electronMass: {
        description: "Electron mass",
        examples: ["electronMass"]
      },
      fermiCoupling: {
        description: "Fermi coupling constant",
        examples: ["fermiCoupling"]
      },
      fineStructure: {
        description: "Fine-structure constant",
        examples: ["fineStructure"]
      },
      hartreeEnergy: {
        description: "Hartree energy",
        examples: ["hartreeEnergy"]
      },
      protonMass: {
        description: "Proton mass",
        examples: ["protonMass"]
      },
      deuteronMass: {
        description: "Deuteron Mass",
        examples: ["deuteronMass"]
      },
      neutronMass: {
        description: "Neutron mass",
        examples: ["neutronMass"]
      },
      quantumOfCirculation: {
        description: "Quantum of circulation",
        examples: ["quantumOfCirculation"]
      },
      rydberg: {
        description: "Rydberg constant",
        examples: ["rydberg"]
      },
      thomsonCrossSection: {
        description: "Thomson cross section",
        examples: ["thomsonCrossSection"]
      },
      weakMixingAngle: {
        description: "Weak mixing angle",
        examples: ["weakMixingAngle"]
      },
      efimovFactor: {
        description: "Efimov factor",
        examples: ["efimovFactor"]
      },
      atomicMass: {
        description: "Atomic mass constant",
        examples: ["atomicMass"]
      },
      avogadro: {
        description: "Avogadro's number",
        examples: ["avogadro"]
      },
      boltzmann: {
        description: "Boltzmann constant",
        examples: ["boltzmann"]
      },
      faraday: {
        description: "Faraday constant",
        examples: ["faraday"]
      },
      firstRadiation: {
        description: "First radiation constant",
        examples: ["firstRadiation"]
      },
      loschmidt: {
        description: "Loschmidt constant at T=273.15 K and p=101.325 kPa",
        examples: ["loschmidt"]
      },
      gasConstant: {
        description: "Gas constant",
        examples: ["gasConstant"]
      },
      molarPlanckConstant: {
        description: "Molar Planck constant",
        examples: ["molarPlanckConstant"]
      },
      molarVolume: {
        description: "Molar volume of an ideal gas at T=273.15 K and p=101.325 kPa",
        examples: ["molarVolume"]
      },
      sackurTetrode: {
        description: "Sackur-Tetrode constant at T=1 K and p=101.325 kPa",
        examples: ["sackurTetrode"]
      },
      secondRadiation: {
        description: "Second radiation constant",
        examples: ["secondRadiation"]
      },
      stefanBoltzmann: {
        description: "Stefan-Boltzmann constant",
        examples: ["stefanBoltzmann"]
      },
      wienDisplacement: {
        description: "Wien displacement law constant",
        examples: ["wienDisplacement"]
      },
      molarMass: {
        description: "Molar mass constant",
        examples: ["molarMass"]
      },
      molarMassC12: {
        description: "Molar mass constant of carbon-12",
        examples: ["molarMassC12"]
      },
      gravity: {
        description: "Standard acceleration of gravity (standard acceleration of free-fall on Earth)",
        examples: ["gravity"]
      },
      planckLength: {
        description: "Planck length",
        examples: ["planckLength"]
      },
      planckMass: {
        description: "Planck mass",
        examples: ["planckMass"]
      },
      planckTime: {
        description: "Planck time",
        examples: ["planckTime"]
      },
      planckCharge: {
        description: "Planck charge",
        examples: ["planckCharge"]
      },
      planckTemperature: {
        description: "Planck temperature",
        examples: ["planckTemperature"]
      },
      derivative: derivativeDocs,
      lsolve: lsolveDocs,
      lsolveAll: lsolveAllDocs,
      lup: lupDocs,
      lusolve: lusolveDocs,
      leafCount: leafCountDocs,
      resolve: resolveDocs,
      simplify: simplifyDocs,
      simplifyCore: simplifyCoreDocs,
      symbolicEqual: symbolicEqualDocs,
      rationalize: rationalizeDocs,
      slu: sluDocs,
      usolve: usolveDocs,
      usolveAll: usolveAllDocs,
      qr: qrDocs,
      abs: absDocs,
      add: addDocs,
      cbrt: cbrtDocs,
      ceil: ceilDocs,
      cube: cubeDocs,
      divide: divideDocs,
      dotDivide: dotDivideDocs,
      dotMultiply: dotMultiplyDocs,
      dotPow: dotPowDocs,
      exp: expDocs,
      expm: expmDocs,
      expm1: expm1Docs,
      fix: fixDocs,
      floor: floorDocs,
      gcd: gcdDocs,
      hypot: hypotDocs,
      lcm: lcmDocs,
      log: logDocs,
      log2: log2Docs,
      log1p: log1pDocs,
      log10: log10Docs,
      mod: modDocs,
      multiply: multiplyDocs,
      norm: normDocs,
      nthRoot: nthRootDocs,
      nthRoots: nthRootsDocs,
      pow: powDocs,
      round: roundDocs,
      sign: signDocs,
      sqrt: sqrtDocs,
      sqrtm: sqrtmDocs,
      square: squareDocs,
      subtract: subtractDocs,
      unaryMinus: unaryMinusDocs,
      unaryPlus: unaryPlusDocs,
      xgcd: xgcdDocs,
      invmod: invmodDocs,
      bitAnd: bitAndDocs,
      bitNot: bitNotDocs,
      bitOr: bitOrDocs,
      bitXor: bitXorDocs,
      leftShift: leftShiftDocs,
      rightArithShift: rightArithShiftDocs,
      rightLogShift: rightLogShiftDocs,
      bellNumbers: bellNumbersDocs,
      catalan: catalanDocs,
      composition: compositionDocs,
      stirlingS2: stirlingS2Docs,
      config: configDocs,
      import: importDocs,
      typed: typedDocs,
      arg: argDocs,
      conj: conjDocs,
      re: reDocs,
      im: imDocs,
      evaluate: evaluateDocs,
      help: helpDocs,
      distance: distanceDocs,
      intersect: intersectDocs,
      and: andDocs,
      not: notDocs,
      or: orDocs,
      xor: xorDocs,
      concat: concatDocs,
      count: countDocs,
      cross: crossDocs,
      column: columnDocs,
      ctranspose: ctransposeDocs,
      det: detDocs,
      diag: diagDocs,
      diff: diffDocs,
      dot: dotDocs,
      getMatrixDataType: getMatrixDataTypeDocs,
      identity: identityDocs,
      filter: filterDocs,
      flatten: flattenDocs,
      forEach: forEachDocs,
      inv: invDocs,
      pinv: pinvDocs,
      eigs: eigsDocs,
      kron: kronDocs,
      matrixFromFunction: matrixFromFunctionDocs,
      matrixFromRows: matrixFromRowsDocs,
      matrixFromColumns: matrixFromColumnsDocs,
      map: mapDocs,
      ones: onesDocs,
      partitionSelect: partitionSelectDocs,
      range: rangeDocs,
      resize: resizeDocs,
      reshape: reshapeDocs,
      rotate: rotateDocs,
      rotationMatrix: rotationMatrixDocs,
      row: rowDocs,
      size: sizeDocs,
      sort: sortDocs,
      squeeze: squeezeDocs,
      subset: subsetDocs,
      trace: traceDocs,
      transpose: transposeDocs,
      zeros: zerosDocs,
      fft: fftDocs,
      ifft: ifftDocs,
      combinations: combinationsDocs,
      combinationsWithRep: combinationsWithRepDocs,
      factorial: factorialDocs,
      gamma: gammaDocs,
      kldivergence: kldivergenceDocs,
      lgamma: lgammaDocs,
      multinomial: multinomialDocs,
      permutations: permutationsDocs,
      pickRandom: pickRandomDocs,
      random: randomDocs,
      randomInt: randomIntDocs,
      compare: compareDocs,
      compareNatural: compareNaturalDocs,
      compareText: compareTextDocs,
      deepEqual: deepEqualDocs,
      equal: equalDocs,
      equalText: equalTextDocs,
      larger: largerDocs,
      largerEq: largerEqDocs,
      smaller: smallerDocs,
      smallerEq: smallerEqDocs,
      unequal: unequalDocs,
      setCartesian: setCartesianDocs,
      setDifference: setDifferenceDocs,
      setDistinct: setDistinctDocs,
      setIntersect: setIntersectDocs,
      setIsSubset: setIsSubsetDocs,
      setMultiplicity: setMultiplicityDocs,
      setPowerset: setPowersetDocs,
      setSize: setSizeDocs,
      setSymDifference: setSymDifferenceDocs,
      setUnion: setUnionDocs,
      erf: erfDocs,
      cumsum: cumSumDocs,
      mad: madDocs,
      max: maxDocs,
      mean: meanDocs,
      median: medianDocs,
      min: minDocs,
      mode: modeDocs,
      prod: prodDocs,
      quantileSeq: quantileSeqDocs,
      std: stdDocs,
      sum: sumDocs,
      variance: varianceDocs,
      acos: acosDocs,
      acosh: acoshDocs,
      acot: acotDocs,
      acoth: acothDocs,
      acsc: acscDocs,
      acsch: acschDocs,
      asec: asecDocs,
      asech: asechDocs,
      asin: asinDocs,
      asinh: asinhDocs,
      atan: atanDocs,
      atanh: atanhDocs,
      atan2: atan2Docs,
      cos: cosDocs,
      cosh: coshDocs,
      cot: cotDocs,
      coth: cothDocs,
      csc: cscDocs,
      csch: cschDocs,
      sec: secDocs,
      sech: sechDocs,
      sin: sinDocs,
      sinh: sinhDocs,
      tan: tanDocs,
      tanh: tanhDocs,
      to: toDocs,
      clone: cloneDocs,
      format: formatDocs,
      bin: binDocs,
      oct: octDocs,
      hex: hexDocs,
      isNaN: isNaNDocs,
      isInteger: isIntegerDocs,
      isNegative: isNegativeDocs,
      isNumeric: isNumericDocs,
      hasNumericValue: hasNumericValueDocs,
      isPositive: isPositiveDocs,
      isPrime: isPrimeDocs,
      isZero: isZeroDocs,
      print: printDocs,
      typeOf: typeOfDocs,
      numeric: numericDocs
    };
  }
});

// node_modules/mathjs/lib/esm/expression/function/help.js
var name233, dependencies234, createHelp;
var init_help2 = __esm({
  "node_modules/mathjs/lib/esm/expression/function/help.js"() {
    init_factory();
    init_customs();
    init_embeddedDocs();
    init_object();
    name233 = "help";
    dependencies234 = ["typed", "mathWithTransform", "Help"];
    createHelp = /* @__PURE__ */ factory(name233, dependencies234, (_ref) => {
      var {
        typed: typed2,
        mathWithTransform: mathWithTransform2,
        Help: Help2
      } = _ref;
      return typed2(name233, {
        any: function any(search) {
          var prop;
          var searchName = search;
          if (typeof search !== "string") {
            for (prop in mathWithTransform2) {
              if (hasOwnProperty2(mathWithTransform2, prop) && search === mathWithTransform2[prop]) {
                searchName = prop;
                break;
              }
            }
          }
          var doc = getSafeProperty(embeddedDocs, searchName);
          if (!doc) {
            var searchText = typeof searchName === "function" ? searchName.name : searchName;
            throw new Error('No documentation found on "' + searchText + '"');
          }
          return new Help2(doc);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/type/chain/function/chain.js
var name234, dependencies235, createChain;
var init_chain = __esm({
  "node_modules/mathjs/lib/esm/type/chain/function/chain.js"() {
    init_factory();
    name234 = "chain";
    dependencies235 = ["typed", "Chain"];
    createChain = /* @__PURE__ */ factory(name234, dependencies235, (_ref) => {
      var {
        typed: typed2,
        Chain: Chain2
      } = _ref;
      return typed2(name234, {
        "": function _() {
          return new Chain2();
        },
        any: function any(value) {
          return new Chain2(value);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/det.js
var name235, dependencies236, createDet;
var init_det2 = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/det.js"() {
    init_is();
    init_object();
    init_string();
    init_factory();
    name235 = "det";
    dependencies236 = ["typed", "matrix", "subtract", "multiply", "divideScalar", "isZero", "unaryMinus"];
    createDet = /* @__PURE__ */ factory(name235, dependencies236, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        subtract: subtract2,
        multiply: multiply2,
        divideScalar: divideScalar2,
        isZero: isZero2,
        unaryMinus: unaryMinus2
      } = _ref;
      return typed2(name235, {
        any: function any(x) {
          return clone(x);
        },
        "Array | Matrix": function det2(x) {
          var size2;
          if (isMatrix(x)) {
            size2 = x.size();
          } else if (Array.isArray(x)) {
            x = matrix2(x);
            size2 = x.size();
          } else {
            size2 = [];
          }
          switch (size2.length) {
            case 0:
              return clone(x);
            case 1:
              if (size2[0] === 1) {
                return clone(x.valueOf()[0]);
              } else {
                throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
              }
            case 2: {
              var rows = size2[0];
              var cols = size2[1];
              if (rows === cols) {
                return _det(x.clone().valueOf(), rows, cols);
              } else {
                throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
              }
            }
            default:
              throw new RangeError("Matrix must be two dimensional (size: " + format3(size2) + ")");
          }
        }
      });
      function _det(matrix3, rows, cols) {
        if (rows === 1) {
          return clone(matrix3[0][0]);
        } else if (rows === 2) {
          return subtract2(multiply2(matrix3[0][0], matrix3[1][1]), multiply2(matrix3[1][0], matrix3[0][1]));
        } else {
          var negated = false;
          var rowIndices = new Array(rows).fill(0).map((_, i3) => i3);
          for (var k = 0; k < rows; k++) {
            var k_ = rowIndices[k];
            if (isZero2(matrix3[k_][k])) {
              var _k = void 0;
              for (_k = k + 1; _k < rows; _k++) {
                if (!isZero2(matrix3[rowIndices[_k]][k])) {
                  k_ = rowIndices[_k];
                  rowIndices[_k] = rowIndices[k];
                  rowIndices[k] = k_;
                  negated = !negated;
                  break;
                }
              }
              if (_k === rows)
                return matrix3[k_][k];
            }
            var piv = matrix3[k_][k];
            var piv_ = k === 0 ? 1 : matrix3[rowIndices[k - 1]][k - 1];
            for (var i2 = k + 1; i2 < rows; i2++) {
              var i_ = rowIndices[i2];
              for (var j = k + 1; j < rows; j++) {
                matrix3[i_][j] = divideScalar2(subtract2(multiply2(matrix3[i_][j], piv), multiply2(matrix3[i_][k], matrix3[k_][j])), piv_);
              }
            }
          }
          var det2 = matrix3[rowIndices[rows - 1]][rows - 1];
          return negated ? unaryMinus2(det2) : det2;
        }
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/inv.js
var name236, dependencies237, createInv;
var init_inv2 = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/inv.js"() {
    init_is();
    init_array();
    init_factory();
    init_string();
    name236 = "inv";
    dependencies237 = ["typed", "matrix", "divideScalar", "addScalar", "multiply", "unaryMinus", "det", "identity", "abs"];
    createInv = /* @__PURE__ */ factory(name236, dependencies237, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        divideScalar: divideScalar2,
        addScalar: addScalar2,
        multiply: multiply2,
        unaryMinus: unaryMinus2,
        det: det2,
        identity: identity2,
        abs: abs2
      } = _ref;
      return typed2(name236, {
        "Array | Matrix": function ArrayMatrix(x) {
          var size2 = isMatrix(x) ? x.size() : arraySize(x);
          switch (size2.length) {
            case 1:
              if (size2[0] === 1) {
                if (isMatrix(x)) {
                  return matrix2([divideScalar2(1, x.valueOf()[0])]);
                } else {
                  return [divideScalar2(1, x[0])];
                }
              } else {
                throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
              }
            case 2: {
              var rows = size2[0];
              var cols = size2[1];
              if (rows === cols) {
                if (isMatrix(x)) {
                  return matrix2(_inv(x.valueOf(), rows, cols), x.storage());
                } else {
                  return _inv(x, rows, cols);
                }
              } else {
                throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
              }
            }
            default:
              throw new RangeError("Matrix must be two dimensional (size: " + format3(size2) + ")");
          }
        },
        any: function any(x) {
          return divideScalar2(1, x);
        }
      });
      function _inv(mat, rows, cols) {
        var r, s, f, value, temp;
        if (rows === 1) {
          value = mat[0][0];
          if (value === 0) {
            throw Error("Cannot calculate inverse, determinant is zero");
          }
          return [[divideScalar2(1, value)]];
        } else if (rows === 2) {
          var d = det2(mat);
          if (d === 0) {
            throw Error("Cannot calculate inverse, determinant is zero");
          }
          return [[divideScalar2(mat[1][1], d), divideScalar2(unaryMinus2(mat[0][1]), d)], [divideScalar2(unaryMinus2(mat[1][0]), d), divideScalar2(mat[0][0], d)]];
        } else {
          var A = mat.concat();
          for (r = 0; r < rows; r++) {
            A[r] = A[r].concat();
          }
          var B = identity2(rows).valueOf();
          for (var c = 0; c < cols; c++) {
            var ABig = abs2(A[c][c]);
            var rBig = c;
            r = c + 1;
            while (r < rows) {
              if (abs2(A[r][c]) > ABig) {
                ABig = abs2(A[r][c]);
                rBig = r;
              }
              r++;
            }
            if (ABig === 0) {
              throw Error("Cannot calculate inverse, determinant is zero");
            }
            r = rBig;
            if (r !== c) {
              temp = A[c];
              A[c] = A[r];
              A[r] = temp;
              temp = B[c];
              B[c] = B[r];
              B[r] = temp;
            }
            var Ac = A[c];
            var Bc = B[c];
            for (r = 0; r < rows; r++) {
              var Ar = A[r];
              var Br = B[r];
              if (r !== c) {
                if (Ar[c] !== 0) {
                  f = divideScalar2(unaryMinus2(Ar[c]), Ac[c]);
                  for (s = c; s < cols; s++) {
                    Ar[s] = addScalar2(Ar[s], multiply2(f, Ac[s]));
                  }
                  for (s = 0; s < cols; s++) {
                    Br[s] = addScalar2(Br[s], multiply2(f, Bc[s]));
                  }
                }
              } else {
                f = Ac[c];
                for (s = c; s < cols; s++) {
                  Ar[s] = divideScalar2(Ar[s], f);
                }
                for (s = 0; s < cols; s++) {
                  Br[s] = divideScalar2(Br[s], f);
                }
              }
            }
          }
          return B;
        }
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/pinv.js
var name237, dependencies238, createPinv;
var init_pinv2 = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/pinv.js"() {
    init_is();
    init_array();
    init_factory();
    init_string();
    init_object();
    name237 = "pinv";
    dependencies238 = ["typed", "matrix", "inv", "deepEqual", "equal", "dotDivide", "dot", "ctranspose", "divideScalar", "multiply", "add", "Complex"];
    createPinv = /* @__PURE__ */ factory(name237, dependencies238, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        inv: inv2,
        deepEqual: deepEqual2,
        equal: equal2,
        dotDivide: dotDivide2,
        dot: dot2,
        ctranspose: ctranspose2,
        divideScalar: divideScalar2,
        multiply: multiply2,
        add: add2,
        Complex: Complex3
      } = _ref;
      return typed2(name237, {
        "Array | Matrix": function ArrayMatrix(x) {
          var size2 = isMatrix(x) ? x.size() : arraySize(x);
          switch (size2.length) {
            case 1:
              if (_isZeros(x))
                return ctranspose2(x);
              if (size2[0] === 1) {
                return inv2(x);
              } else {
                return dotDivide2(ctranspose2(x), dot2(x, x));
              }
            case 2: {
              if (_isZeros(x))
                return ctranspose2(x);
              var rows = size2[0];
              var cols = size2[1];
              if (rows === cols) {
                try {
                  return inv2(x);
                } catch (err) {
                  if (err instanceof Error && err.message.match(/Cannot calculate inverse, determinant is zero/)) {
                  } else {
                    throw err;
                  }
                }
              }
              if (isMatrix(x)) {
                return matrix2(_pinv(x.valueOf(), rows, cols), x.storage());
              } else {
                return _pinv(x, rows, cols);
              }
            }
            default:
              throw new RangeError("Matrix must be two dimensional (size: " + format3(size2) + ")");
          }
        },
        any: function any(x) {
          if (equal2(x, 0))
            return clone(x);
          return divideScalar2(1, x);
        }
      });
      function _pinv(mat, rows, cols) {
        var {
          C,
          F
        } = _rankFact(mat, rows, cols);
        var Cpinv = multiply2(inv2(multiply2(ctranspose2(C), C)), ctranspose2(C));
        var Fpinv = multiply2(ctranspose2(F), inv2(multiply2(F, ctranspose2(F))));
        return multiply2(Fpinv, Cpinv);
      }
      function _rref(mat, rows, cols) {
        var M = clone(mat);
        var lead = 0;
        for (var r = 0; r < rows; r++) {
          if (cols <= lead) {
            return M;
          }
          var i2 = r;
          while (_isZero(M[i2][lead])) {
            i2++;
            if (rows === i2) {
              i2 = r;
              lead++;
              if (cols === lead) {
                return M;
              }
            }
          }
          [M[i2], M[r]] = [M[r], M[i2]];
          var val = M[r][lead];
          for (var j = 0; j < cols; j++) {
            M[r][j] = dotDivide2(M[r][j], val);
          }
          for (var _i = 0; _i < rows; _i++) {
            if (_i === r)
              continue;
            val = M[_i][lead];
            for (var _j = 0; _j < cols; _j++) {
              M[_i][_j] = add2(M[_i][_j], multiply2(-1, multiply2(val, M[r][_j])));
            }
          }
          lead++;
        }
        return M;
      }
      function _rankFact(mat, rows, cols) {
        var rref = _rref(mat, rows, cols);
        var C = mat.map((_, i2) => _.filter((_2, j) => j < rows && !_isZero(dot2(rref[j], rref[j]))));
        var F = rref.filter((_, i2) => !_isZero(dot2(rref[i2], rref[i2])));
        return {
          C,
          F
        };
      }
      function _isZero(x) {
        return equal2(add2(x, Complex3(1, 1)), add2(0, Complex3(1, 1)));
      }
      function _isZeros(arr) {
        return deepEqual2(add2(arr, Complex3(1, 1)), add2(multiply2(arr, 0), Complex3(1, 1)));
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/eigs/complexEigs.js
function createComplexEigs(_ref) {
  var {
    addScalar: addScalar2,
    subtract: subtract2,
    flatten: flatten4,
    multiply: multiply2,
    multiplyScalar: multiplyScalar2,
    divideScalar: divideScalar2,
    sqrt: sqrt2,
    abs: abs2,
    bignumber: bignumber2,
    diag: diag2,
    inv: inv2,
    qr: qr2,
    usolve: usolve2,
    usolveAll: usolveAll2,
    equal: equal2,
    complex: complex2,
    larger: larger2,
    smaller: smaller2,
    matrixFromColumns: matrixFromColumns2,
    dot: dot2
  } = _ref;
  function complexEigs(arr, N, prec, type, findVectors) {
    if (findVectors === void 0) {
      findVectors = true;
    }
    var R = balance(arr, N, prec, type, findVectors);
    reduceToHessenberg(arr, N, prec, type, findVectors, R);
    var {
      values,
      C
    } = iterateUntilTriangular(arr, N, prec, type, findVectors);
    var vectors;
    if (findVectors) {
      vectors = findEigenvectors(arr, N, C, R, values, prec, type);
      vectors = matrixFromColumns2(...vectors);
    }
    return {
      values,
      vectors
    };
  }
  function balance(arr, N, prec, type, findVectors) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var realzero = big ? bignumber2(0) : 0;
    var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
    var realone = big ? bignumber2(1) : 1;
    var radix = big ? bignumber2(10) : 2;
    var radixSq = multiplyScalar2(radix, radix);
    var Rdiag;
    if (findVectors) {
      Rdiag = Array(N).fill(one);
    }
    var last = false;
    while (!last) {
      last = true;
      for (var i2 = 0; i2 < N; i2++) {
        var colNorm = realzero;
        var rowNorm = realzero;
        for (var j = 0; j < N; j++) {
          if (i2 === j)
            continue;
          var c = abs2(arr[i2][j]);
          colNorm = addScalar2(colNorm, c);
          rowNorm = addScalar2(rowNorm, c);
        }
        if (!equal2(colNorm, 0) && !equal2(rowNorm, 0)) {
          var f = realone;
          var _c = colNorm;
          var rowDivRadix = divideScalar2(rowNorm, radix);
          var rowMulRadix = multiplyScalar2(rowNorm, radix);
          while (smaller2(_c, rowDivRadix)) {
            _c = multiplyScalar2(_c, radixSq);
            f = multiplyScalar2(f, radix);
          }
          while (larger2(_c, rowMulRadix)) {
            _c = divideScalar2(_c, radixSq);
            f = divideScalar2(f, radix);
          }
          var condition = smaller2(divideScalar2(addScalar2(_c, rowNorm), f), multiplyScalar2(addScalar2(colNorm, rowNorm), 0.95));
          if (condition) {
            last = false;
            var g2 = divideScalar2(1, f);
            for (var _j = 0; _j < N; _j++) {
              if (i2 === _j) {
                continue;
              }
              arr[i2][_j] = multiplyScalar2(arr[i2][_j], f);
              arr[_j][i2] = multiplyScalar2(arr[_j][i2], g2);
            }
            if (findVectors) {
              Rdiag[i2] = multiplyScalar2(Rdiag[i2], f);
            }
          }
        }
      }
    }
    return diag2(Rdiag);
  }
  function reduceToHessenberg(arr, N, prec, type, findVectors, R) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var zero = big ? bignumber2(0) : cplx ? complex2(0) : 0;
    if (big) {
      prec = bignumber2(prec);
    }
    for (var i2 = 0; i2 < N - 2; i2++) {
      var maxIndex = 0;
      var max2 = zero;
      for (var j = i2 + 1; j < N; j++) {
        var el = arr[j][i2];
        if (smaller2(abs2(max2), abs2(el))) {
          max2 = el;
          maxIndex = j;
        }
      }
      if (smaller2(abs2(max2), prec)) {
        continue;
      }
      if (maxIndex !== i2 + 1) {
        var tmp1 = arr[maxIndex];
        arr[maxIndex] = arr[i2 + 1];
        arr[i2 + 1] = tmp1;
        for (var _j2 = 0; _j2 < N; _j2++) {
          var tmp2 = arr[_j2][maxIndex];
          arr[_j2][maxIndex] = arr[_j2][i2 + 1];
          arr[_j2][i2 + 1] = tmp2;
        }
        if (findVectors) {
          var tmp3 = R[maxIndex];
          R[maxIndex] = R[i2 + 1];
          R[i2 + 1] = tmp3;
        }
      }
      for (var _j3 = i2 + 2; _j3 < N; _j3++) {
        var n = divideScalar2(arr[_j3][i2], max2);
        if (n === 0) {
          continue;
        }
        for (var k = 0; k < N; k++) {
          arr[_j3][k] = subtract2(arr[_j3][k], multiplyScalar2(n, arr[i2 + 1][k]));
        }
        for (var _k = 0; _k < N; _k++) {
          arr[_k][i2 + 1] = addScalar2(arr[_k][i2 + 1], multiplyScalar2(n, arr[_k][_j3]));
        }
        if (findVectors) {
          for (var _k2 = 0; _k2 < N; _k2++) {
            R[_j3][_k2] = subtract2(R[_j3][_k2], multiplyScalar2(n, R[i2 + 1][_k2]));
          }
        }
      }
    }
    return R;
  }
  function iterateUntilTriangular(A, N, prec, type, findVectors) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
    if (big) {
      prec = bignumber2(prec);
    }
    var arr = clone(A);
    var lambdas = [];
    var n = N;
    var Sdiag = [];
    var Qtotal = findVectors ? diag2(Array(N).fill(one)) : void 0;
    var Qpartial = findVectors ? diag2(Array(n).fill(one)) : void 0;
    var lastConvergenceBefore = 0;
    while (lastConvergenceBefore <= 100) {
      lastConvergenceBefore += 1;
      var k = 0;
      for (var i2 = 0; i2 < n; i2++) {
        arr[i2][i2] = subtract2(arr[i2][i2], k);
      }
      var {
        Q: Q2,
        R
      } = qr2(arr);
      arr = multiply2(R, Q2);
      for (var _i = 0; _i < n; _i++) {
        arr[_i][_i] = addScalar2(arr[_i][_i], k);
      }
      if (findVectors) {
        Qpartial = multiply2(Qpartial, Q2);
      }
      if (n === 1 || smaller2(abs2(arr[n - 1][n - 2]), prec)) {
        lastConvergenceBefore = 0;
        lambdas.push(arr[n - 1][n - 1]);
        if (findVectors) {
          Sdiag.unshift([[1]]);
          inflateMatrix(Qpartial, N);
          Qtotal = multiply2(Qtotal, Qpartial);
          if (n > 1) {
            Qpartial = diag2(Array(n - 1).fill(one));
          }
        }
        n -= 1;
        arr.pop();
        for (var _i2 = 0; _i2 < n; _i2++) {
          arr[_i2].pop();
        }
      } else if (n === 2 || smaller2(abs2(arr[n - 2][n - 3]), prec)) {
        lastConvergenceBefore = 0;
        var ll = eigenvalues2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1]);
        lambdas.push(...ll);
        if (findVectors) {
          Sdiag.unshift(jordanBase2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1], ll[0], ll[1], prec, type));
          inflateMatrix(Qpartial, N);
          Qtotal = multiply2(Qtotal, Qpartial);
          if (n > 2) {
            Qpartial = diag2(Array(n - 2).fill(one));
          }
        }
        n -= 2;
        arr.pop();
        arr.pop();
        for (var _i3 = 0; _i3 < n; _i3++) {
          arr[_i3].pop();
          arr[_i3].pop();
        }
      }
      if (n === 0) {
        break;
      }
    }
    lambdas.sort((a, b) => +subtract2(abs2(a), abs2(b)));
    if (lastConvergenceBefore > 100) {
      var err = Error("The eigenvalues failed to converge. Only found these eigenvalues: " + lambdas.join(", "));
      err.values = lambdas;
      err.vectors = [];
      throw err;
    }
    var C = findVectors ? multiply2(Qtotal, blockDiag(Sdiag, N)) : void 0;
    return {
      values: lambdas,
      C
    };
  }
  function findEigenvectors(A, N, C, R, values, prec, type) {
    var Cinv = inv2(C);
    var U = multiply2(Cinv, A, C);
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var zero = big ? bignumber2(0) : cplx ? complex2(0) : 0;
    var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
    var uniqueValues = [];
    var multiplicities = [];
    for (var \u03BB of values) {
      var i2 = indexOf(uniqueValues, \u03BB, equal2);
      if (i2 === -1) {
        uniqueValues.push(\u03BB);
        multiplicities.push(1);
      } else {
        multiplicities[i2] += 1;
      }
    }
    var vectors = [];
    var len = uniqueValues.length;
    var b = Array(N).fill(zero);
    var E = diag2(Array(N).fill(one));
    var failedLambdas = [];
    var _loop = function _loop2(_i42) {
      var \u03BB2 = uniqueValues[_i42];
      var S = subtract2(U, multiply2(\u03BB2, E));
      var solutions = usolveAll2(S, b);
      solutions.shift();
      while (solutions.length < multiplicities[_i42]) {
        var approxVec = inverseIterate(S, N, solutions, prec, type);
        if (approxVec == null) {
          failedLambdas.push(\u03BB2);
          break;
        }
        solutions.push(approxVec);
      }
      var correction = multiply2(inv2(R), C);
      solutions = solutions.map((v) => multiply2(correction, v));
      vectors.push(...solutions.map((v) => flatten4(v)));
    };
    for (var _i4 = 0; _i4 < len; _i4++) {
      _loop(_i4);
    }
    if (failedLambdas.length !== 0) {
      var err = new Error("Failed to find eigenvectors for the following eigenvalues: " + failedLambdas.join(", "));
      err.values = values;
      err.vectors = vectors;
      throw err;
    }
    return vectors;
  }
  function eigenvalues2x2(a, b, c, d) {
    var trA = addScalar2(a, d);
    var detA = subtract2(multiplyScalar2(a, d), multiplyScalar2(b, c));
    var x = multiplyScalar2(trA, 0.5);
    var y = multiplyScalar2(sqrt2(subtract2(multiplyScalar2(trA, trA), multiplyScalar2(4, detA))), 0.5);
    return [addScalar2(x, y), subtract2(x, y)];
  }
  function jordanBase2x2(a, b, c, d, l1, l2, prec, type) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var zero = big ? bignumber2(0) : cplx ? complex2(0) : 0;
    var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
    if (smaller2(abs2(c), prec)) {
      return [[one, zero], [zero, one]];
    }
    if (larger2(abs2(subtract2(l1, l2)), prec)) {
      return [[subtract2(l1, d), subtract2(l2, d)], [c, c]];
    }
    var na = subtract2(a, l1);
    var nb = subtract2(b, l1);
    var nc = subtract2(c, l1);
    var nd = subtract2(d, l1);
    if (smaller2(abs2(nb), prec)) {
      return [[na, one], [nc, zero]];
    } else {
      return [[nb, zero], [nd, one]];
    }
  }
  function inflateMatrix(arr, N) {
    for (var i2 = 0; i2 < arr.length; i2++) {
      arr[i2].push(...Array(N - arr[i2].length).fill(0));
    }
    for (var _i5 = arr.length; _i5 < N; _i5++) {
      arr.push(Array(N).fill(0));
      arr[_i5][_i5] = 1;
    }
    return arr;
  }
  function blockDiag(arr, N) {
    var M = [];
    for (var i2 = 0; i2 < N; i2++) {
      M[i2] = Array(N).fill(0);
    }
    var I = 0;
    for (var sub of arr) {
      var n = sub.length;
      for (var _i6 = 0; _i6 < n; _i6++) {
        for (var j = 0; j < n; j++) {
          M[I + _i6][I + j] = sub[_i6][j];
        }
      }
      I += n;
    }
    return M;
  }
  function indexOf(arr, el, fn) {
    for (var i2 = 0; i2 < arr.length; i2++) {
      if (fn(arr[i2], el)) {
        return i2;
      }
    }
    return -1;
  }
  function inverseIterate(A, N, orthog, prec, type) {
    var largeNum = type === "BigNumber" ? bignumber2(1e3) : 1e3;
    var b;
    var i2 = 0;
    while (true) {
      b = randomOrthogonalVector(N, orthog, type);
      b = usolve2(A, b);
      if (larger2(norm2(b), largeNum)) {
        break;
      }
      if (++i2 >= 5) {
        return null;
      }
    }
    i2 = 0;
    while (true) {
      var c = usolve2(A, b);
      if (smaller2(norm2(orthogonalComplement(b, [c])), prec)) {
        break;
      }
      if (++i2 >= 10) {
        return null;
      }
      b = normalize(c);
    }
    return b;
  }
  function randomOrthogonalVector(N, orthog, type) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var v = Array(N).fill(0).map((_) => 2 * Math.random() - 1);
    if (big) {
      v = v.map((n) => bignumber2(n));
    }
    if (cplx) {
      v = v.map((n) => complex2(n));
    }
    v = orthogonalComplement(v, orthog);
    return normalize(v, type);
  }
  function orthogonalComplement(v, orthog) {
    for (var w of orthog) {
      v = subtract2(v, multiply2(divideScalar2(dot2(w, v), dot2(w, w)), w));
    }
    return v;
  }
  function norm2(v) {
    return abs2(sqrt2(dot2(v, v)));
  }
  function normalize(v, type) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
    return multiply2(divideScalar2(one, norm2(v)), v);
  }
  return complexEigs;
}
var init_complexEigs = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/eigs/complexEigs.js"() {
    init_object();
  }
});

// node_modules/mathjs/lib/esm/function/matrix/eigs/realSymetric.js
function createRealSymmetric(_ref) {
  var {
    config: config3,
    addScalar: addScalar2,
    subtract: subtract2,
    abs: abs2,
    atan: atan3,
    cos: cos2,
    sin: sin2,
    multiplyScalar: multiplyScalar2,
    inv: inv2,
    bignumber: bignumber2,
    multiply: multiply2,
    add: add2
  } = _ref;
  function main(arr, N) {
    var prec = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : config3.epsilon;
    var type = arguments.length > 3 ? arguments[3] : void 0;
    if (type === "number") {
      return diag2(arr, prec);
    }
    if (type === "BigNumber") {
      return diagBig(arr, prec);
    }
    throw TypeError("Unsupported data type: " + type);
  }
  function diag2(x, precision) {
    var N = x.length;
    var e0 = Math.abs(precision / N);
    var psi;
    var Sij = new Array(N);
    for (var i2 = 0; i2 < N; i2++) {
      Sij[i2] = createArray(N, 0);
      Sij[i2][i2] = 1;
    }
    var Vab = getAij(x);
    while (Math.abs(Vab[1]) >= Math.abs(e0)) {
      var _i = Vab[0][0];
      var j = Vab[0][1];
      psi = getTheta(x[_i][_i], x[j][j], x[_i][j]);
      x = x1(x, psi, _i, j);
      Sij = Sij1(Sij, psi, _i, j);
      Vab = getAij(x);
    }
    var Ei = createArray(N, 0);
    for (var _i2 = 0; _i2 < N; _i2++) {
      Ei[_i2] = x[_i2][_i2];
    }
    return sorting(clone(Ei), clone(Sij));
  }
  function diagBig(x, precision) {
    var N = x.length;
    var e0 = abs2(precision / N);
    var psi;
    var Sij = new Array(N);
    for (var i2 = 0; i2 < N; i2++) {
      Sij[i2] = createArray(N, 0);
      Sij[i2][i2] = 1;
    }
    var Vab = getAijBig(x);
    while (abs2(Vab[1]) >= abs2(e0)) {
      var _i3 = Vab[0][0];
      var j = Vab[0][1];
      psi = getThetaBig(x[_i3][_i3], x[j][j], x[_i3][j]);
      x = x1Big(x, psi, _i3, j);
      Sij = Sij1Big(Sij, psi, _i3, j);
      Vab = getAijBig(x);
    }
    var Ei = createArray(N, 0);
    for (var _i4 = 0; _i4 < N; _i4++) {
      Ei[_i4] = x[_i4][_i4];
    }
    return sorting(clone(Ei), clone(Sij));
  }
  function getTheta(aii, ajj, aij) {
    var denom = ajj - aii;
    if (Math.abs(denom) <= config3.epsilon) {
      return Math.PI / 4;
    } else {
      return 0.5 * Math.atan(2 * aij / (ajj - aii));
    }
  }
  function getThetaBig(aii, ajj, aij) {
    var denom = subtract2(ajj, aii);
    if (abs2(denom) <= config3.epsilon) {
      return bignumber2(-1).acos().div(4);
    } else {
      return multiplyScalar2(0.5, atan3(multiply2(2, aij, inv2(denom))));
    }
  }
  function Sij1(Sij, theta, i2, j) {
    var N = Sij.length;
    var c = Math.cos(theta);
    var s = Math.sin(theta);
    var Ski = createArray(N, 0);
    var Skj = createArray(N, 0);
    for (var k = 0; k < N; k++) {
      Ski[k] = c * Sij[k][i2] - s * Sij[k][j];
      Skj[k] = s * Sij[k][i2] + c * Sij[k][j];
    }
    for (var _k = 0; _k < N; _k++) {
      Sij[_k][i2] = Ski[_k];
      Sij[_k][j] = Skj[_k];
    }
    return Sij;
  }
  function Sij1Big(Sij, theta, i2, j) {
    var N = Sij.length;
    var c = cos2(theta);
    var s = sin2(theta);
    var Ski = createArray(N, bignumber2(0));
    var Skj = createArray(N, bignumber2(0));
    for (var k = 0; k < N; k++) {
      Ski[k] = subtract2(multiplyScalar2(c, Sij[k][i2]), multiplyScalar2(s, Sij[k][j]));
      Skj[k] = addScalar2(multiplyScalar2(s, Sij[k][i2]), multiplyScalar2(c, Sij[k][j]));
    }
    for (var _k2 = 0; _k2 < N; _k2++) {
      Sij[_k2][i2] = Ski[_k2];
      Sij[_k2][j] = Skj[_k2];
    }
    return Sij;
  }
  function x1Big(Hij, theta, i2, j) {
    var N = Hij.length;
    var c = bignumber2(cos2(theta));
    var s = bignumber2(sin2(theta));
    var c2 = multiplyScalar2(c, c);
    var s2 = multiplyScalar2(s, s);
    var Aki = createArray(N, bignumber2(0));
    var Akj = createArray(N, bignumber2(0));
    var csHij = multiply2(bignumber2(2), c, s, Hij[i2][j]);
    var Aii = addScalar2(subtract2(multiplyScalar2(c2, Hij[i2][i2]), csHij), multiplyScalar2(s2, Hij[j][j]));
    var Ajj = add2(multiplyScalar2(s2, Hij[i2][i2]), csHij, multiplyScalar2(c2, Hij[j][j]));
    for (var k = 0; k < N; k++) {
      Aki[k] = subtract2(multiplyScalar2(c, Hij[i2][k]), multiplyScalar2(s, Hij[j][k]));
      Akj[k] = addScalar2(multiplyScalar2(s, Hij[i2][k]), multiplyScalar2(c, Hij[j][k]));
    }
    Hij[i2][i2] = Aii;
    Hij[j][j] = Ajj;
    Hij[i2][j] = bignumber2(0);
    Hij[j][i2] = bignumber2(0);
    for (var _k3 = 0; _k3 < N; _k3++) {
      if (_k3 !== i2 && _k3 !== j) {
        Hij[i2][_k3] = Aki[_k3];
        Hij[_k3][i2] = Aki[_k3];
        Hij[j][_k3] = Akj[_k3];
        Hij[_k3][j] = Akj[_k3];
      }
    }
    return Hij;
  }
  function x1(Hij, theta, i2, j) {
    var N = Hij.length;
    var c = Math.cos(theta);
    var s = Math.sin(theta);
    var c2 = c * c;
    var s2 = s * s;
    var Aki = createArray(N, 0);
    var Akj = createArray(N, 0);
    var Aii = c2 * Hij[i2][i2] - 2 * c * s * Hij[i2][j] + s2 * Hij[j][j];
    var Ajj = s2 * Hij[i2][i2] + 2 * c * s * Hij[i2][j] + c2 * Hij[j][j];
    for (var k = 0; k < N; k++) {
      Aki[k] = c * Hij[i2][k] - s * Hij[j][k];
      Akj[k] = s * Hij[i2][k] + c * Hij[j][k];
    }
    Hij[i2][i2] = Aii;
    Hij[j][j] = Ajj;
    Hij[i2][j] = 0;
    Hij[j][i2] = 0;
    for (var _k4 = 0; _k4 < N; _k4++) {
      if (_k4 !== i2 && _k4 !== j) {
        Hij[i2][_k4] = Aki[_k4];
        Hij[_k4][i2] = Aki[_k4];
        Hij[j][_k4] = Akj[_k4];
        Hij[_k4][j] = Akj[_k4];
      }
    }
    return Hij;
  }
  function getAij(Mij) {
    var N = Mij.length;
    var maxMij = 0;
    var maxIJ = [0, 1];
    for (var i2 = 0; i2 < N; i2++) {
      for (var j = i2 + 1; j < N; j++) {
        if (Math.abs(maxMij) < Math.abs(Mij[i2][j])) {
          maxMij = Math.abs(Mij[i2][j]);
          maxIJ = [i2, j];
        }
      }
    }
    return [maxIJ, maxMij];
  }
  function getAijBig(Mij) {
    var N = Mij.length;
    var maxMij = 0;
    var maxIJ = [0, 1];
    for (var i2 = 0; i2 < N; i2++) {
      for (var j = i2 + 1; j < N; j++) {
        if (abs2(maxMij) < abs2(Mij[i2][j])) {
          maxMij = abs2(Mij[i2][j]);
          maxIJ = [i2, j];
        }
      }
    }
    return [maxIJ, maxMij];
  }
  function sorting(E, S) {
    var N = E.length;
    var values = Array(N);
    var vectors = Array(N);
    for (var k = 0; k < N; k++) {
      vectors[k] = Array(N);
    }
    for (var i2 = 0; i2 < N; i2++) {
      var minID = 0;
      var minE = E[0];
      for (var j = 0; j < E.length; j++) {
        if (abs2(E[j]) < abs2(minE)) {
          minID = j;
          minE = E[minID];
        }
      }
      values[i2] = E.splice(minID, 1)[0];
      for (var _k5 = 0; _k5 < N; _k5++) {
        vectors[_k5][i2] = S[_k5][minID];
        S[_k5].splice(minID, 1);
      }
    }
    return {
      values,
      vectors
    };
  }
  function createArray(size2, value) {
    var array = new Array(size2);
    for (var i2 = 0; i2 < size2; i2++) {
      array[i2] = value;
    }
    return array;
  }
  return main;
}
var init_realSymetric = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/eigs/realSymetric.js"() {
    init_object();
  }
});

// node_modules/mathjs/lib/esm/function/matrix/eigs.js
var name238, dependencies239, createEigs;
var init_eigs2 = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/eigs.js"() {
    init_factory();
    init_string();
    init_complexEigs();
    init_realSymetric();
    init_is();
    name238 = "eigs";
    dependencies239 = ["config", "typed", "matrix", "addScalar", "equal", "subtract", "abs", "atan", "cos", "sin", "multiplyScalar", "divideScalar", "inv", "bignumber", "multiply", "add", "larger", "column", "flatten", "number", "complex", "sqrt", "diag", "qr", "usolve", "usolveAll", "im", "re", "smaller", "matrixFromColumns", "dot"];
    createEigs = /* @__PURE__ */ factory(name238, dependencies239, (_ref) => {
      var {
        config: config3,
        typed: typed2,
        matrix: matrix2,
        addScalar: addScalar2,
        subtract: subtract2,
        equal: equal2,
        abs: abs2,
        atan: atan3,
        cos: cos2,
        sin: sin2,
        multiplyScalar: multiplyScalar2,
        divideScalar: divideScalar2,
        inv: inv2,
        bignumber: bignumber2,
        multiply: multiply2,
        add: add2,
        larger: larger2,
        column: column2,
        flatten: flatten4,
        number: number2,
        complex: complex2,
        sqrt: sqrt2,
        diag: diag2,
        qr: qr2,
        usolve: usolve2,
        usolveAll: usolveAll2,
        im: im2,
        re: re2,
        smaller: smaller2,
        matrixFromColumns: matrixFromColumns2,
        dot: dot2
      } = _ref;
      var doRealSymetric = createRealSymmetric({
        config: config3,
        addScalar: addScalar2,
        subtract: subtract2,
        column: column2,
        flatten: flatten4,
        equal: equal2,
        abs: abs2,
        atan: atan3,
        cos: cos2,
        sin: sin2,
        multiplyScalar: multiplyScalar2,
        inv: inv2,
        bignumber: bignumber2,
        complex: complex2,
        multiply: multiply2,
        add: add2
      });
      var doComplexEigs = createComplexEigs({
        config: config3,
        addScalar: addScalar2,
        subtract: subtract2,
        multiply: multiply2,
        multiplyScalar: multiplyScalar2,
        flatten: flatten4,
        divideScalar: divideScalar2,
        sqrt: sqrt2,
        abs: abs2,
        bignumber: bignumber2,
        diag: diag2,
        qr: qr2,
        inv: inv2,
        usolve: usolve2,
        usolveAll: usolveAll2,
        equal: equal2,
        complex: complex2,
        larger: larger2,
        smaller: smaller2,
        matrixFromColumns: matrixFromColumns2,
        dot: dot2
      });
      return typed2("eigs", {
        Array: function Array2(x) {
          var mat = matrix2(x);
          return computeValuesAndVectors(mat);
        },
        "Array, number|BigNumber": function ArrayNumberBigNumber(x, prec) {
          var mat = matrix2(x);
          return computeValuesAndVectors(mat, prec);
        },
        Matrix: function Matrix2(mat) {
          var {
            values,
            vectors
          } = computeValuesAndVectors(mat);
          return {
            values: matrix2(values),
            vectors: matrix2(vectors)
          };
        },
        "Matrix, number|BigNumber": function MatrixNumberBigNumber(mat, prec) {
          var {
            values,
            vectors
          } = computeValuesAndVectors(mat, prec);
          return {
            values: matrix2(values),
            vectors: matrix2(vectors)
          };
        }
      });
      function computeValuesAndVectors(mat, prec) {
        if (prec === void 0) {
          prec = config3.epsilon;
        }
        var size2 = mat.size();
        if (size2.length !== 2 || size2[0] !== size2[1]) {
          throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
        }
        var arr = mat.toArray();
        var N = size2[0];
        if (isReal(arr, N, prec)) {
          coerceReal(arr, N);
          if (isSymmetric(arr, N, prec)) {
            var _type = coerceTypes(mat, arr, N);
            return doRealSymetric(arr, N, prec, _type);
          }
        }
        var type = coerceTypes(mat, arr, N);
        return doComplexEigs(arr, N, prec, type);
      }
      function isSymmetric(arr, N, prec) {
        for (var i2 = 0; i2 < N; i2++) {
          for (var j = i2; j < N; j++) {
            if (larger2(bignumber2(abs2(subtract2(arr[i2][j], arr[j][i2]))), prec)) {
              return false;
            }
          }
        }
        return true;
      }
      function isReal(arr, N, prec) {
        for (var i2 = 0; i2 < N; i2++) {
          for (var j = 0; j < N; j++) {
            if (larger2(bignumber2(abs2(im2(arr[i2][j]))), prec)) {
              return false;
            }
          }
        }
        return true;
      }
      function coerceReal(arr, N) {
        for (var i2 = 0; i2 < N; i2++) {
          for (var j = 0; j < N; j++) {
            arr[i2][j] = re2(arr[i2][j]);
          }
        }
      }
      function coerceTypes(mat, arr, N) {
        var type = mat.datatype();
        if (type === "number" || type === "BigNumber" || type === "Complex") {
          return type;
        }
        var hasNumber = false;
        var hasBig = false;
        var hasComplex = false;
        for (var i2 = 0; i2 < N; i2++) {
          for (var j = 0; j < N; j++) {
            var el = arr[i2][j];
            if (isNumber2(el) || isFraction(el)) {
              hasNumber = true;
            } else if (isBigNumber(el)) {
              hasBig = true;
            } else if (isComplex(el)) {
              hasComplex = true;
            } else {
              throw TypeError("Unsupported type in Matrix: " + typeOf(el));
            }
          }
        }
        if (hasBig && hasComplex) {
          console.warn("Complex BigNumbers not supported, this operation will lose precission.");
        }
        if (hasComplex) {
          for (var _i = 0; _i < N; _i++) {
            for (var _j = 0; _j < N; _j++) {
              arr[_i][_j] = complex2(arr[_i][_j]);
            }
          }
          return "Complex";
        }
        if (hasBig) {
          for (var _i2 = 0; _i2 < N; _i2++) {
            for (var _j2 = 0; _j2 < N; _j2++) {
              arr[_i2][_j2] = bignumber2(arr[_i2][_j2]);
            }
          }
          return "BigNumber";
        }
        if (hasNumber) {
          for (var _i3 = 0; _i3 < N; _i3++) {
            for (var _j3 = 0; _j3 < N; _j3++) {
              arr[_i3][_j3] = number2(arr[_i3][_j3]);
            }
          }
          return "number";
        } else {
          throw TypeError("Matrix contains unsupported types only.");
        }
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/expm.js
var name239, dependencies240, createExpm;
var init_expm2 = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/expm.js"() {
    init_is();
    init_string();
    init_factory();
    name239 = "expm";
    dependencies240 = ["typed", "abs", "add", "identity", "inv", "multiply"];
    createExpm = /* @__PURE__ */ factory(name239, dependencies240, (_ref) => {
      var {
        typed: typed2,
        abs: abs2,
        add: add2,
        identity: identity2,
        inv: inv2,
        multiply: multiply2
      } = _ref;
      return typed2(name239, {
        Matrix: function Matrix2(A) {
          var size2 = A.size();
          if (size2.length !== 2 || size2[0] !== size2[1]) {
            throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
          }
          var n = size2[0];
          var eps = 1e-15;
          var infNorm = infinityNorm(A);
          var params = findParams(infNorm, eps);
          var q = params.q;
          var j = params.j;
          var Apos = multiply2(A, Math.pow(2, -j));
          var N = identity2(n);
          var D = identity2(n);
          var factor = 1;
          var AposToI = Apos;
          var alternate = -1;
          for (var i2 = 1; i2 <= q; i2++) {
            if (i2 > 1) {
              AposToI = multiply2(AposToI, Apos);
              alternate = -alternate;
            }
            factor = factor * (q - i2 + 1) / ((2 * q - i2 + 1) * i2);
            N = add2(N, multiply2(factor, AposToI));
            D = add2(D, multiply2(factor * alternate, AposToI));
          }
          var R = multiply2(inv2(D), N);
          for (var _i = 0; _i < j; _i++) {
            R = multiply2(R, R);
          }
          return isSparseMatrix(A) ? A.createSparseMatrix(R) : R;
        }
      });
      function infinityNorm(A) {
        var n = A.size()[0];
        var infNorm = 0;
        for (var i2 = 0; i2 < n; i2++) {
          var rowSum = 0;
          for (var j = 0; j < n; j++) {
            rowSum += abs2(A.get([i2, j]));
          }
          infNorm = Math.max(rowSum, infNorm);
        }
        return infNorm;
      }
      function findParams(infNorm, eps) {
        var maxSearchSize = 30;
        for (var k = 0; k < maxSearchSize; k++) {
          for (var q = 0; q <= k; q++) {
            var j = k - q;
            if (errorEstimate(infNorm, q, j) < eps) {
              return {
                q,
                j
              };
            }
          }
        }
        throw new Error("Could not find acceptable parameters to compute the matrix exponential (try increasing maxSearchSize in expm.js)");
      }
      function errorEstimate(infNorm, q, j) {
        var qfac = 1;
        for (var i2 = 2; i2 <= q; i2++) {
          qfac *= i2;
        }
        var twoqfac = qfac;
        for (var _i2 = q + 1; _i2 <= 2 * q; _i2++) {
          twoqfac *= _i2;
        }
        var twoqp1fac = twoqfac * (2 * q + 1);
        return 8 * Math.pow(infNorm / Math.pow(2, j), 2 * q) * qfac * qfac / (twoqfac * twoqp1fac);
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/matrix/sqrtm.js
var name240, dependencies241, createSqrtm;
var init_sqrtm2 = __esm({
  "node_modules/mathjs/lib/esm/function/matrix/sqrtm.js"() {
    init_is();
    init_string();
    init_array();
    init_factory();
    name240 = "sqrtm";
    dependencies241 = ["typed", "abs", "add", "multiply", "sqrt", "subtract", "inv", "size", "max", "identity"];
    createSqrtm = /* @__PURE__ */ factory(name240, dependencies241, (_ref) => {
      var {
        typed: typed2,
        abs: abs2,
        add: add2,
        multiply: multiply2,
        sqrt: sqrt2,
        subtract: subtract2,
        inv: inv2,
        size: size2,
        max: max2,
        identity: identity2
      } = _ref;
      var _maxIterations = 1e3;
      var _tolerance = 1e-6;
      function _denmanBeavers(A) {
        var error;
        var iterations = 0;
        var Y = A;
        var Z = identity2(size2(A));
        do {
          var Yk = Y;
          Y = multiply2(0.5, add2(Yk, inv2(Z)));
          Z = multiply2(0.5, add2(Z, inv2(Yk)));
          error = max2(abs2(subtract2(Y, Yk)));
          if (error > _tolerance && ++iterations > _maxIterations) {
            throw new Error("computing square root of matrix: iterative method could not converge");
          }
        } while (error > _tolerance);
        return Y;
      }
      return typed2(name240, {
        "Array | Matrix": function ArrayMatrix(A) {
          var size3 = isMatrix(A) ? A.size() : arraySize(A);
          switch (size3.length) {
            case 1:
              if (size3[0] === 1) {
                return sqrt2(A);
              } else {
                throw new RangeError("Matrix must be square (size: " + format3(size3) + ")");
              }
            case 2: {
              var rows = size3[0];
              var cols = size3[1];
              if (rows === cols) {
                return _denmanBeavers(A);
              } else {
                throw new RangeError("Matrix must be square (size: " + format3(size3) + ")");
              }
            }
            default:
              throw new RangeError("Matrix must be at most two dimensional (size: " + format3(size3) + ")");
          }
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/arithmetic/divide.js
var name241, dependencies242, createDivide;
var init_divide2 = __esm({
  "node_modules/mathjs/lib/esm/function/arithmetic/divide.js"() {
    init_factory();
    init_object();
    init_algorithm11();
    init_algorithm14();
    name241 = "divide";
    dependencies242 = ["typed", "matrix", "multiply", "equalScalar", "divideScalar", "inv"];
    createDivide = /* @__PURE__ */ factory(name241, dependencies242, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        multiply: multiply2,
        equalScalar: equalScalar2,
        divideScalar: divideScalar2,
        inv: inv2
      } = _ref;
      var algorithm11 = createAlgorithm11({
        typed: typed2,
        equalScalar: equalScalar2
      });
      var algorithm14 = createAlgorithm14({
        typed: typed2
      });
      return typed2("divide", extend({
        "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(x, y) {
          return multiply2(x, inv2(y));
        },
        "DenseMatrix, any": function DenseMatrixAny(x, y) {
          return algorithm14(x, y, divideScalar2, false);
        },
        "SparseMatrix, any": function SparseMatrixAny(x, y) {
          return algorithm11(x, y, divideScalar2, false);
        },
        "Array, any": function ArrayAny(x, y) {
          return algorithm14(matrix2(x), y, divideScalar2, false).valueOf();
        },
        "any, Array | Matrix": function anyArrayMatrix(x, y) {
          return multiply2(x, inv2(y));
        }
      }, divideScalar2.signatures));
    });
  }
});

// node_modules/mathjs/lib/esm/function/geometry/distance.js
var name242, dependencies243, createDistance;
var init_distance2 = __esm({
  "node_modules/mathjs/lib/esm/function/geometry/distance.js"() {
    init_is();
    init_factory();
    name242 = "distance";
    dependencies243 = ["typed", "addScalar", "subtract", "divideScalar", "multiplyScalar", "unaryMinus", "sqrt", "abs"];
    createDistance = /* @__PURE__ */ factory(name242, dependencies243, (_ref) => {
      var {
        typed: typed2,
        addScalar: addScalar2,
        subtract: subtract2,
        multiplyScalar: multiplyScalar2,
        divideScalar: divideScalar2,
        unaryMinus: unaryMinus2,
        sqrt: sqrt2,
        abs: abs2
      } = _ref;
      return typed2(name242, {
        "Array, Array, Array": function ArrayArrayArray(x, y, z) {
          if (x.length === 2 && y.length === 2 && z.length === 2) {
            if (!_2d(x)) {
              throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
            }
            if (!_2d(y)) {
              throw new TypeError("Array with 2 numbers or BigNumbers expected for second argument");
            }
            if (!_2d(z)) {
              throw new TypeError("Array with 2 numbers or BigNumbers expected for third argument");
            }
            var m = divideScalar2(subtract2(z[1], z[0]), subtract2(y[1], y[0]));
            var xCoeff = multiplyScalar2(multiplyScalar2(m, m), y[0]);
            var yCoeff = unaryMinus2(multiplyScalar2(m, y[0]));
            var constant = x[1];
            return _distancePointLine2D(x[0], x[1], xCoeff, yCoeff, constant);
          } else {
            throw new TypeError("Invalid Arguments: Try again");
          }
        },
        "Object, Object, Object": function ObjectObjectObject(x, y, z) {
          if (Object.keys(x).length === 2 && Object.keys(y).length === 2 && Object.keys(z).length === 2) {
            if (!_2d(x)) {
              throw new TypeError("Values of pointX and pointY should be numbers or BigNumbers");
            }
            if (!_2d(y)) {
              throw new TypeError("Values of lineOnePtX and lineOnePtY should be numbers or BigNumbers");
            }
            if (!_2d(z)) {
              throw new TypeError("Values of lineTwoPtX and lineTwoPtY should be numbers or BigNumbers");
            }
            if ("pointX" in x && "pointY" in x && "lineOnePtX" in y && "lineOnePtY" in y && "lineTwoPtX" in z && "lineTwoPtY" in z) {
              var m = divideScalar2(subtract2(z.lineTwoPtY, z.lineTwoPtX), subtract2(y.lineOnePtY, y.lineOnePtX));
              var xCoeff = multiplyScalar2(multiplyScalar2(m, m), y.lineOnePtX);
              var yCoeff = unaryMinus2(multiplyScalar2(m, y.lineOnePtX));
              var constant = x.pointX;
              return _distancePointLine2D(x.pointX, x.pointY, xCoeff, yCoeff, constant);
            } else {
              throw new TypeError("Key names do not match");
            }
          } else {
            throw new TypeError("Invalid Arguments: Try again");
          }
        },
        "Array, Array": function ArrayArray(x, y) {
          if (x.length === 2 && y.length === 3) {
            if (!_2d(x)) {
              throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
            }
            if (!_3d(y)) {
              throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
            }
            return _distancePointLine2D(x[0], x[1], y[0], y[1], y[2]);
          } else if (x.length === 3 && y.length === 6) {
            if (!_3d(x)) {
              throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
            }
            if (!_parametricLine(y)) {
              throw new TypeError("Array with 6 numbers or BigNumbers expected for second argument");
            }
            return _distancePointLine3D(x[0], x[1], x[2], y[0], y[1], y[2], y[3], y[4], y[5]);
          } else if (x.length === y.length && x.length > 0) {
            if (!_containsOnlyNumbers(x)) {
              throw new TypeError("All values of an array should be numbers or BigNumbers");
            }
            if (!_containsOnlyNumbers(y)) {
              throw new TypeError("All values of an array should be numbers or BigNumbers");
            }
            return _euclideanDistance(x, y);
          } else {
            throw new TypeError("Invalid Arguments: Try again");
          }
        },
        "Object, Object": function ObjectObject(x, y) {
          if (Object.keys(x).length === 2 && Object.keys(y).length === 3) {
            if (!_2d(x)) {
              throw new TypeError("Values of pointX and pointY should be numbers or BigNumbers");
            }
            if (!_3d(y)) {
              throw new TypeError("Values of xCoeffLine, yCoeffLine and constant should be numbers or BigNumbers");
            }
            if ("pointX" in x && "pointY" in x && "xCoeffLine" in y && "yCoeffLine" in y && "constant" in y) {
              return _distancePointLine2D(x.pointX, x.pointY, y.xCoeffLine, y.yCoeffLine, y.constant);
            } else {
              throw new TypeError("Key names do not match");
            }
          } else if (Object.keys(x).length === 3 && Object.keys(y).length === 6) {
            if (!_3d(x)) {
              throw new TypeError("Values of pointX, pointY and pointZ should be numbers or BigNumbers");
            }
            if (!_parametricLine(y)) {
              throw new TypeError("Values of x0, y0, z0, a, b and c should be numbers or BigNumbers");
            }
            if ("pointX" in x && "pointY" in x && "x0" in y && "y0" in y && "z0" in y && "a" in y && "b" in y && "c" in y) {
              return _distancePointLine3D(x.pointX, x.pointY, x.pointZ, y.x0, y.y0, y.z0, y.a, y.b, y.c);
            } else {
              throw new TypeError("Key names do not match");
            }
          } else if (Object.keys(x).length === 2 && Object.keys(y).length === 2) {
            if (!_2d(x)) {
              throw new TypeError("Values of pointOneX and pointOneY should be numbers or BigNumbers");
            }
            if (!_2d(y)) {
              throw new TypeError("Values of pointTwoX and pointTwoY should be numbers or BigNumbers");
            }
            if ("pointOneX" in x && "pointOneY" in x && "pointTwoX" in y && "pointTwoY" in y) {
              return _euclideanDistance([x.pointOneX, x.pointOneY], [y.pointTwoX, y.pointTwoY]);
            } else {
              throw new TypeError("Key names do not match");
            }
          } else if (Object.keys(x).length === 3 && Object.keys(y).length === 3) {
            if (!_3d(x)) {
              throw new TypeError("Values of pointOneX, pointOneY and pointOneZ should be numbers or BigNumbers");
            }
            if (!_3d(y)) {
              throw new TypeError("Values of pointTwoX, pointTwoY and pointTwoZ should be numbers or BigNumbers");
            }
            if ("pointOneX" in x && "pointOneY" in x && "pointOneZ" in x && "pointTwoX" in y && "pointTwoY" in y && "pointTwoZ" in y) {
              return _euclideanDistance([x.pointOneX, x.pointOneY, x.pointOneZ], [y.pointTwoX, y.pointTwoY, y.pointTwoZ]);
            } else {
              throw new TypeError("Key names do not match");
            }
          } else {
            throw new TypeError("Invalid Arguments: Try again");
          }
        },
        Array: function Array2(arr) {
          if (!_pairwise(arr)) {
            throw new TypeError("Incorrect array format entered for pairwise distance calculation");
          }
          return _distancePairwise(arr);
        }
      });
      function _isNumber(a) {
        return typeof a === "number" || isBigNumber(a);
      }
      function _2d(a) {
        if (a.constructor !== Array) {
          a = _objectToArray(a);
        }
        return _isNumber(a[0]) && _isNumber(a[1]);
      }
      function _3d(a) {
        if (a.constructor !== Array) {
          a = _objectToArray(a);
        }
        return _isNumber(a[0]) && _isNumber(a[1]) && _isNumber(a[2]);
      }
      function _containsOnlyNumbers(a) {
        if (!Array.isArray(a)) {
          a = _objectToArray(a);
        }
        return a.every(_isNumber);
      }
      function _parametricLine(a) {
        if (a.constructor !== Array) {
          a = _objectToArray(a);
        }
        return _isNumber(a[0]) && _isNumber(a[1]) && _isNumber(a[2]) && _isNumber(a[3]) && _isNumber(a[4]) && _isNumber(a[5]);
      }
      function _objectToArray(o) {
        var keys = Object.keys(o);
        var a = [];
        for (var i2 = 0; i2 < keys.length; i2++) {
          a.push(o[keys[i2]]);
        }
        return a;
      }
      function _pairwise(a) {
        if (a[0].length === 2 && _isNumber(a[0][0]) && _isNumber(a[0][1])) {
          if (a.some((aI) => aI.length !== 2 || !_isNumber(aI[0]) || !_isNumber(aI[1]))) {
            return false;
          }
        } else if (a[0].length === 3 && _isNumber(a[0][0]) && _isNumber(a[0][1]) && _isNumber(a[0][2])) {
          if (a.some((aI) => aI.length !== 3 || !_isNumber(aI[0]) || !_isNumber(aI[1]) || !_isNumber(aI[2]))) {
            return false;
          }
        } else {
          return false;
        }
        return true;
      }
      function _distancePointLine2D(x, y, a, b, c) {
        var num = abs2(addScalar2(addScalar2(multiplyScalar2(a, x), multiplyScalar2(b, y)), c));
        var den = sqrt2(addScalar2(multiplyScalar2(a, a), multiplyScalar2(b, b)));
        return divideScalar2(num, den);
      }
      function _distancePointLine3D(x, y, z, x0, y0, z0, a, b, c) {
        var num = [subtract2(multiplyScalar2(subtract2(y0, y), c), multiplyScalar2(subtract2(z0, z), b)), subtract2(multiplyScalar2(subtract2(z0, z), a), multiplyScalar2(subtract2(x0, x), c)), subtract2(multiplyScalar2(subtract2(x0, x), b), multiplyScalar2(subtract2(y0, y), a))];
        num = sqrt2(addScalar2(addScalar2(multiplyScalar2(num[0], num[0]), multiplyScalar2(num[1], num[1])), multiplyScalar2(num[2], num[2])));
        var den = sqrt2(addScalar2(addScalar2(multiplyScalar2(a, a), multiplyScalar2(b, b)), multiplyScalar2(c, c)));
        return divideScalar2(num, den);
      }
      function _euclideanDistance(x, y) {
        var vectorSize = x.length;
        var result = 0;
        var diff2 = 0;
        for (var i2 = 0; i2 < vectorSize; i2++) {
          diff2 = subtract2(x[i2], y[i2]);
          result = addScalar2(multiplyScalar2(diff2, diff2), result);
        }
        return sqrt2(result);
      }
      function _distancePairwise(a) {
        var result = [];
        var pointA = [];
        var pointB = [];
        for (var i2 = 0; i2 < a.length - 1; i2++) {
          for (var j = i2 + 1; j < a.length; j++) {
            if (a[0].length === 2) {
              pointA = [a[i2][0], a[i2][1]];
              pointB = [a[j][0], a[j][1]];
            } else if (a[0].length === 3) {
              pointA = [a[i2][0], a[i2][1], a[i2][2]];
              pointB = [a[j][0], a[j][1], a[j][2]];
            }
            result.push(_euclideanDistance(pointA, pointB));
          }
        }
        return result;
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/geometry/intersect.js
var name243, dependencies244, createIntersect;
var init_intersect2 = __esm({
  "node_modules/mathjs/lib/esm/function/geometry/intersect.js"() {
    init_factory();
    name243 = "intersect";
    dependencies244 = ["typed", "config", "abs", "add", "addScalar", "matrix", "multiply", "multiplyScalar", "divideScalar", "subtract", "smaller", "equalScalar", "flatten", "isZero", "isNumeric"];
    createIntersect = /* @__PURE__ */ factory(name243, dependencies244, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        abs: abs2,
        add: add2,
        addScalar: addScalar2,
        matrix: matrix2,
        multiply: multiply2,
        multiplyScalar: multiplyScalar2,
        divideScalar: divideScalar2,
        subtract: subtract2,
        smaller: smaller2,
        equalScalar: equalScalar2,
        flatten: flatten4,
        isZero: isZero2,
        isNumeric: isNumeric2
      } = _ref;
      return typed2("intersect", {
        "Array, Array, Array": _AAA,
        "Array, Array, Array, Array": _AAAA,
        "Matrix, Matrix, Matrix": function MatrixMatrixMatrix(x, y, plane) {
          var arr = _AAA(x.valueOf(), y.valueOf(), plane.valueOf());
          return arr === null ? null : matrix2(arr);
        },
        "Matrix, Matrix, Matrix, Matrix": function MatrixMatrixMatrixMatrix(w, x, y, z) {
          var arr = _AAAA(w.valueOf(), x.valueOf(), y.valueOf(), z.valueOf());
          return arr === null ? null : matrix2(arr);
        }
      });
      function _AAA(x, y, plane) {
        x = _coerceArr(x);
        y = _coerceArr(y);
        plane = _coerceArr(plane);
        if (!_3d(x)) {
          throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
        }
        if (!_3d(y)) {
          throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
        }
        if (!_4d(plane)) {
          throw new TypeError("Array with 4 numbers expected as third argument");
        }
        return _intersectLinePlane(x[0], x[1], x[2], y[0], y[1], y[2], plane[0], plane[1], plane[2], plane[3]);
      }
      function _AAAA(w, x, y, z) {
        w = _coerceArr(w);
        x = _coerceArr(x);
        y = _coerceArr(y);
        z = _coerceArr(z);
        if (w.length === 2) {
          if (!_2d(w)) {
            throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
          }
          if (!_2d(x)) {
            throw new TypeError("Array with 2 numbers or BigNumbers expected for second argument");
          }
          if (!_2d(y)) {
            throw new TypeError("Array with 2 numbers or BigNumbers expected for third argument");
          }
          if (!_2d(z)) {
            throw new TypeError("Array with 2 numbers or BigNumbers expected for fourth argument");
          }
          return _intersect2d(w, x, y, z);
        } else if (w.length === 3) {
          if (!_3d(w)) {
            throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
          }
          if (!_3d(x)) {
            throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
          }
          if (!_3d(y)) {
            throw new TypeError("Array with 3 numbers or BigNumbers expected for third argument");
          }
          if (!_3d(z)) {
            throw new TypeError("Array with 3 numbers or BigNumbers expected for fourth argument");
          }
          return _intersect3d(w[0], w[1], w[2], x[0], x[1], x[2], y[0], y[1], y[2], z[0], z[1], z[2]);
        } else {
          throw new TypeError("Arrays with two or thee dimensional points expected");
        }
      }
      function _coerceArr(arr) {
        if (arr.length === 1)
          return arr[0];
        if (arr.length > 1 && Array.isArray(arr[0])) {
          if (arr.every((el) => Array.isArray(el) && el.length === 1))
            return flatten4(arr);
        }
        return arr;
      }
      function _2d(x) {
        return x.length === 2 && isNumeric2(x[0]) && isNumeric2(x[1]);
      }
      function _3d(x) {
        return x.length === 3 && isNumeric2(x[0]) && isNumeric2(x[1]) && isNumeric2(x[2]);
      }
      function _4d(x) {
        return x.length === 4 && isNumeric2(x[0]) && isNumeric2(x[1]) && isNumeric2(x[2]) && isNumeric2(x[3]);
      }
      function _intersect2d(p1a, p1b, p2a, p2b) {
        var o1 = p1a;
        var o2 = p2a;
        var d1 = subtract2(o1, p1b);
        var d2 = subtract2(o2, p2b);
        var det2 = subtract2(multiplyScalar2(d1[0], d2[1]), multiplyScalar2(d2[0], d1[1]));
        if (isZero2(det2))
          return null;
        if (smaller2(abs2(det2), config3.epsilon)) {
          return null;
        }
        var d20o11 = multiplyScalar2(d2[0], o1[1]);
        var d21o10 = multiplyScalar2(d2[1], o1[0]);
        var d20o21 = multiplyScalar2(d2[0], o2[1]);
        var d21o20 = multiplyScalar2(d2[1], o2[0]);
        var t = divideScalar2(addScalar2(subtract2(subtract2(d20o11, d21o10), d20o21), d21o20), det2);
        return add2(multiply2(d1, t), o1);
      }
      function _intersect3dHelper(a, b, c, d, e3, f, g2, h, i2, j, k, l) {
        var add1 = multiplyScalar2(subtract2(a, b), subtract2(c, d));
        var add22 = multiplyScalar2(subtract2(e3, f), subtract2(g2, h));
        var add3 = multiplyScalar2(subtract2(i2, j), subtract2(k, l));
        return addScalar2(addScalar2(add1, add22), add3);
      }
      function _intersect3d(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {
        var d1343 = _intersect3dHelper(x1, x3, x4, x3, y1, y3, y4, y3, z1, z3, z4, z3);
        var d4321 = _intersect3dHelper(x4, x3, x2, x1, y4, y3, y2, y1, z4, z3, z2, z1);
        var d1321 = _intersect3dHelper(x1, x3, x2, x1, y1, y3, y2, y1, z1, z3, z2, z1);
        var d4343 = _intersect3dHelper(x4, x3, x4, x3, y4, y3, y4, y3, z4, z3, z4, z3);
        var d2121 = _intersect3dHelper(x2, x1, x2, x1, y2, y1, y2, y1, z2, z1, z2, z1);
        var numerator = subtract2(multiplyScalar2(d1343, d4321), multiplyScalar2(d1321, d4343));
        var denominator = subtract2(multiplyScalar2(d2121, d4343), multiplyScalar2(d4321, d4321));
        if (isZero2(denominator))
          return null;
        var ta = divideScalar2(numerator, denominator);
        var tb = divideScalar2(addScalar2(d1343, multiplyScalar2(ta, d4321)), d4343);
        var pax = addScalar2(x1, multiplyScalar2(ta, subtract2(x2, x1)));
        var pay = addScalar2(y1, multiplyScalar2(ta, subtract2(y2, y1)));
        var paz = addScalar2(z1, multiplyScalar2(ta, subtract2(z2, z1)));
        var pbx = addScalar2(x3, multiplyScalar2(tb, subtract2(x4, x3)));
        var pby = addScalar2(y3, multiplyScalar2(tb, subtract2(y4, y3)));
        var pbz = addScalar2(z3, multiplyScalar2(tb, subtract2(z4, z3)));
        if (equalScalar2(pax, pbx) && equalScalar2(pay, pby) && equalScalar2(paz, pbz)) {
          return [pax, pay, paz];
        } else {
          return null;
        }
      }
      function _intersectLinePlane(x1, y1, z1, x2, y2, z2, x, y, z, c) {
        var x1x = multiplyScalar2(x1, x);
        var x2x = multiplyScalar2(x2, x);
        var y1y = multiplyScalar2(y1, y);
        var y2y = multiplyScalar2(y2, y);
        var z1z = multiplyScalar2(z1, z);
        var z2z = multiplyScalar2(z2, z);
        var numerator = subtract2(subtract2(subtract2(c, x1x), y1y), z1z);
        var denominator = subtract2(subtract2(subtract2(addScalar2(addScalar2(x2x, y2y), z2z), x1x), y1y), z1z);
        var t = divideScalar2(numerator, denominator);
        var px = addScalar2(x1, multiplyScalar2(t, subtract2(x2, x1)));
        var py = addScalar2(y1, multiplyScalar2(t, subtract2(y2, y1)));
        var pz = addScalar2(z1, multiplyScalar2(t, subtract2(z2, z1)));
        return [px, py, pz];
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/statistics/sum.js
var name244, dependencies245, createSum;
var init_sum2 = __esm({
  "node_modules/mathjs/lib/esm/function/statistics/sum.js"() {
    init_collection();
    init_factory();
    init_improveErrorMessage();
    name244 = "sum";
    dependencies245 = ["typed", "config", "add", "numeric"];
    createSum = /* @__PURE__ */ factory(name244, dependencies245, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        add: add2,
        numeric: numeric3
      } = _ref;
      return typed2(name244, {
        "Array | Matrix": _sum,
        "Array | Matrix, number | BigNumber": _nsumDim,
        "...": function _(args) {
          if (containsCollections(args)) {
            throw new TypeError("Scalar values expected in function sum");
          }
          return _sum(args);
        }
      });
      function _sum(array) {
        var sum2;
        deepForEach(array, function(value) {
          try {
            sum2 = sum2 === void 0 ? value : add2(sum2, value);
          } catch (err) {
            throw improveErrorMessage(err, "sum", value);
          }
        });
        if (sum2 === void 0) {
          sum2 = numeric3(0, config3.number);
        }
        if (typeof sum2 === "string") {
          sum2 = numeric3(sum2, config3.number);
        }
        return sum2;
      }
      function _nsumDim(array, dim) {
        try {
          var sum2 = reduce(array, dim, add2);
          return sum2;
        } catch (err) {
          throw improveErrorMessage(err, "sum");
        }
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/statistics/cumsum.js
var name245, dependencies246, createCumSum;
var init_cumsum2 = __esm({
  "node_modules/mathjs/lib/esm/function/statistics/cumsum.js"() {
    init_collection();
    init_factory();
    init_switch();
    init_improveErrorMessage();
    init_array();
    init_IndexError();
    name245 = "cumsum";
    dependencies246 = ["typed", "add", "unaryPlus"];
    createCumSum = /* @__PURE__ */ factory(name245, dependencies246, (_ref) => {
      var {
        typed: typed2,
        add: add2,
        unaryPlus: unaryPlus2
      } = _ref;
      return typed2(name245, {
        Array: _cumsum,
        Matrix: function Matrix2(matrix2) {
          return matrix2.create(_cumsum(matrix2.valueOf()));
        },
        "Array, number | BigNumber": _ncumSumDim,
        "Matrix, number | BigNumber": function MatrixNumberBigNumber(matrix2, dim) {
          return matrix2.create(_ncumSumDim(matrix2.valueOf(), dim));
        },
        "...": function _(args) {
          if (containsCollections(args)) {
            throw new TypeError("All values expected to be scalar in function cumsum");
          }
          return _cumsum(args);
        }
      });
      function _cumsum(array) {
        try {
          return _cumsummap(array);
        } catch (err) {
          throw improveErrorMessage(err, name245);
        }
      }
      function _cumsummap(array) {
        if (array.length === 0) {
          return [];
        }
        var sums = [unaryPlus2(array[0])];
        for (var i2 = 1; i2 < array.length; ++i2) {
          sums.push(add2(sums[i2 - 1], array[i2]));
        }
        return sums;
      }
      function _ncumSumDim(array, dim) {
        var size2 = arraySize(array);
        if (dim < 0 || dim >= size2.length) {
          throw new IndexError(dim, size2.length);
        }
        try {
          return _cumsumDimensional(array, dim);
        } catch (err) {
          throw improveErrorMessage(err, name245);
        }
      }
      function _cumsumDimensional(mat, dim) {
        var i2, ret, tran;
        if (dim <= 0) {
          var initialValue = mat[0][0];
          if (!Array.isArray(initialValue)) {
            return _cumsummap(mat);
          } else {
            tran = _switch(mat);
            ret = [];
            for (i2 = 0; i2 < tran.length; i2++) {
              ret[i2] = _cumsumDimensional(tran[i2], dim - 1);
            }
            return ret;
          }
        } else {
          ret = [];
          for (i2 = 0; i2 < mat.length; i2++) {
            ret[i2] = _cumsumDimensional(mat[i2], dim - 1);
          }
          return ret;
        }
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/statistics/mean.js
var name246, dependencies247, createMean;
var init_mean2 = __esm({
  "node_modules/mathjs/lib/esm/function/statistics/mean.js"() {
    init_collection();
    init_array();
    init_factory();
    init_improveErrorMessage();
    name246 = "mean";
    dependencies247 = ["typed", "add", "divide"];
    createMean = /* @__PURE__ */ factory(name246, dependencies247, (_ref) => {
      var {
        typed: typed2,
        add: add2,
        divide: divide2
      } = _ref;
      return typed2(name246, {
        "Array | Matrix": _mean,
        "Array | Matrix, number | BigNumber": _nmeanDim,
        "...": function _(args) {
          if (containsCollections(args)) {
            throw new TypeError("Scalar values expected in function mean");
          }
          return _mean(args);
        }
      });
      function _nmeanDim(array, dim) {
        try {
          var sum2 = reduce(array, dim, add2);
          var s = Array.isArray(array) ? arraySize(array) : array.size();
          return divide2(sum2, s[dim]);
        } catch (err) {
          throw improveErrorMessage(err, "mean");
        }
      }
      function _mean(array) {
        var sum2;
        var num = 0;
        deepForEach(array, function(value) {
          try {
            sum2 = sum2 === void 0 ? value : add2(sum2, value);
            num++;
          } catch (err) {
            throw improveErrorMessage(err, "mean", value);
          }
        });
        if (num === 0) {
          throw new Error("Cannot calculate the mean of an empty array");
        }
        return divide2(sum2, num);
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/statistics/median.js
var name247, dependencies248, createMedian;
var init_median2 = __esm({
  "node_modules/mathjs/lib/esm/function/statistics/median.js"() {
    init_collection();
    init_array();
    init_factory();
    init_improveErrorMessage();
    name247 = "median";
    dependencies248 = ["typed", "add", "divide", "compare", "partitionSelect"];
    createMedian = /* @__PURE__ */ factory(name247, dependencies248, (_ref) => {
      var {
        typed: typed2,
        add: add2,
        divide: divide2,
        compare: compare2,
        partitionSelect: partitionSelect2
      } = _ref;
      function _median(array) {
        try {
          array = flatten(array.valueOf());
          var num = array.length;
          if (num === 0) {
            throw new Error("Cannot calculate median of an empty array");
          }
          if (num % 2 === 0) {
            var mid = num / 2 - 1;
            var right = partitionSelect2(array, mid + 1);
            var left = array[mid];
            for (var i2 = 0; i2 < mid; ++i2) {
              if (compare2(array[i2], left) > 0) {
                left = array[i2];
              }
            }
            return middle2(left, right);
          } else {
            var m = partitionSelect2(array, (num - 1) / 2);
            return middle(m);
          }
        } catch (err) {
          throw improveErrorMessage(err, "median");
        }
      }
      var middle = typed2({
        "number | BigNumber | Complex | Unit": function numberBigNumberComplexUnit(value) {
          return value;
        }
      });
      var middle2 = typed2({
        "number | BigNumber | Complex | Unit, number | BigNumber | Complex | Unit": function numberBigNumberComplexUnitNumberBigNumberComplexUnit(left, right) {
          return divide2(add2(left, right), 2);
        }
      });
      return typed2(name247, {
        "Array | Matrix": _median,
        "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
          throw new Error("median(A, dim) is not yet supported");
        },
        "...": function _(args) {
          if (containsCollections(args)) {
            throw new TypeError("Scalar values expected in function median");
          }
          return _median(args);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/statistics/mad.js
var name248, dependencies249, createMad;
var init_mad2 = __esm({
  "node_modules/mathjs/lib/esm/function/statistics/mad.js"() {
    init_array();
    init_factory();
    init_improveErrorMessage();
    name248 = "mad";
    dependencies249 = ["typed", "abs", "map", "median", "subtract"];
    createMad = /* @__PURE__ */ factory(name248, dependencies249, (_ref) => {
      var {
        typed: typed2,
        abs: abs2,
        map: map3,
        median: median2,
        subtract: subtract2
      } = _ref;
      return typed2(name248, {
        "Array | Matrix": _mad,
        "...": function _(args) {
          return _mad(args);
        }
      });
      function _mad(array) {
        array = flatten(array.valueOf());
        if (array.length === 0) {
          throw new Error("Cannot calculate median absolute deviation (mad) of an empty array");
        }
        try {
          var med = median2(array);
          return median2(map3(array, function(value) {
            return abs2(subtract2(value, med));
          }));
        } catch (err) {
          if (err instanceof TypeError && err.message.indexOf("median") !== -1) {
            throw new TypeError(err.message.replace("median", "mad"));
          } else {
            throw improveErrorMessage(err, "mad");
          }
        }
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/statistics/variance.js
var DEFAULT_NORMALIZATION, name249, dependencies250, createVariance;
var init_variance2 = __esm({
  "node_modules/mathjs/lib/esm/function/statistics/variance.js"() {
    init_collection();
    init_is();
    init_factory();
    init_improveErrorMessage();
    DEFAULT_NORMALIZATION = "unbiased";
    name249 = "variance";
    dependencies250 = ["typed", "add", "subtract", "multiply", "divide", "apply", "isNaN"];
    createVariance = /* @__PURE__ */ factory(name249, dependencies250, (_ref) => {
      var {
        typed: typed2,
        add: add2,
        subtract: subtract2,
        multiply: multiply2,
        divide: divide2,
        apply: apply2,
        isNaN: isNaN3
      } = _ref;
      return typed2(name249, {
        "Array | Matrix": function ArrayMatrix(array) {
          return _var(array, DEFAULT_NORMALIZATION);
        },
        "Array | Matrix, string": _var,
        "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
          return _varDim(array, dim, DEFAULT_NORMALIZATION);
        },
        "Array | Matrix, number | BigNumber, string": _varDim,
        "...": function _(args) {
          return _var(args, DEFAULT_NORMALIZATION);
        }
      });
      function _var(array, normalization) {
        var sum2;
        var num = 0;
        if (array.length === 0) {
          throw new SyntaxError("Function variance requires one or more parameters (0 provided)");
        }
        deepForEach(array, function(value) {
          try {
            sum2 = sum2 === void 0 ? value : add2(sum2, value);
            num++;
          } catch (err) {
            throw improveErrorMessage(err, "variance", value);
          }
        });
        if (num === 0)
          throw new Error("Cannot calculate variance of an empty array");
        var mean2 = divide2(sum2, num);
        sum2 = void 0;
        deepForEach(array, function(value) {
          var diff2 = subtract2(value, mean2);
          sum2 = sum2 === void 0 ? multiply2(diff2, diff2) : add2(sum2, multiply2(diff2, diff2));
        });
        if (isNaN3(sum2)) {
          return sum2;
        }
        switch (normalization) {
          case "uncorrected":
            return divide2(sum2, num);
          case "biased":
            return divide2(sum2, num + 1);
          case "unbiased": {
            var zero = isBigNumber(sum2) ? sum2.mul(0) : 0;
            return num === 1 ? zero : divide2(sum2, num - 1);
          }
          default:
            throw new Error('Unknown normalization "' + normalization + '". Choose "unbiased" (default), "uncorrected", or "biased".');
        }
      }
      function _varDim(array, dim, normalization) {
        try {
          if (array.length === 0) {
            throw new SyntaxError("Function variance requires one or more parameters (0 provided)");
          }
          return apply2(array, dim, (x) => _var(x, normalization));
        } catch (err) {
          throw improveErrorMessage(err, "variance");
        }
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/statistics/quantileSeq.js
var name250, dependencies251, createQuantileSeq;
var init_quantileSeq2 = __esm({
  "node_modules/mathjs/lib/esm/function/statistics/quantileSeq.js"() {
    init_is();
    init_number();
    init_array();
    init_factory();
    name250 = "quantileSeq";
    dependencies251 = ["typed", "add", "multiply", "partitionSelect", "compare"];
    createQuantileSeq = /* @__PURE__ */ factory(name250, dependencies251, (_ref) => {
      var {
        typed: typed2,
        add: add2,
        multiply: multiply2,
        partitionSelect: partitionSelect2,
        compare: compare2
      } = _ref;
      function quantileSeq2(data, probOrN, sorted) {
        var probArr, dataArr, one;
        if (arguments.length < 2 || arguments.length > 3) {
          throw new SyntaxError("Function quantileSeq requires two or three parameters");
        }
        if (isCollection(data)) {
          sorted = sorted || false;
          if (typeof sorted === "boolean") {
            dataArr = data.valueOf();
            if (isNumber2(probOrN)) {
              if (probOrN < 0) {
                throw new Error("N/prob must be non-negative");
              }
              if (probOrN <= 1) {
                return _quantileSeq(dataArr, probOrN, sorted);
              }
              if (probOrN > 1) {
                if (!isInteger(probOrN)) {
                  throw new Error("N must be a positive integer");
                }
                var nPlusOne = probOrN + 1;
                probArr = new Array(probOrN);
                for (var i2 = 0; i2 < probOrN; ) {
                  probArr[i2] = _quantileSeq(dataArr, ++i2 / nPlusOne, sorted);
                }
                return probArr;
              }
            }
            if (isBigNumber(probOrN)) {
              var BigNumber2 = probOrN.constructor;
              if (probOrN.isNegative()) {
                throw new Error("N/prob must be non-negative");
              }
              one = new BigNumber2(1);
              if (probOrN.lte(one)) {
                return new BigNumber2(_quantileSeq(dataArr, probOrN, sorted));
              }
              if (probOrN.gt(one)) {
                if (!probOrN.isInteger()) {
                  throw new Error("N must be a positive integer");
                }
                var intN = probOrN.toNumber();
                if (intN > 4294967295) {
                  throw new Error("N must be less than or equal to 2^32-1, as that is the maximum length of an Array");
                }
                var _nPlusOne = new BigNumber2(intN + 1);
                probArr = new Array(intN);
                for (var _i = 0; _i < intN; ) {
                  probArr[_i] = new BigNumber2(_quantileSeq(dataArr, new BigNumber2(++_i).div(_nPlusOne), sorted));
                }
                return probArr;
              }
            }
            if (Array.isArray(probOrN)) {
              probArr = new Array(probOrN.length);
              for (var _i2 = 0; _i2 < probArr.length; ++_i2) {
                var currProb = probOrN[_i2];
                if (isNumber2(currProb)) {
                  if (currProb < 0 || currProb > 1) {
                    throw new Error("Probability must be between 0 and 1, inclusive");
                  }
                } else if (isBigNumber(currProb)) {
                  one = new currProb.constructor(1);
                  if (currProb.isNegative() || currProb.gt(one)) {
                    throw new Error("Probability must be between 0 and 1, inclusive");
                  }
                } else {
                  throw new TypeError("Unexpected type of argument in function quantileSeq");
                }
                probArr[_i2] = _quantileSeq(dataArr, currProb, sorted);
              }
              return probArr;
            }
            throw new TypeError("Unexpected type of argument in function quantileSeq");
          }
          throw new TypeError("Unexpected type of argument in function quantileSeq");
        }
        throw new TypeError("Unexpected type of argument in function quantileSeq");
      }
      function _quantileSeq(array, prob, sorted) {
        var flat = flatten(array);
        var len = flat.length;
        if (len === 0) {
          throw new Error("Cannot calculate quantile of an empty sequence");
        }
        if (isNumber2(prob)) {
          var _index = prob * (len - 1);
          var _fracPart = _index % 1;
          if (_fracPart === 0) {
            var value = sorted ? flat[_index] : partitionSelect2(flat, _index);
            validate2(value);
            return value;
          }
          var _integerPart = Math.floor(_index);
          var _left;
          var _right;
          if (sorted) {
            _left = flat[_integerPart];
            _right = flat[_integerPart + 1];
          } else {
            _right = partitionSelect2(flat, _integerPart + 1);
            _left = flat[_integerPart];
            for (var i2 = 0; i2 < _integerPart; ++i2) {
              if (compare2(flat[i2], _left) > 0) {
                _left = flat[i2];
              }
            }
          }
          validate2(_left);
          validate2(_right);
          return add2(multiply2(_left, 1 - _fracPart), multiply2(_right, _fracPart));
        }
        var index2 = prob.times(len - 1);
        if (index2.isInteger()) {
          index2 = index2.toNumber();
          var _value = sorted ? flat[index2] : partitionSelect2(flat, index2);
          validate2(_value);
          return _value;
        }
        var integerPart = index2.floor();
        var fracPart = index2.minus(integerPart);
        var integerPartNumber = integerPart.toNumber();
        var left;
        var right;
        if (sorted) {
          left = flat[integerPartNumber];
          right = flat[integerPartNumber + 1];
        } else {
          right = partitionSelect2(flat, integerPartNumber + 1);
          left = flat[integerPartNumber];
          for (var _i3 = 0; _i3 < integerPartNumber; ++_i3) {
            if (compare2(flat[_i3], left) > 0) {
              left = flat[_i3];
            }
          }
        }
        validate2(left);
        validate2(right);
        var one = new fracPart.constructor(1);
        return add2(multiply2(left, one.minus(fracPart)), multiply2(right, fracPart));
      }
      var validate2 = typed2({
        "number | BigNumber | Unit": function numberBigNumberUnit(x) {
          return x;
        }
      });
      return quantileSeq2;
    });
  }
});

// node_modules/mathjs/lib/esm/function/statistics/std.js
var name251, dependencies252, createStd;
var init_std2 = __esm({
  "node_modules/mathjs/lib/esm/function/statistics/std.js"() {
    init_factory();
    name251 = "std";
    dependencies252 = ["typed", "sqrt", "variance"];
    createStd = /* @__PURE__ */ factory(name251, dependencies252, (_ref) => {
      var {
        typed: typed2,
        sqrt: sqrt2,
        variance: variance2
      } = _ref;
      return typed2(name251, {
        "Array | Matrix": _std,
        "Array | Matrix, string": _std,
        "Array | Matrix, number | BigNumber": _std,
        "Array | Matrix, number | BigNumber, string": _std,
        "...": function _(args) {
          return _std(args);
        }
      });
      function _std(array, normalization) {
        if (array.length === 0) {
          throw new SyntaxError("Function std requires one or more parameters (0 provided)");
        }
        try {
          return sqrt2(variance2.apply(null, arguments));
        } catch (err) {
          if (err instanceof TypeError && err.message.indexOf(" variance") !== -1) {
            throw new TypeError(err.message.replace(" variance", " std"));
          } else {
            throw err;
          }
        }
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/probability/combinations.js
function isPositiveInteger(n) {
  return n.isInteger() && n.gte(0);
}
var name252, dependencies253, createCombinations;
var init_combinations3 = __esm({
  "node_modules/mathjs/lib/esm/function/probability/combinations.js"() {
    init_factory();
    init_combinations();
    name252 = "combinations";
    dependencies253 = ["typed"];
    createCombinations = /* @__PURE__ */ factory(name252, dependencies253, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2(name252, {
        "number, number": combinationsNumber,
        "BigNumber, BigNumber": function BigNumberBigNumber(n, k) {
          var BigNumber2 = n.constructor;
          var result, i2;
          var nMinusk = n.minus(k);
          var one = new BigNumber2(1);
          if (!isPositiveInteger(n) || !isPositiveInteger(k)) {
            throw new TypeError("Positive integer value expected in function combinations");
          }
          if (k.gt(n)) {
            throw new TypeError("k must be less than n in function combinations");
          }
          result = one;
          if (k.lt(nMinusk)) {
            for (i2 = one; i2.lte(nMinusk); i2 = i2.plus(one)) {
              result = result.times(k.plus(i2)).dividedBy(i2);
            }
          } else {
            for (i2 = one; i2.lte(k); i2 = i2.plus(one)) {
              result = result.times(nMinusk.plus(i2)).dividedBy(i2);
            }
          }
          return result;
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/probability/combinationsWithRep.js
function isPositiveInteger2(n) {
  return n.isInteger() && n.gte(0);
}
var name253, dependencies254, createCombinationsWithRep;
var init_combinationsWithRep2 = __esm({
  "node_modules/mathjs/lib/esm/function/probability/combinationsWithRep.js"() {
    init_factory();
    init_number();
    init_product();
    name253 = "combinationsWithRep";
    dependencies254 = ["typed"];
    createCombinationsWithRep = /* @__PURE__ */ factory(name253, dependencies254, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      return typed2(name253, {
        "number, number": function numberNumber(n, k) {
          if (!isInteger(n) || n < 0) {
            throw new TypeError("Positive integer value expected in function combinationsWithRep");
          }
          if (!isInteger(k) || k < 0) {
            throw new TypeError("Positive integer value expected in function combinationsWithRep");
          }
          if (n < 1) {
            throw new TypeError("k must be less than or equal to n + k - 1");
          }
          if (k < n - 1) {
            var _prodrange = product2(n, n + k - 1);
            return _prodrange / product2(1, k);
          }
          var prodrange = product2(k + 1, n + k - 1);
          return prodrange / product2(1, n - 1);
        },
        "BigNumber, BigNumber": function BigNumberBigNumber(n, k) {
          var BigNumber2 = n.constructor;
          var result, i2;
          var one = new BigNumber2(1);
          var nMinusOne = n.minus(one);
          if (!isPositiveInteger2(n) || !isPositiveInteger2(k)) {
            throw new TypeError("Positive integer value expected in function combinationsWithRep");
          }
          if (n.lt(one)) {
            throw new TypeError("k must be less than or equal to n + k - 1 in function combinationsWithRep");
          }
          result = one;
          if (k.lt(nMinusOne)) {
            for (i2 = one; i2.lte(nMinusOne); i2 = i2.plus(one)) {
              result = result.times(k.plus(i2)).dividedBy(i2);
            }
          } else {
            for (i2 = one; i2.lte(k); i2 = i2.plus(one)) {
              result = result.times(nMinusOne.plus(i2)).dividedBy(i2);
            }
          }
          return result;
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/probability/gamma.js
var name254, dependencies255, createGamma;
var init_gamma2 = __esm({
  "node_modules/mathjs/lib/esm/function/probability/gamma.js"() {
    init_collection();
    init_factory();
    init_number2();
    name254 = "gamma";
    dependencies255 = ["typed", "config", "multiplyScalar", "pow", "BigNumber", "Complex"];
    createGamma = /* @__PURE__ */ factory(name254, dependencies255, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        multiplyScalar: multiplyScalar2,
        pow: pow2,
        BigNumber: _BigNumber,
        Complex: _Complex
      } = _ref;
      return typed2(name254, {
        number: gammaNumber,
        Complex: function Complex3(n) {
          if (n.im === 0) {
            return this(n.re);
          }
          if (n.re < 0.5) {
            var _t = new _Complex(1 - n.re, -n.im);
            var r = new _Complex(Math.PI * n.re, Math.PI * n.im);
            return new _Complex(Math.PI).div(r.sin()).div(this(_t));
          }
          n = new _Complex(n.re - 1, n.im);
          var x = new _Complex(gammaP[0], 0);
          for (var i2 = 1; i2 < gammaP.length; ++i2) {
            var gammaPval = new _Complex(gammaP[i2], 0);
            x = x.add(gammaPval.div(n.add(i2)));
          }
          var t = new _Complex(n.re + gammaG + 0.5, n.im);
          var twoPiSqrt = Math.sqrt(2 * Math.PI);
          var tpow = t.pow(n.add(0.5));
          var expt = t.neg().exp();
          return x.mul(twoPiSqrt).mul(tpow).mul(expt);
        },
        BigNumber: function BigNumber2(n) {
          if (n.isInteger()) {
            return n.isNegative() || n.isZero() ? new _BigNumber(Infinity) : bigFactorial(n.minus(1));
          }
          if (!n.isFinite()) {
            return new _BigNumber(n.isNegative() ? NaN : Infinity);
          }
          throw new Error("Integer BigNumber expected");
        },
        "Array | Matrix": function ArrayMatrix(n) {
          return deepMap(n, this);
        }
      });
      function bigFactorial(n) {
        if (n < 8) {
          return new _BigNumber([1, 1, 2, 6, 24, 120, 720, 5040][n]);
        }
        var precision = config3.precision + (Math.log(n.toNumber()) | 0);
        var Big = _BigNumber.clone({
          precision
        });
        if (n % 2 === 1) {
          return n.times(bigFactorial(new _BigNumber(n - 1)));
        }
        var p = n;
        var prod2 = new Big(n);
        var sum2 = n.toNumber();
        while (p > 2) {
          p -= 2;
          sum2 += p;
          prod2 = prod2.times(sum2);
        }
        return new _BigNumber(prod2.toPrecision(_BigNumber.precision));
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/probability/lgamma.js
var name255, dependencies256, createLgamma;
var init_lgamma2 = __esm({
  "node_modules/mathjs/lib/esm/function/probability/lgamma.js"() {
    init_number2();
    init_factory();
    init_number();
    name255 = "lgamma";
    dependencies256 = ["Complex", "typed"];
    createLgamma = /* @__PURE__ */ factory(name255, dependencies256, (_ref) => {
      var {
        Complex: _Complex,
        typed: typed2
      } = _ref;
      var SMALL_RE = 7;
      var SMALL_IM = 7;
      var coeffs = [-0.029550653594771242, 0.00641025641025641, -0.0019175269175269176, 8417508417508417e-19, -5952380952380953e-19, 7936507936507937e-19, -0.002777777777777778, 0.08333333333333333];
      return typed2(name255, {
        number: lgammaNumber,
        Complex: function Complex3(n) {
          var TWOPI = 6.283185307179586;
          var LOGPI = 1.1447298858494002;
          var REFLECTION = 0.1;
          if (n.isNaN()) {
            return new _Complex(NaN, NaN);
          } else if (n.im === 0) {
            return new _Complex(lgammaNumber(n.re), 0);
          } else if (n.re >= SMALL_RE || Math.abs(n.im) >= SMALL_IM) {
            return lgammaStirling(n);
          } else if (n.re <= REFLECTION) {
            var tmp = copysign(TWOPI, n.im) * Math.floor(0.5 * n.re + 0.25);
            var a = n.mul(Math.PI).sin().log();
            var b = this(new _Complex(1 - n.re, -n.im));
            return new _Complex(LOGPI, tmp).sub(a).sub(b);
          } else if (n.im >= 0) {
            return lgammaRecurrence(n);
          } else {
            return lgammaRecurrence(n.conjugate()).conjugate();
          }
        },
        BigNumber: function BigNumber2() {
          throw new Error("mathjs doesn't yet provide an implementation of the algorithm lgamma for BigNumber");
        }
      });
      function lgammaStirling(z) {
        var leftPart = z.sub(0.5).mul(z.log()).sub(z).add(lnSqrt2PI);
        var rz = new _Complex(1, 0).div(z);
        var rzz = rz.div(z);
        var a = coeffs[0];
        var b = coeffs[1];
        var r = 2 * rzz.re;
        var s = rzz.re * rzz.re + rzz.im * rzz.im;
        for (var i2 = 2; i2 < 8; i2++) {
          var tmp = b;
          b = -s * a + coeffs[i2];
          a = r * a + tmp;
        }
        var rightPart = rz.mul(rzz.mul(a).add(b));
        return leftPart.add(rightPart);
      }
      function lgammaRecurrence(z) {
        var signflips = 0;
        var sb = 0;
        var shiftprod = z;
        z = z.add(1);
        while (z.re <= SMALL_RE) {
          shiftprod = shiftprod.mul(z);
          var nsb = shiftprod.im < 0 ? 1 : 0;
          if (nsb !== 0 && sb === 0)
            signflips++;
          sb = nsb;
          z = z.add(1);
        }
        return lgammaStirling(z).sub(shiftprod.log()).sub(new _Complex(0, signflips * 2 * Math.PI * 1));
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/probability/factorial.js
var name256, dependencies257, createFactorial;
var init_factorial2 = __esm({
  "node_modules/mathjs/lib/esm/function/probability/factorial.js"() {
    init_collection();
    init_factory();
    name256 = "factorial";
    dependencies257 = ["typed", "gamma"];
    createFactorial = /* @__PURE__ */ factory(name256, dependencies257, (_ref) => {
      var {
        typed: typed2,
        gamma: gamma2
      } = _ref;
      return typed2(name256, {
        number: function number2(n) {
          if (n < 0) {
            throw new Error("Value must be non-negative");
          }
          return gamma2(n + 1);
        },
        BigNumber: function BigNumber2(n) {
          if (n.isNegative()) {
            throw new Error("Value must be non-negative");
          }
          return gamma2(n.plus(1));
        },
        "Array | Matrix": function ArrayMatrix(n) {
          return deepMap(n, this);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/probability/kldivergence.js
var name257, dependencies258, createKldivergence;
var init_kldivergence2 = __esm({
  "node_modules/mathjs/lib/esm/function/probability/kldivergence.js"() {
    init_factory();
    name257 = "kldivergence";
    dependencies258 = ["typed", "matrix", "divide", "sum", "multiply", "dotDivide", "log", "isNumeric"];
    createKldivergence = /* @__PURE__ */ factory(name257, dependencies258, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        divide: divide2,
        sum: sum2,
        multiply: multiply2,
        dotDivide: dotDivide2,
        log: log3,
        isNumeric: isNumeric2
      } = _ref;
      return typed2(name257, {
        "Array, Array": function ArrayArray(q, p) {
          return _kldiv(matrix2(q), matrix2(p));
        },
        "Matrix, Array": function MatrixArray(q, p) {
          return _kldiv(q, matrix2(p));
        },
        "Array, Matrix": function ArrayMatrix(q, p) {
          return _kldiv(matrix2(q), p);
        },
        "Matrix, Matrix": function MatrixMatrix(q, p) {
          return _kldiv(q, p);
        }
      });
      function _kldiv(q, p) {
        var plength = p.size().length;
        var qlength = q.size().length;
        if (plength > 1) {
          throw new Error("first object must be one dimensional");
        }
        if (qlength > 1) {
          throw new Error("second object must be one dimensional");
        }
        if (plength !== qlength) {
          throw new Error("Length of two vectors must be equal");
        }
        var sumq = sum2(q);
        if (sumq === 0) {
          throw new Error("Sum of elements in first object must be non zero");
        }
        var sump = sum2(p);
        if (sump === 0) {
          throw new Error("Sum of elements in second object must be non zero");
        }
        var qnorm = divide2(q, sum2(q));
        var pnorm = divide2(p, sum2(p));
        var result = sum2(multiply2(qnorm, log3(dotDivide2(qnorm, pnorm))));
        if (isNumeric2(result)) {
          return result;
        } else {
          return Number.NaN;
        }
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/probability/multinomial.js
var name258, dependencies259, createMultinomial;
var init_multinomial2 = __esm({
  "node_modules/mathjs/lib/esm/function/probability/multinomial.js"() {
    init_collection();
    init_factory();
    name258 = "multinomial";
    dependencies259 = ["typed", "add", "divide", "multiply", "factorial", "isInteger", "isPositive"];
    createMultinomial = /* @__PURE__ */ factory(name258, dependencies259, (_ref) => {
      var {
        typed: typed2,
        add: add2,
        divide: divide2,
        multiply: multiply2,
        factorial: factorial2,
        isInteger: isInteger3,
        isPositive: isPositive2
      } = _ref;
      return typed2(name258, {
        "Array | Matrix": function ArrayMatrix(a) {
          var sum2 = 0;
          var denom = 1;
          deepForEach(a, function(ai) {
            if (!isInteger3(ai) || !isPositive2(ai)) {
              throw new TypeError("Positive integer value expected in function multinomial");
            }
            sum2 = add2(sum2, ai);
            denom = multiply2(denom, factorial2(ai));
          });
          return divide2(factorial2(sum2), denom);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/probability/permutations.js
function isPositiveInteger3(n) {
  return n.isInteger() && n.gte(0);
}
var name259, dependencies260, createPermutations;
var init_permutations2 = __esm({
  "node_modules/mathjs/lib/esm/function/probability/permutations.js"() {
    init_number();
    init_product();
    init_factory();
    name259 = "permutations";
    dependencies260 = ["typed", "factorial"];
    createPermutations = /* @__PURE__ */ factory(name259, dependencies260, (_ref) => {
      var {
        typed: typed2,
        factorial: factorial2
      } = _ref;
      return typed2(name259, {
        "number | BigNumber": factorial2,
        "number, number": function numberNumber(n, k) {
          if (!isInteger(n) || n < 0) {
            throw new TypeError("Positive integer value expected in function permutations");
          }
          if (!isInteger(k) || k < 0) {
            throw new TypeError("Positive integer value expected in function permutations");
          }
          if (k > n) {
            throw new TypeError("second argument k must be less than or equal to first argument n");
          }
          return product2(n - k + 1, n);
        },
        "BigNumber, BigNumber": function BigNumberBigNumber(n, k) {
          var result, i2;
          if (!isPositiveInteger3(n) || !isPositiveInteger3(k)) {
            throw new TypeError("Positive integer value expected in function permutations");
          }
          if (k.gt(n)) {
            throw new TypeError("second argument k must be less than or equal to first argument n");
          }
          var one = n.mul(0).add(1);
          result = one;
          for (i2 = n.minus(k).plus(1); i2.lte(n); i2 = i2.plus(1)) {
            result = result.times(i2);
          }
          return result;
        }
      });
    });
  }
});

// node_modules/seedrandom/lib/alea.js
var require_alea = __commonJS({
  "node_modules/seedrandom/lib/alea.js"(exports, module) {
    (function(global2, module2, define2) {
      function Alea(seed) {
        var me = this, mash = Mash();
        me.next = function() {
          var t = 2091639 * me.s0 + me.c * 23283064365386963e-26;
          me.s0 = me.s1;
          me.s1 = me.s2;
          return me.s2 = t - (me.c = t | 0);
        };
        me.c = 1;
        me.s0 = mash(" ");
        me.s1 = mash(" ");
        me.s2 = mash(" ");
        me.s0 -= mash(seed);
        if (me.s0 < 0) {
          me.s0 += 1;
        }
        me.s1 -= mash(seed);
        if (me.s1 < 0) {
          me.s1 += 1;
        }
        me.s2 -= mash(seed);
        if (me.s2 < 0) {
          me.s2 += 1;
        }
        mash = null;
      }
      function copy(f, t) {
        t.c = f.c;
        t.s0 = f.s0;
        t.s1 = f.s1;
        t.s2 = f.s2;
        return t;
      }
      function impl(seed, opts) {
        var xg = new Alea(seed), state = opts && opts.state, prng = xg.next;
        prng.int32 = function() {
          return xg.next() * 4294967296 | 0;
        };
        prng.double = function() {
          return prng() + (prng() * 2097152 | 0) * 11102230246251565e-32;
        };
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      function Mash() {
        var n = 4022871197;
        var mash = function(data) {
          data = String(data);
          for (var i2 = 0; i2 < data.length; i2++) {
            n += data.charCodeAt(i2);
            var h = 0.02519603282416938 * n;
            n = h >>> 0;
            h -= n;
            h *= n;
            n = h >>> 0;
            h -= n;
            n += h * 4294967296;
          }
          return (n >>> 0) * 23283064365386963e-26;
        };
        return mash;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.alea = impl;
      }
    })(
      exports,
      typeof module == "object" && module,
      typeof define == "function" && define
    );
  }
});

// node_modules/seedrandom/lib/xor128.js
var require_xor128 = __commonJS({
  "node_modules/seedrandom/lib/xor128.js"(exports, module) {
    (function(global2, module2, define2) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.x = 0;
        me.y = 0;
        me.z = 0;
        me.w = 0;
        me.next = function() {
          var t = me.x ^ me.x << 11;
          me.x = me.y;
          me.y = me.z;
          me.z = me.w;
          return me.w ^= me.w >>> 19 ^ t ^ t >>> 8;
        };
        if (seed === (seed | 0)) {
          me.x = seed;
        } else {
          strseed += seed;
        }
        for (var k = 0; k < strseed.length + 64; k++) {
          me.x ^= strseed.charCodeAt(k) | 0;
          me.next();
        }
      }
      function copy(f, t) {
        t.x = f.x;
        t.y = f.y;
        t.z = f.z;
        t.w = f.w;
        return t;
      }
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xor128 = impl;
      }
    })(
      exports,
      typeof module == "object" && module,
      typeof define == "function" && define
    );
  }
});

// node_modules/seedrandom/lib/xorwow.js
var require_xorwow = __commonJS({
  "node_modules/seedrandom/lib/xorwow.js"(exports, module) {
    (function(global2, module2, define2) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.next = function() {
          var t = me.x ^ me.x >>> 2;
          me.x = me.y;
          me.y = me.z;
          me.z = me.w;
          me.w = me.v;
          return (me.d = me.d + 362437 | 0) + (me.v = me.v ^ me.v << 4 ^ (t ^ t << 1)) | 0;
        };
        me.x = 0;
        me.y = 0;
        me.z = 0;
        me.w = 0;
        me.v = 0;
        if (seed === (seed | 0)) {
          me.x = seed;
        } else {
          strseed += seed;
        }
        for (var k = 0; k < strseed.length + 64; k++) {
          me.x ^= strseed.charCodeAt(k) | 0;
          if (k == strseed.length) {
            me.d = me.x << 10 ^ me.x >>> 4;
          }
          me.next();
        }
      }
      function copy(f, t) {
        t.x = f.x;
        t.y = f.y;
        t.z = f.z;
        t.w = f.w;
        t.v = f.v;
        t.d = f.d;
        return t;
      }
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xorwow = impl;
      }
    })(
      exports,
      typeof module == "object" && module,
      typeof define == "function" && define
    );
  }
});

// node_modules/seedrandom/lib/xorshift7.js
var require_xorshift7 = __commonJS({
  "node_modules/seedrandom/lib/xorshift7.js"(exports, module) {
    (function(global2, module2, define2) {
      function XorGen(seed) {
        var me = this;
        me.next = function() {
          var X = me.x, i2 = me.i, t, v, w;
          t = X[i2];
          t ^= t >>> 7;
          v = t ^ t << 24;
          t = X[i2 + 1 & 7];
          v ^= t ^ t >>> 10;
          t = X[i2 + 3 & 7];
          v ^= t ^ t >>> 3;
          t = X[i2 + 4 & 7];
          v ^= t ^ t << 7;
          t = X[i2 + 7 & 7];
          t = t ^ t << 13;
          v ^= t ^ t << 9;
          X[i2] = v;
          me.i = i2 + 1 & 7;
          return v;
        };
        function init(me2, seed2) {
          var j, w, X = [];
          if (seed2 === (seed2 | 0)) {
            w = X[0] = seed2;
          } else {
            seed2 = "" + seed2;
            for (j = 0; j < seed2.length; ++j) {
              X[j & 7] = X[j & 7] << 15 ^ seed2.charCodeAt(j) + X[j + 1 & 7] << 13;
            }
          }
          while (X.length < 8)
            X.push(0);
          for (j = 0; j < 8 && X[j] === 0; ++j)
            ;
          if (j == 8)
            w = X[7] = -1;
          else
            w = X[j];
          me2.x = X;
          me2.i = 0;
          for (j = 256; j > 0; --j) {
            me2.next();
          }
        }
        init(me, seed);
      }
      function copy(f, t) {
        t.x = f.x.slice();
        t.i = f.i;
        return t;
      }
      function impl(seed, opts) {
        if (seed == null)
          seed = +new Date();
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (state.x)
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xorshift7 = impl;
      }
    })(
      exports,
      typeof module == "object" && module,
      typeof define == "function" && define
    );
  }
});

// node_modules/seedrandom/lib/xor4096.js
var require_xor4096 = __commonJS({
  "node_modules/seedrandom/lib/xor4096.js"(exports, module) {
    (function(global2, module2, define2) {
      function XorGen(seed) {
        var me = this;
        me.next = function() {
          var w = me.w, X = me.X, i2 = me.i, t, v;
          me.w = w = w + 1640531527 | 0;
          v = X[i2 + 34 & 127];
          t = X[i2 = i2 + 1 & 127];
          v ^= v << 13;
          t ^= t << 17;
          v ^= v >>> 15;
          t ^= t >>> 12;
          v = X[i2] = v ^ t;
          me.i = i2;
          return v + (w ^ w >>> 16) | 0;
        };
        function init(me2, seed2) {
          var t, v, i2, j, w, X = [], limit = 128;
          if (seed2 === (seed2 | 0)) {
            v = seed2;
            seed2 = null;
          } else {
            seed2 = seed2 + "\0";
            v = 0;
            limit = Math.max(limit, seed2.length);
          }
          for (i2 = 0, j = -32; j < limit; ++j) {
            if (seed2)
              v ^= seed2.charCodeAt((j + 32) % seed2.length);
            if (j === 0)
              w = v;
            v ^= v << 10;
            v ^= v >>> 15;
            v ^= v << 4;
            v ^= v >>> 13;
            if (j >= 0) {
              w = w + 1640531527 | 0;
              t = X[j & 127] ^= v + w;
              i2 = 0 == t ? i2 + 1 : 0;
            }
          }
          if (i2 >= 128) {
            X[(seed2 && seed2.length || 0) & 127] = -1;
          }
          i2 = 127;
          for (j = 4 * 128; j > 0; --j) {
            v = X[i2 + 34 & 127];
            t = X[i2 = i2 + 1 & 127];
            v ^= v << 13;
            t ^= t << 17;
            v ^= v >>> 15;
            t ^= t >>> 12;
            X[i2] = v ^ t;
          }
          me2.w = w;
          me2.X = X;
          me2.i = i2;
        }
        init(me, seed);
      }
      function copy(f, t) {
        t.i = f.i;
        t.w = f.w;
        t.X = f.X.slice();
        return t;
      }
      ;
      function impl(seed, opts) {
        if (seed == null)
          seed = +new Date();
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (state.X)
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xor4096 = impl;
      }
    })(
      exports,
      typeof module == "object" && module,
      typeof define == "function" && define
    );
  }
});

// node_modules/seedrandom/lib/tychei.js
var require_tychei = __commonJS({
  "node_modules/seedrandom/lib/tychei.js"(exports, module) {
    (function(global2, module2, define2) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.next = function() {
          var b = me.b, c = me.c, d = me.d, a = me.a;
          b = b << 25 ^ b >>> 7 ^ c;
          c = c - d | 0;
          d = d << 24 ^ d >>> 8 ^ a;
          a = a - b | 0;
          me.b = b = b << 20 ^ b >>> 12 ^ c;
          me.c = c = c - d | 0;
          me.d = d << 16 ^ c >>> 16 ^ a;
          return me.a = a - b | 0;
        };
        me.a = 0;
        me.b = 0;
        me.c = 2654435769 | 0;
        me.d = 1367130551;
        if (seed === Math.floor(seed)) {
          me.a = seed / 4294967296 | 0;
          me.b = seed | 0;
        } else {
          strseed += seed;
        }
        for (var k = 0; k < strseed.length + 20; k++) {
          me.b ^= strseed.charCodeAt(k) | 0;
          me.next();
        }
      }
      function copy(f, t) {
        t.a = f.a;
        t.b = f.b;
        t.c = f.c;
        t.d = f.d;
        return t;
      }
      ;
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.tychei = impl;
      }
    })(
      exports,
      typeof module == "object" && module,
      typeof define == "function" && define
    );
  }
});

// node_modules/seedrandom/seedrandom.js
var require_seedrandom = __commonJS({
  "node_modules/seedrandom/seedrandom.js"(exports, module) {
    (function(global2, pool, math2) {
      var width = 256, chunks = 6, digits2 = 52, rngname = "random", startdenom = math2.pow(width, chunks), significance = math2.pow(2, digits2), overflow = significance * 2, mask = width - 1, nodecrypto;
      function seedrandom2(seed, options, callback) {
        var key = [];
        options = options == true ? { entropy: true } : options || {};
        var shortseed = mixkey(flatten4(
          options.entropy ? [seed, tostring(pool)] : seed == null ? autoseed() : seed,
          3
        ), key);
        var arc4 = new ARC4(key);
        var prng = function() {
          var n = arc4.g(chunks), d = startdenom, x = 0;
          while (n < significance) {
            n = (n + x) * width;
            d *= width;
            x = arc4.g(1);
          }
          while (n >= overflow) {
            n /= 2;
            d /= 2;
            x >>>= 1;
          }
          return (n + x) / d;
        };
        prng.int32 = function() {
          return arc4.g(4) | 0;
        };
        prng.quick = function() {
          return arc4.g(4) / 4294967296;
        };
        prng.double = prng;
        mixkey(tostring(arc4.S), pool);
        return (options.pass || callback || function(prng2, seed2, is_math_call, state) {
          if (state) {
            if (state.S) {
              copy(state, arc4);
            }
            prng2.state = function() {
              return copy(arc4, {});
            };
          }
          if (is_math_call) {
            math2[rngname] = prng2;
            return seed2;
          } else
            return prng2;
        })(
          prng,
          shortseed,
          "global" in options ? options.global : this == math2,
          options.state
        );
      }
      function ARC4(key) {
        var t, keylen = key.length, me = this, i2 = 0, j = me.i = me.j = 0, s = me.S = [];
        if (!keylen) {
          key = [keylen++];
        }
        while (i2 < width) {
          s[i2] = i2++;
        }
        for (i2 = 0; i2 < width; i2++) {
          s[i2] = s[j = mask & j + key[i2 % keylen] + (t = s[i2])];
          s[j] = t;
        }
        (me.g = function(count2) {
          var t2, r = 0, i3 = me.i, j2 = me.j, s2 = me.S;
          while (count2--) {
            t2 = s2[i3 = mask & i3 + 1];
            r = r * width + s2[mask & (s2[i3] = s2[j2 = mask & j2 + t2]) + (s2[j2] = t2)];
          }
          me.i = i3;
          me.j = j2;
          return r;
        })(width);
      }
      function copy(f, t) {
        t.i = f.i;
        t.j = f.j;
        t.S = f.S.slice();
        return t;
      }
      ;
      function flatten4(obj, depth) {
        var result = [], typ = typeof obj, prop;
        if (depth && typ == "object") {
          for (prop in obj) {
            try {
              result.push(flatten4(obj[prop], depth - 1));
            } catch (e3) {
            }
          }
        }
        return result.length ? result : typ == "string" ? obj : obj + "\0";
      }
      function mixkey(seed, key) {
        var stringseed = seed + "", smear, j = 0;
        while (j < stringseed.length) {
          key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
        }
        return tostring(key);
      }
      function autoseed() {
        try {
          var out;
          if (nodecrypto && (out = nodecrypto.randomBytes)) {
            out = out(width);
          } else {
            out = new Uint8Array(width);
            (global2.crypto || global2.msCrypto).getRandomValues(out);
          }
          return tostring(out);
        } catch (e3) {
          var browser = global2.navigator, plugins = browser && browser.plugins;
          return [+new Date(), global2, plugins, global2.screen, tostring(pool)];
        }
      }
      function tostring(a) {
        return String.fromCharCode.apply(0, a);
      }
      mixkey(math2.random(), pool);
      if (typeof module == "object" && module.exports) {
        module.exports = seedrandom2;
        try {
          nodecrypto = __require("crypto");
        } catch (ex) {
        }
      } else if (typeof define == "function" && define.amd) {
        define(function() {
          return seedrandom2;
        });
      } else {
        math2["seed" + rngname] = seedrandom2;
      }
    })(
      typeof self !== "undefined" ? self : exports,
      [],
      Math
    );
  }
});

// node_modules/seedrandom/index.js
var require_seedrandom2 = __commonJS({
  "node_modules/seedrandom/index.js"(exports, module) {
    var alea2 = require_alea();
    var xor128 = require_xor128();
    var xorwow = require_xorwow();
    var xorshift7 = require_xorshift7();
    var xor4096 = require_xor4096();
    var tychei = require_tychei();
    var sr = require_seedrandom();
    sr.alea = alea2;
    sr.xor128 = xor128;
    sr.xorwow = xorwow;
    sr.xorshift7 = xorshift7;
    sr.xor4096 = xor4096;
    sr.tychei = tychei;
    module.exports = sr;
  }
});

// node_modules/mathjs/lib/esm/function/probability/util/seededRNG.js
function createRng(randomSeed) {
  var random2;
  function setSeed(seed) {
    random2 = seed === null ? singletonRandom : (0, import_seedrandom.default)(String(seed));
  }
  setSeed(randomSeed);
  function rng() {
    return random2();
  }
  return rng;
}
var import_seedrandom, singletonRandom;
var init_seededRNG = __esm({
  "node_modules/mathjs/lib/esm/function/probability/util/seededRNG.js"() {
    import_seedrandom = __toESM(require_seedrandom2(), 1);
    singletonRandom = /* @__PURE__ */ (0, import_seedrandom.default)(Date.now());
  }
});

// node_modules/mathjs/lib/esm/function/probability/pickRandom.js
var name260, dependencies261, createPickRandom;
var init_pickRandom2 = __esm({
  "node_modules/mathjs/lib/esm/function/probability/pickRandom.js"() {
    init_array();
    init_factory();
    init_is();
    init_seededRNG();
    name260 = "pickRandom";
    dependencies261 = ["typed", "config", "?on"];
    createPickRandom = /* @__PURE__ */ factory(name260, dependencies261, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        on
      } = _ref;
      var rng = createRng(config3.randomSeed);
      if (on) {
        on("config", function(curr, prev) {
          if (curr.randomSeed !== prev.randomSeed) {
            rng = createRng(curr.randomSeed);
          }
        });
      }
      return typed2(name260, {
        "Array | Matrix": function ArrayMatrix(possibles) {
          return _pickRandom(possibles, {});
        },
        "Array | Matrix, Object": function ArrayMatrixObject(possibles, options) {
          return _pickRandom(possibles, options);
        },
        "Array | Matrix, number": function ArrayMatrixNumber(possibles, number2) {
          return _pickRandom(possibles, {
            number: number2
          });
        },
        "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(possibles, weights) {
          return _pickRandom(possibles, {
            weights
          });
        },
        "Array | Matrix, Array | Matrix, number": function ArrayMatrixArrayMatrixNumber(possibles, weights, number2) {
          return _pickRandom(possibles, {
            number: number2,
            weights
          });
        },
        "Array | Matrix, number, Array | Matrix": function ArrayMatrixNumberArrayMatrix(possibles, number2, weights) {
          return _pickRandom(possibles, {
            number: number2,
            weights
          });
        }
      });
      function _pickRandom(possibles, _ref2) {
        var {
          number: number2,
          weights,
          elementWise = true
        } = _ref2;
        var single = typeof number2 === "undefined";
        if (single) {
          number2 = 1;
        }
        var createMatrix2 = isMatrix(possibles) ? possibles.create : isMatrix(weights) ? weights.create : null;
        possibles = possibles.valueOf();
        if (weights) {
          weights = weights.valueOf();
        }
        if (elementWise === true) {
          possibles = flatten(possibles);
          weights = flatten(weights);
        }
        var totalWeights = 0;
        if (typeof weights !== "undefined") {
          if (weights.length !== possibles.length) {
            throw new Error("Weights must have the same length as possibles");
          }
          for (var i2 = 0, len = weights.length; i2 < len; i2++) {
            if (!isNumber2(weights[i2]) || weights[i2] < 0) {
              throw new Error("Weights must be an array of positive numbers");
            }
            totalWeights += weights[i2];
          }
        }
        var length = possibles.length;
        var result = [];
        var pick;
        while (result.length < number2) {
          if (typeof weights === "undefined") {
            pick = possibles[Math.floor(rng() * length)];
          } else {
            var randKey = rng() * totalWeights;
            for (var _i = 0, _len = possibles.length; _i < _len; _i++) {
              randKey -= weights[_i];
              if (randKey < 0) {
                pick = possibles[_i];
                break;
              }
            }
          }
          result.push(pick);
        }
        return single ? result[0] : createMatrix2 ? createMatrix2(result) : result;
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/probability/util/randomMatrix.js
function randomMatrix(size2, random2) {
  var data = [];
  size2 = size2.slice(0);
  if (size2.length > 1) {
    for (var i2 = 0, length = size2.shift(); i2 < length; i2++) {
      data.push(randomMatrix(size2, random2));
    }
  } else {
    for (var _i = 0, _length = size2.shift(); _i < _length; _i++) {
      data.push(random2());
    }
  }
  return data;
}
var init_randomMatrix = __esm({
  "node_modules/mathjs/lib/esm/function/probability/util/randomMatrix.js"() {
  }
});

// node_modules/mathjs/lib/esm/function/probability/random.js
var name261, dependencies262, createRandom;
var init_random2 = __esm({
  "node_modules/mathjs/lib/esm/function/probability/random.js"() {
    init_factory();
    init_is();
    init_seededRNG();
    init_randomMatrix();
    name261 = "random";
    dependencies262 = ["typed", "config", "?on"];
    createRandom = /* @__PURE__ */ factory(name261, dependencies262, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        on
      } = _ref;
      var rng = createRng(config3.randomSeed);
      if (on) {
        on("config", function(curr, prev) {
          if (curr.randomSeed !== prev.randomSeed) {
            rng = createRng(curr.randomSeed);
          }
        });
      }
      return typed2(name261, {
        "": () => _random(0, 1),
        number: (max2) => _random(0, max2),
        "number, number": (min2, max2) => _random(min2, max2),
        "Array | Matrix": (size2) => _randomMatrix(size2, 0, 1),
        "Array | Matrix, number": (size2, max2) => _randomMatrix(size2, 0, max2),
        "Array | Matrix, number, number": (size2, min2, max2) => _randomMatrix(size2, min2, max2)
      });
      function _randomMatrix(size2, min2, max2) {
        var res = randomMatrix(size2.valueOf(), () => _random(min2, max2));
        return isMatrix(size2) ? size2.create(res) : res;
      }
      function _random(min2, max2) {
        return min2 + rng() * (max2 - min2);
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/probability/randomInt.js
var name262, dependencies263, createRandomInt;
var init_randomInt2 = __esm({
  "node_modules/mathjs/lib/esm/function/probability/randomInt.js"() {
    init_factory();
    init_randomMatrix();
    init_seededRNG();
    init_is();
    name262 = "randomInt";
    dependencies263 = ["typed", "config", "?on"];
    createRandomInt = /* @__PURE__ */ factory(name262, dependencies263, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        on
      } = _ref;
      var rng = createRng(config3.randomSeed);
      if (on) {
        on("config", function(curr, prev) {
          if (curr.randomSeed !== prev.randomSeed) {
            rng = createRng(curr.randomSeed);
          }
        });
      }
      return typed2(name262, {
        "": () => _randomInt(0, 1),
        number: (max2) => _randomInt(0, max2),
        "number, number": (min2, max2) => _randomInt(min2, max2),
        "Array | Matrix": (size2) => _randomIntMatrix(size2, 0, 1),
        "Array | Matrix, number": (size2, max2) => _randomIntMatrix(size2, 0, max2),
        "Array | Matrix, number, number": (size2, min2, max2) => _randomIntMatrix(size2, min2, max2)
      });
      function _randomIntMatrix(size2, min2, max2) {
        var res = randomMatrix(size2.valueOf(), () => _randomInt(min2, max2));
        return isMatrix(size2) ? size2.create(res) : res;
      }
      function _randomInt(min2, max2) {
        return Math.floor(min2 + rng() * (max2 - min2));
      }
    });
  }
});

// node_modules/mathjs/lib/esm/function/combinatorics/stirlingS2.js
var name263, dependencies264, createStirlingS2;
var init_stirlingS22 = __esm({
  "node_modules/mathjs/lib/esm/function/combinatorics/stirlingS2.js"() {
    init_factory();
    init_is();
    name263 = "stirlingS2";
    dependencies264 = ["typed", "addScalar", "subtract", "multiplyScalar", "divideScalar", "pow", "factorial", "combinations", "isNegative", "isInteger", "number", "?bignumber", "larger"];
    createStirlingS2 = /* @__PURE__ */ factory(name263, dependencies264, (_ref) => {
      var {
        typed: typed2,
        addScalar: addScalar2,
        subtract: subtract2,
        multiplyScalar: multiplyScalar2,
        divideScalar: divideScalar2,
        pow: pow2,
        factorial: factorial2,
        combinations: combinations2,
        isNegative: isNegative2,
        isInteger: isInteger3,
        number: number2,
        bignumber: bignumber2,
        larger: larger2
      } = _ref;
      var smallCache = [];
      var bigCache = [];
      return typed2(name263, {
        "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(n, k) {
          if (!isInteger3(n) || isNegative2(n) || !isInteger3(k) || isNegative2(k)) {
            throw new TypeError("Non-negative integer value expected in function stirlingS2");
          } else if (larger2(k, n)) {
            throw new TypeError("k must be less than or equal to n in function stirlingS2");
          }
          var big = !(isNumber2(n) && isNumber2(k));
          var cache = big ? bigCache : smallCache;
          var make = big ? bignumber2 : number2;
          var nn = number2(n);
          var nk = number2(k);
          if (cache[nn] && cache[nn].length > nk) {
            return cache[nn][nk];
          }
          for (var m = 0; m <= nn; ++m) {
            if (!cache[m]) {
              cache[m] = [m === 0 ? make(1) : make(0)];
            }
            if (m === 0)
              continue;
            var row2 = cache[m];
            var prev = cache[m - 1];
            for (var i2 = row2.length; i2 <= m && i2 <= nk; ++i2) {
              if (i2 === m) {
                row2[i2] = 1;
              } else {
                row2[i2] = addScalar2(multiplyScalar2(make(i2), prev[i2]), prev[i2 - 1]);
              }
            }
          }
          return cache[nn][nk];
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/combinatorics/bellNumbers.js
var name264, dependencies265, createBellNumbers;
var init_bellNumbers2 = __esm({
  "node_modules/mathjs/lib/esm/function/combinatorics/bellNumbers.js"() {
    init_factory();
    name264 = "bellNumbers";
    dependencies265 = ["typed", "addScalar", "isNegative", "isInteger", "stirlingS2"];
    createBellNumbers = /* @__PURE__ */ factory(name264, dependencies265, (_ref) => {
      var {
        typed: typed2,
        addScalar: addScalar2,
        isNegative: isNegative2,
        isInteger: isInteger3,
        stirlingS2: stirlingS22
      } = _ref;
      return typed2(name264, {
        "number | BigNumber": function numberBigNumber(n) {
          if (!isInteger3(n) || isNegative2(n)) {
            throw new TypeError("Non-negative integer value expected in function bellNumbers");
          }
          var result = 0;
          for (var i2 = 0; i2 <= n; i2++) {
            result = addScalar2(result, stirlingS22(n, i2));
          }
          return result;
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/combinatorics/catalan.js
var name265, dependencies266, createCatalan;
var init_catalan2 = __esm({
  "node_modules/mathjs/lib/esm/function/combinatorics/catalan.js"() {
    init_factory();
    name265 = "catalan";
    dependencies266 = ["typed", "addScalar", "divideScalar", "multiplyScalar", "combinations", "isNegative", "isInteger"];
    createCatalan = /* @__PURE__ */ factory(name265, dependencies266, (_ref) => {
      var {
        typed: typed2,
        addScalar: addScalar2,
        divideScalar: divideScalar2,
        multiplyScalar: multiplyScalar2,
        combinations: combinations2,
        isNegative: isNegative2,
        isInteger: isInteger3
      } = _ref;
      return typed2(name265, {
        "number | BigNumber": function numberBigNumber(n) {
          if (!isInteger3(n) || isNegative2(n)) {
            throw new TypeError("Non-negative integer value expected in function catalan");
          }
          return divideScalar2(combinations2(multiplyScalar2(n, 2), n), addScalar2(n, 1));
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/combinatorics/composition.js
var name266, dependencies267, createComposition;
var init_composition2 = __esm({
  "node_modules/mathjs/lib/esm/function/combinatorics/composition.js"() {
    init_factory();
    name266 = "composition";
    dependencies267 = ["typed", "addScalar", "combinations", "isNegative", "isPositive", "isInteger", "larger"];
    createComposition = /* @__PURE__ */ factory(name266, dependencies267, (_ref) => {
      var {
        typed: typed2,
        addScalar: addScalar2,
        combinations: combinations2,
        isPositive: isPositive2,
        isNegative: isNegative2,
        isInteger: isInteger3,
        larger: larger2
      } = _ref;
      return typed2(name266, {
        "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(n, k) {
          if (!isInteger3(n) || !isPositive2(n) || !isInteger3(k) || !isPositive2(k)) {
            throw new TypeError("Positive integer value expected in function composition");
          } else if (larger2(k, n)) {
            throw new TypeError("k must be less than or equal to n in function composition");
          }
          return combinations2(addScalar2(n, -1), addScalar2(k, -1));
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/algebra/leafCount.js
var name267, dependencies268, createLeafCount;
var init_leafCount2 = __esm({
  "node_modules/mathjs/lib/esm/function/algebra/leafCount.js"() {
    init_factory();
    name267 = "leafCount";
    dependencies268 = ["parse", "typed"];
    createLeafCount = /* @__PURE__ */ factory(name267, dependencies268, (_ref) => {
      var {
        parse: parse2,
        typed: typed2
      } = _ref;
      function countLeaves(node) {
        var count2 = 0;
        node.forEach((n) => {
          count2 += countLeaves(n);
        });
        return count2 || 1;
      }
      return typed2(name267, {
        string: function string2(expr) {
          return this(parse2(expr));
        },
        Node: function Node2(expr) {
          return countLeaves(expr);
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/algebra/simplify/util.js
function ownKeys2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      (0, import_defineProperty2.default)(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var import_defineProperty2, name268, dependencies269, createUtil;
var init_util = __esm({
  "node_modules/mathjs/lib/esm/function/algebra/simplify/util.js"() {
    import_defineProperty2 = __toESM(require_defineProperty(), 1);
    init_is();
    init_factory();
    init_object();
    name268 = "simplifyUtil";
    dependencies269 = ["FunctionNode", "OperatorNode", "SymbolNode"];
    createUtil = /* @__PURE__ */ factory(name268, dependencies269, (_ref) => {
      var {
        FunctionNode: FunctionNode2,
        OperatorNode: OperatorNode2,
        SymbolNode: SymbolNode2
      } = _ref;
      var T = true;
      var F = false;
      var defaultName = "defaultF";
      var defaultContext = {
        add: {
          trivial: T,
          total: T,
          commutative: T,
          associative: T
        },
        unaryPlus: {
          trivial: T,
          total: T,
          commutative: T,
          associative: T
        },
        subtract: {
          trivial: F,
          total: T,
          commutative: F,
          associative: F
        },
        multiply: {
          trivial: T,
          total: T,
          commutative: T,
          associative: T
        },
        divide: {
          trivial: F,
          total: T,
          commutative: F,
          associative: F
        },
        paren: {
          trivial: T,
          total: T,
          commutative: T,
          associative: F
        },
        defaultF: {
          trivial: F,
          total: T,
          commutative: F,
          associative: F
        }
      };
      var realContext = {
        divide: {
          total: F
        },
        log: {
          total: F
        }
      };
      var positiveContext = {
        subtract: {
          total: F
        },
        abs: {
          trivial: T
        },
        log: {
          total: T
        }
      };
      function hasProperty(nodeOrName, property) {
        var context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultContext;
        var name296 = defaultName;
        if (typeof nodeOrName === "string") {
          name296 = nodeOrName;
        } else if (isOperatorNode(nodeOrName)) {
          name296 = nodeOrName.fn.toString();
        } else if (isFunctionNode(nodeOrName)) {
          name296 = nodeOrName.name;
        } else if (isParenthesisNode(nodeOrName)) {
          name296 = "paren";
        }
        if (hasOwnProperty2(context, name296)) {
          var properties2 = context[name296];
          if (hasOwnProperty2(properties2, property)) {
            return properties2[property];
          }
          if (hasOwnProperty2(defaultContext, name296)) {
            return defaultContext[name296][property];
          }
        }
        if (hasOwnProperty2(context, defaultName)) {
          var _properties = context[defaultName];
          if (hasOwnProperty2(_properties, property)) {
            return _properties[property];
          }
          return defaultContext[defaultName][property];
        }
        if (hasOwnProperty2(defaultContext, name296)) {
          var _properties2 = defaultContext[name296];
          if (hasOwnProperty2(_properties2, property)) {
            return _properties2[property];
          }
        }
        return defaultContext[defaultName][property];
      }
      function isCommutative(node) {
        var context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultContext;
        return hasProperty(node, "commutative", context);
      }
      function isAssociative(node) {
        var context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultContext;
        return hasProperty(node, "associative", context);
      }
      function mergeContext(primary, secondary) {
        var merged = _objectSpread2({}, primary);
        for (var prop in secondary) {
          if (hasOwnProperty2(primary, prop)) {
            merged[prop] = _objectSpread2(_objectSpread2({}, secondary[prop]), primary[prop]);
          } else {
            merged[prop] = secondary[prop];
          }
        }
        return merged;
      }
      function flatten4(node, context) {
        if (!node.args || node.args.length === 0) {
          return node;
        }
        node.args = allChildren(node, context);
        for (var i2 = 0; i2 < node.args.length; i2++) {
          flatten4(node.args[i2], context);
        }
      }
      function allChildren(node, context) {
        var op;
        var children = [];
        var findChildren = function findChildren2(node2) {
          for (var i2 = 0; i2 < node2.args.length; i2++) {
            var child2 = node2.args[i2];
            if (isOperatorNode(child2) && op === child2.op) {
              findChildren2(child2);
            } else {
              children.push(child2);
            }
          }
        };
        if (isAssociative(node, context)) {
          op = node.op;
          findChildren(node);
          return children;
        } else {
          return node.args;
        }
      }
      function unflattenr(node, context) {
        if (!node.args || node.args.length === 0) {
          return;
        }
        var makeNode = createMakeNodeFunction(node);
        var l = node.args.length;
        for (var i2 = 0; i2 < l; i2++) {
          unflattenr(node.args[i2], context);
        }
        if (l > 2 && isAssociative(node, context)) {
          var curnode = node.args.pop();
          while (node.args.length > 0) {
            curnode = makeNode([node.args.pop(), curnode]);
          }
          node.args = curnode.args;
        }
      }
      function unflattenl(node, context) {
        if (!node.args || node.args.length === 0) {
          return;
        }
        var makeNode = createMakeNodeFunction(node);
        var l = node.args.length;
        for (var i2 = 0; i2 < l; i2++) {
          unflattenl(node.args[i2], context);
        }
        if (l > 2 && isAssociative(node, context)) {
          var curnode = node.args.shift();
          while (node.args.length > 0) {
            curnode = makeNode([curnode, node.args.shift()]);
          }
          node.args = curnode.args;
        }
      }
      function createMakeNodeFunction(node) {
        if (isOperatorNode(node)) {
          return function(args) {
            try {
              return new OperatorNode2(node.op, node.fn, args, node.implicit);
            } catch (err) {
              console.error(err);
              return [];
            }
          };
        } else {
          return function(args) {
            return new FunctionNode2(new SymbolNode2(node.name), args);
          };
        }
      }
      return {
        createMakeNodeFunction,
        hasProperty,
        isCommutative,
        isAssociative,
        mergeContext,
        flatten: flatten4,
        allChildren,
        unflattenr,
        unflattenl,
        defaultContext,
        realContext,
        positiveContext
      };
    });
  }
});

// node_modules/mathjs/lib/esm/function/algebra/simplify/simplifyConstant.js
var name269, dependencies270, createSimplifyConstant;
var init_simplifyConstant = __esm({
  "node_modules/mathjs/lib/esm/function/algebra/simplify/simplifyConstant.js"() {
    init_is();
    init_factory();
    init_util();
    init_noop();
    name269 = "simplifyConstant";
    dependencies270 = ["typed", "config", "mathWithTransform", "matrix", "?fraction", "?bignumber", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "SymbolNode"];
    createSimplifyConstant = /* @__PURE__ */ factory(name269, dependencies270, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        mathWithTransform: mathWithTransform2,
        matrix: matrix2,
        fraction: fraction2,
        bignumber: bignumber2,
        AccessorNode: AccessorNode2,
        ArrayNode: ArrayNode2,
        ConstantNode: ConstantNode2,
        FunctionNode: FunctionNode2,
        IndexNode: IndexNode2,
        ObjectNode: ObjectNode2,
        OperatorNode: OperatorNode2,
        SymbolNode: SymbolNode2
      } = _ref;
      var {
        isCommutative,
        isAssociative,
        allChildren,
        createMakeNodeFunction
      } = createUtil({
        FunctionNode: FunctionNode2,
        OperatorNode: OperatorNode2,
        SymbolNode: SymbolNode2
      });
      function simplifyConstant(expr, options) {
        return _ensureNode(foldFraction(expr, options));
      }
      function _removeFractions(thing) {
        if (isFraction(thing)) {
          return thing.valueOf();
        }
        if (thing instanceof Array) {
          return thing.map(_removeFractions);
        }
        if (isMatrix(thing)) {
          return matrix2(_removeFractions(thing.valueOf()));
        }
        return thing;
      }
      function _eval(fnname, args, options) {
        try {
          return mathWithTransform2[fnname].apply(null, args);
        } catch (ignore) {
          args = args.map(_removeFractions);
          return _toNumber(mathWithTransform2[fnname].apply(null, args), options);
        }
      }
      var _toNode = typed2({
        Fraction: _fractionToNode,
        number: function number2(n) {
          if (n < 0) {
            return unaryMinusNode(new ConstantNode2(-n));
          }
          return new ConstantNode2(n);
        },
        BigNumber: function BigNumber2(n) {
          if (n < 0) {
            return unaryMinusNode(new ConstantNode2(-n));
          }
          return new ConstantNode2(n);
        },
        Complex: function Complex3(s) {
          throw new Error("Cannot convert Complex number to Node");
        },
        string: function string2(s) {
          return new ConstantNode2(s);
        },
        Matrix: function Matrix2(m) {
          return new ArrayNode2(m.valueOf().map((e3) => _toNode(e3)));
        }
      });
      function _ensureNode(thing) {
        if (isNode(thing)) {
          return thing;
        }
        return _toNode(thing);
      }
      function _exactFraction(n, options) {
        var exactFractions = options && options.exactFractions !== false;
        if (exactFractions && isFinite(n) && fraction2) {
          var f = fraction2(n);
          var fractionsLimit = options && typeof options.fractionsLimit === "number" ? options.fractionsLimit : Infinity;
          if (f.valueOf() === n && f.n < fractionsLimit && f.d < fractionsLimit) {
            return f;
          }
        }
        return n;
      }
      var _toNumber = typed2({
        "string, Object": function stringObject(s, options) {
          if (config3.number === "BigNumber") {
            if (bignumber2 === void 0) {
              noBignumber();
            }
            return bignumber2(s);
          } else if (config3.number === "Fraction") {
            if (fraction2 === void 0) {
              noFraction();
            }
            return fraction2(s);
          } else {
            var n = parseFloat(s);
            return _exactFraction(n, options);
          }
        },
        "Fraction, Object": function FractionObject(s, options) {
          return s;
        },
        "BigNumber, Object": function BigNumberObject(s, options) {
          return s;
        },
        "number, Object": function numberObject(s, options) {
          return _exactFraction(s, options);
        },
        "Complex, Object": function ComplexObject(s, options) {
          if (s.im !== 0) {
            return s;
          }
          return _exactFraction(s.re, options);
        },
        "Matrix, Object": function MatrixObject(s, options) {
          return matrix2(_exactFraction(s.valueOf()));
        },
        "Array, Object": function ArrayObject(s, options) {
          return s.map(_exactFraction);
        }
      });
      function unaryMinusNode(n) {
        return new OperatorNode2("-", "unaryMinus", [n]);
      }
      function _fractionToNode(f) {
        var n;
        var vn = f.s * f.n;
        if (vn < 0) {
          n = new OperatorNode2("-", "unaryMinus", [new ConstantNode2(-vn)]);
        } else {
          n = new ConstantNode2(vn);
        }
        if (f.d === 1) {
          return n;
        }
        return new OperatorNode2("/", "divide", [n, new ConstantNode2(f.d)]);
      }
      function _foldAccessor(obj, index2, options) {
        if (!isIndexNode(index2)) {
          return new AccessorNode2(_ensureNode(obj), _ensureNode(index2));
        }
        if (isArrayNode(obj) || isMatrix(obj)) {
          var remainingDims = Array.from(index2.dimensions);
          while (remainingDims.length > 0) {
            if (isConstantNode(remainingDims[0]) && typeof remainingDims[0].value !== "string") {
              var first = _toNumber(remainingDims.shift().value, options);
              if (isArrayNode(obj)) {
                obj = obj.items[first - 1];
              } else {
                obj = obj.valueOf()[first - 1];
                if (obj instanceof Array) {
                  obj = matrix2(obj);
                }
              }
            } else if (remainingDims.length > 1 && isConstantNode(remainingDims[1]) && typeof remainingDims[1].value !== "string") {
              var second = _toNumber(remainingDims[1].value, options);
              var tryItems = [];
              var fromItems = isArrayNode(obj) ? obj.items : obj.valueOf();
              for (var item of fromItems) {
                if (isArrayNode(item)) {
                  tryItems.push(item.items[second - 1]);
                } else if (isMatrix(obj)) {
                  tryItems.push(item[second - 1]);
                } else {
                  break;
                }
              }
              if (tryItems.length === fromItems.length) {
                if (isArrayNode(obj)) {
                  obj = new ArrayNode2(tryItems);
                } else {
                  obj = matrix2(tryItems);
                }
                remainingDims.splice(1, 1);
              } else {
                break;
              }
            } else {
              break;
            }
          }
          if (remainingDims.length === index2.dimensions.length) {
            return new AccessorNode2(_ensureNode(obj), index2);
          }
          if (remainingDims.length > 0) {
            index2 = new IndexNode2(remainingDims);
            return new AccessorNode2(_ensureNode(obj), index2);
          }
          return obj;
        }
        if (isObjectNode(obj) && index2.dimensions.length === 1 && isConstantNode(index2.dimensions[0])) {
          var key = index2.dimensions[0].value;
          if (key in obj.properties) {
            return obj.properties[key];
          }
          return new ConstantNode2();
        }
        return new AccessorNode2(_ensureNode(obj), index2);
      }
      function foldOp(fn, args, makeNode, options) {
        return args.reduce(function(a, b) {
          if (!isNode(a) && !isNode(b)) {
            try {
              return _eval(fn, [a, b], options);
            } catch (ignoreandcontinue) {
            }
            a = _toNode(a);
            b = _toNode(b);
          } else if (!isNode(a)) {
            a = _toNode(a);
          } else if (!isNode(b)) {
            b = _toNode(b);
          }
          return makeNode([a, b]);
        });
      }
      function foldFraction(node, options) {
        switch (node.type) {
          case "SymbolNode":
            return node;
          case "ConstantNode":
            switch (typeof node.value) {
              case "number":
                return _toNumber(node.value, options);
              case "string":
                return node.value;
              default:
                if (!isNaN(node.value))
                  return _toNumber(node.value, options);
            }
            return node;
          case "FunctionNode":
            if (mathWithTransform2[node.name] && mathWithTransform2[node.name].rawArgs) {
              return node;
            }
            {
              var operatorFunctions = ["add", "multiply"];
              if (operatorFunctions.indexOf(node.name) === -1) {
                var args = node.args.map((arg2) => foldFraction(arg2, options));
                if (!args.some(isNode)) {
                  try {
                    return _eval(node.name, args, options);
                  } catch (ignoreandcontinue) {
                  }
                }
                if (node.name === "size" && args.length === 1 && isArrayNode(args[0])) {
                  var sz = [];
                  var section = args[0];
                  while (isArrayNode(section)) {
                    sz.push(section.items.length);
                    section = section.items[0];
                  }
                  return matrix2(sz);
                }
                return new FunctionNode2(node.name, args.map(_ensureNode));
              } else {
              }
            }
          case "OperatorNode": {
            var fn = node.fn.toString();
            var _args;
            var res;
            var makeNode = createMakeNodeFunction(node);
            if (isOperatorNode(node) && node.isUnary()) {
              _args = [foldFraction(node.args[0], options)];
              if (!isNode(_args[0])) {
                res = _eval(fn, _args, options);
              } else {
                res = makeNode(_args);
              }
            } else if (isAssociative(node, options.context)) {
              _args = allChildren(node, options.context);
              _args = _args.map((arg2) => foldFraction(arg2, options));
              if (isCommutative(fn, options.context)) {
                var consts = [];
                var vars = [];
                for (var i2 = 0; i2 < _args.length; i2++) {
                  if (!isNode(_args[i2])) {
                    consts.push(_args[i2]);
                  } else {
                    vars.push(_args[i2]);
                  }
                }
                if (consts.length > 1) {
                  res = foldOp(fn, consts, makeNode, options);
                  vars.unshift(res);
                  res = foldOp(fn, vars, makeNode, options);
                } else {
                  res = foldOp(fn, _args, makeNode, options);
                }
              } else {
                res = foldOp(fn, _args, makeNode, options);
              }
            } else {
              _args = node.args.map((arg2) => foldFraction(arg2, options));
              res = foldOp(fn, _args, makeNode, options);
            }
            return res;
          }
          case "ParenthesisNode":
            return foldFraction(node.content, options);
          case "AccessorNode":
            return _foldAccessor(foldFraction(node.object, options), foldFraction(node.index, options), options);
          case "ArrayNode": {
            var foldItems = node.items.map((item) => foldFraction(item, options));
            if (foldItems.some(isNode)) {
              return new ArrayNode2(foldItems.map(_ensureNode));
            }
            return matrix2(foldItems);
          }
          case "IndexNode": {
            return new IndexNode2(node.dimensions.map((n) => simplifyConstant(n, options)));
          }
          case "ObjectNode": {
            var foldProps = {};
            for (var prop in node.properties) {
              foldProps[prop] = simplifyConstant(node.properties[prop], options);
            }
            return new ObjectNode2(foldProps);
          }
          case "AssignmentNode":
          case "BlockNode":
          case "FunctionAssignmentNode":
          case "RangeNode":
          case "ConditionalNode":
          default:
            throw new Error("Unimplemented node type in simplifyConstant: ".concat(node.type));
        }
      }
      return simplifyConstant;
    });
  }
});

// node_modules/mathjs/lib/esm/function/algebra/simplify.js
var name270, dependencies271, createSimplify;
var init_simplify2 = __esm({
  "node_modules/mathjs/lib/esm/function/algebra/simplify.js"() {
    init_is();
    init_factory();
    init_util();
    init_simplifyConstant();
    init_object();
    init_map();
    name270 = "simplify";
    dependencies271 = ["config", "typed", "parse", "add", "subtract", "multiply", "divide", "pow", "isZero", "equal", "resolve", "simplifyCore", "?fraction", "?bignumber", "mathWithTransform", "matrix", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "ParenthesisNode", "SymbolNode"];
    createSimplify = /* @__PURE__ */ factory(name270, dependencies271, (_ref) => {
      var {
        config: config3,
        typed: typed2,
        parse: parse2,
        add: add2,
        subtract: subtract2,
        multiply: multiply2,
        divide: divide2,
        pow: pow2,
        isZero: isZero2,
        equal: equal2,
        resolve: resolve2,
        simplifyCore: simplifyCore2,
        fraction: fraction2,
        bignumber: bignumber2,
        mathWithTransform: mathWithTransform2,
        matrix: matrix2,
        AccessorNode: AccessorNode2,
        ArrayNode: ArrayNode2,
        ConstantNode: ConstantNode2,
        FunctionNode: FunctionNode2,
        IndexNode: IndexNode2,
        ObjectNode: ObjectNode2,
        OperatorNode: OperatorNode2,
        ParenthesisNode: ParenthesisNode2,
        SymbolNode: SymbolNode2
      } = _ref;
      var simplifyConstant = createSimplifyConstant({
        typed: typed2,
        config: config3,
        mathWithTransform: mathWithTransform2,
        matrix: matrix2,
        fraction: fraction2,
        bignumber: bignumber2,
        AccessorNode: AccessorNode2,
        ArrayNode: ArrayNode2,
        ConstantNode: ConstantNode2,
        FunctionNode: FunctionNode2,
        IndexNode: IndexNode2,
        ObjectNode: ObjectNode2,
        OperatorNode: OperatorNode2,
        SymbolNode: SymbolNode2
      });
      var {
        hasProperty,
        isCommutative,
        isAssociative,
        mergeContext,
        flatten: flatten4,
        unflattenr,
        unflattenl,
        createMakeNodeFunction,
        defaultContext,
        realContext,
        positiveContext
      } = createUtil({
        FunctionNode: FunctionNode2,
        OperatorNode: OperatorNode2,
        SymbolNode: SymbolNode2
      });
      var simplify2 = typed2("simplify", {
        string: function string2(expr) {
          return this(parse2(expr), this.rules, createEmptyMap(), {});
        },
        "string, Map | Object": function stringMapObject(expr, scope) {
          return this(parse2(expr), this.rules, scope, {});
        },
        "string, Map | Object, Object": function stringMapObjectObject(expr, scope, options) {
          return this(parse2(expr), this.rules, scope, options);
        },
        "string, Array": function stringArray(expr, rules) {
          return this(parse2(expr), rules, createEmptyMap(), {});
        },
        "string, Array, Map | Object": function stringArrayMapObject(expr, rules, scope) {
          return this(parse2(expr), rules, scope, {});
        },
        "string, Array, Map | Object, Object": function stringArrayMapObjectObject(expr, rules, scope, options) {
          return this(parse2(expr), rules, scope, options);
        },
        "Node, Map | Object": function NodeMapObject(expr, scope) {
          return this(expr, this.rules, scope, {});
        },
        "Node, Map | Object, Object": function NodeMapObjectObject(expr, scope, options) {
          return this(expr, this.rules, scope, options);
        },
        Node: function Node2(expr) {
          return this(expr, this.rules, createEmptyMap(), {});
        },
        "Node, Array": function NodeArray(expr, rules) {
          return this(expr, rules, createEmptyMap(), {});
        },
        "Node, Array, Map | Object": function NodeArrayMapObject(expr, rules, scope) {
          return this(expr, rules, scope, {});
        },
        "Node, Array, Object, Object": function NodeArrayObjectObject(expr, rules, scope, options) {
          return this(expr, rules, createMap(scope), options);
        },
        "Node, Array, Map, Object": function NodeArrayMapObject(expr, rules, scope, options) {
          var debug = options.consoleDebug;
          rules = _buildRules(rules, options.context);
          var res = resolve2(expr, scope);
          res = removeParens(res);
          var visited = {};
          var str = res.toString({
            parenthesis: "all"
          });
          while (!visited[str]) {
            visited[str] = true;
            _lastsym = 0;
            var laststr = str;
            if (debug)
              console.log("Working on: ", str);
            for (var i2 = 0; i2 < rules.length; i2++) {
              var rulestr = "";
              if (typeof rules[i2] === "function") {
                res = rules[i2](res, options);
                if (debug)
                  rulestr = rules[i2].name;
              } else {
                flatten4(res, options.context);
                res = applyRule(res, rules[i2], options.context);
                if (debug) {
                  rulestr = "".concat(rules[i2].l.toString(), " -> ").concat(rules[i2].r.toString());
                }
              }
              if (debug) {
                var newstr = res.toString({
                  parenthesis: "all"
                });
                if (newstr !== laststr) {
                  console.log("Applying", rulestr, "produced", newstr);
                  laststr = newstr;
                }
              }
              unflattenl(res, options.context);
            }
            str = res.toString({
              parenthesis: "all"
            });
          }
          return res;
        }
      });
      simplify2.defaultContext = defaultContext;
      simplify2.realContext = realContext;
      simplify2.positiveContext = positiveContext;
      function removeParens(node) {
        return node.transform(function(node2, path, parent2) {
          return isParenthesisNode(node2) ? removeParens(node2.content) : node2;
        });
      }
      var SUPPORTED_CONSTANTS = {
        true: true,
        false: true,
        e: true,
        i: true,
        Infinity: true,
        LN2: true,
        LN10: true,
        LOG2E: true,
        LOG10E: true,
        NaN: true,
        phi: true,
        pi: true,
        SQRT1_2: true,
        SQRT2: true,
        tau: true
      };
      simplify2.rules = [
        simplifyCore2,
        {
          l: "log(e)",
          r: "1"
        },
        {
          s: "n-n1 -> n+-n1",
          assuming: {
            subtract: {
              total: true
            }
          }
        },
        {
          s: "n-n -> 0",
          assuming: {
            subtract: {
              total: false
            }
          }
        },
        {
          s: "-(c*v) -> v * (-c)",
          assuming: {
            multiply: {
              commutative: true
            },
            subtract: {
              total: true
            }
          }
        },
        {
          s: "-(c*v) -> (-c) * v",
          assuming: {
            multiply: {
              commutative: false
            },
            subtract: {
              total: true
            }
          }
        },
        {
          s: "-(v*c) -> v * (-c)",
          assuming: {
            multiply: {
              commutative: false
            },
            subtract: {
              total: true
            }
          }
        },
        {
          l: "-(n1/n2)",
          r: "-n1/n2"
        },
        {
          l: "-v",
          r: "v * (-1)"
        },
        {
          l: "(n1 + n2)*(-1)",
          r: "n1*(-1) + n2*(-1)",
          repeat: true
        },
        {
          l: "n/n1^n2",
          r: "n*n1^-n2"
        },
        {
          l: "n/n1",
          r: "n*n1^-1"
        },
        {
          s: "(n1*n2)^n3 -> n1^n3 * n2^n3",
          assuming: {
            multiply: {
              commutative: true
            }
          }
        },
        {
          s: "(n1*n2)^(-1) -> n2^(-1) * n1^(-1)",
          assuming: {
            multiply: {
              commutative: false
            }
          }
        },
        {
          s: "(n ^ n1) ^ n2 -> n ^ (n1 * n2)",
          assuming: {
            divide: {
              total: true
            }
          }
        },
        {
          l: " v   * ( v   * n1 + n2)",
          r: "v^2       * n1 +  v   * n2"
        },
        {
          s: " v   * (v^n4 * n1 + n2)   ->  v^(1+n4)  * n1 +  v   * n2",
          assuming: {
            divide: {
              total: true
            }
          }
        },
        {
          s: "v^n3 * ( v   * n1 + n2)   ->  v^(n3+1)  * n1 + v^n3 * n2",
          assuming: {
            divide: {
              total: true
            }
          }
        },
        {
          s: "v^n3 * (v^n4 * n1 + n2)   ->  v^(n3+n4) * n1 + v^n3 * n2",
          assuming: {
            divide: {
              total: true
            }
          }
        },
        {
          l: "n*n",
          r: "n^2"
        },
        {
          s: "n * n^n1 -> n^(n1+1)",
          assuming: {
            divide: {
              total: true
            }
          }
        },
        {
          s: "n^n1 * n^n2 -> n^(n1+n2)",
          assuming: {
            divide: {
              total: true
            }
          }
        },
        simplifyConstant,
        {
          s: "n+n -> 2*n",
          assuming: {
            add: {
              total: true
            }
          }
        },
        {
          l: "n+-n",
          r: "0"
        },
        {
          l: "v*n + v",
          r: "v*(n+1)"
        },
        {
          l: "n3*n1 + n3*n2",
          r: "n3*(n1+n2)"
        },
        {
          l: "n3^(-n4)*n1 +   n3  * n2",
          r: "n3^(-n4)*(n1 + n3^(n4+1) *n2)"
        },
        {
          l: "n3^(-n4)*n1 + n3^n5 * n2",
          r: "n3^(-n4)*(n1 + n3^(n4+n5)*n2)"
        },
        {
          s: "n*v + v -> (n+1)*v",
          assuming: {
            multiply: {
              commutative: false
            }
          }
        },
        {
          s: "n1*n3 + n2*n3 -> (n1+n2)*n3",
          assuming: {
            multiply: {
              commutative: false
            }
          }
        },
        {
          s: "n1*n3^(-n4) + n2 * n3    -> (n1 + n2*n3^(n4 +  1))*n3^(-n4)",
          assuming: {
            multiply: {
              commutative: false
            }
          }
        },
        {
          s: "n1*n3^(-n4) + n2 * n3^n5 -> (n1 + n2*n3^(n4 + n5))*n3^(-n4)",
          assuming: {
            multiply: {
              commutative: false
            }
          }
        },
        {
          l: "n*c + c",
          r: "(n+1)*c"
        },
        {
          s: "c*n + c -> c*(n+1)",
          assuming: {
            multiply: {
              commutative: false
            }
          }
        },
        simplifyConstant,
        {
          s: "(-n)*n1 -> -(n*n1)",
          assuming: {
            subtract: {
              total: true
            }
          }
        },
        {
          s: "n1*(-n) -> -(n1*n)",
          assuming: {
            subtract: {
              total: true
            },
            multiply: {
              commutative: false
            }
          }
        },
        {
          s: "c+v -> v+c",
          assuming: {
            add: {
              commutative: true
            }
          },
          imposeContext: {
            add: {
              commutative: false
            }
          }
        },
        {
          s: "v*c -> c*v",
          assuming: {
            multiply: {
              commutative: true
            }
          },
          imposeContext: {
            multiply: {
              commutative: false
            }
          }
        },
        {
          l: "n+-n1",
          r: "n-n1"
        },
        {
          s: "n*(n1^-1) -> n/n1",
          assuming: {
            multiply: {
              commutative: true
            }
          }
        },
        {
          s: "n*n1^-n2 -> n/n1^n2",
          assuming: {
            multiply: {
              commutative: true
            }
          }
        },
        {
          s: "n^-1 -> 1/n",
          assuming: {
            multiply: {
              commutative: true
            }
          }
        },
        {
          l: "n^1",
          r: "n"
        },
        {
          s: "n*(n1/n2) -> (n*n1)/n2",
          assuming: {
            multiply: {
              associative: true
            }
          }
        },
        {
          s: "n-(n1+n2) -> n-n1-n2",
          assuming: {
            addition: {
              associative: true,
              commutative: true
            }
          }
        },
        {
          l: "1*n",
          r: "n",
          imposeContext: {
            multiply: {
              commutative: true
            }
          }
        },
        {
          s: "n1/(n2/n3) -> (n1*n3)/n2",
          assuming: {
            multiply: {
              associative: true
            }
          }
        },
        {
          l: "n1/(-n2)",
          r: "-n1/n2"
        }
      ];
      function _canonicalizeRule(ruleObject, context) {
        var newRule = {};
        if (ruleObject.s) {
          var lr = ruleObject.s.split("->");
          if (lr.length === 2) {
            newRule.l = lr[0];
            newRule.r = lr[1];
          } else {
            throw SyntaxError("Could not parse rule: " + ruleObject.s);
          }
        } else {
          newRule.l = ruleObject.l;
          newRule.r = ruleObject.r;
        }
        newRule.l = removeParens(parse2(newRule.l));
        newRule.r = removeParens(parse2(newRule.r));
        for (var prop of ["imposeContext", "repeat", "assuming"]) {
          if (prop in ruleObject) {
            newRule[prop] = ruleObject[prop];
          }
        }
        if (ruleObject.evaluate) {
          newRule.evaluate = parse2(ruleObject.evaluate);
        }
        if (isAssociative(newRule.l, context)) {
          var makeNode = createMakeNodeFunction(newRule.l);
          var expandsym = _getExpandPlaceholderSymbol();
          newRule.expanded = {};
          newRule.expanded.l = makeNode([newRule.l.clone(), expandsym]);
          flatten4(newRule.expanded.l, context);
          unflattenr(newRule.expanded.l, context);
          newRule.expanded.r = makeNode([newRule.r, expandsym]);
        }
        return newRule;
      }
      function _buildRules(rules, context) {
        var ruleSet = [];
        for (var i2 = 0; i2 < rules.length; i2++) {
          var rule = rules[i2];
          var newRule = void 0;
          var ruleType = typeof rule;
          switch (ruleType) {
            case "string":
              rule = {
                s: rule
              };
            case "object":
              newRule = _canonicalizeRule(rule, context);
              break;
            case "function":
              newRule = rule;
              break;
            default:
              throw TypeError("Unsupported type of rule: " + ruleType);
          }
          ruleSet.push(newRule);
        }
        return ruleSet;
      }
      var _lastsym = 0;
      function _getExpandPlaceholderSymbol() {
        return new SymbolNode2("_p" + _lastsym++);
      }
      function mapRule(nodes, rule, context) {
        var resNodes = nodes;
        if (nodes) {
          for (var i2 = 0; i2 < nodes.length; ++i2) {
            var newNode = applyRule(nodes[i2], rule, context);
            if (newNode !== nodes[i2]) {
              if (resNodes === nodes) {
                resNodes = nodes.slice();
              }
              resNodes[i2] = newNode;
            }
          }
        }
        return resNodes;
      }
      function applyRule(node, rule, context) {
        if (rule.assuming) {
          for (var symbol in rule.assuming) {
            for (var property in rule.assuming[symbol]) {
              if (hasProperty(symbol, property, context) !== rule.assuming[symbol][property]) {
                return node;
              }
            }
          }
        }
        var mergedContext = mergeContext(rule.imposeContext, context);
        var res = node;
        if (res instanceof OperatorNode2 || res instanceof FunctionNode2) {
          var newArgs = mapRule(res.args, rule, context);
          if (newArgs !== res.args) {
            res = res.clone();
            res.args = newArgs;
          }
        } else if (res instanceof ParenthesisNode2) {
          if (res.content) {
            var newContent = applyRule(res.content, rule, context);
            if (newContent !== res.content) {
              res = new ParenthesisNode2(newContent);
            }
          }
        } else if (res instanceof ArrayNode2) {
          var newItems = mapRule(res.items, rule, context);
          if (newItems !== res.items) {
            res = new ArrayNode2(newItems);
          }
        } else if (res instanceof AccessorNode2) {
          var newObj = res.object;
          if (res.object) {
            newObj = applyRule(res.object, rule, context);
          }
          var newIndex = res.index;
          if (res.index) {
            newIndex = applyRule(res.index, rule, context);
          }
          if (newObj !== res.object || newIndex !== res.index) {
            res = new AccessorNode2(newObj, newIndex);
          }
        } else if (res instanceof IndexNode2) {
          var newDims = mapRule(res.dimensions, rule, context);
          if (newDims !== res.dimensions) {
            res = new IndexNode2(newDims);
          }
        } else if (res instanceof ObjectNode2) {
          var changed = false;
          var newProps = {};
          for (var prop in res.properties) {
            newProps[prop] = applyRule(res.properties[prop], rule, context);
            if (newProps[prop] !== res.properties[prop]) {
              changed = true;
            }
          }
          if (changed) {
            res = new ObjectNode2(newProps);
          }
        }
        var repl = rule.r;
        var matches = _ruleMatch(rule.l, res, mergedContext)[0];
        if (!matches && rule.expanded) {
          repl = rule.expanded.r;
          matches = _ruleMatch(rule.expanded.l, res, mergedContext)[0];
        }
        if (matches) {
          var implicit = res.implicit;
          res = repl.clone();
          if (implicit && "implicit" in repl) {
            res.implicit = true;
          }
          res = res.transform(function(node2) {
            if (node2.isSymbolNode && hasOwnProperty2(matches.placeholders, node2.name)) {
              return matches.placeholders[node2.name].clone();
            } else {
              return node2;
            }
          });
        }
        if (rule.repeat && res !== node) {
          res = applyRule(res, rule, context);
        }
        return res;
      }
      function getSplits(node, context) {
        var res = [];
        var right, rightArgs;
        var makeNode = createMakeNodeFunction(node);
        if (isCommutative(node, context)) {
          for (var i2 = 0; i2 < node.args.length; i2++) {
            rightArgs = node.args.slice(0);
            rightArgs.splice(i2, 1);
            right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);
            res.push(makeNode([node.args[i2], right]));
          }
        } else {
          for (var _i = 1; _i < node.args.length; _i++) {
            var left = node.args[0];
            if (_i > 1) {
              left = makeNode(node.args.slice(0, _i));
            }
            rightArgs = node.args.slice(_i);
            right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);
            res.push(makeNode([left, right]));
          }
        }
        return res;
      }
      function mergeMatch(match1, match2) {
        var res = {
          placeholders: {}
        };
        if (!match1.placeholders && !match2.placeholders) {
          return res;
        } else if (!match1.placeholders) {
          return match2;
        } else if (!match2.placeholders) {
          return match1;
        }
        for (var key in match1.placeholders) {
          if (hasOwnProperty2(match1.placeholders, key)) {
            res.placeholders[key] = match1.placeholders[key];
            if (hasOwnProperty2(match2.placeholders, key)) {
              if (!_exactMatch(match1.placeholders[key], match2.placeholders[key])) {
                return null;
              }
            }
          }
        }
        for (var _key in match2.placeholders) {
          if (hasOwnProperty2(match2.placeholders, _key)) {
            res.placeholders[_key] = match2.placeholders[_key];
          }
        }
        return res;
      }
      function combineChildMatches(list1, list2) {
        var res = [];
        if (list1.length === 0 || list2.length === 0) {
          return res;
        }
        var merged;
        for (var i1 = 0; i1 < list1.length; i1++) {
          for (var i2 = 0; i2 < list2.length; i2++) {
            merged = mergeMatch(list1[i1], list2[i2]);
            if (merged) {
              res.push(merged);
            }
          }
        }
        return res;
      }
      function mergeChildMatches(childMatches) {
        if (childMatches.length === 0) {
          return childMatches;
        }
        var sets = childMatches.reduce(combineChildMatches);
        var uniqueSets = [];
        var unique = {};
        for (var i2 = 0; i2 < sets.length; i2++) {
          var s = JSON.stringify(sets[i2]);
          if (!unique[s]) {
            unique[s] = true;
            uniqueSets.push(sets[i2]);
          }
        }
        return uniqueSets;
      }
      function _ruleMatch(rule, node, context, isSplit) {
        var res = [{
          placeholders: {}
        }];
        if (rule instanceof OperatorNode2 && node instanceof OperatorNode2 || rule instanceof FunctionNode2 && node instanceof FunctionNode2) {
          if (rule instanceof OperatorNode2) {
            if (rule.op !== node.op || rule.fn !== node.fn) {
              return [];
            }
          } else if (rule instanceof FunctionNode2) {
            if (rule.name !== node.name) {
              return [];
            }
          }
          if (node.args.length === 1 && rule.args.length === 1 || !isAssociative(node, context) && node.args.length === rule.args.length || isSplit) {
            var childMatches = [];
            for (var i2 = 0; i2 < rule.args.length; i2++) {
              var childMatch = _ruleMatch(rule.args[i2], node.args[i2], context);
              if (childMatch.length === 0) {
                break;
              }
              childMatches.push(childMatch);
            }
            if (childMatches.length !== rule.args.length) {
              if (!isCommutative(node, context) || rule.args.length === 1) {
                return [];
              }
              if (rule.args.length > 2) {
                throw new Error("permuting >2 commutative non-associative rule arguments not yet implemented");
              }
              var leftMatch = _ruleMatch(rule.args[0], node.args[1], context);
              if (leftMatch.length === 0) {
                return [];
              }
              var rightMatch = _ruleMatch(rule.args[1], node.args[0], context);
              if (rightMatch.length === 0) {
                return [];
              }
              childMatches = [leftMatch, rightMatch];
            }
            res = mergeChildMatches(childMatches);
          } else if (node.args.length >= 2 && rule.args.length === 2) {
            var splits = getSplits(node, context);
            var splitMatches = [];
            for (var _i2 = 0; _i2 < splits.length; _i2++) {
              var matchSet = _ruleMatch(rule, splits[_i2], context, true);
              splitMatches = splitMatches.concat(matchSet);
            }
            return splitMatches;
          } else if (rule.args.length > 2) {
            throw Error("Unexpected non-binary associative function: " + rule.toString());
          } else {
            return [];
          }
        } else if (rule instanceof SymbolNode2) {
          if (rule.name.length === 0) {
            throw new Error("Symbol in rule has 0 length...!?");
          }
          if (SUPPORTED_CONSTANTS[rule.name]) {
            if (rule.name !== node.name) {
              return [];
            }
          } else if (rule.name[0] === "n" || rule.name.substring(0, 2) === "_p") {
            res[0].placeholders[rule.name] = node;
          } else if (rule.name[0] === "v") {
            if (!isConstantNode(node)) {
              res[0].placeholders[rule.name] = node;
            } else {
              return [];
            }
          } else if (rule.name[0] === "c") {
            if (node instanceof ConstantNode2) {
              res[0].placeholders[rule.name] = node;
            } else {
              return [];
            }
          } else {
            throw new Error("Invalid symbol in rule: " + rule.name);
          }
        } else if (rule instanceof ConstantNode2) {
          if (!equal2(rule.value, node.value)) {
            return [];
          }
        } else {
          return [];
        }
        return res;
      }
      function _exactMatch(p, q) {
        if (p instanceof ConstantNode2 && q instanceof ConstantNode2) {
          if (!equal2(p.value, q.value)) {
            return false;
          }
        } else if (p instanceof SymbolNode2 && q instanceof SymbolNode2) {
          if (p.name !== q.name) {
            return false;
          }
        } else if (p instanceof OperatorNode2 && q instanceof OperatorNode2 || p instanceof FunctionNode2 && q instanceof FunctionNode2) {
          if (p instanceof OperatorNode2) {
            if (p.op !== q.op || p.fn !== q.fn) {
              return false;
            }
          } else if (p instanceof FunctionNode2) {
            if (p.name !== q.name) {
              return false;
            }
          }
          if (p.args.length !== q.args.length) {
            return false;
          }
          for (var i2 = 0; i2 < p.args.length; i2++) {
            if (!_exactMatch(p.args[i2], q.args[i2])) {
              return false;
            }
          }
        } else {
          return false;
        }
        return true;
      }
      return simplify2;
    });
  }
});

// node_modules/mathjs/lib/esm/function/algebra/simplifyCore.js
var name271, dependencies272, createSimplifyCore;
var init_simplifyCore2 = __esm({
  "node_modules/mathjs/lib/esm/function/algebra/simplifyCore.js"() {
    init_is();
    init_util();
    init_factory();
    name271 = "simplifyCore";
    dependencies272 = ["equal", "isZero", "add", "subtract", "multiply", "divide", "pow", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "ParenthesisNode", "SymbolNode"];
    createSimplifyCore = /* @__PURE__ */ factory(name271, dependencies272, (_ref) => {
      var {
        equal: equal2,
        isZero: isZero2,
        add: add2,
        subtract: subtract2,
        multiply: multiply2,
        divide: divide2,
        pow: pow2,
        AccessorNode: AccessorNode2,
        ArrayNode: ArrayNode2,
        ConstantNode: ConstantNode2,
        FunctionNode: FunctionNode2,
        IndexNode: IndexNode2,
        ObjectNode: ObjectNode2,
        OperatorNode: OperatorNode2,
        ParenthesisNode: ParenthesisNode2,
        SymbolNode: SymbolNode2
      } = _ref;
      var node0 = new ConstantNode2(0);
      var node1 = new ConstantNode2(1);
      var {
        hasProperty,
        isCommutative
      } = createUtil({
        FunctionNode: FunctionNode2,
        OperatorNode: OperatorNode2,
        SymbolNode: SymbolNode2
      });
      function simplifyCore2(node, options) {
        var context = options ? options.context : void 0;
        if (hasProperty(node, "trivial", context)) {
          if (isFunctionNode(node) && node.args.length === 1) {
            return simplifyCore2(node.args[0], options);
          }
          var simpChild = false;
          var childCount = 0;
          node.forEach((c) => {
            ++childCount;
            if (childCount === 1) {
              simpChild = simplifyCore2(c, options);
            }
          });
          if (childCount === 1) {
            return simpChild;
          }
        }
        if (isOperatorNode(node) && node.isUnary()) {
          var a0 = simplifyCore2(node.args[0], options);
          if (node.op === "-") {
            if (isOperatorNode(a0)) {
              if (a0.isUnary() && a0.op === "-") {
                return a0.args[0];
              } else if (a0.isBinary() && a0.fn === "subtract") {
                return new OperatorNode2("-", "subtract", [a0.args[1], a0.args[0]]);
              }
            }
            return new OperatorNode2(node.op, node.fn, [a0]);
          }
        } else if (isOperatorNode(node) && node.isBinary()) {
          var _a = simplifyCore2(node.args[0], options);
          var a1 = simplifyCore2(node.args[1], options);
          if (node.op === "+") {
            if (isConstantNode(_a)) {
              if (isZero2(_a.value)) {
                return a1;
              } else if (isConstantNode(a1)) {
                return new ConstantNode2(add2(_a.value, a1.value));
              }
            }
            if (isConstantNode(a1) && isZero2(a1.value)) {
              return _a;
            }
            if (isOperatorNode(a1) && a1.isUnary() && a1.op === "-") {
              return new OperatorNode2("-", "subtract", [_a, a1.args[0]]);
            }
            return new OperatorNode2(node.op, node.fn, a1 ? [_a, a1] : [_a]);
          } else if (node.op === "-") {
            if (isConstantNode(_a) && a1) {
              if (isConstantNode(a1)) {
                return new ConstantNode2(subtract2(_a.value, a1.value));
              } else if (isZero2(_a.value)) {
                return new OperatorNode2("-", "unaryMinus", [a1]);
              }
            }
            if (node.fn === "subtract") {
              if (isConstantNode(a1) && isZero2(a1.value)) {
                return _a;
              }
              if (isOperatorNode(a1) && a1.isUnary() && a1.op === "-") {
                return simplifyCore2(new OperatorNode2("+", "add", [_a, a1.args[0]]), options);
              }
              return new OperatorNode2(node.op, node.fn, [_a, a1]);
            }
          } else if (node.op === "*") {
            if (isConstantNode(_a)) {
              if (isZero2(_a.value)) {
                return node0;
              } else if (equal2(_a.value, 1)) {
                return a1;
              } else if (isConstantNode(a1)) {
                return new ConstantNode2(multiply2(_a.value, a1.value));
              }
            }
            if (isConstantNode(a1)) {
              if (isZero2(a1.value)) {
                return node0;
              } else if (equal2(a1.value, 1)) {
                return _a;
              } else if (isOperatorNode(_a) && _a.isBinary() && _a.op === node.op && isCommutative(node, context)) {
                var a00 = _a.args[0];
                if (isConstantNode(a00)) {
                  var a00a1 = new ConstantNode2(multiply2(a00.value, a1.value));
                  return new OperatorNode2(node.op, node.fn, [a00a1, _a.args[1]], node.implicit);
                }
              }
              if (isCommutative(node, context)) {
                return new OperatorNode2(node.op, node.fn, [a1, _a], node.implicit);
              } else {
                return new OperatorNode2(node.op, node.fn, [_a, a1], node.implicit);
              }
            }
            return new OperatorNode2(node.op, node.fn, [_a, a1], node.implicit);
          } else if (node.op === "/") {
            if (isConstantNode(_a)) {
              if (isZero2(_a.value)) {
                return node0;
              } else if (isConstantNode(a1) && (equal2(a1.value, 1) || equal2(a1.value, 2) || equal2(a1.value, 4))) {
                return new ConstantNode2(divide2(_a.value, a1.value));
              }
            }
            return new OperatorNode2(node.op, node.fn, [_a, a1]);
          } else if (node.op === "^") {
            if (isConstantNode(a1)) {
              if (isZero2(a1.value)) {
                return node1;
              } else if (equal2(a1.value, 1)) {
                return _a;
              } else {
                if (isConstantNode(_a)) {
                  return new ConstantNode2(pow2(_a.value, a1.value));
                } else if (isOperatorNode(_a) && _a.isBinary() && _a.op === "^") {
                  var a01 = _a.args[1];
                  if (isConstantNode(a01)) {
                    return new OperatorNode2(node.op, node.fn, [_a.args[0], new ConstantNode2(multiply2(a01.value, a1.value))]);
                  }
                }
              }
            }
          }
          return new OperatorNode2(node.op, node.fn, [_a, a1]);
        } else if (isFunctionNode(node)) {
          return new FunctionNode2(simplifyCore2(node.fn), node.args.map((n) => simplifyCore2(n, options)));
        } else if (isArrayNode(node)) {
          return new ArrayNode2(node.items.map((n) => simplifyCore2(n, options)));
        } else if (isAccessorNode(node)) {
          return new AccessorNode2(simplifyCore2(node.object, options), simplifyCore2(node.index, options));
        } else if (isIndexNode(node)) {
          return new IndexNode2(node.dimensions.map((n) => simplifyCore2(n, options)));
        } else if (isObjectNode(node)) {
          var newProps = {};
          for (var prop in node.properties) {
            newProps[prop] = simplifyCore2(node.properties[prop], options);
          }
          return new ObjectNode2(newProps);
        } else {
        }
        return node;
      }
      return simplifyCore2;
    });
  }
});

// node_modules/mathjs/lib/esm/function/algebra/resolve.js
var name272, dependencies273, createResolve;
var init_resolve2 = __esm({
  "node_modules/mathjs/lib/esm/function/algebra/resolve.js"() {
    init_map();
    init_is();
    init_factory();
    name272 = "resolve";
    dependencies273 = ["parse", "ConstantNode", "FunctionNode", "OperatorNode", "ParenthesisNode"];
    createResolve = /* @__PURE__ */ factory(name272, dependencies273, (_ref) => {
      var {
        parse: parse2,
        ConstantNode: ConstantNode2,
        FunctionNode: FunctionNode2,
        OperatorNode: OperatorNode2,
        ParenthesisNode: ParenthesisNode2
      } = _ref;
      function resolve2(node, scope) {
        var within = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : /* @__PURE__ */ new Set();
        if (!scope) {
          return node;
        }
        if (!isMap(scope)) {
          scope = createMap(scope);
        }
        if (isSymbolNode(node)) {
          if (within.has(node.name)) {
            var variables = Array.from(within).join(", ");
            throw new ReferenceError("recursive loop of variable definitions among {".concat(variables, "}"));
          }
          var value = scope.get(node.name);
          if (isNode(value)) {
            var nextWithin = new Set(within);
            nextWithin.add(node.name);
            return resolve2(value, scope, nextWithin);
          } else if (typeof value === "number") {
            return parse2(String(value));
          } else if (value !== void 0) {
            return new ConstantNode2(value);
          } else {
            return node;
          }
        } else if (isOperatorNode(node)) {
          var args = node.args.map(function(arg2) {
            return resolve2(arg2, scope, within);
          });
          return new OperatorNode2(node.op, node.fn, args, node.implicit);
        } else if (isParenthesisNode(node)) {
          return new ParenthesisNode2(resolve2(node.content, scope, within));
        } else if (isFunctionNode(node)) {
          var _args = node.args.map(function(arg2) {
            return resolve2(arg2, scope, within);
          });
          return new FunctionNode2(node.name, _args);
        }
        return node.map((child2) => resolve2(child2, scope, within));
      }
      return resolve2;
    });
  }
});

// node_modules/mathjs/lib/esm/function/algebra/symbolicEqual.js
var name273, dependencies274, createSymbolicEqual;
var init_symbolicEqual2 = __esm({
  "node_modules/mathjs/lib/esm/function/algebra/symbolicEqual.js"() {
    init_is();
    init_factory();
    name273 = "symbolicEqual";
    dependencies274 = ["parse", "simplify", "typed", "OperatorNode"];
    createSymbolicEqual = /* @__PURE__ */ factory(name273, dependencies274, (_ref) => {
      var {
        parse: parse2,
        simplify: simplify2,
        typed: typed2,
        OperatorNode: OperatorNode2
      } = _ref;
      return typed2(name273, {
        "string, string": function stringString(s1, s2) {
          return this(parse2(s1), parse2(s2), {});
        },
        "string, string, Object": function stringStringObject(s1, s2, options) {
          return this(parse2(s1), parse2(s2), options);
        },
        "Node, string": function NodeString(e1, s2) {
          return this(e1, parse2(s2), {});
        },
        "Node, string, Object": function NodeStringObject(e1, s2, options) {
          return this(e1, parse2(s2), options);
        },
        "string, Node": function stringNode(s1, e22) {
          return this(parse2(s1), e22, {});
        },
        "string, Node, Object": function stringNodeObject(s1, e22, options) {
          return this(parse2(s1), e22, options);
        },
        "Node, Node": function NodeNode(e1, e22) {
          return this(e1, e22, {});
        },
        "Node, Node, Object": function NodeNodeObject(e1, e22, options) {
          var diff2 = new OperatorNode2("-", "subtract", [e1, e22]);
          var simplified = simplify2(diff2, {}, options);
          return isConstantNode(simplified) && !simplified.value;
        }
      });
    });
  }
});

// node_modules/mathjs/lib/esm/function/algebra/derivative.js
var name274, dependencies275, createDerivative;
var init_derivative2 = __esm({
  "node_modules/mathjs/lib/esm/function/algebra/derivative.js"() {
    init_is();
    init_factory();
    name274 = "derivative";
    dependencies275 = ["typed", "config", "parse", "simplify", "equal", "isZero", "numeric", "ConstantNode", "FunctionNode", "OperatorNode", "ParenthesisNode", "SymbolNode"];
    createDerivative = /* @__PURE__ */ factory(name274, dependencies275, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        parse: parse2,
        simplify: simplify2,
        equal: equal2,
        isZero: isZero2,
        numeric: numeric3,
        ConstantNode: ConstantNode2,
        FunctionNode: FunctionNode2,
        OperatorNode: OperatorNode2,
        ParenthesisNode: ParenthesisNode2,
        SymbolNode: SymbolNode2
      } = _ref;
      var derivative2 = typed2("derivative", {
        "Node, SymbolNode, Object": function NodeSymbolNodeObject(expr, variable, options) {
          var constNodes = {};
          constTag(constNodes, expr, variable.name);
          var res = _derivative(expr, constNodes);
          return options.simplify ? simplify2(res) : res;
        },
        "Node, SymbolNode": function NodeSymbolNode(expr, variable) {
          return this(expr, variable, {
            simplify: true
          });
        },
        "string, SymbolNode": function stringSymbolNode(expr, variable) {
          return this(parse2(expr), variable);
        },
        "string, SymbolNode, Object": function stringSymbolNodeObject(expr, variable, options) {
          return this(parse2(expr), variable, options);
        },
        "string, string": function stringString(expr, variable) {
          return this(parse2(expr), parse2(variable));
        },
        "string, string, Object": function stringStringObject(expr, variable, options) {
          return this(parse2(expr), parse2(variable), options);
        },
        "Node, string": function NodeString(expr, variable) {
          return this(expr, parse2(variable));
        },
        "Node, string, Object": function NodeStringObject(expr, variable, options) {
          return this(expr, parse2(variable), options);
        }
      });
      derivative2._simplify = true;
      derivative2.toTex = function(deriv) {
        return _derivTex.apply(null, deriv.args);
      };
      var _derivTex = typed2("_derivTex", {
        "Node, SymbolNode": function NodeSymbolNode(expr, x) {
          if (isConstantNode(expr) && typeOf(expr.value) === "string") {
            return _derivTex(parse2(expr.value).toString(), x.toString(), 1);
          } else {
            return _derivTex(expr.toTex(), x.toString(), 1);
          }
        },
        "Node, ConstantNode": function NodeConstantNode(expr, x) {
          if (typeOf(x.value) === "string") {
            return _derivTex(expr, parse2(x.value));
          } else {
            throw new Error("The second parameter to 'derivative' is a non-string constant");
          }
        },
        "Node, SymbolNode, ConstantNode": function NodeSymbolNodeConstantNode(expr, x, order) {
          return _derivTex(expr.toString(), x.name, order.value);
        },
        "string, string, number": function stringStringNumber(expr, x, order) {
          var d;
          if (order === 1) {
            d = "{d\\over d" + x + "}";
          } else {
            d = "{d^{" + order + "}\\over d" + x + "^{" + order + "}}";
          }
          return d + "\\left[".concat(expr, "\\right]");
        }
      });
      var constTag = typed2("constTag", {
        "Object, ConstantNode, string": function ObjectConstantNodeString(constNodes, node) {
          constNodes[node] = true;
          return true;
        },
        "Object, SymbolNode, string": function ObjectSymbolNodeString(constNodes, node, varName) {
          if (node.name !== varName) {
            constNodes[node] = true;
            return true;
          }
          return false;
        },
        "Object, ParenthesisNode, string": function ObjectParenthesisNodeString(constNodes, node, varName) {
          return constTag(constNodes, node.content, varName);
        },
        "Object, FunctionAssignmentNode, string": function ObjectFunctionAssignmentNodeString(constNodes, node, varName) {
          if (node.params.indexOf(varName) === -1) {
            constNodes[node] = true;
            return true;
          }
          return constTag(constNodes, node.expr, varName);
        },
        "Object, FunctionNode | OperatorNode, string": function ObjectFunctionNodeOperatorNodeString(constNodes, node, varName) {
          if (node.args.length > 0) {
            var isConst = constTag(constNodes, node.args[0], varName);
            for (var i2 = 1; i2 < node.args.length; ++i2) {
              isConst = constTag(constNodes, node.args[i2], varName) && isConst;
            }
            if (isConst) {
              constNodes[node] = true;
              return true;
            }
          }
          return false;
        }
      });
      var _derivative = typed2("_derivative", {
        "ConstantNode, Object": function ConstantNodeObject(node) {
          return createConstantNode2(0);
        },
        "SymbolNode, Object": function SymbolNodeObject(node, constNodes) {
          if (constNodes[node] !== void 0) {
            return createConstantNode2(0);
          }
          return createConstantNode2(1);
        },
        "ParenthesisNode, Object": function ParenthesisNodeObject(node, constNodes) {
          return new ParenthesisNode2(_derivative(node.content, constNodes));
        },
        "FunctionAssignmentNode, Object": function FunctionAssignmentNodeObject(node, constNodes) {
          if (constNodes[node] !== void 0) {
            return createConstantNode2(0);
          }
          return _derivative(node.expr, constNodes);
        },
        "FunctionNode, Object": function FunctionNodeObject(node, constNodes) {
          if (node.args.length !== 1) {
            funcArgsCheck(node);
          }
          if (constNodes[node] !== void 0) {
            return createConstantNode2(0);
          }
          var arg0 = node.args[0];
          var arg1;
          var div = false;
          var negative = false;
          var funcDerivative;
          switch (node.name) {
            case "cbrt":
              div = true;
              funcDerivative = new OperatorNode2("*", "multiply", [createConstantNode2(3), new OperatorNode2("^", "pow", [arg0, new OperatorNode2("/", "divide", [createConstantNode2(2), createConstantNode2(3)])])]);
              break;
            case "sqrt":
            case "nthRoot":
              if (node.args.length === 1) {
                div = true;
                funcDerivative = new OperatorNode2("*", "multiply", [createConstantNode2(2), new FunctionNode2("sqrt", [arg0])]);
              } else if (node.args.length === 2) {
                arg1 = new OperatorNode2("/", "divide", [createConstantNode2(1), node.args[1]]);
                constNodes[arg1] = constNodes[node.args[1]];
                return _derivative(new OperatorNode2("^", "pow", [arg0, arg1]), constNodes);
              }
              break;
            case "log10":
              arg1 = createConstantNode2(10);
            case "log":
              if (!arg1 && node.args.length === 1) {
                funcDerivative = arg0.clone();
                div = true;
              } else if (node.args.length === 1 && arg1 || node.args.length === 2 && constNodes[node.args[1]] !== void 0) {
                funcDerivative = new OperatorNode2("*", "multiply", [arg0.clone(), new FunctionNode2("log", [arg1 || node.args[1]])]);
                div = true;
              } else if (node.args.length === 2) {
                return _derivative(new OperatorNode2("/", "divide", [new FunctionNode2("log", [arg0]), new FunctionNode2("log", [node.args[1]])]), constNodes);
              }
              break;
            case "pow":
              constNodes[arg1] = constNodes[node.args[1]];
              return _derivative(new OperatorNode2("^", "pow", [arg0, node.args[1]]), constNodes);
            case "exp":
              funcDerivative = new FunctionNode2("exp", [arg0.clone()]);
              break;
            case "sin":
              funcDerivative = new FunctionNode2("cos", [arg0.clone()]);
              break;
            case "cos":
              funcDerivative = new OperatorNode2("-", "unaryMinus", [new FunctionNode2("sin", [arg0.clone()])]);
              break;
            case "tan":
              funcDerivative = new OperatorNode2("^", "pow", [new FunctionNode2("sec", [arg0.clone()]), createConstantNode2(2)]);
              break;
            case "sec":
              funcDerivative = new OperatorNode2("*", "multiply", [node, new FunctionNode2("tan", [arg0.clone()])]);
              break;
            case "csc":
              negative = true;
              funcDerivative = new OperatorNode2("*", "multiply", [node, new FunctionNode2("cot", [arg0.clone()])]);
              break;
            case "cot":
              negative = true;
              funcDerivative = new OperatorNode2("^", "pow", [new FunctionNode2("csc", [arg0.clone()]), createConstantNode2(2)]);
              break;
            case "asin":
              div = true;
              funcDerivative = new FunctionNode2("sqrt", [new OperatorNode2("-", "subtract", [createConstantNode2(1), new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)])])]);
              break;
            case "acos":
              div = true;
              negative = true;
              funcDerivative = new FunctionNode2("sqrt", [new OperatorNode2("-", "subtract", [createConstantNode2(1), new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)])])]);
              break;
            case "atan":
              div = true;
              funcDerivative = new OperatorNode2("+", "add", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)]);
              break;
            case "asec":
              div = true;
              funcDerivative = new OperatorNode2("*", "multiply", [new FunctionNode2("abs", [arg0.clone()]), new FunctionNode2("sqrt", [new OperatorNode2("-", "subtract", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])])]);
              break;
            case "acsc":
              div = true;
              negative = true;
              funcDerivative = new OperatorNode2("*", "multiply", [new FunctionNode2("abs", [arg0.clone()]), new FunctionNode2("sqrt", [new OperatorNode2("-", "subtract", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])])]);
              break;
            case "acot":
              div = true;
              negative = true;
              funcDerivative = new OperatorNode2("+", "add", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)]);
              break;
            case "sinh":
              funcDerivative = new FunctionNode2("cosh", [arg0.clone()]);
              break;
            case "cosh":
              funcDerivative = new FunctionNode2("sinh", [arg0.clone()]);
              break;
            case "tanh":
              funcDerivative = new OperatorNode2("^", "pow", [new FunctionNode2("sech", [arg0.clone()]), createConstantNode2(2)]);
              break;
            case "sech":
              negative = true;
              funcDerivative = new OperatorNode2("*", "multiply", [node, new FunctionNode2("tanh", [arg0.clone()])]);
              break;
            case "csch":
              negative = true;
              funcDerivative = new OperatorNode2("*", "multiply", [node, new FunctionNode2("coth", [arg0.clone()])]);
              break;
            case "coth":
              negative = true;
              funcDerivative = new OperatorNode2("^", "pow", [new FunctionNode2("csch", [arg0.clone()]), createConstantNode2(2)]);
              break;
            case "asinh":
              div = true;
              funcDerivative = new FunctionNode2("sqrt", [new OperatorNode2("+", "add", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])]);
              break;
            case "acosh":
              div = true;
              funcDerivative = new FunctionNode2("sqrt", [new OperatorNode2("-", "subtract", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])]);
              break;
            case "atanh":
              div = true;
              funcDerivative = new OperatorNode2("-", "subtract", [createConstantNode2(1), new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)])]);
              break;
            case "asech":
              div = true;
              negative = true;
              funcDerivative = new OperatorNode2("*", "multiply", [arg0.clone(), new FunctionNode2("sqrt", [new OperatorNode2("-", "subtract", [createConstantNode2(1), new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)])])])]);
              break;
            case "acsch":
              div = true;
              negative = true;
              funcDerivative = new OperatorNode2("*", "multiply", [new FunctionNode2("abs", [arg0.clone()]), new FunctionNode2("sqrt", [new OperatorNode2("+", "add", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])])]);
              break;
            case "acoth":
              div = true;
              negative = true;
              funcDerivative = new OperatorNode2("-", "subtract", [createConstantNode2(1), new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)])]);
              break;
            case "abs":
              funcDerivative = new OperatorNode2("/", "divide", [new FunctionNode2(new SymbolNode2("abs"), [arg0.clone()]), arg0.clone()]);
              break;
            case "gamma":
            default:
              throw new Error('Function "' + node.name + '" is not supported by derivative, or a wrong number of arguments is passed');
          }
          var op, func;
          if (div) {
            op = "/";
            func = "divide";
          } else {
            op = "*";
            func = "multiply";
          }
          var chainDerivative = _derivative(arg0, constNodes);
          if (negative) {
            chainDerivative = new OperatorNode2("-", "unaryMinus", [chainDerivative]);
          }
          return new OperatorNode2(op, func, [chainDerivative, funcDerivative]);
        },
        "OperatorNode, Object": function OperatorNodeObject(node, constNodes) {
          if (constNodes[node] !== void 0) {
            return createConstantNode2(0);
          }
          if (node.op === "+") {
            return new OperatorNode2(node.op, node.fn, node.args.map(function(arg2) {
              return _derivative(arg2, constNodes);
            }));
          }
          if (node.op === "-") {
            if (node.isUnary()) {
              return new OperatorNode2(node.op, node.fn, [_derivative(node.args[0], constNodes)]);
            }
            if (node.isBinary()) {
              return new OperatorNode2(node.op, node.fn, [_derivative(node.args[0], constNodes), _derivative(node.args[1], constNodes)]);
            }
          }
          if (node.op === "*") {
            var constantTerms = node.args.filter(function(arg2) {
              return constNodes[arg2] !== void 0;
            });
            if (constantTerms.length > 0) {
              var nonConstantTerms = node.args.filter(function(arg2) {
                return constNodes[arg2] === void 0;
              });
              var nonConstantNode = nonConstantTerms.length === 1 ? nonConstantTerms[0] : new OperatorNode2("*", "multiply", nonConstantTerms);
              var newArgs = constantTerms.concat(_derivative(nonConstantNode, constNodes));
              return new OperatorNode2("*", "multiply", newArgs);
            }
            return new OperatorNode2("+", "add", node.args.map(function(argOuter) {
              return new OperatorNode2("*", "multiply", node.args.map(function(argInner) {
                return argInner === argOuter ? _derivative(argInner, constNodes) : argInner.clone();
              }));
            }));
          }
          if (node.op === "/" && node.isBinary()) {
            var arg0 = node.args[0];
            var arg1 = node.args[1];
            if (constNodes[arg1] !== void 0) {
              return new OperatorNode2("/", "divide", [_derivative(arg0, constNodes), arg1]);
            }
            if (constNodes[arg0] !== void 0) {
              return new OperatorNode2("*", "multiply", [new OperatorNode2("-", "unaryMinus", [arg0]), new OperatorNode2("/", "divide", [_derivative(arg1, constNodes), new OperatorNode2("^", "pow", [arg1.clone(), createConstantNode2(2)])])]);
            }
            return new OperatorNode2("/", "divide", [new OperatorNode2("-", "subtract", [new OperatorNode2("*", "multiply", [_derivative(arg0, constNodes), arg1.clone()]), new OperatorNode2("*", "multiply", [arg0.clone(), _derivative(arg1, constNodes)])]), new OperatorNode2("^", "pow", [arg1.clone(), createConstantNode2(2)])]);
          }
          if (node.op === "^" && node.isBinary()) {
            var _arg = node.args[0];
            var _arg2 = node.args[1];
            if (constNodes[_arg] !== void 0) {
              if (isConstantNode(_arg) && (isZero2(_arg.value) || equal2(_arg.value, 1))) {
                return createConstantNode2(0);
              }
              return new OperatorNode2("*", "multiply", [node, new OperatorNode2("*", "multiply", [new FunctionNode2("log", [_arg.clone()]), _derivative(_arg2.clone(), constNodes)])]);
            }
            if (constNodes[_arg2] !== void 0) {
              if (isConstantNode(_arg2)) {
                if (isZero2(_arg2.value)) {
                  return createConstantNode2(0);
                }
                if (equal2(_arg2.value, 1)) {
                  return _derivative(_arg, constNodes);
                }
              }
              var powMinusOne = new OperatorNode2("^", "pow", [_arg.clone(), new OperatorNode2("-", "subtract", [_arg2, createConstantNode2(1)])]);
              return new OperatorNode2("*", "multiply", [_arg2.clone(), new OperatorNode2("*", "multiply", [_derivative(_arg, constNodes), powMinusOne])]);
            }
            return new OperatorNode2("*", "multiply", [new OperatorNode2("^", "pow", [_arg.clone(), _arg2.clone()]), new OperatorNode2("+", "add", [new OperatorNode2("*", "multiply", [_derivative(_arg, constNodes), new OperatorNode2("/", "divide", [_arg2.clone(), _arg.clone()])]), new OperatorNode2("*", "multiply", [_derivative(_arg2, constNodes), new FunctionNode2("log", [_arg.clone()])])])]);
          }
          throw new Error('Operator "' + node.op + '" is not supported by derivative, or a wrong number of arguments is passed');
        }
      });
      function funcArgsCheck(node) {
        if ((node.name === "log" || node.name === "nthRoot" || node.name === "pow") && node.args.length === 2) {
          return;
        }
        for (var i2 = 0; i2 < node.args.length; ++i2) {
          node.args[i2] = createConstantNode2(0);
        }
        node.compile().evaluate();
        throw new Error("Expected TypeError, but none found");
      }
      function createConstantNode2(value, valueType) {
        return new ConstantNode2(numeric3(value, valueType || config3.number));
      }
      return derivative2;
    });
  }
});

// node_modules/mathjs/lib/esm/function/algebra/rationalize.js
var name275, dependencies276, createRationalize;
var init_rationalize2 = __esm({
  "node_modules/mathjs/lib/esm/function/algebra/rationalize.js"() {
    init_number();
    init_factory();
    init_simplifyConstant();
    name275 = "rationalize";
    dependencies276 = ["config", "typed", "equal", "isZero", "add", "subtract", "multiply", "divide", "pow", "parse", "simplifyCore", "simplify", "?bignumber", "?fraction", "mathWithTransform", "matrix", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "SymbolNode", "ParenthesisNode"];
    createRationalize = /* @__PURE__ */ factory(name275, dependencies276, (_ref) => {
      var {
        config: config3,
        typed: typed2,
        equal: equal2,
        isZero: isZero2,
        add: add2,
        subtract: subtract2,
        multiply: multiply2,
        divide: divide2,
        pow: pow2,
        parse: parse2,
        simplifyCore: simplifyCore2,
        simplify: simplify2,
        fraction: fraction2,
        bignumber: bignumber2,
        mathWithTransform: mathWithTransform2,
        matrix: matrix2,
        AccessorNode: AccessorNode2,
        ArrayNode: ArrayNode2,
        ConstantNode: ConstantNode2,
        FunctionNode: FunctionNode2,
        IndexNode: IndexNode2,
        ObjectNode: ObjectNode2,
        OperatorNode: OperatorNode2,
        SymbolNode: SymbolNode2,
        ParenthesisNode: ParenthesisNode2
      } = _ref;
      var simplifyConstant = createSimplifyConstant({
        typed: typed2,
        config: config3,
        mathWithTransform: mathWithTransform2,
        matrix: matrix2,
        fraction: fraction2,
        bignumber: bignumber2,
        AccessorNode: AccessorNode2,
        ArrayNode: ArrayNode2,
        ConstantNode: ConstantNode2,
        FunctionNode: FunctionNode2,
        IndexNode: IndexNode2,
        ObjectNode: ObjectNode2,
        OperatorNode: OperatorNode2,
        SymbolNode: SymbolNode2
      });
      return typed2(name275, {
        string: function string2(expr) {
          return this(parse2(expr), {}, false);
        },
        "string, boolean": function stringBoolean(expr, detailed) {
          return this(parse2(expr), {}, detailed);
        },
        "string, Object": function stringObject(expr, scope) {
          return this(parse2(expr), scope, false);
        },
        "string, Object, boolean": function stringObjectBoolean(expr, scope, detailed) {
          return this(parse2(expr), scope, detailed);
        },
        Node: function Node2(expr) {
          return this(expr, {}, false);
        },
        "Node, boolean": function NodeBoolean(expr, detailed) {
          return this(expr, {}, detailed);
        },
        "Node, Object": function NodeObject(expr, scope) {
          return this(expr, scope, false);
        },
        "Node, Object, boolean": function NodeObjectBoolean(expr, scope, detailed) {
          var setRules = rulesRationalize();
          var polyRet = polynomial(expr, scope, true, setRules.firstRules);
          var nVars = polyRet.variables.length;
          var noExactFractions = {
            exactFractions: false
          };
          var withExactFractions = {
            exactFractions: true
          };
          expr = polyRet.expression;
          if (nVars >= 1) {
            expr = expandPower(expr);
            var sBefore;
            var rules;
            var eDistrDiv = true;
            var redoInic = false;
            expr = simplify2(expr, setRules.firstRules, {}, noExactFractions);
            var s;
            while (true) {
              rules = eDistrDiv ? setRules.distrDivRules : setRules.sucDivRules;
              expr = simplify2(expr, rules, {}, withExactFractions);
              eDistrDiv = !eDistrDiv;
              s = expr.toString();
              if (s === sBefore) {
                break;
              }
              redoInic = true;
              sBefore = s;
            }
            if (redoInic) {
              expr = simplify2(expr, setRules.firstRulesAgain, {}, noExactFractions);
            }
            expr = simplify2(expr, setRules.finalRules, {}, noExactFractions);
          }
          var coefficients = [];
          var retRationalize = {};
          if (expr.type === "OperatorNode" && expr.isBinary() && expr.op === "/") {
            if (nVars === 1) {
              expr.args[0] = polyToCanonical(expr.args[0], coefficients);
              expr.args[1] = polyToCanonical(expr.args[1]);
            }
            if (detailed) {
              retRationalize.numerator = expr.args[0];
              retRationalize.denominator = expr.args[1];
            }
          } else {
            if (nVars === 1) {
              expr = polyToCanonical(expr, coefficients);
            }
            if (detailed) {
              retRationalize.numerator = expr;
              retRationalize.denominator = null;
            }
          }
          if (!detailed)
            return expr;
          retRationalize.coefficients = coefficients;
          retRationalize.variables = polyRet.variables;
          retRationalize.expression = expr;
          return retRationalize;
        }
      });
      function polynomial(expr, scope, extended, rules) {
        var variables = [];
        var node = simplify2(expr, rules, scope, {
          exactFractions: false
        });
        extended = !!extended;
        var oper = "+-*" + (extended ? "/" : "");
        recPoly(node);
        var retFunc = {};
        retFunc.expression = node;
        retFunc.variables = variables;
        return retFunc;
        function recPoly(node2) {
          var tp = node2.type;
          if (tp === "FunctionNode") {
            throw new Error("There is an unsolved function call");
          } else if (tp === "OperatorNode") {
            if (node2.op === "^") {
              if (node2.args[1].type !== "ConstantNode" || !isInteger(parseFloat(node2.args[1].value))) {
                throw new Error("There is a non-integer exponent");
              } else {
                recPoly(node2.args[0]);
              }
            } else {
              if (oper.indexOf(node2.op) === -1) {
                throw new Error("Operator " + node2.op + " invalid in polynomial expression");
              }
              for (var i2 = 0; i2 < node2.args.length; i2++) {
                recPoly(node2.args[i2]);
              }
            }
          } else if (tp === "SymbolNode") {
            var _name = node2.name;
            var pos = variables.indexOf(_name);
            if (pos === -1) {
              variables.push(_name);
            }
          } else if (tp === "ParenthesisNode") {
            recPoly(node2.content);
          } else if (tp !== "ConstantNode") {
            throw new Error("type " + tp + " is not allowed in polynomial expression");
          }
        }
      }
      function rulesRationalize() {
        var oldRules = [
          simplifyCore2,
          {
            l: "n+n",
            r: "2*n"
          },
          {
            l: "n+-n",
            r: "0"
          },
          simplifyConstant,
          {
            l: "n*(n1^-1)",
            r: "n/n1"
          },
          {
            l: "n*n1^-n2",
            r: "n/n1^n2"
          },
          {
            l: "n1^-1",
            r: "1/n1"
          },
          {
            l: "n*(n1/n2)",
            r: "(n*n1)/n2"
          },
          {
            l: "1*n",
            r: "n"
          }
        ];
        var rulesFirst = [
          {
            l: "(-n1)/(-n2)",
            r: "n1/n2"
          },
          {
            l: "(-n1)*(-n2)",
            r: "n1*n2"
          },
          {
            l: "n1--n2",
            r: "n1+n2"
          },
          {
            l: "n1-n2",
            r: "n1+(-n2)"
          },
          {
            l: "(n1+n2)*n3",
            r: "(n1*n3 + n2*n3)"
          },
          {
            l: "n1*(n2+n3)",
            r: "(n1*n2+n1*n3)"
          },
          {
            l: "c1*n + c2*n",
            r: "(c1+c2)*n"
          },
          {
            l: "c1*n + n",
            r: "(c1+1)*n"
          },
          {
            l: "c1*n - c2*n",
            r: "(c1-c2)*n"
          },
          {
            l: "c1*n - n",
            r: "(c1-1)*n"
          },
          {
            l: "v/c",
            r: "(1/c)*v"
          },
          {
            l: "v/-c",
            r: "-(1/c)*v"
          },
          {
            l: "-v*-c",
            r: "c*v"
          },
          {
            l: "-v*c",
            r: "-c*v"
          },
          {
            l: "v*-c",
            r: "-c*v"
          },
          {
            l: "v*c",
            r: "c*v"
          },
          {
            l: "-(-n1*n2)",
            r: "(n1*n2)"
          },
          {
            l: "-(n1*n2)",
            r: "(-n1*n2)"
          },
          {
            l: "-(-n1+n2)",
            r: "(n1-n2)"
          },
          {
            l: "-(n1+n2)",
            r: "(-n1-n2)"
          },
          {
            l: "(n1^n2)^n3",
            r: "(n1^(n2*n3))"
          },
          {
            l: "-(-n1/n2)",
            r: "(n1/n2)"
          },
          {
            l: "-(n1/n2)",
            r: "(-n1/n2)"
          }
        ];
        var rulesDistrDiv = [
          {
            l: "(n1/n2 + n3/n4)",
            r: "((n1*n4 + n3*n2)/(n2*n4))"
          },
          {
            l: "(n1/n2 + n3)",
            r: "((n1 + n3*n2)/n2)"
          },
          {
            l: "(n1 + n2/n3)",
            r: "((n1*n3 + n2)/n3)"
          }
        ];
        var rulesSucDiv = [
          {
            l: "(n1/(n2/n3))",
            r: "((n1*n3)/n2)"
          },
          {
            l: "(n1/n2/n3)",
            r: "(n1/(n2*n3))"
          }
        ];
        var setRules = {};
        setRules.firstRules = oldRules.concat(rulesFirst, rulesSucDiv);
        setRules.distrDivRules = rulesDistrDiv;
        setRules.sucDivRules = rulesSucDiv;
        setRules.firstRulesAgain = oldRules.concat(rulesFirst);
        setRules.finalRules = [
          simplifyCore2,
          {
            l: "n*-n",
            r: "-n^2"
          },
          {
            l: "n*n",
            r: "n^2"
          },
          simplifyConstant,
          {
            l: "n*-n^n1",
            r: "-n^(n1+1)"
          },
          {
            l: "n*n^n1",
            r: "n^(n1+1)"
          },
          {
            l: "n^n1*-n^n2",
            r: "-n^(n1+n2)"
          },
          {
            l: "n^n1*n^n2",
            r: "n^(n1+n2)"
          },
          {
            l: "n^n1*-n",
            r: "-n^(n1+1)"
          },
          {
            l: "n^n1*n",
            r: "n^(n1+1)"
          },
          {
            l: "n^n1/-n",
            r: "-n^(n1-1)"
          },
          {
            l: "n^n1/n",
            r: "n^(n1-1)"
          },
          {
            l: "n/-n^n1",
            r: "-n^(1-n1)"
          },
          {
            l: "n/n^n1",
            r: "n^(1-n1)"
          },
          {
            l: "n^n1/-n^n2",
            r: "n^(n1-n2)"
          },
          {
            l: "n^n1/n^n2",
            r: "n^(n1-n2)"
          },
          {
            l: "n1+(-n2*n3)",
            r: "n1-n2*n3"
          },
          {
            l: "v*(-c)",
            r: "-c*v"
          },
          {
            l: "n1+-n2",
            r: "n1-n2"
          },
          {
            l: "v*c",
            r: "c*v"
          },
          {
            l: "(n1^n2)^n3",
            r: "(n1^(n2*n3))"
          }
        ];
        return setRules;
      }
      function expandPower(node, parent2, indParent) {
        var tp = node.type;
        var internal = arguments.length > 1;
        if (tp === "OperatorNode" && node.isBinary()) {
          var does = false;
          var val;
          if (node.op === "^") {
            if ((node.args[0].type === "ParenthesisNode" || node.args[0].type === "OperatorNode") && node.args[1].type === "ConstantNode") {
              val = parseFloat(node.args[1].value);
              does = val >= 2 && isInteger(val);
            }
          }
          if (does) {
            if (val > 2) {
              var nEsqTopo = node.args[0];
              var nDirTopo = new OperatorNode2("^", "pow", [node.args[0].cloneDeep(), new ConstantNode2(val - 1)]);
              node = new OperatorNode2("*", "multiply", [nEsqTopo, nDirTopo]);
            } else {
              node = new OperatorNode2("*", "multiply", [node.args[0], node.args[0].cloneDeep()]);
            }
            if (internal) {
              if (indParent === "content") {
                parent2.content = node;
              } else {
                parent2.args[indParent] = node;
              }
            }
          }
        }
        if (tp === "ParenthesisNode") {
          expandPower(node.content, node, "content");
        } else if (tp !== "ConstantNode" && tp !== "SymbolNode") {
          for (var i2 = 0; i2 < node.args.length; i2++) {
            expandPower(node.args[i2], node, i2);
          }
        }
        if (!internal) {
          return node;
        }
      }
      function polyToCanonical(node, coefficients) {
        if (coefficients === void 0) {
          coefficients = [];
        }
        coefficients[0] = 0;
        var o = {};
        o.cte = 1;
        o.oper = "+";
        o.fire = "";
        var maxExpo = 0;
        var varname = "";
        recurPol(node, null, o);
        maxExpo = coefficients.length - 1;
        var first = true;
        var no;
        for (var i2 = maxExpo; i2 >= 0; i2--) {
          if (coefficients[i2] === 0)
            continue;
          var n16 = new ConstantNode2(first ? coefficients[i2] : Math.abs(coefficients[i2]));
          var op = coefficients[i2] < 0 ? "-" : "+";
          if (i2 > 0) {
            var n25 = new SymbolNode2(varname);
            if (i2 > 1) {
              var n3 = new ConstantNode2(i2);
              n25 = new OperatorNode2("^", "pow", [n25, n3]);
            }
            if (coefficients[i2] === -1 && first) {
              n16 = new OperatorNode2("-", "unaryMinus", [n25]);
            } else if (Math.abs(coefficients[i2]) === 1) {
              n16 = n25;
            } else {
              n16 = new OperatorNode2("*", "multiply", [n16, n25]);
            }
          }
          if (first) {
            no = n16;
          } else if (op === "+") {
            no = new OperatorNode2("+", "add", [no, n16]);
          } else {
            no = new OperatorNode2("-", "subtract", [no, n16]);
          }
          first = false;
        }
        if (first) {
          return new ConstantNode2(0);
        } else {
          return no;
        }
        function recurPol(node2, noPai, o2) {
          var tp = node2.type;
          if (tp === "FunctionNode") {
            throw new Error("There is an unsolved function call");
          } else if (tp === "OperatorNode") {
            if ("+-*^".indexOf(node2.op) === -1)
              throw new Error("Operator " + node2.op + " invalid");
            if (noPai !== null) {
              if ((node2.fn === "unaryMinus" || node2.fn === "pow") && noPai.fn !== "add" && noPai.fn !== "subtract" && noPai.fn !== "multiply") {
                throw new Error("Invalid " + node2.op + " placing");
              }
              if ((node2.fn === "subtract" || node2.fn === "add" || node2.fn === "multiply") && noPai.fn !== "add" && noPai.fn !== "subtract") {
                throw new Error("Invalid " + node2.op + " placing");
              }
              if ((node2.fn === "subtract" || node2.fn === "add" || node2.fn === "unaryMinus") && o2.noFil !== 0) {
                throw new Error("Invalid " + node2.op + " placing");
              }
            }
            if (node2.op === "^" || node2.op === "*") {
              o2.fire = node2.op;
            }
            for (var _i = 0; _i < node2.args.length; _i++) {
              if (node2.fn === "unaryMinus")
                o2.oper = "-";
              if (node2.op === "+" || node2.fn === "subtract") {
                o2.fire = "";
                o2.cte = 1;
                o2.oper = _i === 0 ? "+" : node2.op;
              }
              o2.noFil = _i;
              recurPol(node2.args[_i], node2, o2);
            }
          } else if (tp === "SymbolNode") {
            if (node2.name !== varname && varname !== "") {
              throw new Error("There is more than one variable");
            }
            varname = node2.name;
            if (noPai === null) {
              coefficients[1] = 1;
              return;
            }
            if (noPai.op === "^" && o2.noFil !== 0) {
              throw new Error("In power the variable should be the first parameter");
            }
            if (noPai.op === "*" && o2.noFil !== 1) {
              throw new Error("In multiply the variable should be the second parameter");
            }
            if (o2.fire === "" || o2.fire === "*") {
              if (maxExpo < 1)
                coefficients[1] = 0;
              coefficients[1] += o2.cte * (o2.oper === "+" ? 1 : -1);
              maxExpo = Math.max(1, maxExpo);
            }
          } else if (tp === "ConstantNode") {
            var valor = parseFloat(node2.value);
            if (noPai === null) {
              coefficients[0] = valor;
              return;
            }
            if (noPai.op === "^") {
              if (o2.noFil !== 1)
                throw new Error("Constant cannot be powered");
              if (!isInteger(valor) || valor <= 0) {
                throw new Error("Non-integer exponent is not allowed");
              }
              for (var _i2 = maxExpo + 1; _i2 < valor; _i2++) {
                coefficients[_i2] = 0;
              }
              if (valor > maxExpo)
                coefficients[valor] = 0;
              coefficients[valor] += o2.cte * (o2.oper === "+" ? 1 : -1);
              maxExpo = Math.max(valor, maxExpo);
              return;
            }
            o2.cte = valor;
            if (o2.fire === "") {
              coefficients[0] += o2.cte * (o2.oper === "+" ? 1 : -1);
            }
          } else {
            throw new Error("Type " + tp + " is not allowed");
          }
        }
      }
    });
  }
});

// node_modules/mathjs/lib/esm/json/reviver.js
var name276, dependencies277, createReviver;
var init_reviver = __esm({
  "node_modules/mathjs/lib/esm/json/reviver.js"() {
    init_factory();
    name276 = "reviver";
    dependencies277 = ["classes"];
    createReviver = /* @__PURE__ */ factory(name276, dependencies277, (_ref) => {
      var {
        classes: classes2
      } = _ref;
      return function reviver2(key, value) {
        var constructor = classes2[value && value.mathjs];
        if (constructor && typeof constructor.fromJSON === "function") {
          return constructor.fromJSON(value);
        }
        return value;
      };
    });
  }
});

// node_modules/mathjs/lib/esm/json/replacer.js
var name277, dependencies278, createReplacer;
var init_replacer = __esm({
  "node_modules/mathjs/lib/esm/json/replacer.js"() {
    init_factory();
    name277 = "replacer";
    dependencies278 = [];
    createReplacer = /* @__PURE__ */ factory(name277, dependencies278, () => {
      return function replacer2(key, value) {
        if (typeof value === "number" && (!isFinite(value) || isNaN(value))) {
          return {
            mathjs: "number",
            value: String(value)
          };
        }
        return value;
      };
    });
  }
});

// node_modules/mathjs/lib/esm/version.js
var version;
var init_version2 = __esm({
  "node_modules/mathjs/lib/esm/version.js"() {
    version = "10.6.4";
  }
});

// node_modules/mathjs/lib/esm/constants.js
function recreateFactory(name296, dependencies297, create) {
  return factory(name296, dependencies297, create, {
    recreateOnConfigChange: true
  });
}
var createTrue, createFalse, createNull, createInfinity, createNaN, createPi, createTau, createE, createPhi, createLN2, createLN10, createLOG2E, createLOG10E, createSQRT1_2, createSQRT2, createI, createVersion;
var init_constants3 = __esm({
  "node_modules/mathjs/lib/esm/constants.js"() {
    init_factory();
    init_version2();
    init_constants2();
    init_number2();
    createTrue = /* @__PURE__ */ factory("true", [], () => true);
    createFalse = /* @__PURE__ */ factory("false", [], () => false);
    createNull = /* @__PURE__ */ factory("null", [], () => null);
    createInfinity = /* @__PURE__ */ recreateFactory("Infinity", ["config", "?BigNumber"], (_ref) => {
      var {
        config: config3,
        BigNumber: BigNumber2
      } = _ref;
      return config3.number === "BigNumber" ? new BigNumber2(Infinity) : Infinity;
    });
    createNaN = /* @__PURE__ */ recreateFactory("NaN", ["config", "?BigNumber"], (_ref2) => {
      var {
        config: config3,
        BigNumber: BigNumber2
      } = _ref2;
      return config3.number === "BigNumber" ? new BigNumber2(NaN) : NaN;
    });
    createPi = /* @__PURE__ */ recreateFactory("pi", ["config", "?BigNumber"], (_ref3) => {
      var {
        config: config3,
        BigNumber: BigNumber2
      } = _ref3;
      return config3.number === "BigNumber" ? createBigNumberPi(BigNumber2) : pi;
    });
    createTau = /* @__PURE__ */ recreateFactory("tau", ["config", "?BigNumber"], (_ref4) => {
      var {
        config: config3,
        BigNumber: BigNumber2
      } = _ref4;
      return config3.number === "BigNumber" ? createBigNumberTau(BigNumber2) : tau;
    });
    createE = /* @__PURE__ */ recreateFactory("e", ["config", "?BigNumber"], (_ref5) => {
      var {
        config: config3,
        BigNumber: BigNumber2
      } = _ref5;
      return config3.number === "BigNumber" ? createBigNumberE(BigNumber2) : e;
    });
    createPhi = /* @__PURE__ */ recreateFactory("phi", ["config", "?BigNumber"], (_ref6) => {
      var {
        config: config3,
        BigNumber: BigNumber2
      } = _ref6;
      return config3.number === "BigNumber" ? createBigNumberPhi(BigNumber2) : phi;
    });
    createLN2 = /* @__PURE__ */ recreateFactory("LN2", ["config", "?BigNumber"], (_ref7) => {
      var {
        config: config3,
        BigNumber: BigNumber2
      } = _ref7;
      return config3.number === "BigNumber" ? new BigNumber2(2).ln() : Math.LN2;
    });
    createLN10 = /* @__PURE__ */ recreateFactory("LN10", ["config", "?BigNumber"], (_ref8) => {
      var {
        config: config3,
        BigNumber: BigNumber2
      } = _ref8;
      return config3.number === "BigNumber" ? new BigNumber2(10).ln() : Math.LN10;
    });
    createLOG2E = /* @__PURE__ */ recreateFactory("LOG2E", ["config", "?BigNumber"], (_ref9) => {
      var {
        config: config3,
        BigNumber: BigNumber2
      } = _ref9;
      return config3.number === "BigNumber" ? new BigNumber2(1).div(new BigNumber2(2).ln()) : Math.LOG2E;
    });
    createLOG10E = /* @__PURE__ */ recreateFactory("LOG10E", ["config", "?BigNumber"], (_ref10) => {
      var {
        config: config3,
        BigNumber: BigNumber2
      } = _ref10;
      return config3.number === "BigNumber" ? new BigNumber2(1).div(new BigNumber2(10).ln()) : Math.LOG10E;
    });
    createSQRT1_2 = /* @__PURE__ */ recreateFactory(
      "SQRT1_2",
      ["config", "?BigNumber"],
      (_ref11) => {
        var {
          config: config3,
          BigNumber: BigNumber2
        } = _ref11;
        return config3.number === "BigNumber" ? new BigNumber2("0.5").sqrt() : Math.SQRT1_2;
      }
    );
    createSQRT2 = /* @__PURE__ */ recreateFactory("SQRT2", ["config", "?BigNumber"], (_ref12) => {
      var {
        config: config3,
        BigNumber: BigNumber2
      } = _ref12;
      return config3.number === "BigNumber" ? new BigNumber2(2).sqrt() : Math.SQRT2;
    });
    createI = /* @__PURE__ */ recreateFactory("i", ["Complex"], (_ref13) => {
      var {
        Complex: Complex3
      } = _ref13;
      return Complex3.I;
    });
    createVersion = /* @__PURE__ */ factory("version", [], () => version);
  }
});

// node_modules/mathjs/lib/esm/type/unit/physicalConstants.js
function unitFactory(name296, valueStr, unitStr) {
  var dependencies297 = ["config", "Unit", "BigNumber"];
  return factory(name296, dependencies297, (_ref) => {
    var {
      config: config3,
      Unit: Unit2,
      BigNumber: BigNumber2
    } = _ref;
    var value = config3.number === "BigNumber" ? new BigNumber2(valueStr) : parseFloat(valueStr);
    var unit2 = new Unit2(value, unitStr);
    unit2.fixPrefix = true;
    return unit2;
  });
}
function numberFactory(name296, value) {
  var dependencies297 = ["config", "BigNumber"];
  return factory(name296, dependencies297, (_ref2) => {
    var {
      config: config3,
      BigNumber: BigNumber2
    } = _ref2;
    return config3.number === "BigNumber" ? new BigNumber2(value) : value;
  });
}
var createSpeedOfLight, createGravitationConstant, createPlanckConstant, createReducedPlanckConstant, createMagneticConstant, createElectricConstant, createVacuumImpedance, createCoulomb, createElementaryCharge, createBohrMagneton, createConductanceQuantum, createInverseConductanceQuantum, createMagneticFluxQuantum, createNuclearMagneton, createKlitzing, createBohrRadius, createClassicalElectronRadius, createElectronMass, createFermiCoupling, createFineStructure, createHartreeEnergy, createProtonMass, createDeuteronMass, createNeutronMass, createQuantumOfCirculation, createRydberg, createThomsonCrossSection, createWeakMixingAngle, createEfimovFactor, createAtomicMass, createAvogadro, createBoltzmann, createFaraday, createFirstRadiation, createLoschmidt, createGasConstant, createMolarPlanckConstant, createMolarVolume, createSackurTetrode, createSecondRadiation, createStefanBoltzmann, createWienDisplacement, createMolarMass, createMolarMassC12, createGravity, createPlanckLength, createPlanckMass, createPlanckTime, createPlanckCharge, createPlanckTemperature;
var init_physicalConstants = __esm({
  "node_modules/mathjs/lib/esm/type/unit/physicalConstants.js"() {
    init_factory();
    createSpeedOfLight = /* @__PURE__ */ unitFactory("speedOfLight", "299792458", "m s^-1");
    createGravitationConstant = /* @__PURE__ */ unitFactory("gravitationConstant", "6.67430e-11", "m^3 kg^-1 s^-2");
    createPlanckConstant = /* @__PURE__ */ unitFactory("planckConstant", "6.62607015e-34", "J s");
    createReducedPlanckConstant = /* @__PURE__ */ unitFactory("reducedPlanckConstant", "1.0545718176461565e-34", "J s");
    createMagneticConstant = /* @__PURE__ */ unitFactory("magneticConstant", "1.25663706212e-6", "N A^-2");
    createElectricConstant = /* @__PURE__ */ unitFactory("electricConstant", "8.8541878128e-12", "F m^-1");
    createVacuumImpedance = /* @__PURE__ */ unitFactory("vacuumImpedance", "376.730313667", "ohm");
    createCoulomb = /* @__PURE__ */ unitFactory("coulomb", "8.987551792261171e9", "N m^2 C^-2");
    createElementaryCharge = /* @__PURE__ */ unitFactory("elementaryCharge", "1.602176634e-19", "C");
    createBohrMagneton = /* @__PURE__ */ unitFactory("bohrMagneton", "9.2740100783e-24", "J T^-1");
    createConductanceQuantum = /* @__PURE__ */ unitFactory("conductanceQuantum", "7.748091729863649e-5", "S");
    createInverseConductanceQuantum = /* @__PURE__ */ unitFactory("inverseConductanceQuantum", "12906.403729652257", "ohm");
    createMagneticFluxQuantum = /* @__PURE__ */ unitFactory("magneticFluxQuantum", "2.0678338484619295e-15", "Wb");
    createNuclearMagneton = /* @__PURE__ */ unitFactory("nuclearMagneton", "5.0507837461e-27", "J T^-1");
    createKlitzing = /* @__PURE__ */ unitFactory("klitzing", "25812.807459304513", "ohm");
    createBohrRadius = /* @__PURE__ */ unitFactory("bohrRadius", "5.29177210903e-11", "m");
    createClassicalElectronRadius = /* @__PURE__ */ unitFactory("classicalElectronRadius", "2.8179403262e-15", "m");
    createElectronMass = /* @__PURE__ */ unitFactory("electronMass", "9.1093837015e-31", "kg");
    createFermiCoupling = /* @__PURE__ */ unitFactory("fermiCoupling", "1.1663787e-5", "GeV^-2");
    createFineStructure = numberFactory("fineStructure", 0.0072973525693);
    createHartreeEnergy = /* @__PURE__ */ unitFactory("hartreeEnergy", "4.3597447222071e-18", "J");
    createProtonMass = /* @__PURE__ */ unitFactory("protonMass", "1.67262192369e-27", "kg");
    createDeuteronMass = /* @__PURE__ */ unitFactory("deuteronMass", "3.3435830926e-27", "kg");
    createNeutronMass = /* @__PURE__ */ unitFactory("neutronMass", "1.6749271613e-27", "kg");
    createQuantumOfCirculation = /* @__PURE__ */ unitFactory("quantumOfCirculation", "3.6369475516e-4", "m^2 s^-1");
    createRydberg = /* @__PURE__ */ unitFactory("rydberg", "10973731.568160", "m^-1");
    createThomsonCrossSection = /* @__PURE__ */ unitFactory("thomsonCrossSection", "6.6524587321e-29", "m^2");
    createWeakMixingAngle = numberFactory("weakMixingAngle", 0.2229);
    createEfimovFactor = numberFactory("efimovFactor", 22.7);
    createAtomicMass = /* @__PURE__ */ unitFactory("atomicMass", "1.66053906660e-27", "kg");
    createAvogadro = /* @__PURE__ */ unitFactory("avogadro", "6.02214076e23", "mol^-1");
    createBoltzmann = /* @__PURE__ */ unitFactory("boltzmann", "1.380649e-23", "J K^-1");
    createFaraday = /* @__PURE__ */ unitFactory("faraday", "96485.33212331001", "C mol^-1");
    createFirstRadiation = /* @__PURE__ */ unitFactory("firstRadiation", "3.7417718521927573e-16", "W m^2");
    createLoschmidt = /* @__PURE__ */ unitFactory("loschmidt", "2.686780111798444e25", "m^-3");
    createGasConstant = /* @__PURE__ */ unitFactory("gasConstant", "8.31446261815324", "J K^-1 mol^-1");
    createMolarPlanckConstant = /* @__PURE__ */ unitFactory("molarPlanckConstant", "3.990312712893431e-10", "J s mol^-1");
    createMolarVolume = /* @__PURE__ */ unitFactory("molarVolume", "0.022413969545014137", "m^3 mol^-1");
    createSackurTetrode = numberFactory("sackurTetrode", -1.16487052358);
    createSecondRadiation = /* @__PURE__ */ unitFactory("secondRadiation", "0.014387768775039337", "m K");
    createStefanBoltzmann = /* @__PURE__ */ unitFactory("stefanBoltzmann", "5.67037441918443e-8", "W m^-2 K^-4");
    createWienDisplacement = /* @__PURE__ */ unitFactory("wienDisplacement", "2.897771955e-3", "m K");
    createMolarMass = /* @__PURE__ */ unitFactory("molarMass", "0.99999999965e-3", "kg mol^-1");
    createMolarMassC12 = /* @__PURE__ */ unitFactory("molarMassC12", "11.9999999958e-3", "kg mol^-1");
    createGravity = /* @__PURE__ */ unitFactory("gravity", "9.80665", "m s^-2");
    createPlanckLength = /* @__PURE__ */ unitFactory("planckLength", "1.616255e-35", "m");
    createPlanckMass = /* @__PURE__ */ unitFactory("planckMass", "2.176435e-8", "kg");
    createPlanckTime = /* @__PURE__ */ unitFactory("planckTime", "5.391245e-44", "s");
    createPlanckCharge = /* @__PURE__ */ unitFactory("planckCharge", "1.87554603778e-18", "C");
    createPlanckTemperature = /* @__PURE__ */ unitFactory("planckTemperature", "1.416785e+32", "K");
  }
});

// node_modules/mathjs/lib/esm/expression/transform/apply.transform.js
var name278, dependencies279, createApplyTransform;
var init_apply_transform = __esm({
  "node_modules/mathjs/lib/esm/expression/transform/apply.transform.js"() {
    init_errorTransform();
    init_factory();
    init_apply();
    init_is();
    name278 = "apply";
    dependencies279 = ["typed", "isInteger"];
    createApplyTransform = /* @__PURE__ */ factory(name278, dependencies279, (_ref) => {
      var {
        typed: typed2,
        isInteger: isInteger3
      } = _ref;
      var apply2 = createApply({
        typed: typed2,
        isInteger: isInteger3
      });
      return typed2("apply", {
        "...any": function any(args) {
          var dim = args[1];
          if (isNumber2(dim)) {
            args[1] = dim - 1;
          } else if (isBigNumber(dim)) {
            args[1] = dim.minus(1);
          }
          try {
            return apply2.apply(null, args);
          } catch (err) {
            throw errorTransform(err);
          }
        }
      });
    }, {
      isTransformFunction: true
    });
  }
});

// node_modules/mathjs/lib/esm/expression/transform/column.transform.js
var name279, dependencies280, createColumnTransform;
var init_column_transform = __esm({
  "node_modules/mathjs/lib/esm/expression/transform/column.transform.js"() {
    init_errorTransform();
    init_factory();
    init_column();
    init_is();
    name279 = "column";
    dependencies280 = ["typed", "Index", "matrix", "range"];
    createColumnTransform = /* @__PURE__ */ factory(name279, dependencies280, (_ref) => {
      var {
        typed: typed2,
        Index: Index2,
        matrix: matrix2,
        range: range2
      } = _ref;
      var column2 = createColumn({
        typed: typed2,
        Index: Index2,
        matrix: matrix2,
        range: range2
      });
      return typed2("column", {
        "...any": function any(args) {
          var lastIndex = args.length - 1;
          var last = args[lastIndex];
          if (isNumber2(last)) {
            args[lastIndex] = last - 1;
          }
          try {
            return column2.apply(null, args);
          } catch (err) {
            throw errorTransform(err);
          }
        }
      });
    }, {
      isTransformFunction: true
    });
  }
});

// node_modules/mathjs/lib/esm/expression/transform/utils/compileInlineExpression.js
function compileInlineExpression(expression, math2, scope) {
  var symbol = expression.filter(function(node) {
    return isSymbolNode(node) && !(node.name in math2) && !scope.has(node.name);
  })[0];
  if (!symbol) {
    throw new Error('No undefined variable found in inline expression "' + expression + '"');
  }
  var name296 = symbol.name;
  var subScope = createSubScope(scope);
  var eq = expression.compile();
  return function inlineExpression(x) {
    subScope.set(name296, x);
    return eq.evaluate(subScope);
  };
}
var init_compileInlineExpression = __esm({
  "node_modules/mathjs/lib/esm/expression/transform/utils/compileInlineExpression.js"() {
    init_is();
    init_scope();
  }
});

// node_modules/mathjs/lib/esm/expression/transform/filter.transform.js
function _filter(x, callback) {
  var args = maxArgumentCount(callback);
  return filter(x, function(value, index2, array) {
    if (args === 1) {
      return callback(value);
    } else if (args === 2) {
      return callback(value, [index2 + 1]);
    } else {
      return callback(value, [index2 + 1], array);
    }
  });
}
var name280, dependencies281, createFilterTransform;
var init_filter_transform = __esm({
  "node_modules/mathjs/lib/esm/expression/transform/filter.transform.js"() {
    init_is();
    init_array();
    init_function();
    init_compileInlineExpression();
    init_factory();
    name280 = "filter";
    dependencies281 = ["typed"];
    createFilterTransform = /* @__PURE__ */ factory(name280, dependencies281, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      function filterTransform(args, math2, scope) {
        var x, callback;
        if (args[0]) {
          x = args[0].compile().evaluate(scope);
        }
        if (args[1]) {
          if (isSymbolNode(args[1]) || isFunctionAssignmentNode(args[1])) {
            callback = args[1].compile().evaluate(scope);
          } else {
            callback = compileInlineExpression(args[1], math2, scope);
          }
        }
        return filter3(x, callback);
      }
      filterTransform.rawArgs = true;
      var filter3 = typed2("filter", {
        "Array, function": _filter,
        "Matrix, function": function MatrixFunction(x, test) {
          return x.create(_filter(x.toArray(), test));
        },
        "Array, RegExp": filterRegExp,
        "Matrix, RegExp": function MatrixRegExp(x, test) {
          return x.create(filterRegExp(x.toArray(), test));
        }
      });
      return filterTransform;
    }, {
      isTransformFunction: true
    });
  }
});

// node_modules/mathjs/lib/esm/expression/transform/forEach.transform.js
var name281, dependencies282, createForEachTransform;
var init_forEach_transform = __esm({
  "node_modules/mathjs/lib/esm/expression/transform/forEach.transform.js"() {
    init_is();
    init_function();
    init_array();
    init_factory();
    init_compileInlineExpression();
    name281 = "forEach";
    dependencies282 = ["typed"];
    createForEachTransform = /* @__PURE__ */ factory(name281, dependencies282, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      function forEachTransform(args, math2, scope) {
        var x, callback;
        if (args[0]) {
          x = args[0].compile().evaluate(scope);
        }
        if (args[1]) {
          if (isSymbolNode(args[1]) || isFunctionAssignmentNode(args[1])) {
            callback = args[1].compile().evaluate(scope);
          } else {
            callback = compileInlineExpression(args[1], math2, scope);
          }
        }
        return _forEach2(x, callback);
      }
      forEachTransform.rawArgs = true;
      var _forEach2 = typed2("forEach", {
        "Array | Matrix, function": function ArrayMatrixFunction(array, callback) {
          var args = maxArgumentCount(callback);
          var recurse = function recurse2(value, index2) {
            if (Array.isArray(value)) {
              forEach(value, function(child2, i2) {
                recurse2(child2, index2.concat(i2 + 1));
              });
            } else {
              if (args === 1) {
                callback(value);
              } else if (args === 2) {
                callback(value, index2);
              } else {
                callback(value, index2, array);
              }
            }
          };
          recurse(array.valueOf(), []);
        }
      });
      return forEachTransform;
    }, {
      isTransformFunction: true
    });
  }
});

// node_modules/mathjs/lib/esm/expression/transform/index.transform.js
var name282, dependencies283, createIndexTransform;
var init_index_transform = __esm({
  "node_modules/mathjs/lib/esm/expression/transform/index.transform.js"() {
    init_is();
    init_factory();
    name282 = "index";
    dependencies283 = ["Index"];
    createIndexTransform = /* @__PURE__ */ factory(name282, dependencies283, (_ref) => {
      var {
        Index: Index2
      } = _ref;
      return function indexTransform() {
        var args = [];
        for (var i2 = 0, ii = arguments.length; i2 < ii; i2++) {
          var arg2 = arguments[i2];
          if (isRange(arg2)) {
            arg2.start--;
            arg2.end -= arg2.step > 0 ? 0 : 2;
          } else if (arg2 && arg2.isSet === true) {
            arg2 = arg2.map(function(v) {
              return v - 1;
            });
          } else if (isArray(arg2) || isMatrix(arg2)) {
            arg2 = arg2.map(function(v) {
              return v - 1;
            });
          } else if (isNumber2(arg2)) {
            arg2--;
          } else if (isBigNumber(arg2)) {
            arg2 = arg2.toNumber() - 1;
          } else if (typeof arg2 === "string") {
          } else {
            throw new TypeError("Dimension must be an Array, Matrix, number, string, or Range");
          }
          args[i2] = arg2;
        }
        var res = new Index2();
        Index2.apply(res, args);
        return res;
      };
    }, {
      isTransformFunction: true
    });
  }
});

// node_modules/mathjs/lib/esm/expression/transform/map.transform.js
function _map2(array, callback, orig) {
  var argsCount = maxArgumentCount(callback);
  function recurse(value, index2) {
    if (Array.isArray(value)) {
      return map(value, function(child2, i2) {
        return recurse(child2, index2.concat(i2 + 1));
      });
    } else {
      if (argsCount === 1) {
        return callback(value);
      } else if (argsCount === 2) {
        return callback(value, index2);
      } else {
        return callback(value, index2, orig);
      }
    }
  }
  return recurse(array, []);
}
var name283, dependencies284, createMapTransform;
var init_map_transform = __esm({
  "node_modules/mathjs/lib/esm/expression/transform/map.transform.js"() {
    init_is();
    init_function();
    init_array();
    init_factory();
    init_compileInlineExpression();
    name283 = "map";
    dependencies284 = ["typed"];
    createMapTransform = /* @__PURE__ */ factory(name283, dependencies284, (_ref) => {
      var {
        typed: typed2
      } = _ref;
      function mapTransform(args, math2, scope) {
        var x, callback;
        if (args[0]) {
          x = args[0].compile().evaluate(scope);
        }
        if (args[1]) {
          if (isSymbolNode(args[1]) || isFunctionAssignmentNode(args[1])) {
            callback = args[1].compile().evaluate(scope);
          } else {
            callback = compileInlineExpression(args[1], math2, scope);
          }
        }
        return map3(x, callback);
      }
      mapTransform.rawArgs = true;
      var map3 = typed2("map", {
        "Array, function": function ArrayFunction(x, callback) {
          return _map2(x, callback, x);
        },
        "Matrix, function": function MatrixFunction(x, callback) {
          return x.create(_map2(x.valueOf(), callback, x));
        }
      });
      return mapTransform;
    }, {
      isTransformFunction: true
    });
  }
});

// node_modules/mathjs/lib/esm/expression/transform/utils/lastDimToZeroBase.js
function lastDimToZeroBase(args) {
  if (args.length === 2 && isCollection(args[0])) {
    args = args.slice();
    var dim = args[1];
    if (isNumber2(dim)) {
      args[1] = dim - 1;
    } else if (isBigNumber(dim)) {
      args[1] = dim.minus(1);
    }
  }
  return args;
}
var init_lastDimToZeroBase = __esm({
  "node_modules/mathjs/lib/esm/expression/transform/utils/lastDimToZeroBase.js"() {
    init_is();
  }
});

// node_modules/mathjs/lib/esm/expression/transform/max.transform.js
var name284, dependencies285, createMaxTransform;
var init_max_transform = __esm({
  "node_modules/mathjs/lib/esm/expression/transform/max.transform.js"() {
    init_factory();
    init_errorTransform();
    init_max();
    init_lastDimToZeroBase();
    name284 = "max";
    dependencies285 = ["typed", "config", "numeric", "larger"];
    createMaxTransform = /* @__PURE__ */ factory(name284, dependencies285, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        numeric: numeric3,
        larger: larger2
      } = _ref;
      var max2 = createMax({
        typed: typed2,
        config: config3,
        numeric: numeric3,
        larger: larger2
      });
      return typed2("max", {
        "...any": function any(args) {
          args = lastDimToZeroBase(args);
          try {
            return max2.apply(null, args);
          } catch (err) {
            throw errorTransform(err);
          }
        }
      });
    }, {
      isTransformFunction: true
    });
  }
});

// node_modules/mathjs/lib/esm/expression/transform/mean.transform.js
var name285, dependencies286, createMeanTransform;
var init_mean_transform = __esm({
  "node_modules/mathjs/lib/esm/expression/transform/mean.transform.js"() {
    init_factory();
    init_errorTransform();
    init_mean2();
    init_lastDimToZeroBase();
    name285 = "mean";
    dependencies286 = ["typed", "add", "divide"];
    createMeanTransform = /* @__PURE__ */ factory(name285, dependencies286, (_ref) => {
      var {
        typed: typed2,
        add: add2,
        divide: divide2
      } = _ref;
      var mean2 = createMean({
        typed: typed2,
        add: add2,
        divide: divide2
      });
      return typed2("mean", {
        "...any": function any(args) {
          args = lastDimToZeroBase(args);
          try {
            return mean2.apply(null, args);
          } catch (err) {
            throw errorTransform(err);
          }
        }
      });
    }, {
      isTransformFunction: true
    });
  }
});

// node_modules/mathjs/lib/esm/expression/transform/min.transform.js
var name286, dependencies287, createMinTransform;
var init_min_transform = __esm({
  "node_modules/mathjs/lib/esm/expression/transform/min.transform.js"() {
    init_factory();
    init_errorTransform();
    init_min();
    init_lastDimToZeroBase();
    name286 = "min";
    dependencies287 = ["typed", "config", "numeric", "smaller"];
    createMinTransform = /* @__PURE__ */ factory(name286, dependencies287, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        numeric: numeric3,
        smaller: smaller2
      } = _ref;
      var min2 = createMin({
        typed: typed2,
        config: config3,
        numeric: numeric3,
        smaller: smaller2
      });
      return typed2("min", {
        "...any": function any(args) {
          args = lastDimToZeroBase(args);
          try {
            return min2.apply(null, args);
          } catch (err) {
            throw errorTransform(err);
          }
        }
      });
    }, {
      isTransformFunction: true
    });
  }
});

// node_modules/mathjs/lib/esm/expression/transform/range.transform.js
var name287, dependencies288, createRangeTransform;
var init_range_transform = __esm({
  "node_modules/mathjs/lib/esm/expression/transform/range.transform.js"() {
    init_factory();
    init_range();
    name287 = "range";
    dependencies288 = ["typed", "config", "?matrix", "?bignumber", "smaller", "smallerEq", "larger", "largerEq"];
    createRangeTransform = /* @__PURE__ */ factory(name287, dependencies288, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        matrix: matrix2,
        bignumber: bignumber2,
        smaller: smaller2,
        smallerEq: smallerEq2,
        larger: larger2,
        largerEq: largerEq2
      } = _ref;
      var range2 = createRange({
        typed: typed2,
        config: config3,
        matrix: matrix2,
        bignumber: bignumber2,
        smaller: smaller2,
        smallerEq: smallerEq2,
        larger: larger2,
        largerEq: largerEq2
      });
      return typed2("range", {
        "...any": function any(args) {
          var lastIndex = args.length - 1;
          var last = args[lastIndex];
          if (typeof last !== "boolean") {
            args.push(true);
          }
          return range2.apply(null, args);
        }
      });
    }, {
      isTransformFunction: true
    });
  }
});

// node_modules/mathjs/lib/esm/expression/transform/row.transform.js
var name288, dependencies289, createRowTransform;
var init_row_transform = __esm({
  "node_modules/mathjs/lib/esm/expression/transform/row.transform.js"() {
    init_factory();
    init_row();
    init_errorTransform();
    init_is();
    name288 = "row";
    dependencies289 = ["typed", "Index", "matrix", "range"];
    createRowTransform = /* @__PURE__ */ factory(name288, dependencies289, (_ref) => {
      var {
        typed: typed2,
        Index: Index2,
        matrix: matrix2,
        range: range2
      } = _ref;
      var row2 = createRow({
        typed: typed2,
        Index: Index2,
        matrix: matrix2,
        range: range2
      });
      return typed2("row", {
        "...any": function any(args) {
          var lastIndex = args.length - 1;
          var last = args[lastIndex];
          if (isNumber2(last)) {
            args[lastIndex] = last - 1;
          }
          try {
            return row2.apply(null, args);
          } catch (err) {
            throw errorTransform(err);
          }
        }
      });
    }, {
      isTransformFunction: true
    });
  }
});

// node_modules/mathjs/lib/esm/expression/transform/subset.transform.js
var name289, dependencies290, createSubsetTransform;
var init_subset_transform = __esm({
  "node_modules/mathjs/lib/esm/expression/transform/subset.transform.js"() {
    init_factory();
    init_errorTransform();
    init_subset();
    name289 = "subset";
    dependencies290 = ["typed", "matrix"];
    createSubsetTransform = /* @__PURE__ */ factory(name289, dependencies290, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2
      } = _ref;
      var subset2 = createSubset({
        typed: typed2,
        matrix: matrix2
      });
      return typed2("subset", {
        "...any": function any(args) {
          try {
            return subset2.apply(null, args);
          } catch (err) {
            throw errorTransform(err);
          }
        }
      });
    }, {
      isTransformFunction: true
    });
  }
});

// node_modules/mathjs/lib/esm/expression/transform/concat.transform.js
var name290, dependencies291, createConcatTransform;
var init_concat_transform = __esm({
  "node_modules/mathjs/lib/esm/expression/transform/concat.transform.js"() {
    init_is();
    init_errorTransform();
    init_factory();
    init_concat();
    name290 = "concat";
    dependencies291 = ["typed", "matrix", "isInteger"];
    createConcatTransform = /* @__PURE__ */ factory(name290, dependencies291, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        isInteger: isInteger3
      } = _ref;
      var concat2 = createConcat({
        typed: typed2,
        matrix: matrix2,
        isInteger: isInteger3
      });
      return typed2("concat", {
        "...any": function any(args) {
          var lastIndex = args.length - 1;
          var last = args[lastIndex];
          if (isNumber2(last)) {
            args[lastIndex] = last - 1;
          } else if (isBigNumber(last)) {
            args[lastIndex] = last.minus(1);
          }
          try {
            return concat2.apply(null, args);
          } catch (err) {
            throw errorTransform(err);
          }
        }
      });
    }, {
      isTransformFunction: true
    });
  }
});

// node_modules/mathjs/lib/esm/expression/transform/diff.transform.js
var name291, dependencies292, createDiffTransform;
var init_diff_transform = __esm({
  "node_modules/mathjs/lib/esm/expression/transform/diff.transform.js"() {
    init_factory();
    init_errorTransform();
    init_diff();
    init_lastDimToZeroBase();
    name291 = "diff";
    dependencies292 = ["typed", "matrix", "subtract", "number", "bignumber"];
    createDiffTransform = /* @__PURE__ */ factory(name291, dependencies292, (_ref) => {
      var {
        typed: typed2,
        matrix: matrix2,
        subtract: subtract2,
        number: number2,
        bignumber: bignumber2
      } = _ref;
      var diff2 = createDiff({
        typed: typed2,
        matrix: matrix2,
        subtract: subtract2,
        number: number2,
        bignumber: bignumber2
      });
      return typed2(name291, {
        "...any": function any(args) {
          args = lastDimToZeroBase(args);
          try {
            return diff2.apply(null, args);
          } catch (err) {
            throw errorTransform(err);
          }
        }
      });
    }, {
      isTransformFunction: true
    });
  }
});

// node_modules/mathjs/lib/esm/expression/transform/std.transform.js
var name292, dependencies293, createStdTransform;
var init_std_transform = __esm({
  "node_modules/mathjs/lib/esm/expression/transform/std.transform.js"() {
    init_factory();
    init_std2();
    init_errorTransform();
    init_lastDimToZeroBase();
    name292 = "std";
    dependencies293 = ["typed", "sqrt", "variance"];
    createStdTransform = /* @__PURE__ */ factory(name292, dependencies293, (_ref) => {
      var {
        typed: typed2,
        sqrt: sqrt2,
        variance: variance2
      } = _ref;
      var std2 = createStd({
        typed: typed2,
        sqrt: sqrt2,
        variance: variance2
      });
      return typed2("std", {
        "...any": function any(args) {
          args = lastDimToZeroBase(args);
          try {
            return std2.apply(null, args);
          } catch (err) {
            throw errorTransform(err);
          }
        }
      });
    }, {
      isTransformFunction: true
    });
  }
});

// node_modules/mathjs/lib/esm/expression/transform/sum.transform.js
var name293, dependencies294, createSumTransform;
var init_sum_transform = __esm({
  "node_modules/mathjs/lib/esm/expression/transform/sum.transform.js"() {
    init_factory();
    init_errorTransform();
    init_sum2();
    init_lastDimToZeroBase();
    name293 = "sum";
    dependencies294 = ["typed", "config", "add", "numeric"];
    createSumTransform = /* @__PURE__ */ factory(name293, dependencies294, (_ref) => {
      var {
        typed: typed2,
        config: config3,
        add: add2,
        numeric: numeric3
      } = _ref;
      var sum2 = createSum({
        typed: typed2,
        config: config3,
        add: add2,
        numeric: numeric3
      });
      return typed2(name293, {
        "...any": function any(args) {
          args = lastDimToZeroBase(args);
          try {
            return sum2.apply(null, args);
          } catch (err) {
            throw errorTransform(err);
          }
        }
      });
    }, {
      isTransformFunction: true
    });
  }
});

// node_modules/mathjs/lib/esm/expression/transform/cumsum.transform.js
var name294, dependencies295, createCumSumTransform;
var init_cumsum_transform = __esm({
  "node_modules/mathjs/lib/esm/expression/transform/cumsum.transform.js"() {
    init_is();
    init_factory();
    init_errorTransform();
    init_cumsum2();
    name294 = "cumsum";
    dependencies295 = ["typed", "add", "unaryPlus"];
    createCumSumTransform = /* @__PURE__ */ factory(name294, dependencies295, (_ref) => {
      var {
        typed: typed2,
        add: add2,
        unaryPlus: unaryPlus2
      } = _ref;
      var cumsum2 = createCumSum({
        typed: typed2,
        add: add2,
        unaryPlus: unaryPlus2
      });
      return typed2(name294, {
        "...any": function any(args) {
          if (args.length === 2 && isCollection(args[0])) {
            var dim = args[1];
            if (isNumber2(dim)) {
              args[1] = dim - 1;
            } else if (isBigNumber(dim)) {
              args[1] = dim.minus(1);
            }
          }
          try {
            return cumsum2.apply(null, args);
          } catch (err) {
            throw errorTransform(err);
          }
        }
      });
    }, {
      isTransformFunction: true
    });
  }
});

// node_modules/mathjs/lib/esm/expression/transform/variance.transform.js
var name295, dependencies296, createVarianceTransform;
var init_variance_transform = __esm({
  "node_modules/mathjs/lib/esm/expression/transform/variance.transform.js"() {
    init_factory();
    init_errorTransform();
    init_variance2();
    init_lastDimToZeroBase();
    name295 = "variance";
    dependencies296 = ["typed", "add", "subtract", "multiply", "divide", "apply", "isNaN"];
    createVarianceTransform = /* @__PURE__ */ factory(name295, dependencies296, (_ref) => {
      var {
        typed: typed2,
        add: add2,
        subtract: subtract2,
        multiply: multiply2,
        divide: divide2,
        apply: apply2,
        isNaN: isNaN3
      } = _ref;
      var variance2 = createVariance({
        typed: typed2,
        add: add2,
        subtract: subtract2,
        multiply: multiply2,
        divide: divide2,
        apply: apply2,
        isNaN: isNaN3
      });
      return typed2(name295, {
        "...any": function any(args) {
          args = lastDimToZeroBase(args);
          try {
            return variance2.apply(null, args);
          } catch (err) {
            throw errorTransform(err);
          }
        }
      });
    }, {
      isTransformFunction: true
    });
  }
});

// node_modules/mathjs/lib/esm/factoriesAny.js
var init_factoriesAny = __esm({
  "node_modules/mathjs/lib/esm/factoriesAny.js"() {
    init_typed();
    init_ResultSet();
    init_BigNumber();
    init_Complex();
    init_Fraction();
    init_Range();
    init_Matrix();
    init_DenseMatrix();
    init_clone();
    init_isInteger();
    init_isNegative();
    init_isNumeric();
    init_hasNumericValue();
    init_isPositive();
    init_isZero();
    init_isNaN();
    init_typeOf();
    init_equalScalar();
    init_SparseMatrix();
    init_number3();
    init_string2();
    init_boolean();
    init_bignumber();
    init_complex2();
    init_fraction();
    init_matrix();
    init_matrixFromFunction();
    init_matrixFromRows();
    init_matrixFromColumns();
    init_splitUnit();
    init_unaryMinus();
    init_unaryPlus();
    init_abs();
    init_apply();
    init_addScalar();
    init_cbrt();
    init_ceil();
    init_cube();
    init_exp();
    init_expm1();
    init_fix();
    init_floor();
    init_gcd();
    init_lcm();
    init_log10();
    init_log2();
    init_mod();
    init_multiplyScalar();
    init_multiply();
    init_nthRoot();
    init_sign();
    init_sqrt();
    init_square();
    init_subtract();
    init_xgcd();
    init_invmod();
    init_dotMultiply();
    init_bitAnd();
    init_bitNot();
    init_bitOr();
    init_bitXor();
    init_arg();
    init_conj();
    init_im();
    init_re();
    init_not();
    init_or();
    init_xor();
    init_concat();
    init_column();
    init_count();
    init_cross();
    init_diag();
    init_filter();
    init_flatten();
    init_forEach();
    init_getMatrixDataType();
    init_identity();
    init_kron();
    init_map2();
    init_diff();
    init_ones();
    init_range();
    init_reshape();
    init_resize();
    init_rotate();
    init_rotationMatrix();
    init_row();
    init_size();
    init_squeeze();
    init_subset();
    init_transpose();
    init_ctranspose();
    init_zeros();
    init_fft();
    init_ifft();
    init_erf();
    init_mode();
    init_prod();
    init_format();
    init_bin();
    init_oct();
    init_hex();
    init_print();
    init_to();
    init_isPrime();
    init_numeric();
    init_divideScalar();
    init_pow();
    init_round();
    init_log();
    init_log1p();
    init_nthRoots();
    init_dotPow();
    init_dotDivide();
    init_lsolve();
    init_usolve();
    init_lsolveAll();
    init_usolveAll();
    init_leftShift();
    init_rightArithShift();
    init_rightLogShift();
    init_and();
    init_compare();
    init_compareNatural();
    init_compareText();
    init_equal();
    init_equalText();
    init_smaller();
    init_smallerEq();
    init_larger();
    init_largerEq();
    init_deepEqual();
    init_unequal();
    init_partitionSelect();
    init_sort();
    init_max();
    init_min();
    init_ImmutableDenseMatrix();
    init_MatrixIndex();
    init_FibonacciHeap();
    init_Spa();
    init_Unit();
    init_unit();
    init_sparse();
    init_createUnit();
    init_acos();
    init_acosh();
    init_acot();
    init_acoth();
    init_acsc();
    init_acsch();
    init_asec();
    init_asech();
    init_asin();
    init_asinh();
    init_atan();
    init_atan2();
    init_atanh();
    init_cos();
    init_cosh();
    init_cot();
    init_coth();
    init_csc();
    init_csch();
    init_sec();
    init_sech();
    init_sin();
    init_sinh();
    init_tan();
    init_tanh();
    init_setCartesian();
    init_setDifference();
    init_setDistinct();
    init_setIntersect();
    init_setIsSubset();
    init_setMultiplicity();
    init_setPowerset();
    init_setSize();
    init_setSymDifference();
    init_setUnion();
    init_add();
    init_hypot();
    init_norm();
    init_dot();
    init_trace();
    init_function2();
    init_Node();
    init_AccessorNode();
    init_ArrayNode();
    init_AssignmentNode();
    init_BlockNode();
    init_ConditionalNode();
    init_ConstantNode();
    init_FunctionAssignmentNode();
    init_IndexNode();
    init_ObjectNode();
    init_OperatorNode();
    init_ParenthesisNode();
    init_RangeNode();
    init_RelationalNode();
    init_SymbolNode();
    init_FunctionNode();
    init_parse();
    init_compile();
    init_evaluate();
    init_Parser();
    init_parser();
    init_lup();
    init_qr();
    init_slu();
    init_lusolve();
    init_Help();
    init_Chain();
    init_help2();
    init_chain();
    init_det2();
    init_inv2();
    init_pinv2();
    init_eigs2();
    init_expm2();
    init_sqrtm2();
    init_divide2();
    init_distance2();
    init_intersect2();
    init_sum2();
    init_cumsum2();
    init_mean2();
    init_median2();
    init_mad2();
    init_variance2();
    init_quantileSeq2();
    init_std2();
    init_combinations3();
    init_combinationsWithRep2();
    init_gamma2();
    init_lgamma2();
    init_factorial2();
    init_kldivergence2();
    init_multinomial2();
    init_permutations2();
    init_pickRandom2();
    init_random2();
    init_randomInt2();
    init_stirlingS22();
    init_bellNumbers2();
    init_catalan2();
    init_composition2();
    init_leafCount2();
    init_simplify2();
    init_simplifyCore2();
    init_resolve2();
    init_symbolicEqual2();
    init_derivative2();
    init_rationalize2();
    init_reviver();
    init_replacer();
    init_constants3();
    init_physicalConstants();
    init_apply_transform();
    init_column_transform();
    init_filter_transform();
    init_forEach_transform();
    init_index_transform();
    init_map_transform();
    init_max_transform();
    init_mean_transform();
    init_min_transform();
    init_range_transform();
    init_row_transform();
    init_subset_transform();
    init_concat_transform();
    init_diff_transform();
    init_std_transform();
    init_sum_transform();
    init_cumsum_transform();
    init_variance_transform();
  }
});

// node_modules/mathjs/lib/esm/entry/pureFunctionsAny.generated.js
var BigNumber, Complex2, e2, _false, fineStructure, Fraction2, i, _Infinity, LN10, LOG10E, Matrix, _NaN, _null, phi2, Range, ResultSet, SQRT1_2, sackurTetrode, tau2, _true, version2, DenseMatrix, efimovFactor, LN2, pi2, replacer, SQRT2, typed, unaryPlus, weakMixingAngle, abs, acos, acot, acsc, addScalar, arg, asech, asinh2, atan, atanh2, bignumber, bitNot, boolean, clone2, combinations, complex, conj, cosh2, coth, csc, cube, equalScalar, erf, exp, expm13, filter2, forEach2, format4, getMatrixDataType, hex, im, isInteger2, isNegative, isPositive, isZero, LOG2E, lgamma, log103, log23, map2, multiplyScalar, not, number, oct, pickRandom, print, random, re, sec, sign2, sin, SparseMatrix, splitUnit, square, string, tan, typeOf2, acosh2, acsch, apply, asec, bin, combinationsWithRep, cos, csch, isNaN2, isPrime, randomInt, sech, sinh2, sparse, sqrt, tanh2, unaryMinus, acoth, cot, fraction, isNumeric, matrix, matrixFromFunction, mod, nthRoot, numeric2, or, prod, reshape2, size, smaller, squeeze2, subset, subtract, to, transpose, xgcd, zeros2, and, bitAnd, bitXor2, cbrt3, compare, compareText2, concat, count, ctranspose, diag, divideScalar, dotDivide, equal, fft, flatten2, gcd, hasNumericValue, hypot, ifft, kron, largerEq, leftShift, lsolve, matrixFromColumns, min, mode, nthRoots, ones, partitionSelect, resize2, rightArithShift, round, smallerEq, unequal, usolve, xor, add, atan2, bitOr, catalan, compareNatural, cumsum, deepEqual, diff, dot, equalText, floor, identity, invmod, larger, log, lsolveAll, matrixFromRows, multiply, qr, range, rightLogShift, setSize, slu, sum, trace, usolveAll, asin, ceil, composition, cross, det, distance, dotMultiply, FibonacciHeap, fix, ImmutableDenseMatrix, Index, intersect, lcm, log1p2, max, quantileSeq, row, setCartesian, setDistinct, setIsSubset, setPowerset, sort, column, index, inv, pinv, pow, setDifference, setMultiplicity, Spa, sqrtm, Unit, vacuumImpedance, wienDisplacement, atomicMass, bohrMagneton, boltzmann, conductanceQuantum, createUnit, deuteronMass, dotPow, electricConstant, elementaryCharge, expm, faraday, firstRadiation, gamma, gravitationConstant, hartreeEnergy, klitzing, loschmidt, magneticConstant, molarMass, molarPlanckConstant, neutronMass, nuclearMagneton, planckCharge, planckLength, planckTemperature, protonMass, reducedPlanckConstant, rydberg, setIntersect, speedOfLight, stefanBoltzmann, thomsonCrossSection, avogadro, bohrRadius, coulomb, divide, electronMass, factorial, gravity, inverseConductanceQuantum, lup, magneticFluxQuantum, molarMassC12, multinomial, permutations, planckMass, quantumOfCirculation, secondRadiation, stirlingS2, unit, bellNumbers, eigs, fermiCoupling, mean, molarVolume, planckConstant, setSymDifference, classicalElectronRadius, lusolve, median, setUnion, variance, kldivergence, norm, planckTime, rotationMatrix, gasConstant, std, mad, rotate;
var init_pureFunctionsAny_generated = __esm({
  "node_modules/mathjs/lib/esm/entry/pureFunctionsAny.generated.js"() {
    init_configReadonly();
    init_factoriesAny();
    BigNumber = /* @__PURE__ */ createBigNumberClass({
      config
    });
    Complex2 = /* @__PURE__ */ createComplexClass({});
    e2 = /* @__PURE__ */ createE({
      BigNumber,
      config
    });
    _false = /* @__PURE__ */ createFalse({});
    fineStructure = /* @__PURE__ */ createFineStructure({
      BigNumber,
      config
    });
    Fraction2 = /* @__PURE__ */ createFractionClass({});
    i = /* @__PURE__ */ createI({
      Complex: Complex2
    });
    _Infinity = /* @__PURE__ */ createInfinity({
      BigNumber,
      config
    });
    LN10 = /* @__PURE__ */ createLN10({
      BigNumber,
      config
    });
    LOG10E = /* @__PURE__ */ createLOG10E({
      BigNumber,
      config
    });
    Matrix = /* @__PURE__ */ createMatrixClass({});
    _NaN = /* @__PURE__ */ createNaN({
      BigNumber,
      config
    });
    _null = /* @__PURE__ */ createNull({});
    phi2 = /* @__PURE__ */ createPhi({
      BigNumber,
      config
    });
    Range = /* @__PURE__ */ createRangeClass({});
    ResultSet = /* @__PURE__ */ createResultSet({});
    SQRT1_2 = /* @__PURE__ */ createSQRT1_2({
      BigNumber,
      config
    });
    sackurTetrode = /* @__PURE__ */ createSackurTetrode({
      BigNumber,
      config
    });
    tau2 = /* @__PURE__ */ createTau({
      BigNumber,
      config
    });
    _true = /* @__PURE__ */ createTrue({});
    version2 = /* @__PURE__ */ createVersion({});
    DenseMatrix = /* @__PURE__ */ createDenseMatrixClass({
      Matrix
    });
    efimovFactor = /* @__PURE__ */ createEfimovFactor({
      BigNumber,
      config
    });
    LN2 = /* @__PURE__ */ createLN2({
      BigNumber,
      config
    });
    pi2 = /* @__PURE__ */ createPi({
      BigNumber,
      config
    });
    replacer = /* @__PURE__ */ createReplacer({});
    SQRT2 = /* @__PURE__ */ createSQRT2({
      BigNumber,
      config
    });
    typed = /* @__PURE__ */ createTyped({
      BigNumber,
      Complex: Complex2,
      DenseMatrix,
      Fraction: Fraction2
    });
    unaryPlus = /* @__PURE__ */ createUnaryPlus({
      BigNumber,
      config,
      typed
    });
    weakMixingAngle = /* @__PURE__ */ createWeakMixingAngle({
      BigNumber,
      config
    });
    abs = /* @__PURE__ */ createAbs({
      typed
    });
    acos = /* @__PURE__ */ createAcos({
      Complex: Complex2,
      config,
      typed
    });
    acot = /* @__PURE__ */ createAcot({
      BigNumber,
      typed
    });
    acsc = /* @__PURE__ */ createAcsc({
      BigNumber,
      Complex: Complex2,
      config,
      typed
    });
    addScalar = /* @__PURE__ */ createAddScalar({
      typed
    });
    arg = /* @__PURE__ */ createArg({
      typed
    });
    asech = /* @__PURE__ */ createAsech({
      BigNumber,
      Complex: Complex2,
      config,
      typed
    });
    asinh2 = /* @__PURE__ */ createAsinh({
      typed
    });
    atan = /* @__PURE__ */ createAtan({
      typed
    });
    atanh2 = /* @__PURE__ */ createAtanh({
      Complex: Complex2,
      config,
      typed
    });
    bignumber = /* @__PURE__ */ createBignumber({
      BigNumber,
      typed
    });
    bitNot = /* @__PURE__ */ createBitNot({
      typed
    });
    boolean = /* @__PURE__ */ createBoolean({
      typed
    });
    clone2 = /* @__PURE__ */ createClone({
      typed
    });
    combinations = /* @__PURE__ */ createCombinations({
      typed
    });
    complex = /* @__PURE__ */ createComplex({
      Complex: Complex2,
      typed
    });
    conj = /* @__PURE__ */ createConj({
      typed
    });
    cosh2 = /* @__PURE__ */ createCosh({
      typed
    });
    coth = /* @__PURE__ */ createCoth({
      BigNumber,
      typed
    });
    csc = /* @__PURE__ */ createCsc({
      BigNumber,
      typed
    });
    cube = /* @__PURE__ */ createCube({
      typed
    });
    equalScalar = /* @__PURE__ */ createEqualScalar({
      config,
      typed
    });
    erf = /* @__PURE__ */ createErf({
      typed
    });
    exp = /* @__PURE__ */ createExp({
      typed
    });
    expm13 = /* @__PURE__ */ createExpm1({
      Complex: Complex2,
      typed
    });
    filter2 = /* @__PURE__ */ createFilter({
      typed
    });
    forEach2 = /* @__PURE__ */ createForEach({
      typed
    });
    format4 = /* @__PURE__ */ createFormat({
      typed
    });
    getMatrixDataType = /* @__PURE__ */ createGetMatrixDataType({
      typed
    });
    hex = /* @__PURE__ */ createHex({
      format: format4,
      typed
    });
    im = /* @__PURE__ */ createIm({
      typed
    });
    isInteger2 = /* @__PURE__ */ createIsInteger({
      typed
    });
    isNegative = /* @__PURE__ */ createIsNegative({
      typed
    });
    isPositive = /* @__PURE__ */ createIsPositive({
      typed
    });
    isZero = /* @__PURE__ */ createIsZero({
      typed
    });
    LOG2E = /* @__PURE__ */ createLOG2E({
      BigNumber,
      config
    });
    lgamma = /* @__PURE__ */ createLgamma({
      Complex: Complex2,
      typed
    });
    log103 = /* @__PURE__ */ createLog10({
      Complex: Complex2,
      config,
      typed
    });
    log23 = /* @__PURE__ */ createLog2({
      Complex: Complex2,
      config,
      typed
    });
    map2 = /* @__PURE__ */ createMap2({
      typed
    });
    multiplyScalar = /* @__PURE__ */ createMultiplyScalar({
      typed
    });
    not = /* @__PURE__ */ createNot({
      typed
    });
    number = /* @__PURE__ */ createNumber({
      typed
    });
    oct = /* @__PURE__ */ createOct({
      format: format4,
      typed
    });
    pickRandom = /* @__PURE__ */ createPickRandom({
      config,
      typed
    });
    print = /* @__PURE__ */ createPrint({
      typed
    });
    random = /* @__PURE__ */ createRandom({
      config,
      typed
    });
    re = /* @__PURE__ */ createRe({
      typed
    });
    sec = /* @__PURE__ */ createSec({
      BigNumber,
      typed
    });
    sign2 = /* @__PURE__ */ createSign({
      BigNumber,
      Fraction: Fraction2,
      complex,
      typed
    });
    sin = /* @__PURE__ */ createSin({
      typed
    });
    SparseMatrix = /* @__PURE__ */ createSparseMatrixClass({
      Matrix,
      equalScalar,
      typed
    });
    splitUnit = /* @__PURE__ */ createSplitUnit({
      typed
    });
    square = /* @__PURE__ */ createSquare({
      typed
    });
    string = /* @__PURE__ */ createString({
      typed
    });
    tan = /* @__PURE__ */ createTan({
      typed
    });
    typeOf2 = /* @__PURE__ */ createTypeOf({
      typed
    });
    acosh2 = /* @__PURE__ */ createAcosh({
      Complex: Complex2,
      config,
      typed
    });
    acsch = /* @__PURE__ */ createAcsch({
      BigNumber,
      typed
    });
    apply = /* @__PURE__ */ createApply({
      isInteger: isInteger2,
      typed
    });
    asec = /* @__PURE__ */ createAsec({
      BigNumber,
      Complex: Complex2,
      config,
      typed
    });
    bin = /* @__PURE__ */ createBin({
      format: format4,
      typed
    });
    combinationsWithRep = /* @__PURE__ */ createCombinationsWithRep({
      typed
    });
    cos = /* @__PURE__ */ createCos({
      typed
    });
    csch = /* @__PURE__ */ createCsch({
      BigNumber,
      typed
    });
    isNaN2 = /* @__PURE__ */ createIsNaN({
      typed
    });
    isPrime = /* @__PURE__ */ createIsPrime({
      typed
    });
    randomInt = /* @__PURE__ */ createRandomInt({
      config,
      typed
    });
    sech = /* @__PURE__ */ createSech({
      BigNumber,
      typed
    });
    sinh2 = /* @__PURE__ */ createSinh({
      typed
    });
    sparse = /* @__PURE__ */ createSparse({
      SparseMatrix,
      typed
    });
    sqrt = /* @__PURE__ */ createSqrt({
      Complex: Complex2,
      config,
      typed
    });
    tanh2 = /* @__PURE__ */ createTanh({
      typed
    });
    unaryMinus = /* @__PURE__ */ createUnaryMinus({
      typed
    });
    acoth = /* @__PURE__ */ createAcoth({
      BigNumber,
      Complex: Complex2,
      config,
      typed
    });
    cot = /* @__PURE__ */ createCot({
      BigNumber,
      typed
    });
    fraction = /* @__PURE__ */ createFraction({
      Fraction: Fraction2,
      typed
    });
    isNumeric = /* @__PURE__ */ createIsNumeric({
      typed
    });
    matrix = /* @__PURE__ */ createMatrix({
      DenseMatrix,
      Matrix,
      SparseMatrix,
      typed
    });
    matrixFromFunction = /* @__PURE__ */ createMatrixFromFunction({
      isZero,
      matrix,
      typed
    });
    mod = /* @__PURE__ */ createMod({
      DenseMatrix,
      equalScalar,
      matrix,
      typed
    });
    nthRoot = /* @__PURE__ */ createNthRoot({
      BigNumber,
      equalScalar,
      matrix,
      typed
    });
    numeric2 = /* @__PURE__ */ createNumeric({
      bignumber,
      fraction,
      number
    });
    or = /* @__PURE__ */ createOr({
      DenseMatrix,
      equalScalar,
      matrix,
      typed
    });
    prod = /* @__PURE__ */ createProd({
      config,
      multiplyScalar,
      numeric: numeric2,
      typed
    });
    reshape2 = /* @__PURE__ */ createReshape({
      isInteger: isInteger2,
      matrix,
      typed
    });
    size = /* @__PURE__ */ createSize({
      matrix,
      config,
      typed
    });
    smaller = /* @__PURE__ */ createSmaller({
      DenseMatrix,
      config,
      matrix,
      typed
    });
    squeeze2 = /* @__PURE__ */ createSqueeze({
      matrix,
      typed
    });
    subset = /* @__PURE__ */ createSubset({
      matrix,
      typed
    });
    subtract = /* @__PURE__ */ createSubtract({
      DenseMatrix,
      addScalar,
      equalScalar,
      matrix,
      typed,
      unaryMinus
    });
    to = /* @__PURE__ */ createTo({
      matrix,
      typed
    });
    transpose = /* @__PURE__ */ createTranspose({
      matrix,
      typed
    });
    xgcd = /* @__PURE__ */ createXgcd({
      BigNumber,
      config,
      matrix,
      typed
    });
    zeros2 = /* @__PURE__ */ createZeros({
      BigNumber,
      config,
      matrix,
      typed
    });
    and = /* @__PURE__ */ createAnd({
      equalScalar,
      matrix,
      not,
      typed,
      zeros: zeros2
    });
    bitAnd = /* @__PURE__ */ createBitAnd({
      equalScalar,
      matrix,
      typed
    });
    bitXor2 = /* @__PURE__ */ createBitXor({
      DenseMatrix,
      matrix,
      typed
    });
    cbrt3 = /* @__PURE__ */ createCbrt({
      BigNumber,
      Complex: Complex2,
      Fraction: Fraction2,
      config,
      isNegative,
      matrix,
      typed,
      unaryMinus
    });
    compare = /* @__PURE__ */ createCompare({
      BigNumber,
      DenseMatrix,
      Fraction: Fraction2,
      config,
      equalScalar,
      matrix,
      typed
    });
    compareText2 = /* @__PURE__ */ createCompareText({
      matrix,
      typed
    });
    concat = /* @__PURE__ */ createConcat({
      isInteger: isInteger2,
      matrix,
      typed
    });
    count = /* @__PURE__ */ createCount({
      prod,
      size,
      typed
    });
    ctranspose = /* @__PURE__ */ createCtranspose({
      conj,
      transpose,
      typed
    });
    diag = /* @__PURE__ */ createDiag({
      DenseMatrix,
      SparseMatrix,
      matrix,
      typed
    });
    divideScalar = /* @__PURE__ */ createDivideScalar({
      numeric: numeric2,
      typed
    });
    dotDivide = /* @__PURE__ */ createDotDivide({
      DenseMatrix,
      divideScalar,
      equalScalar,
      matrix,
      typed
    });
    equal = /* @__PURE__ */ createEqual({
      DenseMatrix,
      equalScalar,
      matrix,
      typed
    });
    fft = /* @__PURE__ */ createFft({
      addScalar,
      divideScalar,
      exp,
      i,
      matrix,
      multiplyScalar,
      tau: tau2,
      typed
    });
    flatten2 = /* @__PURE__ */ createFlatten({
      matrix,
      typed
    });
    gcd = /* @__PURE__ */ createGcd({
      BigNumber,
      DenseMatrix,
      equalScalar,
      matrix,
      typed
    });
    hasNumericValue = /* @__PURE__ */ createHasNumericValue({
      isNumeric,
      typed
    });
    hypot = /* @__PURE__ */ createHypot({
      abs,
      addScalar,
      divideScalar,
      isPositive,
      multiplyScalar,
      smaller,
      sqrt,
      typed
    });
    ifft = /* @__PURE__ */ createIfft({
      conj,
      dotDivide,
      fft,
      typed
    });
    kron = /* @__PURE__ */ createKron({
      matrix,
      multiplyScalar,
      typed
    });
    largerEq = /* @__PURE__ */ createLargerEq({
      DenseMatrix,
      config,
      matrix,
      typed
    });
    leftShift = /* @__PURE__ */ createLeftShift({
      DenseMatrix,
      equalScalar,
      matrix,
      typed,
      zeros: zeros2
    });
    lsolve = /* @__PURE__ */ createLsolve({
      DenseMatrix,
      divideScalar,
      equalScalar,
      matrix,
      multiplyScalar,
      subtract,
      typed
    });
    matrixFromColumns = /* @__PURE__ */ createMatrixFromColumns({
      flatten: flatten2,
      matrix,
      size,
      typed
    });
    min = /* @__PURE__ */ createMin({
      config,
      numeric: numeric2,
      smaller,
      typed
    });
    mode = /* @__PURE__ */ createMode({
      isNaN: isNaN2,
      isNumeric,
      typed
    });
    nthRoots = /* @__PURE__ */ createNthRoots({
      Complex: Complex2,
      config,
      divideScalar,
      typed
    });
    ones = /* @__PURE__ */ createOnes({
      BigNumber,
      config,
      matrix,
      typed
    });
    partitionSelect = /* @__PURE__ */ createPartitionSelect({
      compare,
      isNaN: isNaN2,
      isNumeric,
      typed
    });
    resize2 = /* @__PURE__ */ createResize({
      config,
      matrix
    });
    rightArithShift = /* @__PURE__ */ createRightArithShift({
      DenseMatrix,
      equalScalar,
      matrix,
      typed,
      zeros: zeros2
    });
    round = /* @__PURE__ */ createRound({
      BigNumber,
      DenseMatrix,
      equalScalar,
      matrix,
      typed,
      zeros: zeros2
    });
    smallerEq = /* @__PURE__ */ createSmallerEq({
      DenseMatrix,
      config,
      matrix,
      typed
    });
    unequal = /* @__PURE__ */ createUnequal({
      DenseMatrix,
      config,
      equalScalar,
      matrix,
      typed
    });
    usolve = /* @__PURE__ */ createUsolve({
      DenseMatrix,
      divideScalar,
      equalScalar,
      matrix,
      multiplyScalar,
      subtract,
      typed
    });
    xor = /* @__PURE__ */ createXor({
      DenseMatrix,
      matrix,
      typed
    });
    add = /* @__PURE__ */ createAdd({
      DenseMatrix,
      SparseMatrix,
      addScalar,
      equalScalar,
      matrix,
      typed
    });
    atan2 = /* @__PURE__ */ createAtan2({
      BigNumber,
      DenseMatrix,
      equalScalar,
      matrix,
      typed
    });
    bitOr = /* @__PURE__ */ createBitOr({
      DenseMatrix,
      equalScalar,
      matrix,
      typed
    });
    catalan = /* @__PURE__ */ createCatalan({
      addScalar,
      combinations,
      divideScalar,
      isInteger: isInteger2,
      isNegative,
      multiplyScalar,
      typed
    });
    compareNatural = /* @__PURE__ */ createCompareNatural({
      compare,
      typed
    });
    cumsum = /* @__PURE__ */ createCumSum({
      add,
      typed,
      unaryPlus
    });
    deepEqual = /* @__PURE__ */ createDeepEqual({
      equal,
      typed
    });
    diff = /* @__PURE__ */ createDiff({
      matrix,
      number,
      subtract,
      typed
    });
    dot = /* @__PURE__ */ createDot({
      addScalar,
      conj,
      multiplyScalar,
      size,
      typed
    });
    equalText = /* @__PURE__ */ createEqualText({
      compareText: compareText2,
      isZero,
      typed
    });
    floor = /* @__PURE__ */ createFloor({
      DenseMatrix,
      config,
      equalScalar,
      matrix,
      round,
      typed,
      zeros: zeros2
    });
    identity = /* @__PURE__ */ createIdentity({
      BigNumber,
      DenseMatrix,
      SparseMatrix,
      config,
      matrix,
      typed
    });
    invmod = /* @__PURE__ */ createInvmod({
      BigNumber,
      add,
      config,
      equal,
      isInteger: isInteger2,
      mod,
      smaller,
      typed,
      xgcd
    });
    larger = /* @__PURE__ */ createLarger({
      DenseMatrix,
      config,
      matrix,
      typed
    });
    log = /* @__PURE__ */ createLog({
      Complex: Complex2,
      config,
      divideScalar,
      typed
    });
    lsolveAll = /* @__PURE__ */ createLsolveAll({
      DenseMatrix,
      divideScalar,
      equalScalar,
      matrix,
      multiplyScalar,
      subtract,
      typed
    });
    matrixFromRows = /* @__PURE__ */ createMatrixFromRows({
      flatten: flatten2,
      matrix,
      size,
      typed
    });
    multiply = /* @__PURE__ */ createMultiply({
      addScalar,
      dot,
      equalScalar,
      matrix,
      multiplyScalar,
      typed
    });
    qr = /* @__PURE__ */ createQr({
      addScalar,
      complex,
      conj,
      divideScalar,
      equal,
      identity,
      isZero,
      matrix,
      multiplyScalar,
      sign: sign2,
      sqrt,
      subtract,
      typed,
      unaryMinus,
      zeros: zeros2
    });
    range = /* @__PURE__ */ createRange({
      bignumber,
      matrix,
      config,
      larger,
      largerEq,
      smaller,
      smallerEq,
      typed
    });
    rightLogShift = /* @__PURE__ */ createRightLogShift({
      DenseMatrix,
      equalScalar,
      matrix,
      typed,
      zeros: zeros2
    });
    setSize = /* @__PURE__ */ createSetSize({
      compareNatural,
      typed
    });
    slu = /* @__PURE__ */ createSlu({
      SparseMatrix,
      abs,
      add,
      divideScalar,
      larger,
      largerEq,
      multiply,
      subtract,
      transpose,
      typed
    });
    sum = /* @__PURE__ */ createSum({
      add,
      config,
      numeric: numeric2,
      typed
    });
    trace = /* @__PURE__ */ createTrace({
      add,
      matrix,
      typed
    });
    usolveAll = /* @__PURE__ */ createUsolveAll({
      DenseMatrix,
      divideScalar,
      equalScalar,
      matrix,
      multiplyScalar,
      subtract,
      typed
    });
    asin = /* @__PURE__ */ createAsin({
      Complex: Complex2,
      config,
      typed
    });
    ceil = /* @__PURE__ */ createCeil({
      DenseMatrix,
      config,
      equalScalar,
      matrix,
      round,
      typed,
      zeros: zeros2
    });
    composition = /* @__PURE__ */ createComposition({
      addScalar,
      combinations,
      isInteger: isInteger2,
      isNegative,
      isPositive,
      larger,
      typed
    });
    cross = /* @__PURE__ */ createCross({
      matrix,
      multiply,
      subtract,
      typed
    });
    det = /* @__PURE__ */ createDet({
      divideScalar,
      isZero,
      matrix,
      multiply,
      subtract,
      typed,
      unaryMinus
    });
    distance = /* @__PURE__ */ createDistance({
      abs,
      addScalar,
      divideScalar,
      multiplyScalar,
      sqrt,
      subtract,
      typed,
      unaryMinus
    });
    dotMultiply = /* @__PURE__ */ createDotMultiply({
      equalScalar,
      matrix,
      multiplyScalar,
      typed
    });
    FibonacciHeap = /* @__PURE__ */ createFibonacciHeapClass({
      larger,
      smaller
    });
    fix = /* @__PURE__ */ createFix({
      Complex: Complex2,
      DenseMatrix,
      ceil,
      equalScalar,
      floor,
      matrix,
      typed,
      zeros: zeros2
    });
    ImmutableDenseMatrix = /* @__PURE__ */ createImmutableDenseMatrixClass({
      DenseMatrix,
      smaller
    });
    Index = /* @__PURE__ */ createIndexClass({
      ImmutableDenseMatrix
    });
    intersect = /* @__PURE__ */ createIntersect({
      abs,
      add,
      addScalar,
      config,
      divideScalar,
      equalScalar,
      flatten: flatten2,
      isNumeric,
      isZero,
      matrix,
      multiply,
      multiplyScalar,
      smaller,
      subtract,
      typed
    });
    lcm = /* @__PURE__ */ createLcm({
      equalScalar,
      matrix,
      typed
    });
    log1p2 = /* @__PURE__ */ createLog1p({
      Complex: Complex2,
      config,
      divideScalar,
      log,
      typed
    });
    max = /* @__PURE__ */ createMax({
      config,
      larger,
      numeric: numeric2,
      typed
    });
    quantileSeq = /* @__PURE__ */ createQuantileSeq({
      add,
      compare,
      multiply,
      partitionSelect,
      typed
    });
    row = /* @__PURE__ */ createRow({
      Index,
      matrix,
      range,
      typed
    });
    setCartesian = /* @__PURE__ */ createSetCartesian({
      DenseMatrix,
      Index,
      compareNatural,
      size,
      subset,
      typed
    });
    setDistinct = /* @__PURE__ */ createSetDistinct({
      DenseMatrix,
      Index,
      compareNatural,
      size,
      subset,
      typed
    });
    setIsSubset = /* @__PURE__ */ createSetIsSubset({
      Index,
      compareNatural,
      size,
      subset,
      typed
    });
    setPowerset = /* @__PURE__ */ createSetPowerset({
      Index,
      compareNatural,
      size,
      subset,
      typed
    });
    sort = /* @__PURE__ */ createSort({
      compare,
      compareNatural,
      matrix,
      typed
    });
    column = /* @__PURE__ */ createColumn({
      Index,
      matrix,
      range,
      typed
    });
    index = /* @__PURE__ */ createIndex({
      Index,
      typed
    });
    inv = /* @__PURE__ */ createInv({
      abs,
      addScalar,
      det,
      divideScalar,
      identity,
      matrix,
      multiply,
      typed,
      unaryMinus
    });
    pinv = /* @__PURE__ */ createPinv({
      Complex: Complex2,
      add,
      ctranspose,
      deepEqual,
      divideScalar,
      dot,
      dotDivide,
      equal,
      inv,
      matrix,
      multiply,
      typed
    });
    pow = /* @__PURE__ */ createPow({
      Complex: Complex2,
      config,
      fraction,
      identity,
      inv,
      matrix,
      multiply,
      number,
      typed
    });
    setDifference = /* @__PURE__ */ createSetDifference({
      DenseMatrix,
      Index,
      compareNatural,
      size,
      subset,
      typed
    });
    setMultiplicity = /* @__PURE__ */ createSetMultiplicity({
      Index,
      compareNatural,
      size,
      subset,
      typed
    });
    Spa = /* @__PURE__ */ createSpaClass({
      FibonacciHeap,
      addScalar,
      equalScalar
    });
    sqrtm = /* @__PURE__ */ createSqrtm({
      abs,
      add,
      identity,
      inv,
      max,
      multiply,
      size,
      sqrt,
      subtract,
      typed
    });
    Unit = /* @__PURE__ */ createUnitClass({
      BigNumber,
      Complex: Complex2,
      Fraction: Fraction2,
      abs,
      addScalar,
      config,
      divideScalar,
      equal,
      fix,
      format: format4,
      isNumeric,
      multiplyScalar,
      number,
      pow,
      round,
      subtract
    });
    vacuumImpedance = /* @__PURE__ */ createVacuumImpedance({
      BigNumber,
      Unit,
      config
    });
    wienDisplacement = /* @__PURE__ */ createWienDisplacement({
      BigNumber,
      Unit,
      config
    });
    atomicMass = /* @__PURE__ */ createAtomicMass({
      BigNumber,
      Unit,
      config
    });
    bohrMagneton = /* @__PURE__ */ createBohrMagneton({
      BigNumber,
      Unit,
      config
    });
    boltzmann = /* @__PURE__ */ createBoltzmann({
      BigNumber,
      Unit,
      config
    });
    conductanceQuantum = /* @__PURE__ */ createConductanceQuantum({
      BigNumber,
      Unit,
      config
    });
    createUnit = /* @__PURE__ */ createCreateUnit({
      Unit,
      typed
    });
    deuteronMass = /* @__PURE__ */ createDeuteronMass({
      BigNumber,
      Unit,
      config
    });
    dotPow = /* @__PURE__ */ createDotPow({
      DenseMatrix,
      equalScalar,
      matrix,
      pow,
      typed
    });
    electricConstant = /* @__PURE__ */ createElectricConstant({
      BigNumber,
      Unit,
      config
    });
    elementaryCharge = /* @__PURE__ */ createElementaryCharge({
      BigNumber,
      Unit,
      config
    });
    expm = /* @__PURE__ */ createExpm({
      abs,
      add,
      identity,
      inv,
      multiply,
      typed
    });
    faraday = /* @__PURE__ */ createFaraday({
      BigNumber,
      Unit,
      config
    });
    firstRadiation = /* @__PURE__ */ createFirstRadiation({
      BigNumber,
      Unit,
      config
    });
    gamma = /* @__PURE__ */ createGamma({
      BigNumber,
      Complex: Complex2,
      config,
      multiplyScalar,
      pow,
      typed
    });
    gravitationConstant = /* @__PURE__ */ createGravitationConstant({
      BigNumber,
      Unit,
      config
    });
    hartreeEnergy = /* @__PURE__ */ createHartreeEnergy({
      BigNumber,
      Unit,
      config
    });
    klitzing = /* @__PURE__ */ createKlitzing({
      BigNumber,
      Unit,
      config
    });
    loschmidt = /* @__PURE__ */ createLoschmidt({
      BigNumber,
      Unit,
      config
    });
    magneticConstant = /* @__PURE__ */ createMagneticConstant({
      BigNumber,
      Unit,
      config
    });
    molarMass = /* @__PURE__ */ createMolarMass({
      BigNumber,
      Unit,
      config
    });
    molarPlanckConstant = /* @__PURE__ */ createMolarPlanckConstant({
      BigNumber,
      Unit,
      config
    });
    neutronMass = /* @__PURE__ */ createNeutronMass({
      BigNumber,
      Unit,
      config
    });
    nuclearMagneton = /* @__PURE__ */ createNuclearMagneton({
      BigNumber,
      Unit,
      config
    });
    planckCharge = /* @__PURE__ */ createPlanckCharge({
      BigNumber,
      Unit,
      config
    });
    planckLength = /* @__PURE__ */ createPlanckLength({
      BigNumber,
      Unit,
      config
    });
    planckTemperature = /* @__PURE__ */ createPlanckTemperature({
      BigNumber,
      Unit,
      config
    });
    protonMass = /* @__PURE__ */ createProtonMass({
      BigNumber,
      Unit,
      config
    });
    reducedPlanckConstant = /* @__PURE__ */ createReducedPlanckConstant({
      BigNumber,
      Unit,
      config
    });
    rydberg = /* @__PURE__ */ createRydberg({
      BigNumber,
      Unit,
      config
    });
    setIntersect = /* @__PURE__ */ createSetIntersect({
      DenseMatrix,
      Index,
      compareNatural,
      size,
      subset,
      typed
    });
    speedOfLight = /* @__PURE__ */ createSpeedOfLight({
      BigNumber,
      Unit,
      config
    });
    stefanBoltzmann = /* @__PURE__ */ createStefanBoltzmann({
      BigNumber,
      Unit,
      config
    });
    thomsonCrossSection = /* @__PURE__ */ createThomsonCrossSection({
      BigNumber,
      Unit,
      config
    });
    avogadro = /* @__PURE__ */ createAvogadro({
      BigNumber,
      Unit,
      config
    });
    bohrRadius = /* @__PURE__ */ createBohrRadius({
      BigNumber,
      Unit,
      config
    });
    coulomb = /* @__PURE__ */ createCoulomb({
      BigNumber,
      Unit,
      config
    });
    divide = /* @__PURE__ */ createDivide({
      divideScalar,
      equalScalar,
      inv,
      matrix,
      multiply,
      typed
    });
    electronMass = /* @__PURE__ */ createElectronMass({
      BigNumber,
      Unit,
      config
    });
    factorial = /* @__PURE__ */ createFactorial({
      gamma,
      typed
    });
    gravity = /* @__PURE__ */ createGravity({
      BigNumber,
      Unit,
      config
    });
    inverseConductanceQuantum = /* @__PURE__ */ createInverseConductanceQuantum({
      BigNumber,
      Unit,
      config
    });
    lup = /* @__PURE__ */ createLup({
      DenseMatrix,
      Spa,
      SparseMatrix,
      abs,
      addScalar,
      divideScalar,
      equalScalar,
      larger,
      matrix,
      multiplyScalar,
      subtract,
      typed,
      unaryMinus
    });
    magneticFluxQuantum = /* @__PURE__ */ createMagneticFluxQuantum({
      BigNumber,
      Unit,
      config
    });
    molarMassC12 = /* @__PURE__ */ createMolarMassC12({
      BigNumber,
      Unit,
      config
    });
    multinomial = /* @__PURE__ */ createMultinomial({
      add,
      divide,
      factorial,
      isInteger: isInteger2,
      isPositive,
      multiply,
      typed
    });
    permutations = /* @__PURE__ */ createPermutations({
      factorial,
      typed
    });
    planckMass = /* @__PURE__ */ createPlanckMass({
      BigNumber,
      Unit,
      config
    });
    quantumOfCirculation = /* @__PURE__ */ createQuantumOfCirculation({
      BigNumber,
      Unit,
      config
    });
    secondRadiation = /* @__PURE__ */ createSecondRadiation({
      BigNumber,
      Unit,
      config
    });
    stirlingS2 = /* @__PURE__ */ createStirlingS2({
      bignumber,
      addScalar,
      combinations,
      divideScalar,
      factorial,
      isInteger: isInteger2,
      isNegative,
      larger,
      multiplyScalar,
      number,
      pow,
      subtract,
      typed
    });
    unit = /* @__PURE__ */ createUnitFunction({
      Unit,
      typed
    });
    bellNumbers = /* @__PURE__ */ createBellNumbers({
      addScalar,
      isInteger: isInteger2,
      isNegative,
      stirlingS2,
      typed
    });
    eigs = /* @__PURE__ */ createEigs({
      abs,
      add,
      addScalar,
      atan,
      bignumber,
      column,
      complex,
      config,
      cos,
      diag,
      divideScalar,
      dot,
      equal,
      flatten: flatten2,
      im,
      inv,
      larger,
      matrix,
      matrixFromColumns,
      multiply,
      multiplyScalar,
      number,
      qr,
      re,
      sin,
      smaller,
      sqrt,
      subtract,
      typed,
      usolve,
      usolveAll
    });
    fermiCoupling = /* @__PURE__ */ createFermiCoupling({
      BigNumber,
      Unit,
      config
    });
    mean = /* @__PURE__ */ createMean({
      add,
      divide,
      typed
    });
    molarVolume = /* @__PURE__ */ createMolarVolume({
      BigNumber,
      Unit,
      config
    });
    planckConstant = /* @__PURE__ */ createPlanckConstant({
      BigNumber,
      Unit,
      config
    });
    setSymDifference = /* @__PURE__ */ createSetSymDifference({
      Index,
      concat,
      setDifference,
      size,
      subset,
      typed
    });
    classicalElectronRadius = /* @__PURE__ */ createClassicalElectronRadius({
      BigNumber,
      Unit,
      config
    });
    lusolve = /* @__PURE__ */ createLusolve({
      DenseMatrix,
      lsolve,
      lup,
      matrix,
      slu,
      typed,
      usolve
    });
    median = /* @__PURE__ */ createMedian({
      add,
      compare,
      divide,
      partitionSelect,
      typed
    });
    setUnion = /* @__PURE__ */ createSetUnion({
      Index,
      concat,
      setIntersect,
      setSymDifference,
      size,
      subset,
      typed
    });
    variance = /* @__PURE__ */ createVariance({
      add,
      apply,
      divide,
      isNaN: isNaN2,
      multiply,
      subtract,
      typed
    });
    kldivergence = /* @__PURE__ */ createKldivergence({
      divide,
      dotDivide,
      isNumeric,
      log,
      matrix,
      multiply,
      sum,
      typed
    });
    norm = /* @__PURE__ */ createNorm({
      abs,
      add,
      conj,
      ctranspose,
      eigs,
      equalScalar,
      larger,
      matrix,
      multiply,
      pow,
      smaller,
      sqrt,
      typed
    });
    planckTime = /* @__PURE__ */ createPlanckTime({
      BigNumber,
      Unit,
      config
    });
    rotationMatrix = /* @__PURE__ */ createRotationMatrix({
      BigNumber,
      DenseMatrix,
      SparseMatrix,
      addScalar,
      config,
      cos,
      matrix,
      multiplyScalar,
      norm,
      sin,
      typed,
      unaryMinus
    });
    gasConstant = /* @__PURE__ */ createGasConstant({
      BigNumber,
      Unit,
      config
    });
    std = /* @__PURE__ */ createStd({
      sqrt,
      typed,
      variance
    });
    mad = /* @__PURE__ */ createMad({
      abs,
      map: map2,
      median,
      subtract,
      typed
    });
    rotate = /* @__PURE__ */ createRotate({
      multiply,
      rotationMatrix,
      typed
    });
  }
});

// node_modules/mathjs/lib/esm/entry/impureFunctionsAny.generated.js
var import_extends5, math, mathWithTransform, classes, Chain, Node, ObjectNode, OperatorNode, ParenthesisNode, RelationalNode, ArrayNode, BlockNode, ConditionalNode, ConstantNode, RangeNode, reviver, chain, FunctionAssignmentNode, AccessorNode, AssignmentNode, IndexNode, SymbolNode, FunctionNode, parse, resolve, simplifyCore, compile, Help, leafCount, simplify, symbolicEqual, evaluate, help, Parser, rationalize, derivative, parser;
var init_impureFunctionsAny_generated = __esm({
  "node_modules/mathjs/lib/esm/entry/impureFunctionsAny.generated.js"() {
    import_extends5 = __toESM(require_extends(), 1);
    init_configReadonly();
    init_factoriesAny();
    init_pureFunctionsAny_generated();
    math = {};
    mathWithTransform = {};
    classes = {};
    Chain = createChainClass({
      math
    });
    Node = createNode({
      mathWithTransform
    });
    ObjectNode = createObjectNode({
      Node
    });
    OperatorNode = createOperatorNode({
      Node
    });
    ParenthesisNode = createParenthesisNode({
      Node
    });
    RelationalNode = createRelationalNode({
      Node
    });
    ArrayNode = createArrayNode({
      Node
    });
    BlockNode = createBlockNode({
      Node,
      ResultSet
    });
    ConditionalNode = createConditionalNode({
      Node
    });
    ConstantNode = createConstantNode({
      Node
    });
    RangeNode = createRangeNode({
      Node
    });
    reviver = createReviver({
      classes
    });
    chain = createChain({
      Chain,
      typed
    });
    FunctionAssignmentNode = createFunctionAssignmentNode({
      Node,
      typed
    });
    AccessorNode = createAccessorNode({
      Node,
      subset
    });
    AssignmentNode = createAssignmentNode({
      matrix,
      Node,
      subset
    });
    IndexNode = createIndexNode({
      Node,
      size
    });
    SymbolNode = createSymbolNode({
      Unit,
      Node,
      math
    });
    FunctionNode = createFunctionNode({
      Node,
      SymbolNode,
      math
    });
    parse = createParse({
      AccessorNode,
      ArrayNode,
      AssignmentNode,
      BlockNode,
      ConditionalNode,
      ConstantNode,
      FunctionAssignmentNode,
      FunctionNode,
      IndexNode,
      ObjectNode,
      OperatorNode,
      ParenthesisNode,
      RangeNode,
      RelationalNode,
      SymbolNode,
      config,
      numeric: numeric2,
      typed
    });
    resolve = createResolve({
      ConstantNode,
      FunctionNode,
      OperatorNode,
      ParenthesisNode,
      parse
    });
    simplifyCore = createSimplifyCore({
      AccessorNode,
      ArrayNode,
      ConstantNode,
      FunctionNode,
      IndexNode,
      ObjectNode,
      OperatorNode,
      ParenthesisNode,
      SymbolNode,
      add,
      divide,
      equal,
      isZero,
      multiply,
      pow,
      subtract
    });
    compile = createCompile({
      parse,
      typed
    });
    Help = createHelpClass({
      parse
    });
    leafCount = createLeafCount({
      parse,
      typed
    });
    simplify = createSimplify({
      bignumber,
      fraction,
      AccessorNode,
      ArrayNode,
      ConstantNode,
      FunctionNode,
      IndexNode,
      ObjectNode,
      OperatorNode,
      ParenthesisNode,
      SymbolNode,
      add,
      config,
      divide,
      equal,
      isZero,
      mathWithTransform,
      matrix,
      multiply,
      parse,
      pow,
      resolve,
      simplifyCore,
      subtract,
      typed
    });
    symbolicEqual = createSymbolicEqual({
      OperatorNode,
      parse,
      simplify,
      typed
    });
    evaluate = createEvaluate({
      parse,
      typed
    });
    help = createHelp({
      Help,
      mathWithTransform,
      typed
    });
    Parser = createParserClass({
      evaluate
    });
    rationalize = createRationalize({
      bignumber,
      fraction,
      AccessorNode,
      ArrayNode,
      ConstantNode,
      FunctionNode,
      IndexNode,
      ObjectNode,
      OperatorNode,
      ParenthesisNode,
      SymbolNode,
      add,
      config,
      divide,
      equal,
      isZero,
      mathWithTransform,
      matrix,
      multiply,
      parse,
      pow,
      simplify,
      simplifyCore,
      subtract,
      typed
    });
    derivative = createDerivative({
      ConstantNode,
      FunctionNode,
      OperatorNode,
      ParenthesisNode,
      SymbolNode,
      config,
      equal,
      isZero,
      numeric: numeric2,
      parse,
      simplify,
      typed
    });
    parser = createParser({
      Parser,
      typed
    });
    (0, import_extends5.default)(math, {
      e: e2,
      false: _false,
      fineStructure,
      i,
      Infinity: _Infinity,
      LN10,
      LOG10E,
      NaN: _NaN,
      null: _null,
      phi: phi2,
      SQRT1_2,
      sackurTetrode,
      tau: tau2,
      true: _true,
      "E": e2,
      version: version2,
      efimovFactor,
      LN2,
      pi: pi2,
      replacer,
      reviver,
      SQRT2,
      typed,
      unaryPlus,
      "PI": pi2,
      weakMixingAngle,
      abs,
      acos,
      acot,
      acsc,
      addScalar,
      arg,
      asech,
      asinh: asinh2,
      atan,
      atanh: atanh2,
      bignumber,
      bitNot,
      boolean,
      chain,
      clone: clone2,
      combinations,
      complex,
      conj,
      cosh: cosh2,
      coth,
      csc,
      cube,
      equalScalar,
      erf,
      exp,
      expm1: expm13,
      filter: filter2,
      forEach: forEach2,
      format: format4,
      getMatrixDataType,
      hex,
      im,
      isInteger: isInteger2,
      isNegative,
      isPositive,
      isZero,
      LOG2E,
      lgamma,
      log10: log103,
      log2: log23,
      map: map2,
      multiplyScalar,
      not,
      number,
      oct,
      pickRandom,
      print,
      random,
      re,
      sec,
      sign: sign2,
      sin,
      splitUnit,
      square,
      string,
      tan,
      typeOf: typeOf2,
      acosh: acosh2,
      acsch,
      apply,
      asec,
      bin,
      combinationsWithRep,
      cos,
      csch,
      isNaN: isNaN2,
      isPrime,
      randomInt,
      sech,
      sinh: sinh2,
      sparse,
      sqrt,
      tanh: tanh2,
      unaryMinus,
      acoth,
      cot,
      fraction,
      isNumeric,
      matrix,
      matrixFromFunction,
      mod,
      nthRoot,
      numeric: numeric2,
      or,
      prod,
      reshape: reshape2,
      size,
      smaller,
      squeeze: squeeze2,
      subset,
      subtract,
      to,
      transpose,
      xgcd,
      zeros: zeros2,
      and,
      bitAnd,
      bitXor: bitXor2,
      cbrt: cbrt3,
      compare,
      compareText: compareText2,
      concat,
      count,
      ctranspose,
      diag,
      divideScalar,
      dotDivide,
      equal,
      fft,
      flatten: flatten2,
      gcd,
      hasNumericValue,
      hypot,
      ifft,
      kron,
      largerEq,
      leftShift,
      lsolve,
      matrixFromColumns,
      min,
      mode,
      nthRoots,
      ones,
      partitionSelect,
      resize: resize2,
      rightArithShift,
      round,
      smallerEq,
      unequal,
      usolve,
      xor,
      add,
      atan2,
      bitOr,
      catalan,
      compareNatural,
      cumsum,
      deepEqual,
      diff,
      dot,
      equalText,
      floor,
      identity,
      invmod,
      larger,
      log,
      lsolveAll,
      matrixFromRows,
      multiply,
      qr,
      range,
      rightLogShift,
      setSize,
      slu,
      sum,
      trace,
      usolveAll,
      asin,
      ceil,
      composition,
      cross,
      det,
      distance,
      dotMultiply,
      fix,
      intersect,
      lcm,
      log1p: log1p2,
      max,
      quantileSeq,
      row,
      setCartesian,
      setDistinct,
      setIsSubset,
      setPowerset,
      sort,
      column,
      index,
      inv,
      pinv,
      pow,
      setDifference,
      setMultiplicity,
      sqrtm,
      vacuumImpedance,
      wienDisplacement,
      atomicMass,
      bohrMagneton,
      boltzmann,
      conductanceQuantum,
      createUnit,
      deuteronMass,
      dotPow,
      electricConstant,
      elementaryCharge,
      expm,
      faraday,
      firstRadiation,
      gamma,
      gravitationConstant,
      hartreeEnergy,
      klitzing,
      loschmidt,
      magneticConstant,
      molarMass,
      molarPlanckConstant,
      neutronMass,
      nuclearMagneton,
      planckCharge,
      planckLength,
      planckTemperature,
      protonMass,
      reducedPlanckConstant,
      rydberg,
      setIntersect,
      speedOfLight,
      stefanBoltzmann,
      thomsonCrossSection,
      avogadro,
      bohrRadius,
      coulomb,
      divide,
      electronMass,
      factorial,
      gravity,
      inverseConductanceQuantum,
      lup,
      magneticFluxQuantum,
      molarMassC12,
      multinomial,
      parse,
      permutations,
      planckMass,
      quantumOfCirculation,
      resolve,
      secondRadiation,
      simplifyCore,
      stirlingS2,
      unit,
      bellNumbers,
      compile,
      eigs,
      fermiCoupling,
      leafCount,
      mean,
      molarVolume,
      planckConstant,
      setSymDifference,
      simplify,
      symbolicEqual,
      classicalElectronRadius,
      evaluate,
      help,
      lusolve,
      median,
      rationalize,
      setUnion,
      variance,
      derivative,
      kldivergence,
      norm,
      planckTime,
      rotationMatrix,
      gasConstant,
      parser,
      std,
      mad,
      rotate,
      config
    });
    (0, import_extends5.default)(mathWithTransform, math, {
      filter: createFilterTransform({
        typed
      }),
      forEach: createForEachTransform({
        typed
      }),
      map: createMapTransform({
        typed
      }),
      apply: createApplyTransform({
        isInteger: isInteger2,
        typed
      }),
      diff: createDiffTransform({
        bignumber,
        matrix,
        number,
        subtract,
        typed
      }),
      subset: createSubsetTransform({
        matrix,
        typed
      }),
      concat: createConcatTransform({
        isInteger: isInteger2,
        matrix,
        typed
      }),
      max: createMaxTransform({
        config,
        larger,
        numeric: numeric2,
        typed
      }),
      min: createMinTransform({
        config,
        numeric: numeric2,
        smaller,
        typed
      }),
      range: createRangeTransform({
        bignumber,
        matrix,
        config,
        larger,
        largerEq,
        smaller,
        smallerEq,
        typed
      }),
      sum: createSumTransform({
        add,
        config,
        numeric: numeric2,
        typed
      }),
      cumsum: createCumSumTransform({
        add,
        typed,
        unaryPlus
      }),
      row: createRowTransform({
        Index,
        matrix,
        range,
        typed
      }),
      column: createColumnTransform({
        Index,
        matrix,
        range,
        typed
      }),
      index: createIndexTransform({
        Index
      }),
      mean: createMeanTransform({
        add,
        divide,
        typed
      }),
      variance: createVarianceTransform({
        add,
        apply,
        divide,
        isNaN: isNaN2,
        multiply,
        subtract,
        typed
      }),
      std: createStdTransform({
        sqrt,
        typed,
        variance
      })
    });
    (0, import_extends5.default)(classes, {
      BigNumber,
      Chain,
      Complex: Complex2,
      Fraction: Fraction2,
      Matrix,
      Node,
      ObjectNode,
      OperatorNode,
      ParenthesisNode,
      Range,
      RelationalNode,
      ResultSet,
      ArrayNode,
      BlockNode,
      ConditionalNode,
      ConstantNode,
      DenseMatrix,
      RangeNode,
      FunctionAssignmentNode,
      SparseMatrix,
      AccessorNode,
      AssignmentNode,
      IndexNode,
      FibonacciHeap,
      ImmutableDenseMatrix,
      Index,
      Spa,
      Unit,
      SymbolNode,
      FunctionNode,
      Help,
      Parser
    });
    Chain.createProxy(math);
  }
});

// node_modules/mathjs/lib/esm/entry/typeChecks.js
var init_typeChecks = __esm({
  "node_modules/mathjs/lib/esm/entry/typeChecks.js"() {
  }
});

// node_modules/mathjs/lib/esm/entry/dependenciesAny.generated.js
var init_dependenciesAny_generated = __esm({
  "node_modules/mathjs/lib/esm/entry/dependenciesAny.generated.js"() {
  }
});

// node_modules/mathjs/lib/esm/entry/mainAny.js
var init_mainAny = __esm({
  "node_modules/mathjs/lib/esm/entry/mainAny.js"() {
    init_pureFunctionsAny_generated();
    init_impureFunctionsAny_generated();
    init_typeChecks();
    init_dependenciesAny_generated();
    init_factoriesAny();
  }
});

// node_modules/mathjs/lib/esm/index.js
var init_esm = __esm({
  "node_modules/mathjs/lib/esm/index.js"() {
    init_mainAny();
  }
});

// node_modules/scikitjs/dist/esm/dummy/DummyRegressor.js
var DummyRegressor;
var init_DummyRegressor = __esm({
  "node_modules/scikitjs/dist/esm/dummy/DummyRegressor.js"() {
    init_utils();
    init_typesUtils();
    init_esm();
    init_mixins();
    init_tf_singleton();
    DummyRegressor = class extends RegressorMixin {
      strategy;
      constant;
      quantile;
      name = "DummyRegressor";
      tf;
      constructor({ strategy = "mean", constant, quantile } = {}) {
        super();
        this.tf = getBackend2();
        this.strategy = strategy;
        this.constant = constant;
        this.quantile = quantile;
      }
      fit(X, y) {
        assert(isScikit1D(y), "y variable can not be converted to a 1D Tensor.");
        assert(["mean", "median", "constant", "quantile"].includes(this.strategy), `Strategy ${this.strategy} not supported. We support 'mean', 'median', 'constant', and 'quantile'`);
        const newY = convertToNumericTensor1D(y);
        if (this.strategy === "mean") {
          this.constant = newY.mean().dataSync()[0];
          return this;
        }
        if (this.strategy === "median") {
          this.constant = median(newY.arraySync());
          return this;
        }
        if (this.strategy === "quantile") {
          assert(typeof this.quantile === "number" && !isNaN(this.quantile) && isFinite(this.quantile), "quantile is not set to a number. Please set it to a value between 0 and 1 in the constructor");
          assert(this.quantile < 0 || this.quantile > 1, "quantile must be set to a value between 0 and 1");
          this.constant = quantileSeq(newY.arraySync(), this.quantile);
          return this;
        }
        return this;
      }
      predict(X) {
        assert(isScikit2D(X), "Data can not be converted to a 2D matrix.");
        let newData = convertToNumericTensor2D(X);
        let length = newData.shape[0];
        return this.tf.tensor1d(Array(length).fill(this.constant));
      }
    };
  }
});

// node_modules/simple-statistics/dist/simple-statistics.mjs
function modeFast(x) {
  var index2 = /* @__PURE__ */ new Map();
  var mode2;
  var modeCount = 0;
  for (var i2 = 0; i2 < x.length; i2++) {
    var newCount = index2.get(x[i2]);
    if (newCount === void 0) {
      newCount = 1;
    } else {
      newCount++;
    }
    if (newCount > modeCount) {
      mode2 = x[i2];
      modeCount = newCount;
    }
    index2.set(x[i2], newCount);
  }
  if (modeCount === 0) {
    throw new Error("mode requires at last one data point");
  }
  return mode2;
}
function cumulativeDistribution(z) {
  var sum2 = z, tmp = z;
  for (var i2 = 1; i2 < 15; i2++) {
    tmp *= z * z / (2 * i2 + 1);
    sum2 += tmp;
  }
  return Math.round((0.5 + sum2 / SQRT_2PI * Math.exp(-z * z / 2)) * 1e4) / 1e4;
}
var BayesianClassifier, PerceptronModel, g, LOGSQRT2PI, SQRT_2PI$1, SQRT_2PI, standardNormalTable, z;
var init_simple_statistics = __esm({
  "node_modules/simple-statistics/dist/simple-statistics.mjs"() {
    BayesianClassifier = function BayesianClassifier2() {
      this.totalCount = 0;
      this.data = {};
    };
    BayesianClassifier.prototype.train = function train(item, category) {
      if (!this.data[category]) {
        this.data[category] = {};
      }
      for (var k in item) {
        var v = item[k];
        if (this.data[category][k] === void 0) {
          this.data[category][k] = {};
        }
        if (this.data[category][k][v] === void 0) {
          this.data[category][k][v] = 0;
        }
        this.data[category][k][v]++;
      }
      this.totalCount++;
    };
    BayesianClassifier.prototype.score = function score(item) {
      var odds = {};
      var category;
      for (var k in item) {
        var v = item[k];
        for (category in this.data) {
          odds[category] = {};
          if (this.data[category][k]) {
            odds[category][k + "_" + v] = (this.data[category][k][v] || 0) / this.totalCount;
          } else {
            odds[category][k + "_" + v] = 0;
          }
        }
      }
      var oddsSums = {};
      for (category in odds) {
        oddsSums[category] = 0;
        for (var combination in odds[category]) {
          oddsSums[category] += odds[category][combination];
        }
      }
      return oddsSums;
    };
    PerceptronModel = function PerceptronModel2() {
      this.weights = [];
      this.bias = 0;
    };
    PerceptronModel.prototype.predict = function predict(features) {
      if (features.length !== this.weights.length) {
        return null;
      }
      var score2 = 0;
      for (var i2 = 0; i2 < this.weights.length; i2++) {
        score2 += this.weights[i2] * features[i2];
      }
      score2 += this.bias;
      if (score2 > 0) {
        return 1;
      } else {
        return 0;
      }
    };
    PerceptronModel.prototype.train = function train2(features, label) {
      if (label !== 0 && label !== 1) {
        return null;
      }
      if (features.length !== this.weights.length) {
        this.weights = features;
        this.bias = 1;
      }
      var prediction = this.predict(features);
      if (typeof prediction === "number" && prediction !== label) {
        var gradient = label - prediction;
        for (var i2 = 0; i2 < this.weights.length; i2++) {
          this.weights[i2] += gradient * features[i2];
        }
        this.bias += gradient;
      }
      return this;
    };
    g = 607 / 128;
    LOGSQRT2PI = Math.log(Math.sqrt(2 * Math.PI));
    SQRT_2PI$1 = Math.sqrt(2 * Math.PI);
    SQRT_2PI = Math.sqrt(2 * Math.PI);
    standardNormalTable = [];
    for (z = 0; z <= 3.09; z += 0.01) {
      standardNormalTable.push(cumulativeDistribution(z));
    }
  }
});

// node_modules/lodash/_baseRandom.js
var require_baseRandom = __commonJS({
  "node_modules/lodash/_baseRandom.js"(exports, module) {
    var nativeFloor = Math.floor;
    var nativeRandom = Math.random;
    function baseRandom(lower, upper) {
      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
    }
    module.exports = baseRandom;
  }
});

// node_modules/lodash/_arraySample.js
var require_arraySample = __commonJS({
  "node_modules/lodash/_arraySample.js"(exports, module) {
    var baseRandom = require_baseRandom();
    function arraySample(array) {
      var length = array.length;
      return length ? array[baseRandom(0, length - 1)] : void 0;
    }
    module.exports = arraySample;
  }
});

// node_modules/lodash/_arrayMap.js
var require_arrayMap = __commonJS({
  "node_modules/lodash/_arrayMap.js"(exports, module) {
    function arrayMap(array, iteratee) {
      var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index2 < length) {
        result[index2] = iteratee(array[index2], index2, array);
      }
      return result;
    }
    module.exports = arrayMap;
  }
});

// node_modules/lodash/_baseValues.js
var require_baseValues = __commonJS({
  "node_modules/lodash/_baseValues.js"(exports, module) {
    var arrayMap = require_arrayMap();
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    module.exports = baseValues;
  }
});

// node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  "node_modules/lodash/_baseTimes.js"(exports, module) {
    function baseTimes(n, iteratee) {
      var index2 = -1, result = Array(n);
      while (++index2 < n) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    module.exports = baseTimes;
  }
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/lodash/isObjectLike.js"(exports, module) {
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module.exports = isObjectLike;
  }
});

// node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  "node_modules/lodash/_baseIsArguments.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    module.exports = baseIsArguments;
  }
});

// node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/lodash/isArguments.js"(exports, module) {
    var baseIsArguments = require_baseIsArguments();
    var isObjectLike = require_isObjectLike();
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty3.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    module.exports = isArguments;
  }
});

// node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "node_modules/lodash/isArray.js"(exports, module) {
    var isArray2 = Array.isArray;
    module.exports = isArray2;
  }
});

// node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  "node_modules/lodash/stubFalse.js"(exports, module) {
    function stubFalse() {
      return false;
    }
    module.exports = stubFalse;
  }
});

// node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  "node_modules/lodash/isBuffer.js"(exports, module) {
    var root = require_root();
    var stubFalse = require_stubFalse();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    module.exports = isBuffer;
  }
});

// node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "node_modules/lodash/_isIndex.js"(exports, module) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex2(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    module.exports = isIndex2;
  }
});

// node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "node_modules/lodash/isLength.js"(exports, module) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    module.exports = isLength;
  }
});

// node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "node_modules/lodash/_baseIsTypedArray.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    module.exports = baseIsTypedArray;
  }
});

// node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "node_modules/lodash/_baseUnary.js"(exports, module) {
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    module.exports = baseUnary;
  }
});

// node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "node_modules/lodash/_nodeUtil.js"(exports, module) {
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e3) {
      }
    }();
    module.exports = nodeUtil;
  }
});

// node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "node_modules/lodash/isTypedArray.js"(exports, module) {
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module.exports = isTypedArray2;
  }
});

// node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  "node_modules/lodash/_arrayLikeKeys.js"(exports, module) {
    var baseTimes = require_baseTimes();
    var isArguments = require_isArguments();
    var isArray2 = require_isArray();
    var isBuffer = require_isBuffer();
    var isIndex2 = require_isIndex();
    var isTypedArray2 = require_isTypedArray();
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty3.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex2(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = arrayLikeKeys;
  }
});

// node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  "node_modules/lodash/_isPrototype.js"(exports, module) {
    var objectProto = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    module.exports = isPrototype;
  }
});

// node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "node_modules/lodash/_overArg.js"(exports, module) {
    function overArg(func, transform) {
      return function(arg2) {
        return func(transform(arg2));
      };
    }
    module.exports = overArg;
  }
});

// node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
  "node_modules/lodash/_nativeKeys.js"(exports, module) {
    var overArg = require_overArg();
    var nativeKeys = overArg(Object.keys, Object);
    module.exports = nativeKeys;
  }
});

// node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
  "node_modules/lodash/_baseKeys.js"(exports, module) {
    var isPrototype = require_isPrototype();
    var nativeKeys = require_nativeKeys();
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty3.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = baseKeys;
  }
});

// node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  "node_modules/lodash/isArrayLike.js"(exports, module) {
    var isFunction2 = require_isFunction();
    var isLength = require_isLength();
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction2(value);
    }
    module.exports = isArrayLike;
  }
});

// node_modules/lodash/keys.js
var require_keys = __commonJS({
  "node_modules/lodash/keys.js"(exports, module) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeys = require_baseKeys();
    var isArrayLike = require_isArrayLike();
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    module.exports = keys;
  }
});

// node_modules/lodash/values.js
var require_values = __commonJS({
  "node_modules/lodash/values.js"(exports, module) {
    var baseValues = require_baseValues();
    var keys = require_keys();
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }
    module.exports = values;
  }
});

// node_modules/lodash/_baseSample.js
var require_baseSample = __commonJS({
  "node_modules/lodash/_baseSample.js"(exports, module) {
    var arraySample = require_arraySample();
    var values = require_values();
    function baseSample(collection) {
      return arraySample(values(collection));
    }
    module.exports = baseSample;
  }
});

// node_modules/lodash/sample.js
var require_sample = __commonJS({
  "node_modules/lodash/sample.js"(exports, module) {
    var arraySample = require_arraySample();
    var baseSample = require_baseSample();
    var isArray2 = require_isArray();
    function sample2(collection) {
      var func = isArray2(collection) ? arraySample : baseSample;
      return func(collection);
    }
    module.exports = sample2;
  }
});

// node_modules/scikitjs/dist/esm/dummy/DummyClassifier.js
var import_uniq2, import_sample, DummyClassifier;
var init_DummyClassifier = __esm({
  "node_modules/scikitjs/dist/esm/dummy/DummyClassifier.js"() {
    init_utils();
    init_typesUtils();
    init_simple_statistics();
    import_uniq2 = __toESM(require_uniq());
    import_sample = __toESM(require_sample());
    init_mixins();
    init_tf_singleton();
    DummyClassifier = class extends ClassifierMixin {
      constant;
      strategy;
      classes;
      name = "DummyClassifier";
      tf;
      constructor({ strategy = "mostFrequent", constant = 0 } = {}) {
        super();
        this.tf = getBackend2();
        this.constant = constant;
        this.strategy = strategy;
        this.classes = [];
      }
      fit(X, y) {
        assert(isScikit1D(y), "Data can not be converted to a 1D or 2D matrix.");
        assert(["mostFrequent", "uniform", "constant"].includes(this.strategy), `Strategy ${this.strategy} not supported. We support 'mostFrequent', 'uniform', and 'constant'`);
        const newY = convertToNumericTensor1D(y);
        this.classes = (0, import_uniq2.default)(newY.arraySync());
        if (this.strategy === "mostFrequent") {
          this.constant = modeFast(newY.arraySync());
          return this;
        }
        return this;
      }
      predictProba(X) {
        assert(isScikit2D(X), "Data can not be converted to a 1D or 2D matrix.");
        assert(["mostFrequent", "uniform", "constant"].includes(this.strategy), `Strategy ${this.strategy} not supported. We support 'mostFrequent', 'uniform', and 'constant'`);
        return this.tf.oneHot(this.predict(X).toInt(), this.classes.length);
      }
      predict(X) {
        assert(isScikit2D(X), "Data can not be converted to a 1D or 2D matrix.");
        assert(["mostFrequent", "uniform", "constant"].includes(this.strategy), `Strategy ${this.strategy} not supported. We support 'mostFrequent', 'uniform', and 'constant'`);
        let newData = convertToNumericTensor2D(X);
        let length = newData.shape[0];
        if (this.strategy === "mostFrequent" || this.strategy === "constant") {
          return this.tf.tensor1d(Array(length).fill(this.constant));
        }
        let returnArr = [];
        for (let i2 = 0; i2 < length; i2++) {
          returnArr.push((0, import_sample.default)(this.classes));
        }
        return this.tf.tensor1d(returnArr);
      }
    };
  }
});

// node_modules/scikitjs/dist/esm/math.js
function tensorMin(tensor, axis, ignoreNaN) {
  let tf3 = getBackend2();
  if (ignoreNaN) {
    return tf3.tidy(() => tf3.where(tensor.isNaN(), Infinity, tensor).min(axis));
  }
  return tensor.min(axis);
}
function tensorMax(tensor, axis, ignoreNaN) {
  let tf3 = getBackend2();
  if (ignoreNaN) {
    return tf3.tidy(() => tf3.where(tensor.isNaN(), -Infinity, tensor).max(axis));
  }
  return tensor.min(axis);
}
function tensorSum(tensor, axis, ignoreNaN) {
  let tf3 = getBackend2();
  if (ignoreNaN) {
    return tf3.tidy(() => tf3.where(tensor.isNaN(), 0, tensor).sum(axis));
  }
  return tensor.sum(axis);
}
function tensorCount(tensor, axis, ignoreNaN) {
  let tf3 = getBackend2();
  if (ignoreNaN) {
    return tf3.tidy(() => tf3.logicalNot(tensor.isNaN()).sum(axis));
  }
  return tf3.onesLike(tensor).sum(axis);
}
function tensorMean(tensor, axis, ignoreNaN, safe) {
  let tf3 = getBackend2();
  if (!ignoreNaN) {
    return tensor.mean(axis);
  }
  if (safe) {
    return tf3.tidy(() => tensorSum(tensor, axis, ignoreNaN).div(turnZerosToOnes(tensorCount(tensor, axis, ignoreNaN))));
  }
  return tf3.tidy(() => tensorSum(tensor, axis, ignoreNaN).div(tensorCount(tensor, axis, ignoreNaN)));
}
function tensorStd(tensor, dim, ignoreNaN) {
  assert(Boolean(ignoreNaN), "We only need to call this function when ignoreNaN is true");
  let tf3 = getBackend2();
  return tf3.tidy(() => {
    const mean2 = tensorMean(tensor, dim, ignoreNaN);
    const countNaN = tensorCount(tensor, dim, ignoreNaN);
    const numerator = tensorSum(tensor.sub(mean2).square(), dim, ignoreNaN);
    const denominator = turnZerosToOnes(countNaN);
    return numerator.div(denominator).sqrt();
  });
}
function turnZerosToOnes(tensor) {
  let tf3 = getBackend2();
  return tf3.tidy(() => {
    const zeros3 = tf3.zerosLike(tensor);
    const booleanAddition = tensor.equal(zeros3);
    return tensor.add(booleanAddition);
  });
}
var init_math = __esm({
  "node_modules/scikitjs/dist/esm/math.js"() {
    init_typesUtils();
    init_tf_singleton();
  }
});

// node_modules/scikitjs/dist/esm/preprocessing/MinMaxScaler.js
var MinMaxScaler;
var init_MinMaxScaler = __esm({
  "node_modules/scikitjs/dist/esm/preprocessing/MinMaxScaler.js"() {
    init_utils();
    init_typesUtils();
    init_math();
    init_mixins();
    init_tf_singleton();
    MinMaxScaler = class extends TransformerMixin {
      featureRange;
      scale;
      min;
      dataMin;
      dataMax;
      dataRange;
      nFeaturesIn;
      nSamplesSeen;
      featureNamesIn;
      name = "MinMaxScaler";
      constructor({ featureRange = [0, 1] } = {}) {
        super();
        this.tf = getBackend2();
        this.featureRange = featureRange;
        this.scale = this.tf.tensor1d([]);
        this.min = this.tf.tensor1d([]);
        this.dataMin = this.tf.tensor1d([]);
        this.dataMax = this.tf.tensor1d([]);
        this.dataRange = this.tf.tensor1d([]);
        this.nFeaturesIn = 0;
        this.nSamplesSeen = 0;
        this.featureNamesIn = [];
      }
      isNumber(value) {
        return typeof value === "number" && isFinite(value);
      }
      fit(X) {
        assert(isScikit2D(X), "Data can not be converted to a 2D matrix.");
        assert(this.isNumber(this.featureRange[0]) && this.isNumber(this.featureRange[1]) && this.featureRange[0] < this.featureRange[1], "featureRange needs to contain exactly two numbers where the first is less than the second");
        const tensorArray = convertToNumericTensor2D(X);
        const max2 = tensorMax(tensorArray, 0, true);
        const min2 = tensorMin(tensorArray, 0, true);
        const range2 = max2.sub(min2);
        this.scale = this.tf.div(this.featureRange[1] - this.featureRange[0], turnZerosToOnes(range2));
        this.min = this.tf.sub(this.featureRange[0], min2.mul(this.scale));
        this.dataMin = min2;
        this.dataMax = max2;
        this.dataRange = range2;
        this.nSamplesSeen = tensorArray.shape[0];
        this.nFeaturesIn = tensorArray.shape[1];
        if (isDataFrameInterface(X)) {
          this.featureNamesIn = [...X.columns];
        }
        return this;
      }
      transform(X) {
        assert(isScikit2D(X), "Data can not be converted to a 2D matrix.");
        const tensorArray = convertToNumericTensor2D(X);
        const outputData = tensorArray.mul(this.scale).add(this.min);
        return outputData;
      }
      inverseTransform(X) {
        assert(isScikit2D(X), "Data can not be converted to a 2D matrix.");
        const tensorArray = convertToNumericTensor2D(X);
        const outputData = tensorArray.sub(this.min).div(this.scale);
        return outputData;
      }
    };
  }
});

// node_modules/scikitjs/dist/esm/preprocessing/StandardScaler.js
var StandardScaler;
var init_StandardScaler = __esm({
  "node_modules/scikitjs/dist/esm/preprocessing/StandardScaler.js"() {
    init_utils();
    init_typesUtils();
    init_math();
    init_mixins();
    init_tf_singleton();
    StandardScaler = class extends TransformerMixin {
      scale;
      mean;
      withMean;
      withStd;
      nFeaturesIn;
      nSamplesSeen;
      featureNamesIn;
      name = "StandardScaler";
      constructor({ withMean = true, withStd = true } = {}) {
        super();
        this.tf = getBackend2();
        this.withMean = withMean;
        this.withStd = withStd;
        this.scale = this.tf.tensor1d([]);
        this.mean = this.tf.tensor1d([]);
        this.nFeaturesIn = 0;
        this.nSamplesSeen = 0;
        this.featureNamesIn = [];
      }
      fit(X) {
        assert(isScikit2D(X), "Data can not be converted to a 2D matrix.");
        const tensorArray = convertToNumericTensor2D(X);
        if (this.withMean) {
          this.mean = tensorMean(tensorArray, 0, true);
        }
        if (this.withStd) {
          const std2 = tensorStd(tensorArray, 0, true);
          this.scale = turnZerosToOnes(std2);
        }
        this.nSamplesSeen = tensorArray.shape[0];
        this.nFeaturesIn = tensorArray.shape[1];
        if (isDataFrameInterface(X)) {
          this.featureNamesIn = [...X.columns];
        }
        return this;
      }
      transform(X) {
        assert(isScikit2D(X), "Data can not be converted to a 2D matrix.");
        let tensorArray = convertToNumericTensor2D(X);
        if (this.withMean) {
          tensorArray = tensorArray.sub(this.mean);
        }
        if (this.withStd) {
          tensorArray = tensorArray.div(this.scale);
        }
        return tensorArray;
      }
      inverseTransform(X) {
        assert(isScikit2D(X), "Data can not be converted to a 2D matrix.");
        let tensorArray = convertToNumericTensor2D(X);
        if (this.withStd) {
          tensorArray = tensorArray.mul(this.scale);
        }
        if (this.withMean) {
          tensorArray = tensorArray.add(this.mean);
        }
        return tensorArray;
      }
    };
  }
});

// node_modules/scikitjs/dist/esm/preprocessing/MaxAbsScaler.js
var MaxAbsScaler;
var init_MaxAbsScaler = __esm({
  "node_modules/scikitjs/dist/esm/preprocessing/MaxAbsScaler.js"() {
    init_utils();
    init_typesUtils();
    init_math();
    init_mixins();
    init_tf_singleton();
    MaxAbsScaler = class extends TransformerMixin {
      scale;
      nFeaturesIn;
      nSamplesSeen;
      featureNamesIn;
      name = "MaxAbsScaler";
      constructor() {
        super();
        this.tf = getBackend2();
        this.scale = this.tf.tensor1d([]);
        this.nFeaturesIn = 0;
        this.nSamplesSeen = 0;
        this.featureNamesIn = [];
      }
      fit(X) {
        assert(isScikit2D(X), "Data can not be converted to a 2D matrix.");
        const tensorArray = convertToNumericTensor2D(X);
        const scale = tensorMax(tensorArray.abs(), 0, true);
        this.scale = turnZerosToOnes(scale);
        this.nSamplesSeen = tensorArray.shape[0];
        this.nFeaturesIn = tensorArray.shape[1];
        if (isDataFrameInterface(X)) {
          this.featureNamesIn = [...X.columns];
        }
        return this;
      }
      transform(X) {
        assert(isScikit2D(X), "Data can not be converted to a 2D matrix.");
        const tensorArray = convertToNumericTensor2D(X);
        const outputData = tensorArray.div(this.scale);
        return outputData;
      }
      inverseTransform(X) {
        assert(isScikit2D(X), "Data can not be converted to a 2D matrix.");
        const tensorArray = convertToNumericTensor2D(X);
        const outputData = tensorArray.mul(this.scale);
        return outputData;
      }
    };
  }
});

// node_modules/scikitjs/dist/esm/impute/SimpleImputer.js
function isEmpty(value) {
  return value === void 0 || value === null || isNaN(value) && typeof value !== "string";
}
function removeMissingValuesFromArray(arr) {
  const values = arr.filter((val) => {
    return !isEmpty(val);
  });
  return values;
}
var SimpleImputer;
var init_SimpleImputer = __esm({
  "node_modules/scikitjs/dist/esm/impute/SimpleImputer.js"() {
    init_utils();
    init_math();
    init_esm();
    init_simple_statistics();
    init_mixins();
    init_tf_singleton();
    SimpleImputer = class extends TransformerMixin {
      missingValues;
      fillValue;
      strategy;
      statistics;
      name = "SimpleImputer";
      tf;
      constructor({ strategy = "mean", fillValue = void 0, missingValues = NaN } = {}) {
        super();
        this.tf = getBackend2();
        this.missingValues = missingValues;
        this.strategy = strategy;
        this.fillValue = fillValue;
        this.statistics = this.tf.tensor1d([]);
      }
      fit(X) {
        if (this.strategy === "constant") {
          return this;
        }
        if (this.strategy === "mean") {
          const newTensor = convertToNumericTensor2D(X);
          const mean2 = tensorMean(newTensor, 0, true);
          this.statistics = mean2;
          return this;
        }
        if (this.strategy === "mostFrequent") {
          const newTensor = convertToNumericTensor2D(X);
          const mostFrequents = newTensor.transpose().arraySync().map((arr) => modeFast(removeMissingValuesFromArray(arr)));
          this.statistics = this.tf.tensor1d(mostFrequents);
          return this;
        }
        if (this.strategy === "median") {
          const newTensor = convertToNumericTensor2D(X);
          const medians = newTensor.transpose().arraySync().map((arr) => median(removeMissingValuesFromArray(arr)));
          this.statistics = this.tf.tensor1d(medians);
          return this;
        }
        throw new Error(`Strategy ${this.strategy} is unsupported. Supported strategies are 'mean', 'median', 'mostFrequent', and 'constant'`);
      }
      transform(X) {
        if (this.strategy === "constant") {
          const newTensor2 = convertToTensor2D(X);
          if (this.fillValue === void 0) {
            if (newTensor2.dtype !== "string") {
              return this.tf.where(newTensor2.isNaN(), 0, newTensor2);
            } else {
              return this.tf.where(newTensor2.isNaN(), "missing_value", newTensor2);
            }
          }
          return this.tf.where(newTensor2.isNaN(), this.fillValue, newTensor2);
        }
        const newTensor = convertToNumericTensor2D(X);
        return this.tf.where(newTensor.isNaN(), this.statistics.reshape([1, -1]), newTensor);
      }
    };
  }
});

// node_modules/scikitjs/dist/esm/preprocessing/LabelEncoder.js
var LabelEncoder;
var init_LabelEncoder = __esm({
  "node_modules/scikitjs/dist/esm/preprocessing/LabelEncoder.js"() {
    init_typesUtils();
    init_tf_singleton();
    init_simpleSerializer();
    LabelEncoder = class extends Serialize {
      classes;
      name = "LabelEncoder";
      tf;
      constructor() {
        super();
        this.tf = getBackend2();
        this.classes = [];
      }
      convertTo1DArray(X) {
        if (isSeriesInterface(X)) {
          return X.values;
        }
        if (isTensor(X)) {
          return X.arraySync();
        }
        return X;
      }
      classesToMapping(classes2) {
        const labels = /* @__PURE__ */ new Map();
        classes2.forEach((value, index2) => {
          labels.set(value, index2);
        });
        return labels;
      }
      fit(X) {
        const arr = this.convertTo1DArray(X);
        const dataSet = Array.from(new Set(arr));
        this.classes = dataSet;
        return this;
      }
      transform(X) {
        const arr = this.convertTo1DArray(X);
        const labels = this.classesToMapping(this.classes);
        const encodedData = arr.map((value) => {
          let val = labels.get(value);
          return val === void 0 ? -1 : val;
        });
        return this.tf.tensor1d(encodedData);
      }
      fitTransform(X) {
        return this.fit(X).transform(X);
      }
      inverseTransform(X) {
        const arr = this.convertTo1DArray(X);
        const labels = this.classesToMapping(this.classes);
        const invMap = new Map(Array.from(labels, (a) => a.reverse()));
        const tempData = arr.map((value) => {
          return invMap.get(value) === void 0 ? null : invMap.get(value);
        });
        return tempData;
      }
    };
  }
});

// node_modules/scikitjs/dist/esm/preprocessing/OrdinalEncoder.js
var OrdinalEncoder;
var init_OrdinalEncoder = __esm({
  "node_modules/scikitjs/dist/esm/preprocessing/OrdinalEncoder.js"() {
    init_utils();
    init_mixins();
    init_tf_singleton();
    init_typesUtils();
    OrdinalEncoder = class extends TransformerMixin {
      categories;
      handleUnknown;
      unknownValue;
      categoriesParam;
      nFeaturesIn;
      featureNamesIn;
      name = "OrdinalEncoder";
      constructor({ categories = "auto", handleUnknown = "error", unknownValue = NaN } = {}) {
        super();
        this.tf = getBackend2();
        this.categoriesParam = categories;
        this.categories = [];
        this.handleUnknown = handleUnknown;
        this.unknownValue = unknownValue;
        this.nFeaturesIn = 0;
        this.featureNamesIn = [];
      }
      classesToMapping(classes2) {
        const labels = /* @__PURE__ */ new Map();
        classes2.forEach((value, index2) => {
          labels.set(value, index2);
        });
        return labels;
      }
      loopOver2DArrayToSetLabels(array2D) {
        for (let j = 0; j < array2D[0].length; j++) {
          let curSet = /* @__PURE__ */ new Set();
          for (let i2 = 0; i2 < array2D.length; i2++) {
            curSet.add(array2D[i2][j]);
          }
          let results = Array.from(curSet);
          this.categories.push(results);
        }
      }
      fit(X, y) {
        const array2D = convertScikit2DToArray(X);
        if (this.categoriesParam === "auto") {
          this.loopOver2DArrayToSetLabels(array2D);
          return this;
        }
        this.categories = this.categoriesParam;
        this.nFeaturesIn = array2D.length === 0 ? 0 : array2D[0].length || 0;
        if (isDataFrameInterface(X)) {
          this.featureNamesIn = [...X.columns];
        }
        return this;
      }
      loopOver2DArrayToUseLabels(array2D) {
        let labels = this.categories.map((el) => this.classesToMapping(el));
        let finalArray = [];
        for (let i2 = 0; i2 < array2D.length; i2++) {
          let curArray = [];
          for (let j = 0; j < array2D[0].length; j++) {
            let curElem = array2D[i2][j];
            let val = labels[j].get(curElem);
            if (val === void 0) {
              if (this.handleUnknown === "error") {
                throw new Error(`Unknown value ${curElem} encountered while transforming. Not encountered in training data`);
              } else {
                val = this.unknownValue;
              }
            }
            curArray.push(val);
          }
          finalArray.push(curArray);
        }
        return finalArray;
      }
      transform(X, y) {
        const array2D = convertScikit2DToArray(X);
        const result2D = this.loopOver2DArrayToUseLabels(array2D);
        return this.tf.tensor2d(result2D, void 0, "int32");
      }
    };
  }
});

// node_modules/scikitjs/dist/esm/preprocessing/Normalizer.js
var Normalizer;
var init_Normalizer = __esm({
  "node_modules/scikitjs/dist/esm/preprocessing/Normalizer.js"() {
    init_utils();
    init_typesUtils();
    init_mixins();
    init_tf_singleton();
    Normalizer = class extends TransformerMixin {
      norm;
      nFeaturesIn;
      featureNamesIn;
      name = "Normalizer";
      constructor({ norm: norm2 = "l2" } = {}) {
        super();
        this.tf = getBackend2();
        this.norm = norm2;
        this.nFeaturesIn = 0;
        this.featureNamesIn = [];
      }
      fit(X) {
        assert(isScikit2D(X), "Data can not be converted to a 2D matrix.");
        const tensorArray = convertToNumericTensor2D(X);
        this.nFeaturesIn = tensorArray.shape[1];
        if (isDataFrameInterface(X)) {
          this.featureNamesIn = [...X.columns];
        }
        return this;
      }
      transform(X) {
        assert(isScikit2D(X), "Data can not be converted to a 2D matrix.");
        const tensorArray = convertToNumericTensor2D(X);
        if (this.norm === "l1") {
          const means2 = this.tf.abs(tensorArray).sum(1).reshape([-1, 1]);
          return tensorArray.divNoNan(means2);
        }
        if (this.norm === "l2") {
          const means2 = tensorArray.square().sum(1).sqrt().reshape([-1, 1]);
          return tensorArray.divNoNan(means2);
        }
        const means = this.tf.abs(tensorArray).max(1).reshape([-1, 1]);
        return tensorArray.divNoNan(means);
      }
    };
  }
});

// node_modules/scikitjs/dist/esm/pipeline/Pipeline.js
function makePipeline(...args) {
  let pipelineSteps = [];
  for (let i2 = 0; i2 < args.length; i2++) {
    let cur = args[i2];
    pipelineSteps.push([cur.name, cur]);
  }
  return new Pipeline({ steps: pipelineSteps });
}
var Pipeline;
var init_Pipeline = __esm({
  "node_modules/scikitjs/dist/esm/pipeline/Pipeline.js"() {
    init_typesUtils();
    init_simpleSerializer();
    Pipeline = class extends Serialize {
      steps;
      name = "Pipeline";
      constructor({ steps = [] } = {}) {
        super();
        this.steps = steps;
        this.validateSteps(this.steps);
      }
      isTransformer(possibleTransformer) {
        if (possibleTransformer === "passthrough") {
          return true;
        }
        if (typeof possibleTransformer.fit === "function" && typeof possibleTransformer.transform === "function" && typeof possibleTransformer.fitTransform === "function") {
          return true;
        }
        return false;
      }
      isEstimator(possibleTransformer) {
        if (possibleTransformer === "passthrough") {
          return true;
        }
        if (typeof possibleTransformer.fit === "function") {
          return true;
        }
        return false;
      }
      validateSteps(steps) {
        assert(Array.isArray(steps), `steps is not an array. It is ${steps}`);
        if (steps.length === 0) {
          return;
        }
        for (let i2 = 0; i2 < steps.length - 1; i2++) {
          const step = steps[i2];
          assert(Array.isArray(step), `A single step in your pipeline must be an array containing a string as the first argument, and the transformer in the second. Something akin to ['minmaxscaler', new MinMaxScaler()]. Instead it is ${step}`);
          assert(this.isTransformer(step[1]), `The ${i2}th step in your pipeline isn't an array containing a name and a Transformer. Instead it is ${steps[i2]}.`);
        }
        let lastEstimator = steps[steps.length - 1];
        assert(Array.isArray(lastEstimator), `The last element in your pipeline must be a 2-element array that contains a string as the first argument, and an estimator as the second. Instead it is ${lastEstimator}`);
        assert(this.isEstimator(lastEstimator[1]), `The last element in your pipeline should be an Estimator. Instead it is ${lastEstimator}`);
      }
      transformExceptLast(X) {
        let XT = X;
        for (let i2 = 0; i2 < this.steps.length - 1; i2++) {
          const [, transformer] = this.steps[i2];
          if (transformer === "passthrough") {
            continue;
          }
          XT = transformer.transform(XT);
        }
        return XT;
      }
      fitTransformExceptLast(X) {
        let XT = X;
        for (let i2 = 0; i2 < this.steps.length - 1; i2++) {
          const [, transformer] = this.steps[i2];
          if (transformer === "passthrough") {
            continue;
          }
          XT = transformer.fitTransform(XT);
        }
        return XT;
      }
      getLastEstimator() {
        if (this.steps.length === 0) {
          return null;
        }
        return this.steps[this.steps.length - 1][1];
      }
      assertEstimatorHasFunction(estimator, funcName) {
        assert(estimator !== null, `Your final Estimator is null and therefore you can't call ${funcName}`);
        assert(typeof estimator[funcName] === "function", `Estimator ${estimator} doesn't implement the function ${funcName}`);
      }
      async fit(X, y) {
        this.validateSteps(this.steps);
        const lastEstimator = this.getLastEstimator();
        this.assertEstimatorHasFunction(lastEstimator, "fit");
        let XT = this.fitTransformExceptLast(X);
        await lastEstimator.fit(XT, y);
        return this;
      }
      transform(X) {
        this.validateSteps(this.steps);
        const lastEstimator = this.getLastEstimator();
        this.assertEstimatorHasFunction(lastEstimator, "transform");
        let XT = this.transformExceptLast(X);
        return lastEstimator.transform(XT);
      }
      fitTransform(X, y) {
        this.validateSteps(this.steps);
        const lastEstimator = this.getLastEstimator();
        this.assertEstimatorHasFunction(lastEstimator, "fitTransform");
        let XT = this.fitTransformExceptLast(X);
        return lastEstimator.fitTransform(XT);
      }
      predict(X) {
        this.validateSteps(this.steps);
        const lastEstimator = this.getLastEstimator();
        this.assertEstimatorHasFunction(lastEstimator, "predict");
        let XT = this.transformExceptLast(X);
        return lastEstimator.predict(XT);
      }
      async fitPredict(X, y) {
        this.validateSteps(this.steps);
        const lastEstimator = this.getLastEstimator();
        this.assertEstimatorHasFunction(lastEstimator, "fitPredict");
        let XT = this.fitTransformExceptLast(X);
        return await lastEstimator.fitPredict(XT, y);
      }
    };
  }
});

// node_modules/scikitjs/dist/esm/compose/ColumnTransformer.js
function isStringArray(arr) {
  return Array.isArray(arr) && typeof arr[0] === "string";
}
var ColumnTransformer;
var init_ColumnTransformer = __esm({
  "node_modules/scikitjs/dist/esm/compose/ColumnTransformer.js"() {
    init_typesUtils();
    init_tf_singleton();
    init_simpleSerializer();
    ColumnTransformer = class extends Serialize {
      transformers;
      remainder;
      name = "ColumnTransformer";
      tf;
      constructor({ transformers = [], remainder = "drop" } = {}) {
        super();
        this.tf = getBackend2();
        this.transformers = transformers;
        this.remainder = remainder;
      }
      fit(X, y) {
        for (let i2 = 0; i2 < this.transformers.length; i2++) {
          let [, curTransform, selection] = this.transformers[i2];
          let subsetX = this.getColumns(X, selection);
          curTransform.fit(subsetX, y);
        }
        return this;
      }
      transform(X, y) {
        let output = [];
        for (let i2 = 0; i2 < this.transformers.length; i2++) {
          let [, curTransform, selection] = this.transformers[i2];
          let subsetX = this.getColumns(X, selection);
          output.push(curTransform.transform(subsetX, y));
        }
        return this.tf.concat(output, 1);
      }
      fitTransform(X, y) {
        let output = [];
        for (let i2 = 0; i2 < this.transformers.length; i2++) {
          let [, curTransform, selection] = this.transformers[i2];
          let subsetX = this.getColumns(X, selection);
          output.push(curTransform.fitTransform(subsetX, y));
        }
        return this.tf.concat(output, 1);
      }
      getColumns(X, selectedColumns) {
        if (isDataFrameInterface(X)) {
          if (isStringArray(selectedColumns)) {
            return X.loc({ columns: selectedColumns }).tensor;
          }
          if (Array.isArray(selectedColumns)) {
            return X.iloc({ columns: selectedColumns }).tensor;
          }
          if (typeof selectedColumns === "string") {
            return X[selectedColumns].tensor;
          }
          return X.iloc({ columns: [selectedColumns] }).tensor;
        } else {
          if (isStringArray(selectedColumns) || typeof selectedColumns === "string") {
            throw new Error("Can't pass string selected columns when not a DataFrame");
          }
          if (typeof selectedColumns === "number") {
            let columns = this.tf.tensor1d([selectedColumns]);
            return X.gather(columns, 1);
          } else {
            let columns = this.tf.tensor1d(selectedColumns);
            return X.gather(columns, 1);
          }
        }
      }
    };
  }
});

// node_modules/scikitjs/dist/esm/preprocessing/RobustScaler.js
function isEmpty2(value) {
  return value === void 0 || value === null || isNaN(value) && typeof value !== "string";
}
function removeMissingValuesFromArray2(arr) {
  const values = arr.filter((val) => {
    return !isEmpty2(val);
  });
  return values;
}
var RobustScaler;
var init_RobustScaler = __esm({
  "node_modules/scikitjs/dist/esm/preprocessing/RobustScaler.js"() {
    init_utils();
    init_typesUtils();
    init_math();
    init_mixins();
    init_esm();
    init_tf_singleton();
    RobustScaler = class extends TransformerMixin {
      scale;
      center;
      nFeaturesIn;
      featureNamesIn;
      quantileRange;
      withScaling;
      withCentering;
      name = "RobustScaler";
      constructor({ quantileRange = [25, 75], withCentering = true, withScaling = true } = {}) {
        super();
        this.tf = getBackend2();
        this.scale = this.tf.tensor1d([]);
        this.center = this.tf.tensor1d([]);
        this.quantileRange = quantileRange;
        this.withScaling = withScaling;
        this.withCentering = withCentering;
        this.nFeaturesIn = 0;
        this.featureNamesIn = [];
      }
      isNumber(value) {
        return typeof value === "number" && isFinite(value);
      }
      fit(X) {
        assert(isScikit2D(X), "Data can not be converted to a 2D matrix.");
        assert(this.isNumber(this.quantileRange[0]) && this.isNumber(this.quantileRange[1]), "quantileRange values must be numbers");
        let lowPercentile = this.quantileRange[0];
        let highPercentile = this.quantileRange[1];
        assert(lowPercentile < highPercentile && 0 <= lowPercentile && lowPercentile <= 100 && 0 <= highPercentile && highPercentile <= 100, "quantileRange numbers must be between 0 and 100");
        const tensorArray = convertToNumericTensor2D(X);
        const rowOrientedArray = tensorArray.transpose().arraySync();
        if (this.withCentering) {
          const quantiles = rowOrientedArray.map((arr) => quantileSeq(removeMissingValuesFromArray2(arr), 0.5));
          this.center = this.tf.tensor1d(quantiles);
        }
        if (this.withScaling) {
          const quantiles = rowOrientedArray.map((arr) => quantileSeq(removeMissingValuesFromArray2(arr), [
            lowPercentile / 100,
            highPercentile / 100
          ]));
          const scale = this.tf.tensor1d(quantiles.map((el) => el[1] - el[0]));
          this.scale = turnZerosToOnes(scale);
        }
        this.nFeaturesIn = tensorArray.shape[1];
        if (isDataFrameInterface(X)) {
          this.featureNamesIn = [...X.columns];
        }
        return this;
      }
      transform(X) {
        assert(isScikit2D(X), "Data can not be converted to a 2D matrix.");
        let tensorArray = convertToNumericTensor2D(X);
        if (this.withCentering) {
          tensorArray = tensorArray.sub(this.center);
        }
        if (this.withScaling) {
          tensorArray = tensorArray.div(this.scale);
        }
        return tensorArray;
      }
      inverseTransform(X) {
        assert(isScikit2D(X), "Data can not be converted to a 2D matrix.");
        let tensorArray = convertToNumericTensor2D(X);
        if (this.withScaling) {
          tensorArray = tensorArray.mul(this.scale);
        }
        if (this.withCentering) {
          tensorArray = tensorArray.add(this.center);
        }
        return tensorArray;
      }
    };
  }
});

// node_modules/scikitjs/dist/esm/cluster/KMeans.js
var KMeans;
var init_KMeans = __esm({
  "node_modules/scikitjs/dist/esm/cluster/KMeans.js"() {
    init_utils();
    init_tf_singleton();
    init_simpleSerializer();
    KMeans = class extends Serialize {
      nClusters;
      init;
      nInit;
      maxIter;
      tol;
      randomState;
      clusterCenters;
      name = "KMeans";
      tf;
      constructor({ nClusters = 8, init = "random", maxIter = 300, tol = 1e-4, nInit = 10, randomState } = {}) {
        super();
        this.tf = getBackend2();
        this.nClusters = nClusters;
        this.init = init;
        this.maxIter = maxIter;
        this.tol = tol;
        this.randomState = randomState;
        this.nInit = nInit;
        this.clusterCenters = this.tf.tensor2d([[]]);
      }
      initCentroids(X) {
        if (this.init === "random") {
          let indices = sampleWithoutReplacement(X.shape[0], this.nClusters, this.randomState);
          this.clusterCenters = this.tf.gather(X, indices);
          return;
        }
        throw new Error(`init ${this.init} is not currently implemented`);
      }
      closestCentroid(X) {
        return this.tf.tidy(() => {
          const expandedX = this.tf.expandDims(X, 1);
          const expandedClusters = this.tf.expandDims(this.clusterCenters, 0);
          return this.tf.squaredDifference(expandedX, expandedClusters).sum(2).argMin(1);
        });
      }
      updateCentroids(X, nearestIndices) {
        return this.tf.tidy(() => {
          const newCentroids = [];
          for (let i2 = 0; i2 < this.nClusters; i2++) {
            const mask = this.tf.equal(nearestIndices, this.tf.scalar(i2).toInt());
            const currentCentroid = this.tf.div(
              this.tf.sum(this.tf.mul(this.tf.expandDims(mask.toFloat(), 1), X), 0),
              this.tf.sum(mask.toFloat())
            );
            newCentroids.push(currentCentroid);
          }
          return this.tf.stack(newCentroids);
        });
      }
      fit(X) {
        let XTensor2D = convertToNumericTensor2D(X);
        this.initCentroids(XTensor2D);
        for (let i2 = 0; i2 < this.maxIter; i2++) {
          const centroidPicks = this.closestCentroid(XTensor2D);
          this.clusterCenters = this.updateCentroids(XTensor2D, centroidPicks);
        }
        return this;
      }
      predict(X) {
        let XTensor2D = convertToNumericTensor2D(X);
        return this.closestCentroid(XTensor2D);
      }
      transform(X) {
        return this.tf.tidy(() => {
          const XTensor2D = convertToNumericTensor2D(X);
          const expandedX = this.tf.expandDims(XTensor2D, 1);
          const expandedClusters = this.tf.expandDims(this.clusterCenters, 0);
          return this.tf.squaredDifference(expandedX, expandedClusters).sum(2).sqrt();
        });
      }
      fitPredict(X) {
        return this.fit(X).predict(X);
      }
      fitTransform(X) {
        return this.fit(X).transform(X);
      }
      score(X) {
        return this.tf.tidy(() => {
          const XTensor2D = convertToNumericTensor2D(X);
          const expandedX = this.tf.expandDims(XTensor2D, 1);
          const expandedClusters = this.tf.expandDims(this.clusterCenters, 0);
          return this.tf.squaredDifference(expandedX, expandedClusters).sum(2).min(1).sqrt().sum();
        });
      }
    };
  }
});

// node_modules/scikitjs/dist/esm/datasets/datasets.js
var dataUrls;
var init_datasets = __esm({
  "node_modules/scikitjs/dist/esm/datasets/datasets.js"() {
    dataUrls = {
      loadBoston: "http://scikitjs.org/data/boston.csv",
      loadIris: "http://scikitjs.org/data/iris.csv",
      loadWine: "http://scikitjs.org/data/wine.csv",
      loadDiabetes: "http://scikitjs.org/data/diabetes.csv",
      loadBreastCancer: "http://scikitjs.org/data/breast_cancer.csv",
      loadDigits: "http://scikitjs.org/data/digits.csv",
      fetchCaliforniaHousing: "http://scikitjs.org/data/california_housing.csv"
    };
  }
});

// node_modules/scikitjs/dist/esm/ensemble/VotingRegressor.js
function makeVotingRegressor(...args) {
  let estimators = [];
  for (let i2 = 0; i2 < args.length; i2++) {
    let cur = args[i2];
    estimators.push([cur.name, cur]);
  }
  return new VotingRegressor({ estimators });
}
var VotingRegressor;
var init_VotingRegressor = __esm({
  "node_modules/scikitjs/dist/esm/ensemble/VotingRegressor.js"() {
    init_mixins();
    init_tf_singleton();
    VotingRegressor = class extends RegressorMixin {
      estimators;
      weights;
      name = "VotingRegressor";
      constructor({ estimators = [], weights = void 0 } = {}) {
        super();
        this.tf = getBackend2();
        this.estimators = estimators;
        this.weights = weights;
      }
      async fit(X, y) {
        for (let i2 = 0; i2 < this.estimators?.length; i2++) {
          let [_, curEstimator] = this.estimators[i2];
          await curEstimator.fit(X, y);
        }
        return this;
      }
      predict(X) {
        let responses = [];
        let numEstimators = this.estimators.length;
        const weights = this.weights || Array(numEstimators).fill(1 / numEstimators);
        for (let i2 = 0; i2 < numEstimators; i2++) {
          let [_, curEstimator] = this.estimators[i2];
          let curWeight = weights[i2];
          responses.push(curEstimator.predict(X).mul(curWeight));
        }
        return this.tf.addN(responses);
      }
      transform(X) {
        let responses = [];
        let numEstimators = this.estimators.length;
        for (let i2 = 0; i2 < numEstimators; i2++) {
          let [_, curEstimator] = this.estimators[i2];
          responses.push(curEstimator.predict(X));
        }
        return responses;
      }
      async fitTransform(X, y) {
        return (await this.fit(X, y)).transform(X);
      }
    };
  }
});

// node_modules/scikitjs/dist/esm/ensemble/VotingClassifier.js
function makeVotingClassifier(...args) {
  let estimators = [];
  for (let i2 = 0; i2 < args.length; i2++) {
    let cur = args[i2];
    estimators.push([cur.name, cur]);
  }
  return new VotingClassifier({ estimators });
}
var VotingClassifier;
var init_VotingClassifier = __esm({
  "node_modules/scikitjs/dist/esm/ensemble/VotingClassifier.js"() {
    init_tf_singleton();
    init_mixins();
    init_LabelEncoder();
    VotingClassifier = class extends ClassifierMixin {
      estimators;
      weights;
      le;
      name = "VotingClassifier";
      tf;
      constructor({ estimators = [], weights = void 0, voting = "hard" } = {}) {
        super();
        this.tf = getBackend2();
        this.estimators = estimators;
        this.weights = weights;
        this.voting = voting;
        this.le = new LabelEncoder();
      }
      async fit(X, y) {
        let newY = this.le.fitTransform(y);
        for (let i2 = 0; i2 < this.estimators?.length; i2++) {
          let [_, curEstimator] = this.estimators[i2];
          await curEstimator.fit(X, newY);
        }
        return this;
      }
      predictProba(X) {
        let responses = [];
        let numEstimators = this.estimators.length;
        const weights = this.weights || Array(numEstimators).fill(1 / numEstimators);
        for (let i2 = 0; i2 < numEstimators; i2++) {
          let [_, curEstimator] = this.estimators[i2];
          let curWeight = weights[i2];
          responses.push(curEstimator.predictProba(X).mul(curWeight));
        }
        return this.tf.addN(responses);
      }
      predict(X) {
        let responses = [];
        let numEstimators = this.estimators.length;
        const weights = this.weights || Array(numEstimators).fill(1 / numEstimators);
        if (this.voting === "hard") {
          for (let i2 = 0; i2 < numEstimators; i2++) {
            let [_, curEstimator] = this.estimators[i2];
            let curWeight = weights[i2];
            let predictions = curEstimator.predict(X).toInt();
            let oneHot = this.tf.oneHot(predictions, this.le.classes.length);
            responses.push(oneHot.mul(curWeight));
          }
          return this.tf.tensor1d(this.le.inverseTransform(this.tf.addN(responses).argMax(1)));
        } else {
          for (let i2 = 0; i2 < numEstimators; i2++) {
            let [_, curEstimator] = this.estimators[i2];
            let curWeight = weights[i2];
            let predictions = curEstimator.predictProba(X);
            responses.push(predictions.mul(curWeight));
          }
          return this.tf.tensor1d(this.le.inverseTransform(this.tf.addN(responses).argMax(1)));
        }
      }
      transform(X) {
        let responses = [];
        let numEstimators = this.estimators.length;
        if (this.voting === "hard") {
          for (let i2 = 0; i2 < numEstimators; i2++) {
            let [_, curEstimator] = this.estimators[i2];
            responses.push(curEstimator.predict(X));
          }
          return responses;
        } else {
          for (let i2 = 0; i2 < numEstimators; i2++) {
            let [_, curEstimator] = this.estimators[i2];
            responses.push(curEstimator.predictProba(X));
          }
          return responses;
        }
      }
      async fitTransform(X, y) {
        return (await this.fit(X, y)).transform(X);
      }
    };
  }
});

// node_modules/scikitjs/dist/esm/neighbors/BruteNeighborhood.js
var BruteNeighborhood;
var init_BruteNeighborhood = __esm({
  "node_modules/scikitjs/dist/esm/neighbors/BruteNeighborhood.js"() {
    init_typesUtils();
    init_tf_singleton();
    BruteNeighborhood = class {
      _metric;
      _entries;
      tf;
      constructor({ metric, entries }) {
        this._metric = metric;
        this._entries = entries;
        this.tf = getBackend2();
      }
      kNearest(k, queryPoints) {
        const { _metric, _entries } = this;
        assert(_entries.shape[1] == queryPoints.shape[1], "X_train.shape[1] must equal X_predict.shape[1]");
        return this.tf.tidy(() => {
          const result = this.tf.unstack(queryPoints).map((queryPoint) => {
            return this.tf.tidy(() => {
              const dist = _metric.tensorDistance(queryPoint, _entries).neg();
              const { values, indices } = this.tf.topk(dist, k);
              return [values, indices];
            });
          });
          return {
            distances: this.tf.stack(result.map((x) => x[0])).neg(),
            indices: this.tf.stack(result.map((x) => x[1]))
          };
        });
      }
    };
  }
});

// node_modules/scikitjs/dist/esm/neighbors/Metric.js
var minkowskiTensorDistance, minkowskiMetric, manhattanMetric, euclideanMetric, chebyshevMetric;
var init_Metric = __esm({
  "node_modules/scikitjs/dist/esm/neighbors/Metric.js"() {
    init_typesUtils();
    init_tf_singleton();
    minkowskiTensorDistance = (p) => (u, v) => {
      let tf3 = getBackend2();
      const m = u.shape[u.rank - 1] ?? NaN;
      const n = v.shape[v.rank - 1] ?? NaN;
      assert(m === n, `minkowskiDistance(${p}).tensorDistance(u,v): u.shape[-1] must equal v.shape[-1].`);
      return tf3.tidy(() => {
        return tf3.norm(tf3.sub(u, v), p, -1);
      });
    };
    minkowskiMetric = (p) => {
      switch (p) {
        case 1:
          return manhattanMetric;
        case 2:
          return euclideanMetric;
        case Infinity:
          return chebyshevMetric;
      }
      assert(1 <= p, "minkowskiMetric(p): Invalid p.");
      const metric = {
        tensorDistance: minkowskiTensorDistance(p),
        distance(u, v) {
          const len = u.length;
          if (len !== v.length) {
            throw new Error(`minkowskiMetric(${p}).treeMetric(u,v): u and v must have same length.`);
          }
          let norm2 = 0;
          for (let i2 = 0; i2 < len; i2++) {
            norm2 += Math.abs(u[i2] - v[i2]) ** p;
          }
          return norm2 ** (1 / p);
        },
        distToBBox(pt, bBox) {
          if (pt.length * 2 != bBox.length) {
            throw new Error(`minkowskiMetric(${p}).treeMetric.minDistToBBox(pt,bBox): pt.length*2 must equal bBox.length.`);
          }
          let norm2 = 0;
          for (let j = 0, i2 = 0; i2 < pt.length; i2++) {
            let x = Math.max(0, bBox[j++] - pt[i2], pt[i2] - bBox[j++]);
            norm2 += x ** p;
          }
          return norm2 ** (1 / p);
        },
        name: `minkowskiMetric(${p})`,
        toString() {
          return this.name;
        }
      };
      return Object.freeze(metric);
    };
    manhattanMetric = Object.freeze({
      tensorDistance: minkowskiTensorDistance(1),
      distance(u, v) {
        const len = u.length;
        if (len !== v.length) {
          throw new Error(`minkowskiMetric(1).distance(u,v): u and v must have same length.`);
        }
        let norm2 = 0;
        for (let i2 = 0; i2 < len; i2++) {
          norm2 += Math.abs(u[i2] - v[i2]);
        }
        return norm2;
      },
      minDistToBBox(pt, bBox) {
        const len = bBox.length;
        if (len !== pt.length << 1) {
          throw new Error(`minkowskiMetric(1).minDistToBBox(pt,bBox): pt.length*2 must equal bBox.length.`);
        }
        let norm2 = 0;
        for (let i2 = 0; i2 < len; ) {
          const pi3 = pt[i2 >>> 1];
          const u = bBox[i2++] - pi3;
          const v = pi3 - bBox[i2++];
          const x = 0.5 * (Math.abs(u) + u + (Math.abs(v) + v));
          norm2 += x;
        }
        return norm2;
      },
      name: "manhattanMetric",
      toString() {
        return this.name;
      }
    });
    euclideanMetric = Object.freeze({
      tensorDistance: minkowskiTensorDistance(2),
      distance(u, v) {
        const len = u.length;
        if (len !== v.length) {
          throw new Error(`minkowskiMetric(2).distance(u,v): u and v must have same length.`);
        }
        let norm2 = 0;
        for (let i2 = 0; i2 < len; i2++) {
          const x = u[i2] - v[i2];
          norm2 += x * x;
        }
        return Math.sqrt(norm2);
      },
      minDistToBBox(pt, bBox) {
        const len = bBox.length;
        if (len !== pt.length * 2) {
          throw new Error(`minkowskiMetric(2).minDistToBBox(pt,bBox): pt.length*2 must equal bBox.length.`);
        }
        let norm2 = 0;
        for (let i2 = 0; i2 < len; ) {
          const pi3 = pt[i2 >>> 1];
          const u = bBox[i2++] - pi3;
          const v = pi3 - bBox[i2++];
          const x = 0.5 * (Math.abs(u) + u + (Math.abs(v) + v));
          norm2 += x * x;
        }
        return Math.sqrt(norm2);
      },
      name: "euclideanMetric",
      toString() {
        return this.name;
      }
    });
    chebyshevMetric = Object.freeze({
      tensorDistance: minkowskiTensorDistance(Infinity),
      distance(u, v) {
        const len = u.length;
        if (len !== v.length) {
          throw new Error(`minkowskiMetric(Infinity).distance(u,v): u and v must have same length.`);
        }
        let norm2 = 0;
        for (let i2 = 0; i2 < len; i2++) {
          const x = Math.abs(u[i2] - v[i2]);
          norm2 = Math.max(norm2, x);
        }
        return norm2;
      },
      minDistToBBox(pt, bBox) {
        const len = bBox.length;
        if (len !== pt.length * 2) {
          throw new Error(`minkowskiMetric(Infinity).minDistToBBox(pt,bBox): pt.length*2 must equal bBox.length.`);
        }
        let norm2 = -Infinity;
        for (let i2 = 0; i2 < len; ) {
          const pi3 = pt[i2 >>> 1];
          const u = bBox[i2++] - pi3;
          const v = pi3 - bBox[i2++];
          const x = 0.5 * (Math.abs(u) + u + (Math.abs(v) + v));
          norm2 = Math.max(norm2, x);
        }
        return norm2;
      },
      name: "chebyshevMetric",
      toString() {
        return this.name;
      }
    });
  }
});

// node_modules/scikitjs/dist/esm/randUtils.js
function _prng_restore(prng, xg, opts) {
  let state = opts && opts.state;
  if (state) {
    if (typeof state == "object")
      xg.copy(state, xg);
    prng.state = () => xg.copy(xg, {});
  }
}
function alea(seed, opts) {
  let xg = new AleaGen(seed);
  let prng = () => xg.next();
  _prng_restore(prng, xg, opts);
  return prng;
}
var AleaGen, createRng2, randInt, shuffle;
var init_randUtils = __esm({
  "node_modules/scikitjs/dist/esm/randUtils.js"() {
    AleaGen = class {
      c;
      s0;
      s1;
      s2;
      constructor(seed) {
        if (seed == null)
          seed = +new Date();
        let n = 4022871197;
        this.c = 1;
        this.s0 = mash(" ");
        this.s1 = mash(" ");
        this.s2 = mash(" ");
        this.s0 -= mash(seed);
        if (this.s0 < 0) {
          this.s0 += 1;
        }
        this.s1 -= mash(seed);
        if (this.s1 < 0) {
          this.s1 += 1;
        }
        this.s2 -= mash(seed);
        if (this.s2 < 0) {
          this.s2 += 1;
        }
        function mash(data) {
          data = String(data);
          for (let i2 = 0; i2 < data.length; i2++) {
            n += data.charCodeAt(i2);
            let h = 0.02519603282416938 * n;
            n = h >>> 0;
            h -= n;
            h *= n;
            n = h >>> 0;
            h -= n;
            n += h * 4294967296;
          }
          return (n >>> 0) * 23283064365386963e-26;
        }
      }
      next() {
        let { c, s0, s1, s2 } = this;
        let t = 2091639 * s0 + c * 23283064365386963e-26;
        this.s0 = s1;
        this.s1 = s2;
        return this.s2 = t - (this.c = t | 0);
      }
      copy(f, t) {
        t.c = f.c;
        t.s0 = f.s0;
        t.s1 = f.s1;
        t.s2 = f.s2;
        return t;
      }
    };
    createRng2 = (seed) => alea(seed?.toString());
    randInt = (rand) => (from, until) => {
      if (from >= until) {
        throw new Error("randInt(rng)(from,until): from must be less than until.");
      }
      const result = Math.floor(from + (until - from) * rand());
      if (result === until) {
        return result - 1;
      }
      return result;
    };
    shuffle = (rand) => (array) => {
      const _randInt = randInt(rand);
      for (let i2 = array.length; i2 > 1; i2--) {
        const j = _randInt(0, i2);
        const tmp = array[i2 - 1];
        array[i2 - 1] = array[j];
        array[j] = tmp;
      }
    };
  }
});

// node_modules/scikitjs/dist/esm/neighbors/CappedMaxHeap.js
var CappedMaxHeap;
var init_CappedMaxHeap = __esm({
  "node_modules/scikitjs/dist/esm/neighbors/CappedMaxHeap.js"() {
    init_typesUtils();
    CappedMaxHeap = class {
      _keys;
      _vals;
      _pos;
      constructor(keys, vals) {
        const len = keys.length;
        assert(len > 0, "new CappedMaxHeap(keys,vals): keys.length must be positive.");
        assert(len === vals.length, "new CappedMaxHeap(keys,vals): keys.length must equal vals.length.");
        keys[0] = NaN;
        this._keys = keys;
        this._vals = vals;
        this._pos = len;
      }
      get maxKey() {
        return this._keys[0];
      }
      add(key, val) {
        let { _keys, _vals, _pos: p } = this;
        if (0 < p) {
          this._pos = --p;
        } else if (_keys[0] <= key) {
          return;
        }
        const end = _keys.length - 1;
        for (; ; ) {
          let c = (p << 1) + 1;
          if (c > end) {
            break;
          }
          c += +(c < end && _keys[c] < _keys[c + 1]);
          if (_keys[c] <= key) {
            break;
          }
          _keys[p] = _keys[c];
          _vals[p] = _vals[c];
          p = c;
        }
        _keys[p] = key;
        _vals[p] = val;
      }
      sort() {
        const { _keys, _vals, _pos } = this;
        assert(0 === _pos, "CappedMaxHeap().sort(): Heap is not full yet.");
        const swap = (i2, j) => {
          let _key = _keys[i2];
          _keys[i2] = _keys[j];
          _keys[j] = _key;
          let _val = _vals[i2];
          _vals[i2] = _vals[j];
          _vals[j] = _val;
        };
        const sort2 = (from) => {
          if (_keys[from] > _keys[from + 1]) {
            swap(from, from + 1);
          }
        };
        const sort3 = (from) => {
          sort2(from);
          if (_keys[from + 1] > _keys[from + 2]) {
            swap(from + 1, from + 2);
            sort2(from);
          }
        };
        const sort4 = (from, until) => {
          switch (until - from) {
            case 0:
              return;
            case 1:
              return;
            case 2:
              return sort2(from);
            case 3:
              return sort3(from);
          }
          const mid = from + until >>> 1;
          sort3(mid - 1);
          const piv = _keys[mid];
          swap(from, mid);
          let l = from;
          let r = from + 1;
          for (let i2 = r; i2 < until; i2++) {
            let ki = _keys[i2];
            if (ki <= piv) {
              swap(i2, r);
              if (ki < piv) {
                swap(l++, r);
              }
              r++;
            }
          }
          sort4(from, l);
          sort4(r, until);
        };
        sort4(0, _keys.length);
      }
    };
  }
});

// node_modules/scikitjs/dist/esm/neighbors/KdTree.js
var child, parent, ceilPow2, KdTree;
var init_KdTree = __esm({
  "node_modules/scikitjs/dist/esm/neighbors/KdTree.js"() {
    init_typesUtils();
    init_randUtils();
    init_randUtils();
    init_CappedMaxHeap();
    init_tf_singleton();
    child = (parent2) => (parent2 << 1) + 1;
    parent = (child2) => child2 - 1 >> 1;
    ceilPow2 = (int32) => {
      assert(0 <= int32 && int32 <= 1073741824, "ceilPow2(x): x must be in range [0, 1<<30].");
      int32 = Math.ceil(int32);
      int32 = Math.max(int32, 1);
      return 2147483648 >>> -1 + Math.clz32(int32 - 1);
    };
    KdTree = class {
      _nSamples;
      _nFeatures;
      _metric;
      _points;
      _indices;
      _bBoxes;
      _offsets;
      tf;
      constructor(nSamples, nFeatures, metric, points, bBoxes, offsets, indices) {
        this.tf = getBackend2();
        this._nSamples = nSamples;
        this._nFeatures = nFeatures;
        this._metric = metric;
        this._points = points;
        this._bBoxes = bBoxes;
        this._offsets = offsets;
        this._indices = indices;
        Object.freeze(this);
      }
      static async build({ metric, entries, leafSize = 16 }) {
        assert(1 < leafSize, "new KdTree({leafSize=16}): leafSize must be a positive number.");
        assert("function" === typeof metric.minDistToBBox, "new KdTree({metric}): metric must implement `minDistToBBox` function.");
        const [nSamples, nFeatures] = entries.shape;
        const indices = new Int32Array(nSamples);
        for (let i2 = 0; i2 < nSamples; i2++) {
          indices[i2] = i2;
        }
        const data = (await entries.data()).slice();
        const points = Array.from(indices, (_, i2) => data.subarray(nFeatures * i2, nFeatures * ++i2));
        const nLeafs = ceilPow2(nSamples / leafSize);
        const nNodes = nLeafs * 2 - 1;
        const leaf0 = nNodes - nLeafs;
        const offsets = new Int32Array(nLeafs + 1);
        const bBoxes = function() {
          const n = nFeatures * 2;
          const flat = new Float32Array(nNodes * n);
          const bBoxes2 = [];
          for (let i2 = 0; i2 < nNodes; ) {
            bBoxes2.push(flat.subarray(n * i2, n * ++i2));
          }
          return bBoxes2;
        }();
        const randInt2 = randInt(alea(`KdTree[${nSamples},${nFeatures}]`));
        const swapIndices = (i2, j) => {
          const t = indices[i2];
          indices[i2] = indices[j];
          indices[j] = t;
        };
        const buildTree = (node, from, until) => {
          const bBox = bBoxes[node];
          for (let i2 = 0; i2 < bBox.length; i2++) {
            bBox[i2] = i2 % 2 ? -Infinity : Infinity;
          }
          for (let i2 = from; i2 < until; i2++) {
            const j = nFeatures * indices[i2];
            for (let k = 0; k < bBox.length; ) {
              const djk = data[j + (k >>> 1)];
              bBox[k] = Math.min(bBox[k++], djk);
              bBox[k] = Math.max(bBox[k++], djk);
            }
          }
          if (leaf0 <= node) {
            const leaf = node - leaf0;
            offsets[leaf] = from;
            offsets[leaf + 1] = until;
            return;
          }
          const axis = function() {
            let axis2 = 0;
            let dMax = -Infinity;
            for (let i2 = bBox.length; i2 > 0; ) {
              const di = bBox[--i2] - bBox[--i2];
              if (di > dMax) {
                dMax = di;
                axis2 = i2 >>> 1;
              }
            }
            return axis2;
          }();
          const mid = from + until >>> 1;
          for (let pos = from, end = until; ; ) {
            const threshold = data[nFeatures * indices[randInt2(pos, end)] + axis];
            let l = pos;
            let r = pos;
            for (let i2 = pos; i2 < end; i2++) {
              let pi3 = data[nFeatures * indices[i2] + axis];
              if (pi3 <= threshold) {
                swapIndices(i2, r);
                if (pi3 < threshold) {
                  swapIndices(l++, r);
                }
                r++;
              }
            }
            if (l > mid)
              end = l;
            else if (r < mid)
              pos = r;
            else
              break;
          }
          const c = child(node);
          buildTree(c, from, mid);
          buildTree(c + 1, mid, until);
        };
        buildTree(0, 0, nSamples);
        const swapData = (i2, j) => {
          i2 *= nFeatures;
          j *= nFeatures;
          for (const end = i2 + nFeatures; i2 < end; i2++, j++) {
            const d = data[i2];
            data[i2] = data[j];
            data[j] = d;
          }
        };
        for (let perm = indices.slice(), i2 = 0; i2 < nSamples; i2++) {
          for (let j = i2; ; ) {
            let k = perm[j];
            perm[j] = j;
            if (k === i2) {
              break;
            }
            swapData(j, j = k);
          }
        }
        return new KdTree(nSamples, nFeatures, metric, points, bBoxes, offsets, indices);
      }
      kNearest(k, queryPoints) {
        const { _nSamples, _nFeatures, _metric, _points, _bBoxes, _offsets, _indices } = this;
        k = Math.min(k, _nSamples);
        const [nQueries, nDim] = queryPoints.shape;
        assert(_nFeatures === nDim, "KNeighbors: X_train.shape[1] must equal X_predict.shape[1].");
        const dists = new Float32Array(nQueries * k);
        const indxs = new Int32Array(nQueries * k);
        const leaf0 = parent(_bBoxes.length - 1) + 1;
        if (0 < k && 0 < nQueries) {
          const query = queryPoints.dataSync();
          let heap;
          let queryPt;
          const knn = (node, minDist) => {
            if (minDist >= heap.maxKey) {
              return;
            }
            if (node < leaf0) {
              const c = child(node);
              const dist0 = _metric.minDistToBBox(queryPt, _bBoxes[c]);
              const dist1 = _metric.minDistToBBox(queryPt, _bBoxes[c + 1]);
              if (dist0 <= dist1) {
                knn(c, dist0);
                knn(c + 1, dist1);
              } else {
                knn(c + 1, dist1);
                knn(c, dist0);
              }
            } else {
              node -= leaf0;
              const from = _offsets[node];
              const until = _offsets[node + 1];
              for (let i2 = from; i2 < until; i2++) {
                const dist = _metric.distance(queryPt, _points[i2]);
                heap.add(dist, _indices[i2]);
              }
            }
          };
          for (let q = 0; q < nQueries; q++) {
            queryPt = query.subarray(nDim * q, nDim * (q + 1));
            const off = k * q;
            const end = k + off;
            heap = new CappedMaxHeap(dists.subarray(off, end), indxs.subarray(off, end));
            knn(0, _metric.minDistToBBox(queryPt, _bBoxes[0]));
          }
        }
        return {
          distances: this.tf.tensor2d(dists, [nQueries, k], "float32"),
          indices: this.tf.tensor2d(indxs, [nQueries, k], "int32")
        };
      }
    };
  }
});

// node_modules/scikitjs/dist/esm/neighbors/KNeighborsBase.js
var WEIGHTS_FUNCTIONS, METRICS, ALGORITHMS, KNeighborsBase;
var init_KNeighborsBase = __esm({
  "node_modules/scikitjs/dist/esm/neighbors/KNeighborsBase.js"() {
    init_BruteNeighborhood();
    init_Metric();
    init_utils();
    init_typesUtils();
    init_KdTree();
    init_tf_singleton();
    init_simpleSerializer();
    WEIGHTS_FUNCTIONS = {
      uniform(distances) {
        let tf3 = getBackend2();
        const { shape } = distances;
        return tf3.fill(shape, 1 / shape[1]);
      },
      distance(distances) {
        let tf3 = getBackend2();
        return tf3.tidy(() => {
          const min2 = distances.min(1, true);
          const invDist = tf3.divNoNan(min2.toFloat(), distances);
          const is0 = distances.lessEqual(0).toFloat();
          const weights = tf3.where(min2.lessEqual(0), is0, invDist);
          const wsum = weights.sum(1, true);
          return weights.div(wsum);
        });
      }
    };
    METRICS = {
      minkowski: (p) => minkowskiMetric(p),
      manhattan: () => minkowskiMetric(1),
      euclidean: () => minkowskiMetric(2),
      chebyshev: () => minkowskiMetric(Infinity)
    };
    ALGORITHMS = {
      kdTree: KdTree.build,
      brute: async (params) => new BruteNeighborhood(params),
      auto: (params) => {
        return "function" === typeof params.metric.minDistToBBox ? ALGORITHMS.kdTree(params) : ALGORITHMS.brute(params);
      }
    };
    KNeighborsBase = class extends Serialize {
      _neighborhood;
      _y;
      weights;
      algorithm;
      leafSize;
      p;
      metric;
      nNeighbors;
      constructor(params = {}) {
        super();
        Object.assign(this, params);
      }
      _getFitParams() {
        const { _neighborhood, _y, nNeighbors = 5, weights = "uniform" } = this;
        assert(0 <= nNeighbors && nNeighbors % 1 === 0, "KNeighbors({nNeighbors})::predict(X): nNeighbors must be a positive int.");
        assert(Object.keys(WEIGHTS_FUNCTIONS).includes(weights), "KNeighbors({weights})::predict(X): invalid weights.");
        assert(void 0 != _neighborhood && void 0 != _y, "KNeighbors::predict(X): model not trained yet. Call `await fit(x, y)` first.");
        const weightsFn = WEIGHTS_FUNCTIONS[weights];
        return {
          nNeighbors,
          weightsFn,
          neighborhood: _neighborhood,
          y: _y
        };
      }
      async fit(X, y) {
        const { algorithm = "auto", metric = "minkowski", p = 2, leafSize } = this;
        assert(Object.keys(METRICS).includes(metric), "KNeighbors({metric}).fit(X,y): invalid metric.");
        assert(Object.keys(ALGORITHMS).includes(algorithm), "KNeighbors({algorithm}).fit(X,y): invalid algorithm.");
        const metricFn = METRICS[metric](p);
        const entries = convertToNumericTensor2D(X);
        this._neighborhood = await ALGORITHMS[algorithm]({
          entries,
          metric: metricFn,
          leafSize
        });
        this._y = convertToNumericTensor1D(y);
        return this;
      }
    };
    __publicField(KNeighborsBase, "SUPPORTED_ALGORITHMS", Object.freeze(Object.keys(ALGORITHMS)));
  }
});

// node_modules/scikitjs/dist/esm/neighbors/KNeighborsRegressor.js
var KNeighborsRegressor;
var init_KNeighborsRegressor = __esm({
  "node_modules/scikitjs/dist/esm/neighbors/KNeighborsRegressor.js"() {
    init_KNeighborsBase();
    init_utils();
    init_tf_singleton();
    KNeighborsRegressor = class extends KNeighborsBase {
      name = "KNeighborsRegressor";
      predict(X) {
        let tf3 = getBackend2();
        const { neighborhood, y, nNeighbors, weightsFn } = this._getFitParams();
        return tf3.tidy(() => {
          const _X = convertToNumericTensor2D(X);
          const { distances, indices } = neighborhood.kNearest(nNeighbors, _X);
          const targets = y.gather(indices);
          const weights = weightsFn(distances);
          return tf3.matMul(targets.reshape([-1, 1, nNeighbors]), weights.reshape([-1, nNeighbors, 1])).as1D();
        });
      }
    };
  }
});

// node_modules/scikitjs/dist/esm/tfUtils.js
function polyfillUnique(tf3) {
  if (tf3.engine().backendNames().includes("tensorflow") && !tf3.getKernel("Unique", "tensorflow")) {
    console.info("[scikit.js] Installing tfjs-node polyfill for tf.unique().");
    tf3.registerKernel({
      kernelName: "Unique",
      backendName: "tensorflow",
      kernelFunc: (args) => {
        const x = args.inputs.x;
        const backend = args.backend;
        const { axis } = args.attrs;
        const axs = tf3.tensor1d([axis], "int32");
        const types = {
          float32: backend.binding.TF_FLOAT,
          float64: backend.binding.TF_DOUBLE,
          int32: backend.binding.TF_INT32,
          int64: backend.binding.TF_INT64,
          complex64: backend.binding.TF_COMPLEX64,
          bool: backend.binding.TF_BOOL,
          string: backend.binding.TF_STRING
        };
        assert(Object.keys(types).includes(x.dtype), "Unexpected dtype.");
        try {
          const opAttrs = [
            {
              value: types[x.dtype],
              name: "T",
              type: backend.binding.TF_ATTR_TYPE
            },
            {
              value: types.int32,
              name: "Taxis",
              type: backend.binding.TF_ATTR_TYPE
            },
            {
              value: types.int32,
              name: "out_idx",
              type: backend.binding.TF_ATTR_TYPE
            }
          ];
          return backend.executeMultipleOutputs("UniqueV2", opAttrs, [x, axs], 2);
        } finally {
          axs.dispose();
        }
      }
    });
  }
}
var init_tfUtils = __esm({
  "node_modules/scikitjs/dist/esm/tfUtils.js"() {
    init_typesUtils();
  }
});

// node_modules/scikitjs/dist/esm/model_selection/scorers.js
function accuracy(X, y) {
  let tf3 = getBackend2();
  return tf3.tidy(() => {
    y = convertToTensor1D(y);
    const yPred = this.predict(X);
    return tf3.equal(y, yPred).sum().div(y.shape[0]);
  });
}
var init_scorers = __esm({
  "node_modules/scikitjs/dist/esm/model_selection/scorers.js"() {
    init_tf_singleton();
    init_utils();
  }
});

// node_modules/scikitjs/dist/esm/neighbors/KNeighborsClassifier.js
var KNeighborsClassifier;
var init_KNeighborsClassifier = __esm({
  "node_modules/scikitjs/dist/esm/neighbors/KNeighborsClassifier.js"() {
    init_KNeighborsBase();
    init_utils();
    init_tfUtils();
    init_scorers();
    init_tf_singleton();
    KNeighborsClassifier = class extends KNeighborsBase {
      classes_;
      score = accuracy;
      name = "KNeighborsClassifier";
      predictProba(X) {
        const { neighborhood, y, nNeighbors, weightsFn } = this._getFitParams();
        const [nClasses] = this.classes_?.shape;
        let tf3 = getBackend2();
        return tf3.tidy(() => {
          const _X = convertToNumericTensor2D(X);
          const nSamples = _X.shape[0];
          const { distances, indices } = neighborhood.kNearest(nNeighbors, _X);
          const labels = y.gather(indices);
          const weight = weightsFn(distances);
          const oneHot = tf3.oneHot(labels, nClasses);
          return tf3.mul(oneHot.reshape([nSamples, nNeighbors, nClasses]), weight.reshape([nSamples, nNeighbors, 1])).sum(1);
        });
      }
      predict(X) {
        const classes2 = this.classes_;
        let tf3 = getBackend2();
        return tf3.tidy(() => {
          const probs = this.predictProba(X);
          const labels = probs.argMax(1);
          return classes2.gather(labels);
        });
      }
      async fit(X, labels) {
        let tf3 = getBackend2();
        const { values, indices } = tf3.tidy(() => {
          const _labels = convertToTensor1D(labels);
          polyfillUnique(tf3);
          return tf3.unique(_labels);
        });
        await super.fit(X, indices);
        this.classes_ = values;
        return this;
      }
    };
  }
});

// node_modules/scikitjs/dist/esm/svm/LinearSVC.js
var LinearSVC;
var init_LinearSVC = __esm({
  "node_modules/scikitjs/dist/esm/svm/LinearSVC.js"() {
    init_SgdClassifier();
    init_tf_singleton();
    LinearSVC = class extends SGDClassifier {
      constructor({ penalty = "l2", C = 1, fitIntercept = true } = {}) {
        let tf3 = getBackend2();
        super({
          modelCompileArgs: {
            optimizer: tf3.train.adam(0.1),
            loss: tf3.losses.hingeLoss,
            metrics: ["accuracy"]
          },
          modelFitArgs: {
            batchSize: 32,
            epochs: 1e3,
            verbose: 0,
            callbacks: [
              tf3.callbacks.earlyStopping({ monitor: "loss", patience: 50 })
            ]
          },
          denseLayerArgs: {
            units: 1,
            useBias: Boolean(fitIntercept),
            activation: "softmax",
            kernelInitializer: tf3.initializers.zeros(),
            biasInitializer: tf3.initializers.zeros(),
            kernelRegularizer: penalty === "l2" ? tf3.regularizers.l2({ l2: C }) : penalty === "l1" ? tf3.regularizers.l1({ l1: C }) : void 0
          },
          isClassification: true,
          optimizerType: "adam",
          lossType: "hingeLoss"
        });
        this.name = "LinearSVC";
      }
    };
  }
});

// node_modules/scikitjs/dist/esm/svm/LinearSVR.js
var LinearSVR;
var init_LinearSVR = __esm({
  "node_modules/scikitjs/dist/esm/svm/LinearSVR.js"() {
    init_SgdRegressor();
    init_tf_singleton();
    LinearSVR = class extends SGDRegressor {
      constructor({ epsilon = 0, C = 1, fitIntercept = true } = {}) {
        let tf3 = getBackend2();
        super({
          modelCompileArgs: {
            optimizer: tf3.train.adam(0.1),
            loss: function(yPred, yTrue) {
              return tf3.abs(tf3.sub(yPred, yTrue)).sub(epsilon).maximum(0);
            },
            metrics: ["accuracy"]
          },
          modelFitArgs: {
            batchSize: 32,
            epochs: 1e3,
            verbose: 0,
            callbacks: [
              tf3.callbacks.earlyStopping({ monitor: "loss", patience: 50 })
            ]
          },
          denseLayerArgs: {
            units: 1,
            useBias: Boolean(fitIntercept),
            kernelRegularizer: tf3.regularizers.l2({ l2: C })
          },
          optimizerType: "adam",
          lossType: "custom"
        });
        this.name = "LinearSVR";
      }
    };
  }
});

// node_modules/scikitjs/dist/esm/naive_bayes/BaseNaiveBayes.js
var BaseNaiveBayes;
var init_BaseNaiveBayes = __esm({
  "node_modules/scikitjs/dist/esm/naive_bayes/BaseNaiveBayes.js"() {
    init_tfUtils();
    init_utils();
    init_tf_singleton();
    init_simpleSerializer();
    BaseNaiveBayes = class extends Serialize {
      priors;
      varSmoothing;
      classes;
      means;
      variances;
      tf;
      constructor(params = {}) {
        super();
        this.tf = getBackend2();
        this.classes = this.tf.tensor1d([]);
        this.means = [];
        this.variances = [];
        if (params.priors) {
          this.priors = convertToTensor1D(params.priors);
        }
        this.varSmoothing = params.varSmoothing ? params.varSmoothing : 1e-9;
      }
      async fit(X, y) {
        const features = convertToNumericTensor2D(X);
        const labels = convertToTensor1D(y);
        const { values, meansByLabel, variancesByLabel } = this.tf.tidy(() => {
          polyfillUnique(this.tf);
          const meansByLabel2 = [];
          const variancesByLabel2 = [];
          const { values: values2 } = this.tf.unique(labels);
          const { variance: variance2 } = this.tf.moments(features, 0);
          const epsilon = variance2.max().mul(this.varSmoothing);
          this.tf.unstack(values2).forEach((c) => {
            const mask = this.tf.equal(labels, c).toFloat();
            const numInstances = this.tf.sum(mask);
            const mean2 = this.tf.mul(features, mask.expandDims(1)).sum(0).div(numInstances);
            const variance3 = this.tf.sub(features, mean2).mul(mask.expandDims(1)).pow(2).sum(0).div(numInstances).add(epsilon);
            meansByLabel2.push(mean2);
            variancesByLabel2.push(variance3);
          });
          return { values: values2, meansByLabel: meansByLabel2, variancesByLabel: variancesByLabel2 };
        });
        this.classes = values;
        this.means = meansByLabel;
        this.variances = variancesByLabel;
        return this;
      }
      predictProba(X) {
        const features = convertToNumericTensor2D(X);
        const probabilities = this.tf.tidy(() => {
          let probs = [];
          this.classes.unstack().forEach((_, idx) => {
            const mean2 = this.means[idx];
            const variance2 = this.variances[idx];
            const prob = this.kernel(features, mean2, variance2);
            probs.push(prob);
          });
          const withoutPriors = this.tf.stack(probs, 1);
          if (this.priors) {
            return withoutPriors.mul(this.priors);
          } else {
            return withoutPriors;
          }
        });
        return probabilities;
      }
      predict(X) {
        const probs = this.predictProba(X);
        return probs.argMax(1);
      }
    };
  }
});

// node_modules/scikitjs/dist/esm/naive_bayes/GaussianNB.js
var GaussianNB;
var init_GaussianNB = __esm({
  "node_modules/scikitjs/dist/esm/naive_bayes/GaussianNB.js"() {
    init_BaseNaiveBayes();
    init_tf_singleton();
    GaussianNB = class extends BaseNaiveBayes {
      name = "GaussianNB";
      kernel(features, mean2, variance2) {
        let tf3 = getBackend2();
        return tf3.tidy(() => {
          return tf3.sub(features, mean2.expandDims(0)).pow(2).div(variance2.expandDims(0).mul(-2)).exp().div(variance2.mul(2 * Math.PI).expandDims(0).sqrt()).prod(1);
        });
      }
    };
  }
});

// node_modules/scikitjs/dist/esm/tree/Criterion.js
function giniCoefficient(labelFreqs, nSamples) {
  let freqSquares = 0;
  for (let i2 = 0; i2 < labelFreqs.length; i2++) {
    freqSquares += labelFreqs[i2] * labelFreqs[i2];
  }
  return 1 - freqSquares / (nSamples * nSamples);
}
function entropy(labelFreqs, nSamples) {
  let totalEntropy = 0;
  for (let i2 = 0; i2 < labelFreqs.length; i2++) {
    let labelFrequency = labelFreqs[i2];
    if (labelFrequency > 0) {
      labelFrequency /= nSamples;
      totalEntropy -= labelFrequency * Math.log2(labelFrequency);
    }
  }
  return totalEntropy;
}
function mse(ySquaredSum, ySum, nSamples) {
  let yBar = ySum / nSamples;
  let val = ySquaredSum / nSamples - yBar * yBar;
  return val;
}
function arrayMax(labels) {
  let max2 = Number.NEGATIVE_INFINITY;
  for (let i2 = 0; i2 < labels.length; i2++) {
    if (labels[i2] > max2) {
      max2 = labels[i2];
    }
  }
  return max2;
}
var ClassificationCriterion, RegressionCriterion;
var init_Criterion = __esm({
  "node_modules/scikitjs/dist/esm/tree/Criterion.js"() {
    init_simpleSerializer();
    ClassificationCriterion = class extends Serialize {
      y;
      impurityMeasure;
      start = 0;
      end = 0;
      pos = 0;
      nLabels;
      labelFreqsTotal = [];
      labelFreqsLeft = [];
      labelFreqsRight = [];
      nSamples = 0;
      nSamplesLeft = 0;
      nSamplesRight = 0;
      name = "ClassificationCriterion";
      constructor({ impurityMeasure, y }) {
        super();
        this.impurityMeasure = impurityMeasure;
        this.nLabels = arrayMax(y) + 1;
        this.y = y;
        this.labelFreqsTotal = new Array(this.nLabels).fill(0);
        this.labelFreqsLeft = new Array(this.nLabels).fill(0);
        this.labelFreqsRight = new Array(this.nLabels).fill(0);
      }
      init(start, end, sampleMap) {
        this.start = start;
        this.end = end;
        this.nSamples = end - start;
        this.labelFreqsTotal = this.labelFreqsTotal.fill(0);
        this.labelFreqsLeft = this.labelFreqsLeft.fill(0);
        this.labelFreqsRight = this.labelFreqsRight.fill(0);
        for (let i2 = start; i2 < end; i2++) {
          let sampleNumber = sampleMap[i2];
          this.labelFreqsTotal[this.y[sampleNumber]] += 1;
        }
      }
      reset() {
        this.pos = this.start;
        this.labelFreqsLeft = this.labelFreqsLeft.fill(0);
        this.labelFreqsRight = this.labelFreqsRight.fill(0);
      }
      update(newPos, sampleMap) {
        for (let i2 = this.pos; i2 < newPos; i2++) {
          let sampleNumber = sampleMap[i2];
          this.labelFreqsLeft[this.y[sampleNumber]] += 1;
        }
        for (let i2 = 0; i2 < this.labelFreqsTotal.length; i2++) {
          this.labelFreqsRight[i2] = this.labelFreqsTotal[i2] - this.labelFreqsLeft[i2];
        }
        this.pos = newPos;
        this.nSamplesLeft = this.pos - this.start;
        this.nSamplesRight = this.end - this.pos;
      }
      childrenImpurities() {
        let impurityFunc = this.impurityMeasure === "gini" ? giniCoefficient : entropy;
        return {
          impurityLeft: impurityFunc(this.labelFreqsLeft, this.nSamplesLeft),
          impurityRight: impurityFunc(this.labelFreqsRight, this.nSamplesRight)
        };
      }
      impurityImprovement() {
        let { impurityLeft, impurityRight } = this.childrenImpurities();
        return -this.nSamplesLeft * impurityLeft - this.nSamplesRight * impurityRight;
      }
      nodeImpurity() {
        let impurityFunc = this.impurityMeasure === "gini" ? giniCoefficient : entropy;
        return impurityFunc(this.labelFreqsTotal, this.nSamples);
      }
      nodeValue() {
        return this.labelFreqsTotal;
      }
      static fromJson(model) {
        const jsonClass = JSON.parse(model);
        const newModel = new ClassificationCriterion({
          impurityMeasure: jsonClass.impurityMeasure,
          y: jsonClass.y
        });
        return Object.assign(newModel, jsonClass);
      }
    };
    RegressionCriterion = class extends Serialize {
      y;
      impurityMeasure;
      start = 0;
      end = 0;
      pos = 0;
      squaredSum = 0;
      squaredSumLeft = 0;
      squaredSumRight = 0;
      sumTotal = 0;
      sumTotalLeft = 0;
      sumTotalRight = 0;
      nSamples = 0;
      nSamplesLeft = 0;
      nSamplesRight = 0;
      name = "RegressionCriterion";
      constructor({ impurityMeasure, y }) {
        super();
        this.impurityMeasure = impurityMeasure;
        this.y = y;
      }
      init(start, end, sampleMap) {
        this.sumTotal = 0;
        this.squaredSum = 0;
        this.start = start;
        this.end = end;
        this.nSamples = end - start;
        for (let i2 = start; i2 < end; i2++) {
          let sampleNumber = sampleMap[i2];
          let yValue = this.y[sampleNumber];
          this.sumTotal += yValue;
          this.squaredSum += yValue * yValue;
        }
      }
      reset() {
        this.pos = this.start;
        this.squaredSumLeft = 0;
        this.sumTotalLeft = 0;
        this.squaredSumRight = 0;
        this.sumTotalRight = 0;
      }
      update(newPos, sampleMap) {
        for (let i2 = this.pos; i2 < newPos; i2++) {
          let sampleNumber = sampleMap[i2];
          let yValue = this.y[sampleNumber];
          this.sumTotalLeft += yValue;
          this.squaredSumLeft += yValue * yValue;
        }
        this.sumTotalRight = this.sumTotal - this.sumTotalLeft;
        this.squaredSumRight = this.squaredSum - this.squaredSumLeft;
        this.pos = newPos;
        this.nSamplesLeft = this.pos - this.start;
        this.nSamplesRight = this.end - this.pos;
      }
      childrenImpurities() {
        let impurityFunc = mse;
        return {
          impurityLeft: impurityFunc(this.squaredSumLeft, this.sumTotalLeft, this.nSamplesLeft),
          impurityRight: impurityFunc(this.squaredSumRight, this.sumTotalRight, this.nSamplesRight)
        };
      }
      impurityImprovement() {
        let { impurityLeft, impurityRight } = this.childrenImpurities();
        return -this.nSamplesLeft * impurityLeft - this.nSamplesRight * impurityRight;
      }
      nodeImpurity() {
        let impurityFunc = mse;
        return impurityFunc(this.squaredSum, this.sumTotal, this.nSamples);
      }
      nodeValue() {
        return [this.sumTotal / this.nSamples];
      }
      static fromJson(model) {
        const jsonClass = JSON.parse(model);
        const newModel = new RegressionCriterion({
          impurityMeasure: jsonClass.impurityMeasure,
          y: jsonClass.y
        });
        return Object.assign(newModel, jsonClass);
      }
    };
  }
});

// node_modules/lodash/_copyArray.js
var require_copyArray = __commonJS({
  "node_modules/lodash/_copyArray.js"(exports, module) {
    function copyArray(source, array) {
      var index2 = -1, length = source.length;
      array || (array = Array(length));
      while (++index2 < length) {
        array[index2] = source[index2];
      }
      return array;
    }
    module.exports = copyArray;
  }
});

// node_modules/lodash/_shuffleSelf.js
var require_shuffleSelf = __commonJS({
  "node_modules/lodash/_shuffleSelf.js"(exports, module) {
    var baseRandom = require_baseRandom();
    function shuffleSelf(array, size2) {
      var index2 = -1, length = array.length, lastIndex = length - 1;
      size2 = size2 === void 0 ? length : size2;
      while (++index2 < size2) {
        var rand = baseRandom(index2, lastIndex), value = array[rand];
        array[rand] = array[index2];
        array[index2] = value;
      }
      array.length = size2;
      return array;
    }
    module.exports = shuffleSelf;
  }
});

// node_modules/lodash/_arrayShuffle.js
var require_arrayShuffle = __commonJS({
  "node_modules/lodash/_arrayShuffle.js"(exports, module) {
    var copyArray = require_copyArray();
    var shuffleSelf = require_shuffleSelf();
    function arrayShuffle(array) {
      return shuffleSelf(copyArray(array));
    }
    module.exports = arrayShuffle;
  }
});

// node_modules/lodash/_baseShuffle.js
var require_baseShuffle = __commonJS({
  "node_modules/lodash/_baseShuffle.js"(exports, module) {
    var shuffleSelf = require_shuffleSelf();
    var values = require_values();
    function baseShuffle(collection) {
      return shuffleSelf(values(collection));
    }
    module.exports = baseShuffle;
  }
});

// node_modules/lodash/shuffle.js
var require_shuffle = __commonJS({
  "node_modules/lodash/shuffle.js"(exports, module) {
    var arrayShuffle = require_arrayShuffle();
    var baseShuffle = require_baseShuffle();
    var isArray2 = require_isArray();
    function shuffle3(collection) {
      var func = isArray2(collection) ? arrayShuffle : baseShuffle;
      return func(collection);
    }
    module.exports = shuffle3;
  }
});

// node_modules/scikitjs/dist/esm/tree/Splitter.js
function makeDefaultSplit() {
  return {
    feature: 0,
    threshold: 0,
    pos: -1,
    impurityLeft: Number.POSITIVE_INFINITY,
    impurityRight: Number.POSITIVE_INFINITY,
    foundSplit: false
  };
}
var import_shuffle, Splitter;
var init_Splitter = __esm({
  "node_modules/scikitjs/dist/esm/tree/Splitter.js"() {
    init_Criterion();
    import_shuffle = __toESM(require_shuffle());
    init_simpleSerializer();
    Splitter = class extends Serialize {
      kMinSplitDiff;
      X;
      y;
      criterion;
      start;
      end;
      minSamplesLeaf;
      maxFeatures;
      featureOrder;
      shuffleFeatures;
      sampleMap;
      nSamplesTotal;
      nFeatures;
      name = "Splitter";
      constructor({ X, y, minSamplesLeaf, impurityMeasure, maxFeatures, samplesSubset = [] }) {
        super();
        this.X = X;
        this.y = y;
        this.nFeatures = X[0].length;
        this.minSamplesLeaf = minSamplesLeaf;
        this.maxFeatures = Math.min(maxFeatures, this.nFeatures);
        this.shuffleFeatures = maxFeatures < this.nFeatures;
        this.sampleMap = new Int32Array(X.length);
        this.start = 0;
        this.end = 0;
        this.kMinSplitDiff = 1e-8;
        if (samplesSubset.length === 0) {
          this.nSamplesTotal = X.length;
          for (let i2 = 0; i2 < this.nSamplesTotal; i2++) {
            this.sampleMap[i2] = i2;
          }
        } else {
          this.nSamplesTotal = samplesSubset.length;
          for (let i2 = 0; i2 < this.nSamplesTotal; i2++) {
            this.sampleMap[i2] = samplesSubset[i2];
          }
        }
        if (impurityMeasure === "squared_error") {
          this.criterion = new RegressionCriterion({ impurityMeasure, y });
        } else {
          this.criterion = new ClassificationCriterion({ impurityMeasure, y });
        }
        this.featureOrder = [];
        for (let i2 = 0; i2 < this.nFeatures; i2++) {
          this.featureOrder.push(i2);
        }
        this.resetSampleRange(0, this.nSamplesTotal);
      }
      resetSampleRange(start, end) {
        this.start = start;
        this.end = end;
        this.criterion.init(start, end, this.sampleMap);
      }
      splitNode() {
        let currentSplit = makeDefaultSplit();
        let bestSplit = makeDefaultSplit();
        let currentImpurityImprovement = Number.NEGATIVE_INFINITY;
        let bestImpurityImprovement = Number.NEGATIVE_INFINITY;
        let currentFeatureNum = 0;
        let currentFeature = 0;
        currentSplit.foundSplit = false;
        if (this.shuffleFeatures) {
          this.featureOrder = (0, import_shuffle.default)(this.featureOrder);
        }
        while (currentFeatureNum < this.maxFeatures) {
          currentFeature = this.featureOrder[currentFeatureNum];
          let currentFeatureValues = new Float32Array(this.end - this.start);
          for (let i2 = this.start; i2 < this.end; i2++) {
            let row2 = this.X[this.sampleMap[i2]];
            let val = row2[currentFeature];
            currentFeatureValues[i2 - this.start] = val;
          }
          currentFeatureValues.sort();
          this.criterion.reset();
          this.sampleMap.subarray(this.start, this.end).sort((a, b) => this.X[a][currentFeature] - this.X[b][currentFeature]);
          if (currentFeatureValues[0] === currentFeatureValues[currentFeatureValues.length - 1]) {
            currentFeatureNum += 1;
            continue;
          }
          let pos = this.start + 1;
          while (pos < this.end) {
            while (pos < this.end && currentFeatureValues[pos - this.start] <= currentFeatureValues[pos - this.start - 1] + this.kMinSplitDiff) {
              pos++;
            }
            if (pos === this.end) {
              pos++;
              continue;
            }
            if (!(pos - this.start < this.minSamplesLeaf || this.end - pos < this.minSamplesLeaf)) {
              currentSplit.pos = pos;
              this.criterion.update(currentSplit.pos, this.sampleMap);
              currentImpurityImprovement = this.criterion.impurityImprovement();
              if (currentImpurityImprovement > bestImpurityImprovement) {
                bestImpurityImprovement = currentImpurityImprovement;
                currentSplit.foundSplit = true;
                currentSplit.feature = currentFeature;
                currentSplit.threshold = (currentFeatureValues[pos - this.start - 1] + currentFeatureValues[pos - this.start]) / 2;
                bestSplit = Object.assign({}, currentSplit);
              }
            }
            pos += 1;
          }
          currentFeatureNum += 1;
        }
        if (currentSplit.foundSplit) {
          if (bestSplit.pos < this.end) {
            if (currentFeature !== bestSplit.feature) {
              let leftPos = this.start;
              let rightPos = this.end;
              let tmp = 0;
              while (leftPos < rightPos) {
                if (this.X[this.sampleMap[leftPos]][bestSplit.feature] <= bestSplit.threshold) {
                  leftPos += 1;
                } else {
                  rightPos -= 1;
                  tmp = this.sampleMap[leftPos];
                  this.sampleMap[leftPos] = this.sampleMap[rightPos];
                  this.sampleMap[rightPos] = tmp;
                }
              }
            }
          }
          this.criterion.reset();
          this.criterion.update(bestSplit.pos, this.sampleMap);
          let { impurityLeft, impurityRight } = this.criterion.childrenImpurities();
          bestSplit.impurityLeft = impurityLeft;
          bestSplit.impurityRight = impurityRight;
          return bestSplit;
        } else {
          return currentSplit;
        }
      }
    };
  }
});

// node_modules/scikitjs/dist/esm/tree/utils.js
function validateX(X) {
  if (X.length === 0) {
    throw new Error(`X can not be empty, but it has a length of 0. It is ${X}.`);
  }
  for (let i2 = 0; i2 < X.length; i2++) {
    let curRow = X[i2];
    if (curRow.length === 0) {
      throw new Error(`Rows in X can not be empty, but row ${i2} in X is ${curRow}.`);
    }
    for (let j = 0; j < curRow.length; j++) {
      if (typeof curRow[j] !== "number" || !Number.isFinite(curRow[j])) {
        throw new Error(`X must contain finite non-NaN numbers, but the element at X[${i2}][${j}] is ${curRow[j]}`);
      }
    }
  }
}
function validateY(y) {
  if (y.length === 0) {
    throw new Error(`y can not be empty, but it has a length of 0. It is ${y}.`);
  }
  for (let i2 = 0; i2 < y.length; i2++) {
    let curVal = y[i2];
    if (!Number.isSafeInteger(curVal)) {
      throw new Error(`Some y values are not an integer. Found ${curVal} but must be an integer only`);
    }
  }
}
var init_utils3 = __esm({
  "node_modules/scikitjs/dist/esm/tree/utils.js"() {
  }
});

// node_modules/scikitjs/dist/esm/tree/DecisionTree.js
function argMax(array) {
  return array.map((x, i2) => [x, i2]).reduce((r, a) => a[0] > r[0] ? a : r)[1];
}
var DecisionTree, DecisionTreeBase, DecisionTreeClassifier, DecisionTreeRegressor;
var init_DecisionTree = __esm({
  "node_modules/scikitjs/dist/esm/tree/DecisionTree.js"() {
    init_Splitter();
    init_metrics();
    init_Splitter();
    init_typesUtils();
    init_utils3();
    init_utils();
    init_LabelEncoder();
    init_simpleSerializer();
    DecisionTree = class {
      nodes = [];
      isBuilt = false;
      name = "DecisionTree";
      getLeafNodes(X) {
        let leafNodeIds = [];
        for (let i2 = 0; i2 < X.length; i2++) {
          let nodeId = 0;
          while (!this.nodes[nodeId].isLeaf) {
            if (X[i2][this.nodes[nodeId].splitFeature] <= this.nodes[nodeId].threshold) {
              nodeId = this.nodes[nodeId].leftChildId;
            } else {
              nodeId = this.nodes[nodeId].rightChildId;
            }
          }
          leafNodeIds.push(nodeId);
        }
        return leafNodeIds;
      }
      populateChildIds() {
        for (let i2 = 1; i2 < this.nodes.length; i2++) {
          if (this.nodes[i2].isLeft) {
            this.nodes[this.nodes[i2].parentId].leftChildId = i2;
          } else {
            this.nodes[this.nodes[i2].parentId].rightChildId = i2;
          }
        }
      }
      predictProba(samples) {
        if (!this.isBuilt) {
          throw new Error("Decision tree must be built with BuildTree method before predictions can be made.");
        }
        let leafNodeIds = this.getLeafNodes(samples);
        let classProbabilities = [];
        for (let i2 = 0; i2 < leafNodeIds.length; i2++) {
          let currentClassProbabilities = [];
          let curNodeId = leafNodeIds[i2];
          for (let nClass = 0; nClass < this.nodes[0].value.length; nClass++) {
            currentClassProbabilities.push(this.nodes[curNodeId].value[nClass] / this.nodes[curNodeId].nSamples);
          }
          classProbabilities.push(currentClassProbabilities);
        }
        return classProbabilities;
      }
      predictClassification(samples) {
        if (!this.isBuilt) {
          throw new Error("Decision tree must be built with BuildTree method before predictions can be made.");
        }
        let leafNodeIds = this.getLeafNodes(samples);
        let classPredictions = [];
        for (let nSample = 0; nSample < leafNodeIds.length; nSample++) {
          let curNodeId = leafNodeIds[nSample];
          classPredictions.push(argMax(this.nodes[curNodeId].value));
        }
        return classPredictions;
      }
      predictRegression(samples) {
        if (!this.isBuilt) {
          throw new Error("Decision tree must be built with BuildTree method before predictions can be made.");
        }
        let leafNodeIds = this.getLeafNodes(samples);
        let classPredictions = [];
        for (let nSample = 0; nSample < leafNodeIds.length; nSample++) {
          let curNodeId = leafNodeIds[nSample];
          classPredictions.push(this.nodes[curNodeId].value[0]);
        }
        return classPredictions;
      }
    };
    DecisionTreeBase = class extends Serialize {
      splitter;
      stack = [];
      minSamplesLeaf;
      maxDepth;
      minSamplesSplit;
      minImpurityDecrease;
      tree;
      criterion;
      maxFeatures;
      maxFeaturesNumb;
      X = [];
      y = [];
      labelEncoder;
      name;
      constructor({ criterion = "gini", maxDepth = Number.POSITIVE_INFINITY, minSamplesSplit = 2, minSamplesLeaf = 1, maxFeatures = void 0, minImpurityDecrease = 0 } = {}) {
        super();
        this.criterion = criterion;
        this.maxDepth = maxDepth === void 0 ? Number.POSITIVE_INFINITY : Number(maxDepth);
        this.minSamplesSplit = minSamplesSplit;
        this.minSamplesLeaf = minSamplesLeaf;
        this.maxFeatures = maxFeatures;
        this.minImpurityDecrease = minImpurityDecrease;
        this.maxFeaturesNumb = 0;
        this.tree = new DecisionTree();
        this.name = "DecisionTreeBase";
      }
      calcMaxFeatures(nFeatures, maxFeatures) {
        if (maxFeatures === "log2") {
          return Math.floor(Math.log2(nFeatures));
        }
        if (maxFeatures === "sqrt") {
          return Math.floor(Math.sqrt(nFeatures));
        }
        if (maxFeatures === "auto") {
          return Math.floor(Math.sqrt(nFeatures));
        }
        if (typeof maxFeatures === "number") {
          assert(maxFeatures >= 1, "maxFeatures must be greater than 1");
          return Math.min(Math.floor(maxFeatures), nFeatures);
        }
        return nFeatures;
      }
      fit(X, y, samplesSubset) {
        this.X = X;
        this.y = y;
        let newSamplesSubset = samplesSubset || [];
        this.maxFeaturesNumb = this.calcMaxFeatures(X[0].length, this.maxFeatures);
        this.splitter = new Splitter({
          X,
          y,
          minSamplesLeaf: this.minSamplesLeaf,
          impurityMeasure: this.criterion,
          maxFeatures: this.maxFeaturesNumb,
          samplesSubset: newSamplesSubset
        });
        let rootNode = {
          start: 0,
          end: this.splitter.sampleMap.length,
          depth: 0,
          impurity: 0,
          nSamples: this.splitter.sampleMap.length,
          parentId: -1,
          isLeft: false
        };
        this.stack.push(rootNode);
        let isRootNode = true;
        while (this.stack.length !== 0) {
          let currentRecord = this.stack.pop();
          this.splitter.resetSampleRange(currentRecord.start, currentRecord.end);
          let currentSplit = makeDefaultSplit();
          let isLeaf = !(currentRecord.depth < this.maxDepth) || currentRecord.nSamples < this.minSamplesSplit || currentRecord.nSamples < 2 * this.minSamplesLeaf;
          if (isRootNode) {
            currentRecord.impurity = this.splitter.criterion.nodeImpurity();
            isRootNode = false;
          }
          if (!isLeaf) {
            currentSplit = this.splitter.splitNode();
            isLeaf = isLeaf || !currentSplit.foundSplit || currentRecord.impurity <= this.minImpurityDecrease;
          }
          let currentNode = {
            parentId: currentRecord.parentId,
            impurity: currentRecord.impurity,
            isLeaf,
            isLeft: currentRecord.isLeft,
            nSamples: currentRecord.nSamples,
            splitFeature: currentSplit.feature,
            threshold: currentSplit.threshold,
            value: this.splitter.criterion.nodeValue().slice(),
            leftChildId: -1,
            rightChildId: -1
          };
          this.tree.nodes.push(currentNode);
          let nodeId = this.tree.nodes.length - 1;
          if (!isLeaf) {
            let rightRecord = {
              start: currentSplit.pos,
              end: currentRecord.end,
              nSamples: currentRecord.end - currentSplit.pos,
              depth: currentRecord.depth + 1,
              parentId: nodeId,
              isLeft: false,
              impurity: currentSplit.impurityRight
            };
            this.stack.push(rightRecord);
            let leftRecord = {
              start: currentRecord.start,
              end: currentSplit.pos,
              nSamples: currentSplit.pos - currentRecord.start,
              depth: currentRecord.depth + 1,
              parentId: nodeId,
              isLeft: true,
              impurity: currentSplit.impurityLeft
            };
            this.stack.push(leftRecord);
          }
        }
        this.tree.populateChildIds();
        this.tree.isBuilt = true;
      }
    };
    DecisionTreeClassifier = class extends DecisionTreeBase {
      labelEncoder;
      name;
      constructor({ criterion = "gini", maxDepth = void 0, minSamplesSplit = 2, minSamplesLeaf = 1, maxFeatures = void 0, minImpurityDecrease = 0 } = {}) {
        assert(["gini", "entropy"].includes(criterion), 'For classification must pass either the "gini" or "entropy" criterion');
        super({
          criterion,
          maxDepth,
          minSamplesSplit,
          minSamplesLeaf,
          maxFeatures,
          minImpurityDecrease
        });
        this.labelEncoder = new LabelEncoder();
        this.name = "DecisionTreeClassifier";
      }
      fit(X, y) {
        assert(isScikit1D(y), "y value is not a 1D container");
        assert(isScikit2D(X), "X value is not a 2D container");
        let XArray = convertScikit2DToArray(X);
        let yArray = convertScikit1DToArray(y);
        assert(XArray.length === yArray.length, "X and y must be the same size");
        validateX(XArray);
        validateY(yArray);
        let yArrayFixed = this.labelEncoder.fitTransform(yArray);
        super.fit(XArray, convertScikit1DToArray(yArrayFixed));
        return this;
      }
      getNLeaves() {
        return this.tree.nodes.filter((el) => el.isLeaf).length;
      }
      predict(X) {
        assert(isScikit2D(X), "X value is not a 2D container");
        let XArray = convertScikit2DToArray(X);
        validateX(XArray);
        let yValues = this.tree.predictClassification(XArray);
        return this.labelEncoder.inverseTransform(yValues);
      }
      predictProba(X) {
        return this.tree.predictProba(X);
      }
      score(X, y) {
        const yPred = this.predict(X);
        return accuracyScore(y, yPred);
      }
    };
    DecisionTreeRegressor = class extends DecisionTreeBase {
      name;
      constructor({ criterion = "squared_error", maxDepth = void 0, minSamplesSplit = 2, minSamplesLeaf = 1, maxFeatures = void 0, minImpurityDecrease = 0 } = {}) {
        assert(["squared_error"].includes(criterion), 'Must pass the regression criterion of "squared_error"');
        super({
          criterion,
          maxDepth,
          minSamplesSplit,
          minSamplesLeaf,
          maxFeatures,
          minImpurityDecrease
        });
        this.name = "DecisionTreeRegressor";
      }
      fit(X, y) {
        assert(isScikit1D(y), "y value is not a 1D container");
        assert(isScikit2D(X), "X value is not a 2D container");
        let XArray = convertScikit2DToArray(X);
        let yArray = convertScikit1DToArray(y);
        assert(XArray.length === yArray.length, "X and y must be the same size");
        validateX(XArray);
        super.fit(XArray, yArray);
        return this;
      }
      getNLeaves() {
        return this.tree.nodes.filter((el) => el.isLeaf).length;
      }
      predict(X) {
        return this.tree.predictRegression(X);
      }
      score(X, y) {
        const yPred = this.predict(X);
        return r2Score(y, yPred);
      }
    };
  }
});

// node_modules/scikitjs/dist/esm/datasets/makeRegression.js
var makeRegression, makeLowRankMatrix;
var init_makeRegression = __esm({
  "node_modules/scikitjs/dist/esm/datasets/makeRegression.js"() {
    init_tf_singleton();
    makeRegression = ({ nSamples = 100, nFeatures = 100, nInformative = 10, nTargets = 1, noise = 1, bias = 0, effectiveRank = null, tailStrength = 0.5, shuffle: shuffle3 = false, coef = false } = {}) => {
      let tf3 = getBackend2();
      return tf3.tidy(() => {
        const numberInformative = Math.min(nFeatures, nInformative);
        let X;
        if (effectiveRank === null) {
          X = tf3.randomNormal([nSamples, nFeatures]);
        } else {
          X = makeLowRankMatrix({
            nSamples,
            nFeatures,
            effectiveRank,
            tailStrength
          });
        }
        const model = tf3.randomNormal([numberInformative, nTargets]).mul(100);
        const zeros3 = tf3.zeros([nFeatures - numberInformative, nTargets]);
        const groundTruth = tf3.concat([model, zeros3]);
        let Y = X.dot(groundTruth).add(bias);
        if (noise > 0) {
          Y = Y.add(tf3.randomNormal(Y.shape, void 0, noise));
        }
        if (shuffle3) {
          const randomTen = tf3.util.createShuffledIndices(nSamples);
          X = X.gather(randomTen);
        }
        Y = tf3.squeeze(Y);
        if (coef) {
          return [X, Y, tf3.squeeze(groundTruth)];
        }
        return [X, Y];
      });
    };
    makeLowRankMatrix = ({ nSamples = 100, nFeatures = 100, effectiveRank = 10, tailStrength = 0.5 } = {}) => {
      let tf3 = getBackend2();
      return tf3.tidy(() => {
        let n = Math.min(nSamples, nFeatures);
        let [u] = tf3.linalg.qr(tf3.randomNormal([nSamples, n]));
        let [v] = tf3.linalg.qr(tf3.randomNormal([nFeatures, n]));
        let singularIndex = tf3.range(0, n);
        const singularIndexByRank = singularIndex.div(effectiveRank);
        const lowRank = tf3.exp(singularIndexByRank.square().neg()).mul(1 - tailStrength);
        let tail = tf3.exp(singularIndexByRank.mul(-0.1)).mul(tailStrength);
        let s = lowRank.add(tail);
        return u.mul(s).dot(v.transpose());
      });
    };
  }
});

// node_modules/scikitjs/dist/esm/model_selection/KFold.js
var KFold;
var init_KFold = __esm({
  "node_modules/scikitjs/dist/esm/model_selection/KFold.js"() {
    init_typesUtils();
    init_randUtils();
    init_utils();
    init_tf_singleton();
    KFold = class {
      nSplits;
      shuffle;
      randomState;
      name;
      tf;
      constructor({ nSplits = 5, shuffle: shuffle3 = false, randomState } = {}) {
        nSplits = Number(nSplits);
        assert(Number.isInteger(nSplits) && nSplits > 1, "new KFold({nSplits}): nSplits must be an int greater than 1.");
        this.tf = getBackend2();
        this.nSplits = nSplits;
        this.shuffle = Boolean(shuffle3);
        this.randomState = randomState;
        this.name = "KFold";
      }
      getNumSplits() {
        return this.nSplits;
      }
      *split(X, y, groups) {
        const { nSplits, shuffle: shuffle3, randomState } = this;
        const nSamples = getLength(X);
        assert(nSplits <= nSamples, "KFold({nSplits})::split(X): nSplits must not be greater than X.shape[0].");
        if (y != null) {
          assert(nSamples === getLength(y), "KFold::split(X,y): X.shape[0] must equal y.shape[0].");
        }
        if (groups != null) {
          assert(nSamples === getLength(groups), "KFold::split(X,y,groups): X.shape[0] must equal groups.shape[0].");
        }
        const range2 = new Int32Array(nSamples);
        for (let i2 = 0; i2 < range2.length; i2++) {
          range2[i2] = i2;
        }
        if (shuffle3) {
          const rng = createRng2(randomState);
          shuffle(rng)(range2);
        }
        const chunkBase = Math.floor(nSamples / nSplits);
        let remainder = nSamples % nSplits;
        let offset = 0;
        while (offset < nSamples) {
          const chunk = remainder-- > 0 ? chunkBase + 1 : chunkBase;
          const train3 = new Int32Array(nSamples - chunk);
          train3.set(range2.subarray(0, offset), 0);
          train3.set(range2.subarray(offset + chunk), offset);
          const test = range2.slice(offset, offset + chunk);
          yield {
            trainIndex: this.tf.tensor1d(train3, "int32"),
            testIndex: this.tf.tensor1d(test, "int32")
          };
          offset += chunk;
        }
      }
    };
  }
});

// node_modules/scikitjs/dist/esm/model_selection/trainTestSplit.js
function validateShuffleSplit(nSamples, testSize, trainSize, defaultTestSize = 0.1) {
  assert(trainSize === void 0 || typeof trainSize === "number", `Invalid value for trainSize: ${trainSize}. Must be number or undefined`);
  assert(testSize === void 0 || typeof testSize === "number", `Invalid value for testSize: ${testSize}. Must be number or undefined`);
  if (testSize === void 0 && trainSize === void 0) {
    testSize = defaultTestSize;
  }
  if (typeof testSize === "number") {
    if (Number.isInteger(testSize) && (testSize >= nSamples || testSize <= 0) || !Number.isInteger(testSize) && (testSize <= 0 || testSize >= 1)) {
      throw Error(`testSize=${testSize} should be either positive and smaller than the number of samples ${nSamples} or a float in the (0, 1) range`);
    }
  }
  if (typeof trainSize === "number") {
    if (Number.isInteger(trainSize) && (trainSize >= nSamples || trainSize <= 0) || !Number.isInteger(trainSize) && (trainSize <= 0 || trainSize >= 1)) {
      throw Error(`trainSize=${trainSize} should be either positive and smaller than the number of samples ${nSamples} or a float in the (0, 1) range`);
    }
  }
  if (!Number.isInteger(trainSize) && !Number.isInteger(testSize) && trainSize && testSize && trainSize + testSize > 1) {
    throw Error(`The sum of testSize and trainSize = ${trainSize + testSize}, should be in the (0, 1) range. Reduce testSize and/or trainSize.`);
  }
  let nTest;
  let nTrain;
  if (Number.isInteger(testSize)) {
    nTest = testSize;
  } else if (typeof testSize === "number") {
    nTest = Math.ceil(testSize * nSamples);
  }
  if (Number.isInteger(trainSize)) {
    nTrain = trainSize;
  } else if (typeof trainSize === "number") {
    nTrain = Math.ceil(trainSize * nSamples);
  }
  if (trainSize === void 0) {
    nTrain = nSamples - nTest;
  }
  if (testSize === void 0) {
    nTest = nSamples - nTrain;
  }
  if (typeof nTrain !== "number" || typeof nTest !== "number") {
    throw Error("nTrain and nTest must be a number");
  }
  if (nTrain + nTest > nSamples) {
    throw Error(`The sum of trainSize and testSize = ${nTrain + nTest}, should be smaller than the number of samples ${nSamples}. Reduce testSize and/or trainSize.`);
  }
  nTrain = Math.floor(nTrain);
  nTest = Math.floor(nTest);
  if (nTrain === 0) {
    throw Error(`With nSamples=${nSamples}, testSize=${testSize} and trainSize=${trainSize}, the resulting train set will be empty. Adjust any of the aforementioned parameters.`);
  }
  return [nTrain, nTest];
}
function getIndices(X, indices) {
  let tf3 = getBackend2();
  if (isTensor(X)) {
    return tf3.gather(X, indices);
  }
  if (isDataFrameInterface(X)) {
    return X.iloc({ rows: indices });
  }
  if (isSeriesInterface(X)) {
    return X.iloc(indices);
  }
  return indices.map((i2) => X[i2]);
}
function trainTestSplit(X, y, testSize = 0.1, trainSize, randomState) {
  const Xlen = getLength(X);
  const ylen = getLength(y);
  assert(Xlen === ylen, `X and y don't have the same number of elements. They are of different size`);
  let [nTrain, nTest] = validateShuffleSplit(Xlen, testSize, trainSize);
  let shuffledIndices = sampleWithoutReplacement(Xlen, Xlen, randomState);
  let trainIndices = shuffledIndices.slice(0, nTrain);
  let testIndices = shuffledIndices.slice(nTrain);
  return [
    getIndices(X, trainIndices),
    getIndices(X, testIndices),
    getIndices(y, trainIndices),
    getIndices(y, testIndices)
  ];
}
var init_trainTestSplit = __esm({
  "node_modules/scikitjs/dist/esm/model_selection/trainTestSplit.js"() {
    init_typesUtils();
    init_utils();
    init_tf_singleton();
  }
});

// node_modules/scikitjs/dist/esm/model_selection/crossValScore.js
async function crossValScore(estimator, X, y, params) {
  let tf3 = getBackend2();
  let unsupervised = y == null || params == null && !isScikit1D(y);
  if (unsupervised) {
    params = params ?? y;
  }
  let { cv = new KFold(), groups, scoring } = params ?? {};
  if (scoring == null) {
    assert("function" === typeof estimator.score, "crossValScore(estimator,[X,y],params): Either params.scoring or estimator.score(X,y) must be defined.");
    scoring = estimator.score;
  }
  const scores = [];
  scoring = scoring.bind(estimator);
  let result = void 0;
  tf3.engine().startScope();
  try {
    X = convertToTensor2D(X);
    if (!unsupervised) {
      y = convertToTensor1D(y);
    }
    for (const { trainIndex, testIndex } of cv.split(X, y, groups)) {
      let score2;
      const X_train = X.gather(trainIndex);
      const X_test = X.gather(testIndex);
      if (unsupervised) {
        await estimator.fit(X_train);
        score2 = scoring(X_test);
      } else {
        const y_train = y.gather(trainIndex);
        const y_test = y.gather(testIndex);
        await estimator.fit(X_train, y_train);
        score2 = scoring(X_test, y_test);
        y_train.dispose();
        y_test.dispose();
      }
      scores.push(score2);
      trainIndex.dispose();
      testIndex.dispose();
      X_train.dispose();
      X_test.dispose();
    }
    return result = tf3.stack(scores);
  } finally {
    tf3.engine().endScope(result);
  }
}
var init_crossValScore = __esm({
  "node_modules/scikitjs/dist/esm/model_selection/crossValScore.js"() {
    init_typesUtils();
    init_KFold();
    init_typesUtils();
    init_utils();
    init_tf_singleton();
  }
});

// node_modules/scikitjs/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  ClassificationCriterion: () => ClassificationCriterion,
  ColumnTransformer: () => ColumnTransformer,
  DecisionTree: () => DecisionTree,
  DecisionTreeBase: () => DecisionTreeBase,
  DecisionTreeClassifier: () => DecisionTreeClassifier,
  DecisionTreeRegressor: () => DecisionTreeRegressor,
  DummyClassifier: () => DummyClassifier,
  DummyRegressor: () => DummyRegressor,
  ElasticNet: () => ElasticNet,
  GaussianNB: () => GaussianNB,
  KFold: () => KFold,
  KMeans: () => KMeans,
  KNeighborsClassifier: () => KNeighborsClassifier,
  KNeighborsRegressor: () => KNeighborsRegressor,
  LabelEncoder: () => LabelEncoder,
  LassoRegression: () => LassoRegression,
  LinearRegression: () => LinearRegression,
  LinearSVC: () => LinearSVC,
  LinearSVR: () => LinearSVR,
  LogisticRegression: () => LogisticRegression,
  MaxAbsScaler: () => MaxAbsScaler,
  MinMaxScaler: () => MinMaxScaler,
  Normalizer: () => Normalizer,
  OneHotEncoder: () => OneHotEncoder,
  OrdinalEncoder: () => OrdinalEncoder,
  Pipeline: () => Pipeline,
  RegressionCriterion: () => RegressionCriterion,
  RidgeRegression: () => RidgeRegression,
  RobustScaler: () => RobustScaler,
  Serialize: () => Serialize,
  SimpleImputer: () => SimpleImputer,
  Splitter: () => Splitter,
  StandardScaler: () => StandardScaler,
  VotingClassifier: () => VotingClassifier,
  VotingRegressor: () => VotingRegressor,
  crossValScore: () => crossValScore,
  dataUrls: () => dataUrls,
  fromJSON: () => fromJSON,
  fromObject: () => fromObject,
  getBackend: () => getBackend2,
  makeLowRankMatrix: () => makeLowRankMatrix,
  makePipeline: () => makePipeline,
  makeRegression: () => makeRegression,
  makeVotingClassifier: () => makeVotingClassifier,
  makeVotingRegressor: () => makeVotingRegressor,
  metrics: () => metrics_exports,
  setBackend: () => setBackend2,
  trainTestSplit: () => trainTestSplit
});
var init_esm2 = __esm({
  "node_modules/scikitjs/dist/esm/index.js"() {
    init_LinearRegression();
    init_LassoRegression();
    init_RidgeRegression();
    init_ElasticNet();
    init_LogisticRegression();
    init_metrics();
    init_DummyRegressor();
    init_DummyClassifier();
    init_MinMaxScaler();
    init_StandardScaler();
    init_MaxAbsScaler();
    init_SimpleImputer();
    init_OneHotEncoder();
    init_LabelEncoder();
    init_OrdinalEncoder();
    init_Normalizer();
    init_Pipeline();
    init_ColumnTransformer();
    init_RobustScaler();
    init_KMeans();
    init_datasets();
    init_VotingRegressor();
    init_VotingClassifier();
    init_KNeighborsRegressor();
    init_KNeighborsClassifier();
    init_LinearSVC();
    init_LinearSVR();
    init_GaussianNB();
    init_DecisionTree();
    init_makeRegression();
    init_tf_singleton();
    init_KFold();
    init_trainTestSplit();
    init_crossValScore();
    init_simpleSerializer();
    init_Criterion();
    init_Splitter();
    init_DecisionTree();
  }
});

// src/model.ts
import * as JSONStackData from "@jsonstack/data";
import * as JSONStackDataTypes from "@jsonstack/data/src/DataSet";
import * as JSONStackModel from "@jsonstack/model";
import Promisie from "promisie/src/index";

// src/constants.ts
import { DateTime } from "luxon";
import Outlier from "outlier";
function getLuxonDateTime(options) {
  const { dateObject, dateFormat } = options;
  if (dateFormat === "js" && typeof dateObject === "object" || typeof dateObject === "object" && dateObject instanceof Date) {
    return {
      date: DateTime.fromJSDate(dateObject, { zone: options.time_zone }),
      format: "js"
    };
  } else if (typeof dateFormat === "string" && dateFormat !== "iso" && dateFormat !== "js") {
    return {
      date: DateTime.fromFormat(dateObject, dateFormat, { zone: options.time_zone }),
      format: dateFormat
    };
  } else {
    return {
      date: DateTime.fromISO(dateObject, { zone: options.time_zone }),
      format: "iso"
    };
  }
}
var generatedMonthNumbers = [];
var generatedWeekNumbers = [];
var generatedDayNumbers = [];
var generatedQuarterhourNumbers = [];
var generatedOrdinalDayNumbers = [];
var generatedHourNumbers = [];
var generatedMinuteNumbers = [];
var generatedSecondNumbers = [];
var generatedMockDateObject = {
  year: new Date().getFullYear(),
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  week: 1,
  weekday: 1,
  quarter_hour: 1,
  oridinalday: 1
};
var generatedMockDates = [generatedMockDateObject];
for (let i2 = 0; i2 <= 366; i2++) {
  const newMockDate = Object.assign({}, generatedMockDateObject);
  if (i2 >= 1 && i2 <= 12) {
    newMockDate.month = i2;
    generatedMonthNumbers.push(i2);
  }
  if (i2 >= 1 && i2 <= 52) {
    newMockDate.week = i2;
    generatedWeekNumbers.push(i2);
  }
  if (i2 >= 1 && i2 <= 7) {
    newMockDate.weekday = i2;
    generatedDayNumbers.push(i2);
  }
  if (i2 >= 1 && i2 <= 366) {
    newMockDate.oridinalday = i2;
    generatedOrdinalDayNumbers.push(i2);
  }
  if (i2 >= 1 && i2 <= 31) {
    newMockDate.day = i2;
    generatedDayNumbers.push(i2);
  }
  if (i2 >= 1 && i2 <= 96) {
    newMockDate.quarter_hour = i2;
    generatedQuarterhourNumbers.push(i2);
  }
  if (i2 <= 23) {
    newMockDate.hour = i2;
    generatedHourNumbers.push(i2);
  }
  if (i2 <= 59) {
    newMockDate.minute = i2;
    generatedMinuteNumbers.push(i2);
  }
  if (i2 <= 59) {
    newMockDate.second = i2;
    generatedSecondNumbers.push(i2);
  }
  generatedMockDates.push(newMockDate);
}
function training_on_progress({ completion_percentage, loss, epoch, status, logs, defaultLog = true }) {
  if (defaultLog)
    console.log({ completion_percentage, loss, epoch, status, logs });
}
var mockDates = generatedMockDates;
function getPartialHour(minute) {
  const partialHour = minute / 15;
  if (partialHour < 1) {
    return 1;
  } else if (partialHour < 2) {
    return 2;
  } else if (partialHour < 3) {
    return 3;
  } else {
    return 4;
  }
}
function getQuarterHour(parsedDate) {
  if (typeof parsedDate.hour === "undefined" || typeof parsedDate.minute === "undefined")
    throw new ReferenceError("both hour and minute are required");
  return parsedDate.hour * 4 + getPartialHour(parsedDate.minute);
}
function getParsedDate(date, options) {
  const luxonDate = DateTime.fromJSDate(date, options);
  const parsedDate = Object.assign({}, luxonDate.toObject());
  parsedDate.week = luxonDate.weekNumber;
  parsedDate.ordinal_day = luxonDate.ordinal;
  parsedDate.weekday = luxonDate.weekday;
  parsedDate.days_in_month = luxonDate.daysInMonth;
  parsedDate.weekend = luxonDate.weekday === 6 || luxonDate.weekday === 7 ? true : false;
  parsedDate.quarter_hour = getQuarterHour(parsedDate);
  return parsedDate;
}
function getLocalParsedDate({ date, time_zone, dimension }) {
  const end_date = DateTime.fromJSDate(date).plus({
    [timeProperty[dimension]]: 1
  }).toJSDate();
  const startOriginDate = DateTime.fromJSDate(date, { zone: time_zone });
  const endOriginDate = DateTime.fromJSDate(end_date, { zone: time_zone });
  const startDate = DateTime.fromJSDate(date);
  const endDate = DateTime.fromJSDate(end_date);
  const { year, month, day, ordinal, weekday, hour, minute, second } = startOriginDate;
  return {
    year,
    month,
    day,
    hour,
    minute,
    second,
    days_in_month: startOriginDate.daysInMonth,
    ordinal_day: ordinal,
    week: startOriginDate.weekNumber,
    weekday,
    weekend: startOriginDate.weekday >= 6,
    origin_time_zone: time_zone,
    start_origin_date_string: startOriginDate.toFormat(prettyTimeStringOutputFormat),
    start_gmt_date_string: startDate.toJSDate().toUTCString(),
    end_origin_date_string: endOriginDate.toFormat(prettyTimeStringOutputFormat),
    end_gmt_date_string: endDate.toJSDate().toUTCString()
  };
}
var prettyTimeStringOutputFormat = "ccc, dd LLL yyyy TTT";
var timeProperty = {
  ["monthly" /* MONTHLY */]: "months",
  ["weekly" /* WEEKLY */]: "weeks",
  ["daily" /* DAILY */]: "days",
  ["hourly" /* HOURLY */]: "hours"
};
var durationToDimensionProperty = {
  "years": "yearly" /* YEARLY */,
  "weeks": "weekly" /* WEEKLY */,
  "months": "monthly" /* MONTHLY */,
  "days": "daily" /* DAILY */,
  "hours": "hourly" /* HOURLY */
};
var ISOOptions = {
  includeOffset: false,
  suppressMilliseconds: true
};
var dimensionDurations = ["years", "months", "weeks", "days", "hours"];
var flattenDelimiter = "+=+";
function getOpenHour(options = {}) {
  return 1;
}
function getIsOutlier({ outlier_property } = {}) {
  if (outlier_property) {
    const data = this.data;
    const outlier = Outlier(data.map((datum2) => datum2[outlier_property]));
    const datum = this.datum;
    const dataPoint = datum[outlier_property];
    return outlier.testOutlier(dataPoint) ? 1 : -1;
  } else {
    return 0;
  }
}
function addMockDataToDataSet(DataSet3, { mockEncodedData = [], includeConstants = true }) {
  const newMockData = new Array().concat(mockEncodedData, includeConstants ? mockDates : []);
  DataSet3.data = DataSet3.data.concat(newMockData);
  return DataSet3;
}
function removeMockDataFromDataSet(DataSet3, { mockEncodedData = [], includeConstants = true }) {
  const newMockData = new Array().concat(mockEncodedData, includeConstants ? mockDates : []);
  DataSet3.data.splice(DataSet3.data.length - newMockData.length, newMockData.length);
  return DataSet3;
}
function removeEvaluationData(evaluation) {
  evaluation.actuals = void 0;
  delete evaluation.actuals;
  evaluation.estimates = void 0;
  delete evaluation.estimates;
  return evaluation;
}

// src/features.ts
import { DateTime as DateTime2 } from "luxon";
function getUniqueYears({ start, end, time_zone }) {
  if (!time_zone)
    throw new ReferenceError("Missing required timezone");
  let startDate = DateTime2.fromISO(start, { zone: time_zone }).set({ month: 1, day: 1, hour: 0, minute: 0, second: 0, millisecond: 0 });
  const endDate = DateTime2.fromISO(end, { zone: time_zone }).set({ month: 1, day: 1, hour: 0, minute: 0, second: 0, millisecond: 0 });
  const uniqueDates = [];
  do {
    if (startDate.isValid === false)
      throw new SyntaxError("Date format is invalid, must be an ISO Date (ISO 8601 e.g. 2019-03-21T11:42:00 - YYYY-MM-DDTHH:mm:ss)");
    uniqueDates.push(startDate.toJSDate());
    startDate = startDate.plus({ years: 1 });
  } while (startDate <= endDate);
  return uniqueDates;
}
function getUniqueMonths({ start, end, time_zone }) {
  if (!time_zone)
    throw new ReferenceError("Missing required timezone");
  let startDate = DateTime2.fromISO(start, { zone: time_zone }).set({ day: 1, hour: 0, minute: 0, second: 0, millisecond: 0 });
  const endDate = DateTime2.fromISO(end, { zone: time_zone }).set({ day: 1, hour: 0, minute: 0, second: 0, millisecond: 0 });
  const uniqueDates = [];
  do {
    if (startDate.isValid === false)
      throw new SyntaxError("Date format is invalid, must be an ISO Date (ISO 8601 e.g. 2019-03-21T11:42:00 - YYYY-MM-DDTHH:mm:ss)");
    uniqueDates.push(startDate.toJSDate());
    startDate = startDate.plus({ months: 1 });
  } while (startDate <= endDate);
  return uniqueDates;
}
function getUniqueWeeks({ start, end, weekday = "monday", time_zone }) {
  if (!time_zone)
    throw new ReferenceError("Missing required timezone");
  const weekdayNumbers = {
    monday: 1,
    "1": 1,
    tuesday: 2,
    "2": 1,
    wednesday: 3,
    "3": 1,
    thursday: 4,
    "4": 1,
    friday: 5,
    "5": 1,
    saturday: 6,
    "6": 1,
    sunday: 7,
    "7": 1,
    default: 1
  };
  const weekdayString = weekday.toString().toLowerCase();
  const weekdayNumber = weekdayNumbers[weekdayString];
  if (!weekdayNumber)
    throw new ReferenceError(`Invalid weekday (${weekday}), must be either 1-7 or monday-sunday`);
  let startLuxon = DateTime2.fromISO(start, { zone: time_zone }).set({ hour: 0, minute: 0, second: 0, millisecond: 0 });
  let endLuxon = DateTime2.fromISO(end, { zone: time_zone }).set({ hour: 0, minute: 0, second: 0, millisecond: 0 });
  let startDate = weekdayNumber >= startLuxon.weekday ? startLuxon.plus({ days: weekdayNumber - startLuxon.weekday }) : startLuxon.minus({ days: startLuxon.weekday - weekdayNumber });
  const endDate = weekdayNumber >= endLuxon.weekday ? endLuxon.plus({ days: weekdayNumber - endLuxon.weekday }) : endLuxon.minus({ days: endLuxon.weekday - weekdayNumber });
  const uniqueDates = [];
  do {
    if (startDate.isValid === false)
      throw new SyntaxError("Date format is invalid, must be an ISO Date (ISO 8601 e.g. 2019-03-21T11:42:00 - YYYY-MM-DDTHH:mm:ss)");
    uniqueDates.push(startDate.toJSDate());
    startDate = startDate.plus({ days: 7 });
  } while (startDate <= endDate);
  return uniqueDates;
}
function getUniqueDays({ start, end, time_zone }) {
  if (!time_zone)
    throw new ReferenceError("Missing required timezone");
  let startDate = DateTime2.fromISO(start, { zone: time_zone }).set({ hour: 0, minute: 0, second: 0, millisecond: 0 });
  const endDate = DateTime2.fromISO(end, { zone: time_zone }).set({ hour: 0, minute: 0, second: 0, millisecond: 0 });
  const uniqueDates = [];
  do {
    if (startDate.isValid === false)
      throw new SyntaxError("Date format is invalid, must be an ISO Date (ISO 8601 e.g. 2019-03-21T11:42:00 - YYYY-MM-DDTHH:mm:ss)");
    uniqueDates.push(startDate.toJSDate());
    startDate = startDate.plus({ days: 1 });
  } while (startDate <= endDate);
  return uniqueDates;
}
function getUniqueHours({ start, end, time_zone }) {
  if (!time_zone)
    throw new ReferenceError("Missing required timezone");
  let startDate = DateTime2.fromISO(start, { zone: time_zone }).set({ minute: 0, second: 0, millisecond: 0 });
  const endDate = DateTime2.fromISO(end, { zone: time_zone }).set({ minute: 0, second: 0, millisecond: 0 });
  const uniqueDates = [];
  do {
    if (startDate.isValid === false)
      throw new SyntaxError("Date format is invalid, must be an ISO Date (ISO 8601 e.g. 2019-03-21T11:42:00 - YYYY-MM-DDTHH:mm:ss)");
    uniqueDates.push(startDate.toJSDate());
    startDate = startDate.plus({ hours: 1 });
  } while (startDate <= endDate);
  return uniqueDates;
}
function getUniqueMinutes({ start, end, time_zone }) {
  if (!time_zone)
    throw new ReferenceError("Missing required timezone");
  let startDate = DateTime2.fromISO(start, { zone: time_zone }).set({ second: 0, millisecond: 0 });
  const endDate = DateTime2.fromISO(end, { zone: time_zone }).set({ second: 0, millisecond: 0 });
  const uniqueDates = [];
  do {
    if (startDate.isValid === false)
      throw new SyntaxError("Date format is invalid, must be an ISO Date (ISO 8601 e.g. 2019-03-21T11:42:00 - YYYY-MM-DDTHH:mm:ss)");
    uniqueDates.push(startDate.toJSDate());
    startDate = startDate.plus({ minutes: 1 });
  } while (startDate <= endDate);
  return uniqueDates;
}
function getUniqueSeconds({ start, end, time_zone }) {
  if (!time_zone)
    throw new ReferenceError("Missing required timezone");
  let startDate = DateTime2.fromISO(start, { zone: time_zone }).set({ millisecond: 0 });
  const endDate = DateTime2.fromISO(end, { zone: time_zone }).set({ millisecond: 0 });
  const uniqueDates = [];
  do {
    if (startDate.isValid === false)
      throw new SyntaxError("Date format is invalid, must be an ISO Date (ISO 8601 e.g. 2019-03-21T11:42:00 - YYYY-MM-DDTHH:mm:ss)");
    uniqueDates.push(startDate.toJSDate());
    startDate = startDate.plus({ seconds: 1 });
  } while (startDate <= endDate);
  return uniqueDates;
}
var dimensionDates = {
  ["yearly" /* YEARLY */]: getUniqueYears,
  ["monthly" /* MONTHLY */]: getUniqueMonths,
  ["weekly" /* WEEKLY */]: getUniqueWeeks,
  ["daily" /* DAILY */]: getUniqueDays,
  ["hourly" /* HOURLY */]: getUniqueHours,
  ["minutely" /* MINUTELY */]: getUniqueMinutes,
  ["secondly" /* SECONDLY */]: getUniqueSeconds
};
function getEncodedFeatures({ DataSet: DataSet3, features = [] }) {
  if (DataSet3.encoders.size) {
    const featuresCopy = new Array().concat(features);
    const encodedFeatures = [];
    for (let encode2 of DataSet3.encoders.keys()) {
      if (features.includes(encode2)) {
        const existingIndex = featuresCopy.indexOf(encode2);
        featuresCopy.splice(existingIndex, 1);
        encodedFeatures.push(...DataSet3.encoders.get(encode2).labels.map((label) => `${DataSet3.encoders.get(encode2).prefix}${label}`));
      }
    }
    return Array.from(new Set(encodedFeatures.concat(featuresCopy)));
  }
  return features;
}
function getAutoFeatures({ variables, datum }) {
  return variables.map((variable) => {
    const autofeature = {
      feature_field_name: variable,
      feature_field_type: "auto-detect" /* AUTO */
    };
    if (typeof datum[variable] === "number")
      autofeature.feature_field_type = "number" /* NUMBER */;
    else if (typeof datum[variable] === "boolean")
      autofeature.feature_field_type = "boolean" /* BOOLEAN */;
    else if (typeof datum[variable] === "string")
      autofeature.feature_field_type = "text-encoded" /* TEXT */;
    return autofeature;
  });
}
function autoAssignFeatureColumns({ independent_variables, dependent_variables, datum, input_independent_features, output_dependent_features, training_feature_column_options = {}, preprocessing_feature_column_options = {} }) {
  const autoFeatureFilter = (autoFeature) => Object.keys(training_feature_column_options).includes(autoFeature.feature_field_name) === false;
  const input_auto_features = new Array().concat(
    independent_variables && independent_variables.length && datum ? getAutoFeatures({ variables: independent_variables, datum }) : [],
    input_independent_features || []
  );
  const output_auto_features = new Array().concat(
    dependent_variables && dependent_variables.length && datum ? getAutoFeatures({ variables: dependent_variables, datum }) : [],
    output_dependent_features || []
  );
  const model_auto_features = new Array().concat(input_auto_features, output_auto_features);
  model_auto_features.filter(autoFeatureFilter).forEach((auto_feature) => {
    if (auto_feature.feature_field_type === "text-encoded" /* TEXT */) {
      training_feature_column_options[auto_feature.feature_field_name] = ["onehot"];
    } else if (auto_feature.feature_field_type === "text-label" /* LABEL */) {
      training_feature_column_options[auto_feature.feature_field_name] = ["label"];
    } else if (auto_feature.feature_field_type === "boolean" /* BOOLEAN */) {
      training_feature_column_options[auto_feature.feature_field_name] = ["label", { binary: true }];
    } else if (["number" /* NUMBER */, "auto-detect" /* AUTO */].includes(auto_feature.feature_field_type)) {
      training_feature_column_options[auto_feature.feature_field_name] = ["scale", "standard"];
      preprocessing_feature_column_options[auto_feature.feature_field_name] = ["median"];
    }
  });
  return {
    x_raw_independent_features: input_auto_features.map((af) => af.feature_field_name),
    y_raw_dependent_labels: output_auto_features.map((af) => af.feature_field_name),
    training_feature_column_options,
    preprocessing_feature_column_options
  };
}

// src/model.ts
import * as Luxon from "luxon";
import flatten3 from "flat";
import { default as ConfusionMatrix } from "ml-confusion-matrix";

// src/tensorflow_singleton.ts
var tf = null;
function setBackend(tfInput) {
  tf = tfInput;
}
function getBackend() {
  if (tf === null) {
    throw Error(`
============================
Howdy \u{1F44B}\u{1F44B}. Looks like you are running @jsonstack/jsonm but you haven't set a Tensorflow backend. 
To do so, simply import (or require) your tensorflow library, and call setBackend like so,

import * as tf from '@tensorflow/tfjs';
import * as jsm from '@jsonstack/jsonm';
jsm.setBackend(tf);

That will let @jsonstack/jsonm know you wish to use a tensorflow library to perform your calculations.
============================
    `);
  }
  return tf;
}
function createModelFitCallback(callbackFunctions) {
  const tf3 = getBackend();
  if (Array.isArray(callbackFunctions)) {
    return callbackFunctions;
  } else if (callbackFunctions) {
    return Object.keys(callbackFunctions).map((callbackFunctionName) => {
      return new tf3.CustomCallback({ [callbackFunctionName]: callbackFunctions[callbackFunctionName] });
    });
  } else
    return [];
}

// src/scikitjs_singleton.ts
init_esm2();
var scikit = null;
scikit = esm_exports;
function setScikit(scikitInput) {
  scikit = scikitInput;
}
function getScikit() {
  if (scikit === null) {
    throw Error(`
============================
Howdy \u{1F44B}\u{1F44B}. Looks like you are running @jsonstack/model but you haven't set a ScikitJS backend. 
To do so, simply import (or require) your scikit library, and call setScikit like so,

import * as tf from '@tensorflow/tfjs';
import * as scikit from 'scikitjs';
import * as jsm from '@jsonstack/model';
jsm.setBackend(tf);
jsm.setScikit(scikit);

That will let @jsonstack/model know you wish to use a scikitjs library to perform your calculations.
============================
    `);
  }
  return scikit;
}

// src/model.ts
var ModelTypes = /* @__PURE__ */ ((ModelTypes3) => {
  ModelTypes3["FAST_FORECAST"] = "ai-fast-forecast";
  ModelTypes3["FORECAST"] = "ai-forecast";
  ModelTypes3["TIMESERIES_REGRESSION_FORECAST"] = "ai-timeseries-regression-forecast";
  ModelTypes3["LINEAR_REGRESSION"] = "ai-linear-regression";
  ModelTypes3["REGRESSION"] = "ai-regression";
  ModelTypes3["CLASSIFICATION"] = "ai-classification";
  ModelTypes3["LOGISTIC_CLASSIFICATION"] = "ai-logistic-classification";
  return ModelTypes3;
})(ModelTypes || {});
var ModelCategories = /* @__PURE__ */ ((ModelCategories2) => {
  ModelCategories2["PREDICTION"] = "regression";
  ModelCategories2["DECISION"] = "classification";
  ModelCategories2["FORECAST"] = "timeseries";
  ModelCategories2["RECOMMENDATION"] = "recommendation";
  ModelCategories2["REACTION"] = "reinforced";
  return ModelCategories2;
})(ModelCategories || {});
var modelMap = {
  "ai-fast-forecast": JSONStackModel.LSTMTimeSeries,
  "ai-forecast": JSONStackModel.LSTMMultivariateTimeSeries,
  "ai-timeseries-regression-forecast": JSONStackModel.MultipleLinearRegression,
  "ai-linear-regression": JSONStackModel.MultipleLinearRegression,
  "ai-regression": JSONStackModel.DeepLearningRegression,
  "ai-classification": JSONStackModel.DeepLearningClassification,
  "ai-logistic-classification": JSONStackModel.LogisticRegression
};
var modelCategoryMap = {
  ["ai-fast-forecast" /* FAST_FORECAST */]: "timeseries" /* FORECAST */,
  ["ai-forecast" /* FORECAST */]: "timeseries" /* FORECAST */,
  ["ai-timeseries-regression-forecast" /* TIMESERIES_REGRESSION_FORECAST */]: "timeseries" /* FORECAST */,
  ["ai-linear-regression" /* LINEAR_REGRESSION */]: "regression" /* PREDICTION */,
  ["ai-regression" /* REGRESSION */]: "regression" /* PREDICTION */,
  ["ai-classification" /* CLASSIFICATION */]: "classification" /* DECISION */,
  ["ai-logistic-classification" /* LOGISTIC_CLASSIFICATION */]: "classification" /* DECISION */
};
function getGeneratedStatefulFunction({ variable_name = "", function_body = "", props, function_name_prefix = "next_value_" }) {
  const func = Function("state", `'use strict';${function_body}`).bind({ props });
  Object.defineProperty(
    func,
    "name",
    {
      value: `${function_name_prefix}${variable_name}`
    }
  );
  return func;
}
function sumPreviousRows(options) {
  const { property, rows, offset = 1 } = options;
  const reverseTransform = Boolean(this.reverseTransform);
  const OFFSET = typeof this.offset === "number" ? this.offset : offset;
  const index2 = OFFSET;
  if (this.debug) {
    if (OFFSET < 1)
      throw new RangeError(`Offset must be larger than or equal to the default of 1 [property:${property}]`);
  }
  const begin = index2;
  const end = rows + index2;
  const sum2 = this.data.slice(begin, end).reduce((result, val) => {
    const value = reverseTransform ? this.DataSet.inverseTransformObject(val) : val;
    result = result + value[property];
    return result;
  }, 0);
  return sum2;
}
var _ModelX = class {
  config;
  status;
  trainingData;
  removedFilterdtrainingData;
  use_empty_objects;
  use_preprocessing_on_trainning_data;
  use_next_value_functions_for_training_data;
  use_mock_encoded_data;
  validate_training_data;
  x_independent_features;
  y_dependent_labels;
  x_raw_independent_features;
  y_raw_dependent_labels;
  original_data_test;
  original_data_train;
  testDataSet;
  trainDataSet;
  prediction_inputs;
  prediction_options;
  x_indep_matrix_train;
  x_indep_matrix_test;
  y_dep_matrix_train;
  y_dep_matrix_test;
  Model;
  training_options;
  cross_validation_options;
  training_size_values;
  training_model_loss;
  preprocessing_feature_column_options;
  training_feature_column_options;
  training_data_filter_function_body;
  training_data_filter_function;
  training_progress_callback;
  prediction_inputs_next_value_functions;
  prediction_inputs_next_value_function;
  prediction_timeseries_time_zone;
  prediction_timeseries_date_feature;
  prediction_timeseries_date_format;
  retrain_forecast_model_with_predictions;
  prediction_timeseries_dimension_feature;
  prediction_timeseries_start_date;
  prediction_timeseries_end_date;
  dimension;
  entity;
  DataSet;
  forecastDates;
  emptyObject;
  mockEncodedData;
  debug;
  tf;
  scikit;
  auto_assign_features;
  independent_variables;
  dependent_variables;
  input_independent_features;
  output_dependent_features;
  max_evaluation_outputs;
  getTimeseriesDimension;
  constructor(configuration, options = {}) {
    this.debug = typeof configuration.debug === "boolean" ? configuration.debug : true;
    this.config = {
      use_cache: typeof configuration.use_cache === "boolean" ? configuration.use_cache : true,
      model_type: configuration.model_type || "ai-regression" /* REGRESSION */,
      use_mock_dates_to_fit_trainning_data: configuration.use_mock_dates_to_fit_trainning_data
    };
    this.config.model_category = modelCategoryMap[this.config.model_type];
    this.status = {
      trained: false,
      lastTrained: void 0
    };
    this.entity = configuration.entity || {};
    this.emptyObject = configuration.emptyObject || {};
    this.mockEncodedData = configuration.mockEncodedData || [];
    this.use_empty_objects = Boolean(Object.keys(this.emptyObject).length);
    this.use_mock_encoded_data = Boolean(this.mockEncodedData.length);
    this.dimension = configuration.dimension;
    this.training_data_filter_function_body = configuration.training_data_filter_function_body;
    this.training_data_filter_function = configuration.training_data_filter_function;
    this.trainingData = configuration.trainingData || [];
    this.removedFilterdtrainingData = [];
    this.DataSet = configuration.DataSet || new JSONStackData.DataSet();
    this.max_evaluation_outputs = configuration.max_evaluation_outputs || 5;
    this.testDataSet = configuration.testDataSet || new JSONStackData.DataSet();
    this.trainDataSet = configuration.trainDataSet || new JSONStackData.DataSet();
    this.x_indep_matrix_train = configuration.x_indep_matrix_train || [];
    this.x_indep_matrix_test = configuration.x_indep_matrix_test || [];
    this.y_dep_matrix_train = configuration.y_dep_matrix_train || [];
    this.y_dep_matrix_test = configuration.y_dep_matrix_test || [];
    this.x_independent_features = configuration.x_independent_features || [];
    this.x_raw_independent_features = configuration.x_raw_independent_features || [];
    this.y_dependent_labels = configuration.y_dependent_labels || [];
    this.y_raw_dependent_labels = configuration.y_raw_dependent_labels || [];
    this.auto_assign_features = typeof configuration.auto_assign_features === "boolean" ? configuration.auto_assign_features : true;
    this.independent_variables = configuration.independent_variables;
    this.dependent_variables = configuration.dependent_variables;
    this.input_independent_features = configuration.input_independent_features;
    this.output_dependent_features = configuration.output_dependent_features;
    this.use_next_value_functions_for_training_data = configuration.use_next_value_functions_for_training_data;
    this.training_size_values = configuration.training_size_values;
    this.cross_validation_options = {
      train_size: 0.7,
      ...configuration.cross_validation_options
    };
    this.preprocessing_feature_column_options = configuration.preprocessing_feature_column_options || {};
    this.training_feature_column_options = configuration.training_feature_column_options || {};
    const customFit = configuration.training_options && configuration.training_options.fit ? configuration.training_options.fit : {};
    this.training_options = {
      stateful: true,
      features: this.x_independent_features.length,
      ...configuration.training_options,
      fit: {
        epochs: 100,
        batchSize: 5,
        verbose: 0,
        callbacks: {},
        ...customFit
      }
    };
    this.training_progress_callback = configuration.training_progress_callback || training_on_progress;
    if (this.training_options && this.training_options.fit && this.training_options.fit.callbacks && this.training_options.fit.epochs) {
      this.training_options.fit.callbacks.onEpochEnd = (epoch, logs) => {
        const totalEpochs = this.training_options.fit ? this.training_options.fit.epochs : 0;
        const completion_percentage = epoch / totalEpochs || 0;
        this.training_model_loss = logs.loss;
        this.training_progress_callback({ completion_percentage, loss: logs.loss, epoch, logs, status: "training", defaultLog: this.debug });
      };
      this.training_options.fit.callbacks.onTrainEnd = (logs) => {
        const totalEpochs = this.training_options.fit ? this.training_options.fit.epochs : 0;
        const completion_percentage = 1;
        this.training_progress_callback({ completion_percentage, loss: this.training_model_loss || 0, epoch: totalEpochs, logs, status: "trained", defaultLog: this.debug });
      };
      this.training_options.fit.callbacks.onTrainBegin = (logs) => {
        const totalEpochs = this.training_options.fit ? this.training_options.fit.epochs : 0;
        const completion_percentage = 0;
        this.training_progress_callback({ completion_percentage, loss: logs.loss, epoch: totalEpochs, logs, status: "initializing", defaultLog: this.debug });
      };
    }
    this.prediction_options = configuration.prediction_options || {};
    this.prediction_inputs = configuration.prediction_inputs || [];
    this.prediction_timeseries_time_zone = configuration.prediction_timeseries_time_zone || "utc";
    this.prediction_timeseries_date_feature = configuration.prediction_timeseries_date_feature || "date";
    this.prediction_timeseries_date_format = configuration.prediction_timeseries_date_format;
    this.validate_training_data = typeof configuration.validate_training_data === "boolean" ? configuration.validate_training_data : true;
    this.retrain_forecast_model_with_predictions = configuration.retrain_forecast_model_with_predictions;
    this.use_preprocessing_on_trainning_data = typeof configuration.use_preprocessing_on_trainning_data !== "undefined" ? configuration.use_preprocessing_on_trainning_data : true;
    this.prediction_timeseries_start_date = configuration.prediction_timeseries_start_date;
    this.prediction_timeseries_end_date = configuration.prediction_timeseries_end_date;
    this.prediction_timeseries_dimension_feature = configuration.prediction_timeseries_dimension_feature || "dimension";
    this.prediction_inputs_next_value_functions = configuration.prediction_inputs_next_value_functions || configuration.next_value_functions || [];
    this.tf = getBackend();
    this.scikit = getScikit();
    this.scikit.setBackend(this.tf);
    JSONStackModel.setBackend(this.tf);
    JSONStackModel.setScikit(this.scikit);
    this.Model = configuration.Model || new JSONStackModel.TensorScriptModelInterface();
    this.original_data_test = [];
    this.original_data_train = [];
    this.forecastDates = [];
    this.getTimeseriesDimension = _ModelX.calcTimeseriesDimension.bind(this);
    return this;
  }
  static calcTimeseriesDimension(options = {}) {
    let timeseriesDataSetDateFormat = options.timeseries_date_format || this.prediction_timeseries_date_format;
    let timeseriesForecastDimension = options.dimension || this.dimension;
    let timeseriesDateFeature = options.timeseries_date_feature || this.prediction_timeseries_date_feature;
    let DataSetData = options.DataSetData || this.DataSet && this.DataSet.data || [];
    if (timeseriesForecastDimension && timeseriesDataSetDateFormat) {
      this.dimension = timeseriesForecastDimension;
      return {
        dimension: timeseriesForecastDimension,
        dateFormat: timeseriesDataSetDateFormat
      };
    }
    if (typeof timeseriesForecastDimension !== "string" && DataSetData && Array.isArray(DataSetData) && DataSetData.length) {
      if (DataSetData.length && DataSetData[0][this.prediction_timeseries_dimension_feature]) {
        timeseriesForecastDimension = DataSetData[0][this.prediction_timeseries_dimension_feature];
      }
      if (DataSetData.length > 1 && DataSetData[0][timeseriesDateFeature]) {
        const recentDateField = DataSetData[1][timeseriesDateFeature];
        const parsedRecentDateField = getLuxonDateTime({
          dateObject: recentDateField,
          dateFormat: timeseriesDataSetDateFormat
        });
        timeseriesDataSetDateFormat = parsedRecentDateField.format;
        const test_end_date = parsedRecentDateField.date;
        const test_start_date = getLuxonDateTime({
          dateObject: DataSetData[0][timeseriesDateFeature],
          dateFormat: timeseriesDataSetDateFormat
        }).date;
        const durationDifference = test_end_date.diff(test_start_date, dimensionDurations).toObject();
        const durationDimensions = Object.keys(durationDifference).filter((diffProp) => durationDifference[diffProp] === 1);
        if (durationDimensions.length === 1) {
          timeseriesForecastDimension = durationToDimensionProperty[durationDimensions[0]];
        }
      }
    }
    if (typeof timeseriesForecastDimension !== "string" || Object.keys(dimensionDates).indexOf(timeseriesForecastDimension) === -1)
      throw new ReferenceError(`Invalid timeseries dimension (${timeseriesForecastDimension})`);
    this.prediction_timeseries_date_format = timeseriesDataSetDateFormat;
    this.dimension = timeseriesForecastDimension;
    if (typeof timeseriesDataSetDateFormat === "undefined")
      throw new ReferenceError("Invalid timeseries date format");
    return {
      dimension: timeseriesForecastDimension,
      dateFormat: timeseriesDataSetDateFormat
    };
  }
  getForecastDates(options = {}) {
    const start = this.prediction_timeseries_start_date && this.prediction_timeseries_start_date instanceof Date ? Luxon.DateTime.fromJSDate(this.prediction_timeseries_start_date).toISO(ISOOptions) : this.prediction_timeseries_start_date;
    const end = this.prediction_timeseries_end_date instanceof Date ? Luxon.DateTime.fromJSDate(this.prediction_timeseries_end_date).toISO(ISOOptions) : this.prediction_timeseries_end_date;
    if (!this.dimension)
      throw ReferenceError("Forecasts require a timeseries dimension");
    else if (!start || !end)
      throw ReferenceError("Start and End Forecast Dates are required");
    this.forecastDates = dimensionDates[this.dimension]({
      start,
      end,
      time_zone: this.prediction_timeseries_time_zone
    });
    return this.forecastDates;
  }
  addMockData({ use_mock_dates = false } = {}) {
    if (use_mock_dates && this.use_mock_encoded_data && this.DataSet)
      this.DataSet = addMockDataToDataSet(this.DataSet, { includeConstants: true, mockEncodedData: this.mockEncodedData });
    else if (use_mock_dates && this.DataSet)
      this.DataSet = addMockDataToDataSet(this.DataSet, {});
    else if (this.use_mock_encoded_data && this.DataSet)
      this.DataSet = addMockDataToDataSet(this.DataSet, { includeConstants: false, mockEncodedData: this.mockEncodedData });
  }
  removeMockData({ use_mock_dates = false } = {}) {
    if (use_mock_dates && this.use_mock_encoded_data && this.DataSet)
      this.DataSet = removeMockDataFromDataSet(this.DataSet, { includeConstants: true, mockEncodedData: this.mockEncodedData });
    else if (use_mock_dates && this.DataSet)
      this.DataSet = removeMockDataFromDataSet(this.DataSet, {});
    else if (this.use_mock_encoded_data && this.DataSet)
      this.DataSet = removeMockDataFromDataSet(this.DataSet, { includeConstants: false, mockEncodedData: this.mockEncodedData });
  }
  getCrosstrainingData() {
    let test;
    let train3;
    if (this.config.model_category === "timeseries") {
      const trainSizePercentage = this.cross_validation_options.train_size || 0.7;
      const train_size = this.training_size_values ? this.DataSet.data.length - this.training_size_values : parseInt((this.DataSet.data.length * trainSizePercentage).toString());
      test = this.DataSet.data.slice(train_size, this.DataSet.data.length);
      train3 = this.DataSet.data.slice(0, train_size);
    } else {
      const testTrainSplit = JSONStackData.cross_validation.train_test_split(this.DataSet.data, this.cross_validation_options);
      train3 = testTrainSplit.train;
      test = testTrainSplit.test;
    }
    return { test, train: train3 };
  }
  validateTrainingData({ cross_validate_training_data, inputMatrix } = {
    inputMatrix: void 0
  }) {
    const checkValidationData = inputMatrix ? inputMatrix : this.x_indep_matrix_train;
    const dataType = inputMatrix ? "Prediction" : "Trainning";
    checkValidationData.forEach((trainningData, i2) => {
      trainningData.forEach((trainningVal, v) => {
        if (typeof trainningVal !== "number" || isNaN(trainningVal)) {
          throw new TypeError(`${dataType} data (${i2}) has an invalid ${this.x_independent_features[v]}. Value: ${trainningVal}`);
        }
      });
    });
    return true;
  }
  async getTrainingData(options = {}) {
    if (options.trainingData) {
      this.trainingData = options.trainingData;
    } else if (typeof options.getDataPromise === "function") {
      this.trainingData = await options.getDataPromise({});
    }
  }
  async checkTrainingStatus(options = {}) {
    if (options.retrain || this.status.trained === false) {
      await this.getTrainingData(options);
      await this.trainModel(options);
    }
    return true;
  }
  async getDataSetProperties(options = {}) {
    const {
      nextValueIncludeForecastDate = true,
      nextValueIncludeForecastTimezone = true,
      nextValueIncludeForecastAssociations = true,
      nextValueIncludeDateProperty = true,
      nextValueIncludeParsedDate = true,
      nextValueIncludeLocalParsedDate = true,
      nextValueIncludeForecastInputs = true
    } = options;
    const props = { Luxon, JSONStackData };
    const nextValueFunctions = this.prediction_inputs_next_value_functions.reduce((functionsObject, func) => {
      functionsObject[func.variable_name] = getGeneratedStatefulFunction({
        ...func,
        props,
        function_name_prefix: "next_value_"
      });
      return functionsObject;
    }, {});
    const filterFunctionBody = `'use strict';
    ${this.training_data_filter_function_body}
    `;
    this.training_data_filter_function = this.training_data_filter_function_body ? Function("datum", "datumIndex", filterFunctionBody).bind({ props }) : this.training_data_filter_function;
    if (typeof this.training_data_filter_function === "function" && this.training_data_filter_function.name && this.training_data_filter_function.name.includes("anonymous"))
      Object.defineProperty(this.training_data_filter_function, "name", { value: "training_data_filter_function" });
    this.prediction_inputs_next_value_function = function nextValueFunction(state) {
      const lastDataRow = state.lastDataRow || {};
      const zone = lastDataRow.origin_time_zone || this.prediction_timeseries_time_zone;
      const date = state.forecastDate;
      state.sumPreviousRows = sumPreviousRows.bind({
        data: state.data,
        DataSet: state.DataSet,
        offset: state.existingDatasetObjectIndex,
        reverseTransform: state.reverseTransform
      });
      const helperNextValueData = {};
      if (nextValueIncludeForecastDate) {
        helperNextValueData[this.prediction_timeseries_date_feature] = state.forecastDate;
      }
      if (nextValueIncludeDateProperty) {
        helperNextValueData.date = state.forecastDate;
      }
      if (nextValueIncludeForecastTimezone) {
        helperNextValueData.origin_time_zone = lastDataRow.origin_time_zone;
      }
      if (nextValueIncludeForecastAssociations) {
        helperNextValueData.associated_data_location = lastDataRow.associated_data_location ? lastDataRow.associated_data_location.toString() : lastDataRow.associated_data_location;
        helperNextValueData.associated_data_product = lastDataRow.associated_data_product ? lastDataRow.associated_data_product.toString() : lastDataRow.associated_data_product;
        helperNextValueData.associated_data_entity = lastDataRow.associated_data_entity ? lastDataRow.associated_data_entity.toString() : lastDataRow.associated_data_entity;
        helperNextValueData.forecast_entity_type = lastDataRow.feature_entity_type ? lastDataRow.feature_entity_type.toString() : lastDataRow.forecast_entity_type;
        helperNextValueData.forecast_entity_title = lastDataRow.feature_entity_title ? lastDataRow.feature_entity_title.toString() : lastDataRow.forecast_entity_title;
        helperNextValueData.forecast_entity_name = lastDataRow.feature_entity_name ? lastDataRow.feature_entity_name.toString() : lastDataRow.forecast_entity_name;
        helperNextValueData.forecast_entity_id = lastDataRow.feature_entity_id ? lastDataRow.feature_entity_id.toString() : lastDataRow.forecast_entity_id;
      }
      if (nextValueIncludeParsedDate && state.forecastDate) {
        const parsedDate = getParsedDate(state.forecastDate, { zone });
        const isOpen = getOpenHour.bind({ entity: this.entity, dimension: this.dimension }, { date, parsedDate, zone });
        const isOutlier = getIsOutlier.bind({ entity: this.entity, data: state.data, datum: helperNextValueData });
        state.parsedDate = parsedDate;
        state.isOpen = isOpen;
        state.isOutlier = isOutlier;
        Object.assign(helperNextValueData, parsedDate);
      }
      if (nextValueIncludeLocalParsedDate) {
        Object.assign(helperNextValueData, getLocalParsedDate({ date: state.forecastDate, time_zone: zone, dimension: this.dimension }));
      }
      if (nextValueIncludeForecastInputs) {
        Object.assign(helperNextValueData, state.rawInputPredictionObject);
      }
      return Object.keys(nextValueFunctions).reduce((nextValueObject, functionName) => {
        nextValueObject[functionName] = nextValueFunctions[functionName](state);
        return nextValueObject;
      }, helperNextValueData);
    };
    if (this.config.model_category === "timeseries" /* FORECAST */) {
      this.dimension = this.getTimeseriesDimension(options).dimension;
    }
    if (this.dimension && this.config.model_category === "timeseries" /* FORECAST */ && this.prediction_inputs && this.prediction_inputs.length && (!this.prediction_timeseries_start_date || !this.prediction_timeseries_end_date)) {
      if (!this.prediction_timeseries_start_date)
        this.prediction_timeseries_start_date = this.prediction_inputs[0][this.prediction_timeseries_date_feature];
      if (!this.prediction_timeseries_end_date)
        this.prediction_timeseries_end_date = this.prediction_inputs[this.prediction_inputs.length - 1][this.prediction_timeseries_date_feature];
    }
    if (this.dimension && this.config.model_category === "timeseries" /* FORECAST */ && this.prediction_timeseries_start_date && this.prediction_timeseries_end_date) {
      this.getForecastDates();
    }
  }
  getForecastDatesFromPredictionInputs(options = {}) {
    const raw_prediction_inputs = options.prediction_inputs.map((predictionInput) => {
      const inputDate = predictionInput[this.prediction_timeseries_date_feature];
      const predictionDate = inputDate && inputDate instanceof Date ? inputDate : this.prediction_timeseries_date_format ? Luxon.DateTime.fromFormat(inputDate, this.prediction_timeseries_date_format).toJSDate() : inputDate;
      return {
        ...predictionInput,
        [this.prediction_timeseries_date_feature]: predictionDate
      };
    });
    const forecastDates = raw_prediction_inputs.map((rawInput) => rawInput[this.prediction_timeseries_date_feature]);
    return {
      forecastDates,
      raw_prediction_inputs
    };
  }
  async validateTimeseriesData(options = {}) {
    const { fixPredictionDates = true } = options;
    const dimension = this.dimension;
    let raw_prediction_inputs = options.prediction_inputs || await this.getPredictionData(options) || [];
    const lastOriginalDataSetIndex = this.DataSet.data.length - 1;
    const lastOriginalDataSetObject = this.DataSet.data[lastOriginalDataSetIndex];
    let forecastDates = this.forecastDates;
    if (options.set_forecast_dates_for_predictions && this.forecastDates.length < 1) {
      const transformedInputs = this.getForecastDatesFromPredictionInputs(options);
      forecastDates = transformedInputs.forecastDates;
      raw_prediction_inputs = transformedInputs.raw_prediction_inputs;
    }
    const datasetDateOptions = getLuxonDateTime({
      dateObject: lastOriginalDataSetObject[this.prediction_timeseries_date_feature],
      dateFormat: this.prediction_timeseries_date_format,
      time_zone: this.prediction_timeseries_time_zone
    });
    const lastOriginalForecastDateTimeLuxon = datasetDateOptions.date;
    const lastOriginalForecastDateTimeFormat = datasetDateOptions.format;
    const lastOriginalForecastDate = lastOriginalForecastDateTimeLuxon.toJSDate();
    const datasetDates = lastOriginalDataSetObject[this.prediction_timeseries_date_feature] instanceof Date ? this.DataSet.columnArray(this.prediction_timeseries_date_feature) : this.DataSet.columnArray(this.prediction_timeseries_date_feature).map((originalDateFormattedDate) => getLuxonDateTime({
      dateObject: originalDateFormattedDate,
      dateFormat: lastOriginalForecastDateTimeFormat,
      time_zone: this.prediction_timeseries_time_zone
    }).date.toJSDate());
    const firstDatasetDate = datasetDates[0];
    if (fixPredictionDates && typeof this.prediction_timeseries_start_date === "string")
      this.prediction_timeseries_start_date = Luxon.DateTime.fromISO(this.prediction_timeseries_start_date).toJSDate();
    if (fixPredictionDates && this.prediction_timeseries_start_date && this.prediction_timeseries_start_date < firstDatasetDate) {
      this.prediction_timeseries_start_date = firstDatasetDate;
      forecastDates = this.getForecastDates();
      console.log("modified", { forecastDates });
    }
    let forecastDateFirstDataSetDateIndex;
    if (forecastDates.length) {
      forecastDateFirstDataSetDateIndex = datasetDates.findIndex((DataSetDate) => DataSetDate.valueOf() === forecastDates[0].valueOf());
      if (forecastDateFirstDataSetDateIndex === -1) {
        const lastDataSetDate = datasetDates[datasetDates.length - 1];
        const firstForecastInputDate = forecastDates[0];
        const firstForecastDateFromInput = Luxon.DateTime.fromJSDate(lastDataSetDate, { zone: this.prediction_timeseries_time_zone }).plus({
          [timeProperty[dimension]]: 1
        });
        if (firstForecastDateFromInput.valueOf() === firstForecastInputDate.valueOf()) {
          forecastDateFirstDataSetDateIndex = datasetDates.length;
        }
      }
      if (forecastDateFirstDataSetDateIndex === -1)
        throw new RangeError(`Forecast Date Range (${this.prediction_timeseries_start_date} - ${this.prediction_timeseries_end_date}) must include an existing forecast date (${this.DataSet.data[0][this.prediction_timeseries_date_feature]} - ${this.DataSet.data[lastOriginalDataSetIndex][this.prediction_timeseries_date_feature]})`);
      if (raw_prediction_inputs.length) {
        if (raw_prediction_inputs[0][this.prediction_timeseries_date_feature] instanceof Date === false) {
          raw_prediction_inputs = raw_prediction_inputs.map((raw_input) => {
            return Object.assign({}, raw_input, {
              [this.prediction_timeseries_date_feature]: getLuxonDateTime({
                dateObject: raw_input[this.prediction_timeseries_date_feature],
                dateFormat: lastOriginalForecastDateTimeFormat,
                time_zone: this.prediction_timeseries_time_zone
              }).date.toJSDate()
            });
          });
        }
        const firstRawInputDate = raw_prediction_inputs[0][this.prediction_timeseries_date_feature];
        const firstForecastDate = forecastDates[0];
        let raw_prediction_input_dates = raw_prediction_inputs.map((raw_input) => raw_input[this.prediction_timeseries_date_feature]);
        if (fixPredictionDates && firstForecastDate > firstRawInputDate) {
          const matchingInputIndex = raw_prediction_input_dates.findIndex((inputPredictionDate) => inputPredictionDate.valueOf() === firstForecastDate.valueOf());
          raw_prediction_inputs = raw_prediction_inputs.slice(matchingInputIndex);
          raw_prediction_input_dates = raw_prediction_inputs.map((raw_input) => raw_input[this.prediction_timeseries_date_feature]);
        }
        const rawPredictionForecastDateIndex = forecastDates.findIndex((forecastDate) => forecastDate.valueOf() === raw_prediction_input_dates[0].valueOf());
        if (rawPredictionForecastDateIndex < 0)
          throw new RangeError(`Prediction Input First Date(${raw_prediction_input_dates[0]}) must be inclusive of forecastDates ( ${forecastDates[0]} - ${forecastDates[forecastDates.length - 1]})`);
      }
    }
    return { forecastDates, forecastDateFirstDataSetDateIndex, lastOriginalForecastDate, raw_prediction_inputs, dimension, datasetDates };
  }
  async getPredictionData(options = {}) {
    if (typeof options.getPredictionInputPromise === "function") {
      this.prediction_inputs = await options.getPredictionInputPromise({ ModelX: this });
    }
    return this.prediction_inputs;
  }
  async trainModel(options = {}) {
    const { cross_validate_training_data = true, use_next_value_functions_for_training_data = false, use_mock_dates_to_fit_trainning_data = false } = options;
    const modelObject = modelMap[this.config.model_type];
    const use_mock_dates = use_mock_dates_to_fit_trainning_data || this.config.use_mock_dates_to_fit_trainning_data;
    let trainingData = options.trainingData || this.trainingData || [];
    trainingData = new Array().concat(trainingData);
    let test;
    let train3;
    this.status.trained = false;
    await this.getDataSetProperties({
      DataSetData: trainingData
    });
    if (typeof this.training_data_filter_function === "function" && use_next_value_functions_for_training_data === false) {
      trainingData = trainingData.filter(this.training_data_filter_function);
    }
    if (!use_next_value_functions_for_training_data && this.use_empty_objects) {
      trainingData = trainingData.map((trainningDatum) => ({
        ...this.emptyObject,
        ...trainningDatum
      }));
    }
    this.DataSet = new JSONStackData.DataSet(trainingData);
    if (this.auto_assign_features && (!this.x_independent_features || !this.x_independent_features.length) && !this.y_dependent_labels || !this.y_dependent_labels.length) {
      const autoFeatures = autoAssignFeatureColumns({
        input_independent_features: this.input_independent_features,
        output_dependent_features: this.output_dependent_features,
        independent_variables: this.independent_variables,
        dependent_variables: this.dependent_variables,
        training_feature_column_options: this.training_feature_column_options,
        preprocessing_feature_column_options: this.preprocessing_feature_column_options,
        datum: trainingData[0]
      });
      this.x_raw_independent_features = Array.from(new Set(new Array().concat(this.x_raw_independent_features, autoFeatures.x_raw_independent_features)));
      this.y_raw_dependent_labels = Array.from(new Set(new Array().concat(this.y_raw_dependent_labels, autoFeatures.y_raw_dependent_labels)));
      this.preprocessing_feature_column_options = {
        ...autoFeatures.preprocessing_feature_column_options,
        ...this.preprocessing_feature_column_options
      };
      this.training_feature_column_options = {
        ...autoFeatures.training_feature_column_options,
        ...this.training_feature_column_options
      };
    }
    if (this.use_preprocessing_on_trainning_data && this.preprocessing_feature_column_options && Object.keys(this.preprocessing_feature_column_options).length) {
      this.DataSet.fitColumns(this.preprocessing_feature_column_options);
    }
    if (use_next_value_functions_for_training_data || this.use_next_value_functions_for_training_data) {
      const trainingDates = trainingData.map((tdata) => tdata[this.prediction_timeseries_date_feature]);
      trainingData = trainingData.map((trainingDatum, dataIndex) => {
        if (this.prediction_timeseries_date_format)
          trainingDatum[this.prediction_timeseries_date_feature] = Luxon.DateTime.fromFormat(trainingDatum[this.prediction_timeseries_date_feature], this.prediction_timeseries_date_format).toJSDate();
        const forecastDate = trainingDatum[this.prediction_timeseries_date_feature];
        const forecastPredictionIndex = dataIndex;
        if (trainingDatum._id)
          trainingDatum._id = trainingDatum._id.toString();
        if (trainingDatum.feature_entity_id)
          trainingDatum.feature_entity_id = trainingDatum.feature_entity_id.toString();
        const trainningNextValueData = this.prediction_inputs_next_value_function ? this.prediction_inputs_next_value_function({
          rawInputPredictionObject: trainingDatum,
          forecastDate,
          forecastDates: trainingDates,
          forecastPredictionIndex,
          existingDatasetObjectIndex: dataIndex,
          unscaledLastForecastedValue: trainingData[dataIndex - 1],
          data: trainingData,
          DataSet: this.DataSet || new JSONStackData.DataSet(),
          lastDataRow: trainingData[trainingData.length - 1],
          reverseTransform: false
        }) : {};
        const calculatedDatum = this.use_empty_objects ? Object.assign(
          {},
          this.emptyObject,
          flatten3(trainingDatum, { maxDepth: 2, delimiter: flattenDelimiter }),
          flatten3(trainningNextValueData, { maxDepth: 2, delimiter: flattenDelimiter })
        ) : Object.assign({}, trainingDatum, trainningNextValueData);
        return calculatedDatum;
      });
      if (typeof this.training_data_filter_function === "function" && use_next_value_functions_for_training_data === true) {
        trainingData = trainingData.filter((datum, datumIndex) => {
          if (this.training_data_filter_function) {
            const removeValue = this.training_data_filter_function(datum, datumIndex);
            if (!removeValue)
              this.removedFilterdtrainingData.push(datum);
            return removeValue;
          }
        });
      }
      this.DataSet = new JSONStackData.DataSet(trainingData);
    }
    ["is_location_open", "is_open_hour", "is_location_open"].forEach((feat_col_option) => {
      if (this.training_feature_column_options[feat_col_option]) {
        this.training_feature_column_options[feat_col_option] = ["label", { binary: true }];
      }
    });
    this.addMockData({ use_mock_dates });
    this.DataSet.fitColumns(this.training_feature_column_options);
    this.removeMockData({ use_mock_dates });
    if (this.auto_assign_features && (!this.x_independent_features || !this.x_independent_features.length) && (!this.y_dependent_labels || !this.y_dependent_labels.length)) {
      this.x_independent_features = new Array().concat(this.x_independent_features, getEncodedFeatures({ DataSet: this.DataSet, features: this.x_raw_independent_features }));
      this.y_dependent_labels = new Array().concat(this.y_dependent_labels, getEncodedFeatures({ DataSet: this.DataSet, features: this.y_raw_dependent_labels }));
    }
    if (!this.x_independent_features || !this.x_independent_features.length)
      throw new ReferenceError("Missing Inputs (x_independent_features)");
    if (!this.y_dependent_labels || !this.y_dependent_labels.length)
      throw new ReferenceError("Missing Outputs (y_dependent_labels)");
    this.x_independent_features = Array.from(new Set(this.x_independent_features));
    this.y_dependent_labels = Array.from(new Set(this.y_dependent_labels));
    if (cross_validate_training_data) {
      let crosstrainingData = this.getCrosstrainingData();
      test = crosstrainingData.test;
      train3 = crosstrainingData.train;
      this.original_data_test = crosstrainingData.test;
      this.original_data_train = crosstrainingData.train;
      this.testDataSet = new JSONStackData.DataSet(test);
      this.trainDataSet = new JSONStackData.DataSet(train3);
      this.x_indep_matrix_train = this.trainDataSet.columnMatrix(this.x_independent_features);
      this.x_indep_matrix_test = this.testDataSet.columnMatrix(this.x_independent_features);
      this.y_dep_matrix_train = this.trainDataSet.columnMatrix(this.y_dependent_labels);
      this.y_dep_matrix_test = this.testDataSet.columnMatrix(this.y_dependent_labels);
    } else {
      this.x_indep_matrix_train = this.DataSet.columnMatrix(this.x_independent_features);
      this.y_dep_matrix_train = this.DataSet.columnMatrix(this.y_dependent_labels);
    }
    this.Model = new modelObject(this.training_options, {});
    if (this.config.model_category === "timeseries") {
      const validationData = await this.validateTimeseriesData(options);
    }
    if (this.validate_training_data) {
      this.validateTrainingData({ cross_validate_training_data });
    }
    if (this.config.model_category === "timeseries" && this.config.model_type === "ai-fast-forecast") {
      await this.Model.train(this.x_indep_matrix_train, this.y_dep_matrix_train, void 0, void 0, void 0);
    } else {
      await this.Model.train(this.x_indep_matrix_train, this.y_dep_matrix_train, void 0, void 0, void 0);
    }
    this.status.trained = true;
    this.status.lastTrained = new Date();
    return this;
  }
  async predictModel(options = {}) {
    if (Array.isArray(options)) {
      const PredictionOptions = {
        prediction_inputs: options
      };
      options = PredictionOptions;
    }
    const { descalePredictions = true, includeInputs = true, includeEvaluation = false } = options;
    const predictionOptions = {
      probability: this.config.model_category === "classification" /* DECISION */ ? false : true,
      ...this.prediction_options,
      ...options.predictionOptions
    };
    let predictions;
    let newTransformedPredictions;
    let unscaledInputs;
    let __evaluation;
    let [trainingstatus, raw_prediction_inputs] = await Promise.all([
      this.checkTrainingStatus(options),
      options.prediction_inputs || await this.getPredictionData(options)
    ]);
    if (includeEvaluation) {
      let { test, train: train3 } = this.getCrosstrainingData();
      const testDataSet = new JSONStackDataTypes.DataSet(test);
      const x_indep_matrix_test = testDataSet.columnMatrix(this.x_independent_features);
      const y_dep_matrix_test = testDataSet.columnMatrix(this.y_dependent_labels);
      const evaluationOptions = Object.assign({}, options, {
        x_indep_matrix_test,
        y_dep_matrix_test
      });
      const primaryLabel = this.y_dependent_labels[0];
      const evaluation = await this.evaluateModel(evaluationOptions);
      __evaluation = Object.keys(evaluation).reduce((result, evaluationDependentLabel) => {
        const evalItem = removeEvaluationData(evaluation[evaluationDependentLabel]);
        if (evaluationDependentLabel === primaryLabel) {
          result = Object.assign({}, result, evalItem);
          if (this.y_dependent_labels.length > 1)
            result.data[evaluationDependentLabel] = evalItem;
        } else {
          result.data[evaluationDependentLabel] = evalItem;
        }
        return result;
      }, { data: {} });
    }
    if (this.config.model_category === "timeseries") {
      predictions = await this.timeseriesForecast(options);
    } else {
      unscaledInputs = raw_prediction_inputs;
      this.prediction_inputs = raw_prediction_inputs.map((prediction_value) => {
        const pred_val = this.use_empty_objects ? Object.assign(
          {},
          this.emptyObject,
          flatten3(prediction_value, { maxDepth: 2, delimiter: flattenDelimiter })
        ) : prediction_value;
        return this.DataSet.transformObject(pred_val, { checkColumnLength: false });
      });
      const inputMatrix = this.DataSet.columnMatrix(this.x_independent_features, this.prediction_inputs);
      if (this.validate_training_data) {
        this.validateTrainingData({ cross_validate_training_data: false, inputMatrix });
      }
      newTransformedPredictions = await this.Model.predict(inputMatrix, predictionOptions);
      predictions = this.DataSet.reverseColumnMatrix({ vectors: newTransformedPredictions, labels: this.y_dependent_labels });
    }
    if (descalePredictions) {
      const emptyPrediction = this.y_dependent_labels.reduce((result, label) => {
        result[label] = 0;
        return result;
      }, {});
      const dimension = this.dimension;
      predictions = predictions.map((val, i2) => {
        const transformed = this.DataSet.inverseTransformObject(val, {});
        const is_location_open = transformed.is_location_open;
        let empty = {};
        if ((dimension === "hourly" || dimension === "daily") && this.entity && !is_location_open) {
          if (this.debug)
            console.info(`Manually fixing prediction on closed - ${dimension} ${transformed.date}`);
          empty = Object.assign({}, emptyPrediction);
        }
        const descaled = Object.assign(
          {},
          empty,
          transformed,
          includeInputs && this.config.model_category !== "timeseries" ? unscaledInputs[i2] : {},
          includeEvaluation ? { __evaluation } : {}
        );
        return descaled;
      });
    } else if (includeInputs && this.config.model_category !== "timeseries") {
      predictions = predictions.map((val, i2) => Object.assign(
        {},
        this.DataSet.inverseTransformObject(val, {}),
        includeInputs ? this.prediction_inputs[i2] : {},
        includeEvaluation ? { __evaluation } : {}
      ));
    }
    if (this.use_empty_objects) {
      predictions = predictions.map((pred) => flatten3.unflatten(pred, { delimiter: flattenDelimiter }));
    }
    return predictions;
  }
  async retrainTimeseriesModel(options = {}) {
    const { inputMatrix, predictionMatrix, fitOptions } = options;
    const fit = {
      ...this.Model.settings.fit,
      ...fitOptions
    };
    const x_timeseries = inputMatrix;
    const y_timeseries = predictionMatrix;
    const x_matrix = x_timeseries;
    const y_matrix = y_timeseries;
    let yShape;
    this.Model;
    const timeseriesShape = typeof this.Model.getTimeseriesShape === "function" ? this.Model.getTimeseriesShape(x_matrix) : void 0;
    const x_matrix_timeseries = typeof timeseriesShape !== "undefined" ? this.Model.reshape(x_matrix, timeseriesShape) : x_matrix;
    const xs = this.Model.tf.tensor(x_matrix_timeseries, timeseriesShape);
    const ys = this.Model.tf.tensor(y_matrix, yShape);
    await this.Model.model.fit(xs, ys, fit);
    xs.dispose();
    ys.dispose();
    return this;
  }
  async timeseriesForecast(options = {}) {
    const retrain_forecast_model_with_predictions = this.retrain_forecast_model_with_predictions;
    const predictionOptions = Object.assign({
      probability: this.config.model_category === "classification" ? false : true
    }, this.prediction_options, options.predictionOptions);
    options.set_forecast_dates_for_predictions = true;
    const { forecastDates, forecastDateFirstDataSetDateIndex, lastOriginalForecastDate, raw_prediction_inputs, dimension, datasetDates } = await this.validateTimeseriesData(options);
    const forecasts = [];
    let forecastPredictionIndex = 0;
    const lastDatasetDate = datasetDates[datasetDates.length - 1];
    await Promisie.each(forecastDates, 1, async (forecastDate) => {
      const existingDatasetObjectIndex = forecastDateFirstDataSetDateIndex + forecastPredictionIndex;
      const rawInputPredictionObject = raw_prediction_inputs[forecastPredictionIndex];
      let predictionMatrix;
      let predictionInput;
      let datasetScaledObject;
      let datasetUnscaledObject;
      let unscaledRawInputObject;
      let scaledRawInputObject;
      if (forecastDate <= lastOriginalForecastDate) {
        datasetScaledObject = this.DataSet.data[existingDatasetObjectIndex];
        datasetUnscaledObject = this.DataSet.inverseTransformObject(datasetScaledObject, {});
        predictionInput = [
          datasetScaledObject
        ];
      }
      const lastForecastedValue = forecasts.length ? forecasts[forecasts.length - 1] : {};
      let unscaledLastForecastedValue = Object.keys(lastForecastedValue).length ? this.DataSet.inverseTransformObject(lastForecastedValue, {}) : {};
      unscaledLastForecastedValue = this.y_dependent_labels.reduce((result, feature) => {
        if (typeof unscaledLastForecastedValue[feature] !== "undefined") {
          result[feature] = unscaledLastForecastedValue[feature];
        }
        return result;
      }, {});
      const unscaledDatasetData = [].concat(this.removedFilterdtrainingData, this.DataSet.data.map((scaledDatum) => {
        const unscaledDatum = this.DataSet.inverseTransformObject(scaledDatum, {});
        return unscaledDatum;
      }));
      const unscaledNextValueFunctionObject = Object.keys(this.prediction_inputs_next_value_functions).length > 0 ? this.prediction_inputs_next_value_function({
        rawInputPredictionObject,
        forecastDate,
        forecastDates,
        forecastPredictionIndex,
        existingDatasetObjectIndex: existingDatasetObjectIndex + this.removedFilterdtrainingData.length,
        unscaledLastForecastedValue,
        data: unscaledDatasetData,
        DataSet: this.DataSet,
        lastDataRow: Object.assign({}, this.DataSet.data[this.DataSet.data.length - 1], datasetUnscaledObject, rawInputPredictionObject, unscaledLastForecastedValue)
      }) : {};
      const parsedLocalDate = getLocalParsedDate({ date: forecastDate, time_zone: this.prediction_timeseries_time_zone, dimension });
      unscaledRawInputObject = this.use_empty_objects ? Object.assign(
        {},
        this.emptyObject,
        flatten3(datasetUnscaledObject || {}, { maxDepth: 2, delimiter: flattenDelimiter }),
        flatten3(unscaledNextValueFunctionObject || {}, { maxDepth: 2, delimiter: flattenDelimiter }),
        flatten3(rawInputPredictionObject || {}, { maxDepth: 2, delimiter: flattenDelimiter }),
        flatten3(unscaledLastForecastedValue, { maxDepth: 2, delimiter: flattenDelimiter }),
        flatten3(parsedLocalDate, { maxDepth: 2, delimiter: flattenDelimiter })
      ) : Object.assign({}, datasetUnscaledObject, unscaledNextValueFunctionObject, rawInputPredictionObject, unscaledLastForecastedValue, parsedLocalDate);
      scaledRawInputObject = this.DataSet.transformObject(unscaledRawInputObject, { checkColumnLength: false });
      predictionInput = [
        scaledRawInputObject
      ];
      if (predictionInput) {
        const inputMatrix = this.DataSet.columnMatrix(this.x_independent_features, predictionInput);
        if (this.validate_training_data) {
          this.validateTrainingData({ cross_validate_training_data: false, inputMatrix });
        }
        predictionMatrix = await this.Model.predict(inputMatrix, predictionOptions);
        if (retrain_forecast_model_with_predictions && forecastDate > lastDatasetDate) {
          await this.retrainTimeseriesModel({
            inputMatrix,
            predictionMatrix
          });
        }
        const newPredictionObject = this.DataSet.reverseColumnMatrix({ vectors: predictionMatrix, labels: this.y_dependent_labels })[0];
        const forecast = Object.assign(
          {},
          datasetScaledObject,
          scaledRawInputObject,
          newPredictionObject,
          parsedLocalDate,
          {
            [this.prediction_timeseries_date_feature]: forecastDate
          }
        );
        if (forecastDate > lastOriginalForecastDate) {
          this.DataSet.data.splice(existingDatasetObjectIndex, 0, forecast);
        }
        forecasts.push(forecast);
      }
      forecastPredictionIndex++;
      return predictionMatrix;
    });
    return forecasts;
  }
  evaluateClassificationAccuracy(options = {}) {
    const { dependent_feature_label, estimatesDescaled, actualsDescaled } = options;
    const estimates = JSONStackData.DataSet.columnArray(dependent_feature_label, { data: estimatesDescaled });
    const actuals = JSONStackData.DataSet.columnArray(dependent_feature_label, { data: actualsDescaled });
    const CM = ConfusionMatrix.fromLabels(actuals, estimates);
    const accuracy2 = CM.getAccuracy();
    return {
      accuracy: accuracy2,
      matrix: CM.matrix,
      labels: CM.labels,
      actuals,
      estimates
    };
  }
  evaluateRegressionAccuracy(options = {}) {
    const { dependent_feature_label, estimatesDescaled, actualsDescaled } = options;
    const estimates = JSONStackData.DataSet.columnArray(dependent_feature_label, { data: estimatesDescaled });
    const actuals = JSONStackData.DataSet.columnArray(dependent_feature_label, { data: actualsDescaled });
    const standardError = JSONStackData.util.standardError(actuals, estimates);
    const rSquared = JSONStackData.util.rSquared(actuals, estimates);
    const adjustedRSquared = JSONStackData.util.adjustedRSquared({
      actuals,
      estimates,
      rSquared,
      sampleSize: actuals.length,
      independentVariables: this.x_independent_features.length
    });
    const hasZeroActual = Boolean(actuals.filter((a) => a === 0 || isNaN(a)).length);
    const originalMeanAbsolutePercentageError = JSONStackData.util.meanAbsolutePercentageError(actuals, estimates);
    const MAD = JSONStackData.util.meanAbsoluteDeviation(actuals, estimates);
    const MEAN = JSONStackData.util.mean(actuals);
    let metric = "meanAbsolutePercentageError";
    let reason = "Actuals do not contain Zero values";
    if (hasZeroActual) {
      metric = "MAD over MEAN ratio";
      reason = "Actuals contain Zero values";
    }
    let errorPercentage = hasZeroActual ? MAD / MEAN : originalMeanAbsolutePercentageError;
    if (errorPercentage < 0)
      errorPercentage = 0;
    if (errorPercentage > 1)
      errorPercentage = 1;
    const accuracyPercentage = 1 - errorPercentage;
    return {
      standardError,
      rSquared,
      adjustedRSquared,
      actuals,
      estimates,
      meanForecastError: JSONStackData.util.meanForecastError(actuals, estimates),
      meanAbsoluteDeviation: JSONStackData.util.meanAbsoluteDeviation(actuals, estimates),
      trackingSignal: JSONStackData.util.trackingSignal(actuals, estimates),
      meanSquaredError: JSONStackData.util.meanSquaredError(actuals, estimates),
      meanAbsolutePercentageError: errorPercentage,
      accuracyPercentage,
      metric,
      reason,
      originalMeanAbsolutePercentageError
    };
  }
  async evaluateModel(options = {}) {
    await this.checkTrainingStatus(options);
    const x_indep_matrix_test = options.x_indep_matrix_test || this.x_indep_matrix_test;
    const y_dep_matrix_test = options.y_dep_matrix_test || this.y_dep_matrix_test;
    const predictionOptions = Object.assign({
      probability: this.config.model_category === "classification" ? false : true
    }, this.prediction_options, options.predictionOptions);
    const estimatesPredictions = await this.Model.predict(x_indep_matrix_test, predictionOptions);
    const estimatedValues = this.DataSet.reverseColumnMatrix({ vectors: estimatesPredictions, labels: this.y_dependent_labels });
    const actualValues = this.DataSet.reverseColumnMatrix({ vectors: y_dep_matrix_test, labels: this.y_dependent_labels });
    const dimension = this.dimension;
    const emptyPrediction = this.y_dependent_labels.reduce((result, label) => {
      result[label] = 0;
      return result;
    }, {});
    const estimatesDescaled = estimatedValues.map((val, i2) => {
      let inverseTransformedObject = this.DataSet.inverseTransformObject(val, {});
      if (this.config.model_category === "timeseries") {
        const scaledInput = x_indep_matrix_test[i2];
        const [inputObject] = this.DataSet.reverseColumnMatrix({ vectors: [scaledInput], labels: this.x_independent_features });
        const inverseInputObject = this.DataSet.inverseTransformObject(inputObject, {});
        const is_location_open = inputObject.is_location_open;
        const { year, month, day, hour } = inverseInputObject;
        if ((dimension === "hourly" || dimension === "daily") && this.entity && !is_location_open) {
          console.info(`Manually fixing prediction on closed - ${dimension} ${year}-${month}-${day}T${hour}`);
          inverseTransformedObject = emptyPrediction;
        }
      }
      const formattedInverse = this.use_empty_objects ? flatten3.unflatten(inverseTransformedObject, { delimiter: flattenDelimiter }) : inverseTransformedObject;
      return formattedInverse;
    });
    const actualsDescaled = actualValues.map((val) => {
      const inverseTransformedObject = this.DataSet.inverseTransformObject(val, {});
      return this.use_empty_objects ? flatten3.unflatten(inverseTransformedObject, { delimiter: flattenDelimiter }) : inverseTransformedObject;
    });
    const evaluationDependentLabels = Array.isArray(this.y_raw_dependent_labels) && this.y_raw_dependent_labels.length ? this.y_raw_dependent_labels : this.y_dependent_labels;
    evaluationDependentLabels.splice(this.max_evaluation_outputs);
    if (this.config.model_category === "classification") {
      return evaluationDependentLabels.reduce((evaluation, dependent_feature_label) => {
        evaluation[dependent_feature_label] = this.evaluateClassificationAccuracy({ dependent_feature_label, estimatesDescaled, actualsDescaled });
        return evaluation;
      }, {});
    } else {
      return evaluationDependentLabels.reduce((evaluation, dependent_feature_label) => {
        evaluation[dependent_feature_label] = this.evaluateRegressionAccuracy({ dependent_feature_label, estimatesDescaled, actualsDescaled });
        return evaluation;
      }, {});
    }
  }
};
var ModelX = _ModelX;
__publicField(ModelX, "prediction_timeseries_date_format");
__publicField(ModelX, "prediction_timeseries_date_feature");
__publicField(ModelX, "dimension");
__publicField(ModelX, "prediction_timeseries_dimension_feature");

// src/dataset.ts
import { loadCSV, loadTSV } from "@jsonstack/data/src/csv";

// src/transforms.ts
import * as Luxon2 from "luxon";
function getFirstDataset(datasets = {}) {
  return datasets[Object.keys(datasets)[0]] || [];
}

// src/dataset.ts
import Promisie2 from "promisie/src/index";
import axios from "axios";
var defaultReducerContext = {
  Promisie: Promisie2,
  getFirstDataset
};
async function getDataSet(jds = {}) {
  if (Array.isArray(jds))
    return jds;
  const { reducer, data, _data_static, _data_promise, _data_url, _data_csv, _data_tsv, _data_csv_options } = jds;
  let returnData = [];
  if (data)
    returnData = data;
  else if (_data_static)
    returnData = _data_static;
  else if (_data_csv)
    returnData = await loadCSV(_data_csv, _data_csv_options);
  else if (_data_tsv)
    returnData = await loadTSV(_data_tsv, _data_csv_options);
  else if (reducer)
    returnData = await ReduceDataset(reducer);
  else if (_data_promise)
    returnData = await _data_promise();
  else if (_data_url) {
    const response = await axios(_data_url);
    returnData = await response.data;
  }
  return returnData;
}
async function ReduceDataset(reducer) {
  const { name: name296 } = reducer;
  const context = {
    context: {
      ...defaultReducerContext,
      name: name296,
      ...reducer.context
    }
  };
  const reducerFunctions = Array.isArray(reducer.reducer_function) ? reducer.reducer_function : [reducer.reducer_function];
  const reducerFunctionArray = reducerFunctions.map((reducer_function, index2) => getFunctionString({ reducer_function, name: name296, context, index: index2 }));
  const ReducerFunction = Promisie2.pipe(reducerFunctionArray);
  const datasets = await ResolveDataset(reducer.datasets);
  const { dataset_reduced } = await ReducerFunction(datasets);
  return dataset_reduced;
}
async function ResolveDataset(datasets = []) {
  let i2 = 0;
  let datasetData = {};
  if (datasets.length) {
    const datasetsOrderedArray = await Promisie2.map(datasets, 10, async (jds) => {
      const dsDatum = {};
      if (Array.isArray(jds)) {
        dsDatum[`dataset_${i2}`] = jds;
      } else {
        const data = await getDataSet(jds);
        dsDatum[jds.name || `dataset_${i2}`] = data;
      }
      i2++;
      return dsDatum;
    });
    datasetData = datasetsOrderedArray.reduce((result, orderedDataset) => {
      const key = Object.keys(orderedDataset)[0];
      const val = orderedDataset[key];
      result[key] = val;
      return result;
    }, {});
  }
  return datasetData;
}
function getFunctionString(reductionFunctionData) {
  const { reducer_function, name: name296, context, index: index2 } = reductionFunctionData;
  if (typeof reducer_function === "function") {
    const reduceFunction = async function getFunction(datasets) {
      const dataset_reduced = await reducer_function.call(context, datasets);
      return { dataset_reduced };
    }.bind(context);
    Object.defineProperty(
      reduceFunction,
      "name",
      {
        value: reducer_function.name || "ReducerFunction_" + index2
      }
    );
    return reduceFunction;
  } else {
    const functionBodyString = `'use strict'; 
    return async function getAsyncString(){
      try {
        const dataset_reduced = await (async function getReducerData(){
          ${reducer_function}
        }.bind(this))();
        return {dataset_reduced};
      } catch(e){
        throw e;
      }
    }.call(this /* ,options */);
    `;
    const stringFunction = Function("datasets", functionBodyString).bind(context);
    Object.defineProperty(
      stringFunction,
      "name",
      {
        value: name296 || "ReducerFunction_" + index2
      }
    );
    return stringFunction;
  }
}

// src/jsonm.ts
var ModelToTypeMap = {
  "regression": "ai-linear-regression",
  "prediction": "ai-regression",
  "classification": "ai-classification",
  "description": "ai-classification",
  "forecast": "ai-timeseries-regression-forecast"
};
async function getModelFromJSONM(jml) {
  const trainingData = Array.isArray(jml.dataset) ? jml.dataset : await getDataSet(jml.dataset);
  return new ModelX({
    trainingData,
    independent_variables: getInputs(jml),
    input_independent_features: jml.input_transforms,
    dependent_variables: jml.outputs,
    output_dependent_features: jml.output_transforms,
    training_progress_callback: jml.on_progress,
    training_options: jml.training_options || getModelTrainingOptions(jml.options),
    model_type: jml.model_type || ModelToTypeMap[jml.type] || jml.type,
    ...getModelOptions(jml, trainingData[0])
  });
}
var getModel = getModelFromJSONM;
function getModelTrainingOptions({ accuracy_target } = {}) {
  return {
    fit: {
      epochs: 300,
      batchSize: 20
    }
  };
}
function getInputs(jml) {
  if (jml?.type === "forecast")
    return Array.from(new Set(jml.inputs.concat(["year", "month", "day"])));
  else
    return jml.inputs;
}
function getDateField(DataRow) {
  if (DataRow?.Date)
    return "Date";
  else
    return "date";
}
function getModelOptions(jml, datum) {
  const defaultModelOptions = {};
  if (!jml?.model_options && jml?.type === "forecast") {
    defaultModelOptions.prediction_timeseries_time_zone = jml?.forecast_date_time_zone;
    defaultModelOptions.prediction_timeseries_date_feature = jml?.forecast_date_field || getDateField(datum);
    defaultModelOptions.prediction_timeseries_date_format = jml?.forecast_date_format;
    defaultModelOptions.validate_training_data = true;
    defaultModelOptions.retrain_forecast_model_with_predictions = true;
    defaultModelOptions.use_next_value_functions_for_training_data = true;
    defaultModelOptions.use_mock_dates_to_fit_trainning_data = true;
    defaultModelOptions.use_preprocessing_on_trainning_data = true;
    defaultModelOptions.training_feature_column_options = {
      year: ["onehot"],
      month: ["onehot"],
      day: ["onehot"]
    };
  }
  return {
    ...defaultModelOptions,
    ...jml?.model_options
  };
}

// src/index.ts
import * as Data from "@jsonstack/data";
import * as Model from "@jsonstack/model";
export {
  Data,
  ModelX as JSONModel,
  Model,
  ModelCategories,
  ModelTypes,
  ModelX,
  autoAssignFeatureColumns,
  createModelFitCallback,
  getAutoFeatures,
  getBackend,
  getDataSet,
  getGeneratedStatefulFunction,
  getModel,
  getModelFromJSONM,
  getModelTrainingOptions,
  getScikit,
  setBackend,
  setScikit,
  sumPreviousRows
};
/**
 * @license Complex.js v2.1.1 12/05/2020
 *
 * Copyright (c) 2020, Robert Eisele (robert@xarg.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/
/**
 * @license Fraction.js v4.2.0 05/03/2022
 * https://www.xarg.org/2014/03/rational-numbers-in-javascript/
 *
 * Copyright (c) 2021, Robert Eisele (robert@xarg.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/
/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/
/**
*  @license
* Copyright 2022, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/
// *  @license
